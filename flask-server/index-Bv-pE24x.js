const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/blosc-CrUiACa7.js","assets/chunk-INHXZS53-D3tQiqtZ.js","assets/lz4-B_Exjfmr.js","assets/zstd-u5eweWyS.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
(async () => {
  var _e, _t, _pk_instances, n_fn, _e2, _e3, _e4, _e5, _t2, _n2, _i2, _r, _e6, _t3, _e7, _t4, _e8, _t5, _e9, _a2, _b2, _e10, _c2;
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
    new MutationObserver((i) => {
      for (const a of i) if (a.type === "childList") for (const s of a.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function n(i) {
      const a = {};
      return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
    }
    function r(i) {
      if (i.ep) return;
      i.ep = true;
      const a = n(i);
      fetch(i.href, a);
    }
  })();
  var ci = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function t0(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  function EF(t) {
    if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
    var e = t.default;
    if (typeof e == "function") {
      var n = function r() {
        var i = false;
        try {
          i = this instanceof r;
        } catch {
        }
        return i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
      };
      n.prototype = e.prototype;
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
      value: true
    }), Object.keys(t).forEach(function(r) {
      var i = Object.getOwnPropertyDescriptor(t, r);
      Object.defineProperty(n, r, i.get ? i : {
        enumerable: true,
        get: function() {
          return t[r];
        }
      });
    }), n;
  }
  var P3 = {
    exports: {}
  }, i1 = {};
  var xw;
  function bF() {
    if (xw) return i1;
    xw = 1;
    var t = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
    function n(r, i, a) {
      var s = null;
      if (a !== void 0 && (s = "" + a), i.key !== void 0 && (s = "" + i.key), "key" in i) {
        a = {};
        for (var o in i) o !== "key" && (a[o] = i[o]);
      } else a = i;
      return i = a.ref, {
        $$typeof: t,
        type: r,
        key: s,
        ref: i !== void 0 ? i : null,
        props: a
      };
    }
    return i1.Fragment = e, i1.jsx = n, i1.jsxs = n, i1;
  }
  var ww;
  function DF() {
    return ww || (ww = 1, P3.exports = bF()), P3.exports;
  }
  var be = DF(), G3 = {
    exports: {}
  }, Zt = {};
  var Cw;
  function MF() {
    if (Cw) return Zt;
    Cw = 1;
    var t = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), o = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), c = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), u = Symbol.iterator;
    function h(B) {
      return B === null || typeof B != "object" ? null : (B = u && B[u] || B["@@iterator"], typeof B == "function" ? B : null);
    }
    var g = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, v = Object.assign, m = {};
    function y(B, Y, X) {
      this.props = B, this.context = Y, this.refs = m, this.updater = X || g;
    }
    y.prototype.isReactComponent = {}, y.prototype.setState = function(B, Y) {
      if (typeof B != "object" && typeof B != "function" && B != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, B, Y, "setState");
    }, y.prototype.forceUpdate = function(B) {
      this.updater.enqueueForceUpdate(this, B, "forceUpdate");
    };
    function w() {
    }
    w.prototype = y.prototype;
    function C(B, Y, X) {
      this.props = B, this.context = Y, this.refs = m, this.updater = X || g;
    }
    var T = C.prototype = new w();
    T.constructor = C, v(T, y.prototype), T.isPureReactComponent = true;
    var S = Array.isArray, E = {
      H: null,
      A: null,
      T: null,
      S: null,
      V: null
    }, b = Object.prototype.hasOwnProperty;
    function D(B, Y, X, ie, oe, he) {
      return X = he.ref, {
        $$typeof: t,
        type: B,
        key: Y,
        ref: X !== void 0 ? X : null,
        props: he
      };
    }
    function R(B, Y) {
      return D(B.type, Y, void 0, void 0, void 0, B.props);
    }
    function I(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function O(B) {
      var Y = {
        "=": "=0",
        ":": "=2"
      };
      return "$" + B.replace(/[=:]/g, function(X) {
        return Y[X];
      });
    }
    var L = /\/+/g;
    function N(B, Y) {
      return typeof B == "object" && B !== null && B.key != null ? O("" + B.key) : Y.toString(36);
    }
    function F() {
    }
    function V(B) {
      switch (B.status) {
        case "fulfilled":
          return B.value;
        case "rejected":
          throw B.reason;
        default:
          switch (typeof B.status == "string" ? B.then(F, F) : (B.status = "pending", B.then(function(Y) {
            B.status === "pending" && (B.status = "fulfilled", B.value = Y);
          }, function(Y) {
            B.status === "pending" && (B.status = "rejected", B.reason = Y);
          })), B.status) {
            case "fulfilled":
              return B.value;
            case "rejected":
              throw B.reason;
          }
      }
      throw B;
    }
    function k(B, Y, X, ie, oe) {
      var he = typeof B;
      (he === "undefined" || he === "boolean") && (B = null);
      var Le = false;
      if (B === null) Le = true;
      else switch (he) {
        case "bigint":
        case "string":
        case "number":
          Le = true;
          break;
        case "object":
          switch (B.$$typeof) {
            case t:
            case e:
              Le = true;
              break;
            case f:
              return Le = B._init, k(Le(B._payload), Y, X, ie, oe);
          }
      }
      if (Le) return oe = oe(B), Le = ie === "" ? "." + N(B, 0) : ie, S(oe) ? (X = "", Le != null && (X = Le.replace(L, "$&/") + "/"), k(oe, Y, X, "", function(ot) {
        return ot;
      })) : oe != null && (I(oe) && (oe = R(oe, X + (oe.key == null || B && B.key === oe.key ? "" : ("" + oe.key).replace(L, "$&/") + "/") + Le)), Y.push(oe)), 1;
      Le = 0;
      var Je = ie === "" ? "." : ie + ":";
      if (S(B)) for (var Pe = 0; Pe < B.length; Pe++) ie = B[Pe], he = Je + N(ie, Pe), Le += k(ie, Y, X, he, oe);
      else if (Pe = h(B), typeof Pe == "function") for (B = Pe.call(B), Pe = 0; !(ie = B.next()).done; ) ie = ie.value, he = Je + N(ie, Pe++), Le += k(ie, Y, X, he, oe);
      else if (he === "object") {
        if (typeof B.then == "function") return k(V(B), Y, X, ie, oe);
        throw Y = String(B), Error("Objects are not valid as a React child (found: " + (Y === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : Y) + "). If you meant to render a collection of children, use an array instead.");
      }
      return Le;
    }
    function _(B, Y, X) {
      if (B == null) return B;
      var ie = [], oe = 0;
      return k(B, ie, "", "", function(he) {
        return Y.call(X, he, oe++);
      }), ie;
    }
    function K(B) {
      if (B._status === -1) {
        var Y = B._result;
        Y = Y(), Y.then(function(X) {
          (B._status === 0 || B._status === -1) && (B._status = 1, B._result = X);
        }, function(X) {
          (B._status === 0 || B._status === -1) && (B._status = 2, B._result = X);
        }), B._status === -1 && (B._status = 0, B._result = Y);
      }
      if (B._status === 1) return B._result.default;
      throw B._result;
    }
    var Z = typeof reportError == "function" ? reportError : function(B) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var Y = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof B == "object" && B !== null && typeof B.message == "string" ? String(B.message) : String(B),
          error: B
        });
        if (!window.dispatchEvent(Y)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", B);
        return;
      }
      console.error(B);
    };
    function j() {
    }
    return Zt.Children = {
      map: _,
      forEach: function(B, Y, X) {
        _(B, function() {
          Y.apply(this, arguments);
        }, X);
      },
      count: function(B) {
        var Y = 0;
        return _(B, function() {
          Y++;
        }), Y;
      },
      toArray: function(B) {
        return _(B, function(Y) {
          return Y;
        }) || [];
      },
      only: function(B) {
        if (!I(B)) throw Error("React.Children.only expected to receive a single React element child.");
        return B;
      }
    }, Zt.Component = y, Zt.Fragment = n, Zt.Profiler = i, Zt.PureComponent = C, Zt.StrictMode = r, Zt.Suspense = l, Zt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = E, Zt.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(B) {
        return E.H.useMemoCache(B);
      }
    }, Zt.cache = function(B) {
      return function() {
        return B.apply(null, arguments);
      };
    }, Zt.cloneElement = function(B, Y, X) {
      if (B == null) throw Error("The argument must be a React element, but you passed " + B + ".");
      var ie = v({}, B.props), oe = B.key, he = void 0;
      if (Y != null) for (Le in Y.ref !== void 0 && (he = void 0), Y.key !== void 0 && (oe = "" + Y.key), Y) !b.call(Y, Le) || Le === "key" || Le === "__self" || Le === "__source" || Le === "ref" && Y.ref === void 0 || (ie[Le] = Y[Le]);
      var Le = arguments.length - 2;
      if (Le === 1) ie.children = X;
      else if (1 < Le) {
        for (var Je = Array(Le), Pe = 0; Pe < Le; Pe++) Je[Pe] = arguments[Pe + 2];
        ie.children = Je;
      }
      return D(B.type, oe, void 0, void 0, he, ie);
    }, Zt.createContext = function(B) {
      return B = {
        $$typeof: s,
        _currentValue: B,
        _currentValue2: B,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      }, B.Provider = B, B.Consumer = {
        $$typeof: a,
        _context: B
      }, B;
    }, Zt.createElement = function(B, Y, X) {
      var ie, oe = {}, he = null;
      if (Y != null) for (ie in Y.key !== void 0 && (he = "" + Y.key), Y) b.call(Y, ie) && ie !== "key" && ie !== "__self" && ie !== "__source" && (oe[ie] = Y[ie]);
      var Le = arguments.length - 2;
      if (Le === 1) oe.children = X;
      else if (1 < Le) {
        for (var Je = Array(Le), Pe = 0; Pe < Le; Pe++) Je[Pe] = arguments[Pe + 2];
        oe.children = Je;
      }
      if (B && B.defaultProps) for (ie in Le = B.defaultProps, Le) oe[ie] === void 0 && (oe[ie] = Le[ie]);
      return D(B, he, void 0, void 0, null, oe);
    }, Zt.createRef = function() {
      return {
        current: null
      };
    }, Zt.forwardRef = function(B) {
      return {
        $$typeof: o,
        render: B
      };
    }, Zt.isValidElement = I, Zt.lazy = function(B) {
      return {
        $$typeof: f,
        _payload: {
          _status: -1,
          _result: B
        },
        _init: K
      };
    }, Zt.memo = function(B, Y) {
      return {
        $$typeof: c,
        type: B,
        compare: Y === void 0 ? null : Y
      };
    }, Zt.startTransition = function(B) {
      var Y = E.T, X = {};
      E.T = X;
      try {
        var ie = B(), oe = E.S;
        oe !== null && oe(X, ie), typeof ie == "object" && ie !== null && typeof ie.then == "function" && ie.then(j, Z);
      } catch (he) {
        Z(he);
      } finally {
        E.T = Y;
      }
    }, Zt.unstable_useCacheRefresh = function() {
      return E.H.useCacheRefresh();
    }, Zt.use = function(B) {
      return E.H.use(B);
    }, Zt.useActionState = function(B, Y, X) {
      return E.H.useActionState(B, Y, X);
    }, Zt.useCallback = function(B, Y) {
      return E.H.useCallback(B, Y);
    }, Zt.useContext = function(B) {
      return E.H.useContext(B);
    }, Zt.useDebugValue = function() {
    }, Zt.useDeferredValue = function(B, Y) {
      return E.H.useDeferredValue(B, Y);
    }, Zt.useEffect = function(B, Y, X) {
      var ie = E.H;
      if (typeof X == "function") throw Error("useEffect CRUD overload is not enabled in this build of React.");
      return ie.useEffect(B, Y);
    }, Zt.useId = function() {
      return E.H.useId();
    }, Zt.useImperativeHandle = function(B, Y, X) {
      return E.H.useImperativeHandle(B, Y, X);
    }, Zt.useInsertionEffect = function(B, Y) {
      return E.H.useInsertionEffect(B, Y);
    }, Zt.useLayoutEffect = function(B, Y) {
      return E.H.useLayoutEffect(B, Y);
    }, Zt.useMemo = function(B, Y) {
      return E.H.useMemo(B, Y);
    }, Zt.useOptimistic = function(B, Y) {
      return E.H.useOptimistic(B, Y);
    }, Zt.useReducer = function(B, Y, X) {
      return E.H.useReducer(B, Y, X);
    }, Zt.useRef = function(B) {
      return E.H.useRef(B);
    }, Zt.useState = function(B) {
      return E.H.useState(B);
    }, Zt.useSyncExternalStore = function(B, Y, X) {
      return E.H.useSyncExternalStore(B, Y, X);
    }, Zt.useTransition = function() {
      return E.H.useTransition();
    }, Zt.version = "19.1.1", Zt;
  }
  var Tw;
  function F6() {
    return Tw || (Tw = 1, G3.exports = MF()), G3.exports;
  }
  var me = F6(), z3 = {
    exports: {}
  }, a1 = {}, W3 = {
    exports: {}
  }, H3 = {};
  var Sw;
  function RF() {
    return Sw || (Sw = 1, (function(t) {
      function e(_, K) {
        var Z = _.length;
        _.push(K);
        e: for (; 0 < Z; ) {
          var j = Z - 1 >>> 1, B = _[j];
          if (0 < i(B, K)) _[j] = K, _[Z] = B, Z = j;
          else break e;
        }
      }
      function n(_) {
        return _.length === 0 ? null : _[0];
      }
      function r(_) {
        if (_.length === 0) return null;
        var K = _[0], Z = _.pop();
        if (Z !== K) {
          _[0] = Z;
          e: for (var j = 0, B = _.length, Y = B >>> 1; j < Y; ) {
            var X = 2 * (j + 1) - 1, ie = _[X], oe = X + 1, he = _[oe];
            if (0 > i(ie, Z)) oe < B && 0 > i(he, ie) ? (_[j] = he, _[oe] = Z, j = oe) : (_[j] = ie, _[X] = Z, j = X);
            else if (oe < B && 0 > i(he, Z)) _[j] = he, _[oe] = Z, j = oe;
            else break e;
          }
        }
        return K;
      }
      function i(_, K) {
        var Z = _.sortIndex - K.sortIndex;
        return Z !== 0 ? Z : _.id - K.id;
      }
      if (t.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var a = performance;
        t.unstable_now = function() {
          return a.now();
        };
      } else {
        var s = Date, o = s.now();
        t.unstable_now = function() {
          return s.now() - o;
        };
      }
      var l = [], c = [], f = 1, u = null, h = 3, g = false, v = false, m = false, y = false, w = typeof setTimeout == "function" ? setTimeout : null, C = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null;
      function S(_) {
        for (var K = n(c); K !== null; ) {
          if (K.callback === null) r(c);
          else if (K.startTime <= _) r(c), K.sortIndex = K.expirationTime, e(l, K);
          else break;
          K = n(c);
        }
      }
      function E(_) {
        if (m = false, S(_), !v) if (n(l) !== null) v = true, b || (b = true, N());
        else {
          var K = n(c);
          K !== null && k(E, K.startTime - _);
        }
      }
      var b = false, D = -1, R = 5, I = -1;
      function O() {
        return y ? true : !(t.unstable_now() - I < R);
      }
      function L() {
        if (y = false, b) {
          var _ = t.unstable_now();
          I = _;
          var K = true;
          try {
            e: {
              v = false, m && (m = false, C(D), D = -1), g = true;
              var Z = h;
              try {
                t: {
                  for (S(_), u = n(l); u !== null && !(u.expirationTime > _ && O()); ) {
                    var j = u.callback;
                    if (typeof j == "function") {
                      u.callback = null, h = u.priorityLevel;
                      var B = j(u.expirationTime <= _);
                      if (_ = t.unstable_now(), typeof B == "function") {
                        u.callback = B, S(_), K = true;
                        break t;
                      }
                      u === n(l) && r(l), S(_);
                    } else r(l);
                    u = n(l);
                  }
                  if (u !== null) K = true;
                  else {
                    var Y = n(c);
                    Y !== null && k(E, Y.startTime - _), K = false;
                  }
                }
                break e;
              } finally {
                u = null, h = Z, g = false;
              }
              K = void 0;
            }
          } finally {
            K ? N() : b = false;
          }
        }
      }
      var N;
      if (typeof T == "function") N = function() {
        T(L);
      };
      else if (typeof MessageChannel < "u") {
        var F = new MessageChannel(), V = F.port2;
        F.port1.onmessage = L, N = function() {
          V.postMessage(null);
        };
      } else N = function() {
        w(L, 0);
      };
      function k(_, K) {
        D = w(function() {
          _(t.unstable_now());
        }, K);
      }
      t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(_) {
        _.callback = null;
      }, t.unstable_forceFrameRate = function(_) {
        0 > _ || 125 < _ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : R = 0 < _ ? Math.floor(1e3 / _) : 5;
      }, t.unstable_getCurrentPriorityLevel = function() {
        return h;
      }, t.unstable_next = function(_) {
        switch (h) {
          case 1:
          case 2:
          case 3:
            var K = 3;
            break;
          default:
            K = h;
        }
        var Z = h;
        h = K;
        try {
          return _();
        } finally {
          h = Z;
        }
      }, t.unstable_requestPaint = function() {
        y = true;
      }, t.unstable_runWithPriority = function(_, K) {
        switch (_) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            _ = 3;
        }
        var Z = h;
        h = _;
        try {
          return K();
        } finally {
          h = Z;
        }
      }, t.unstable_scheduleCallback = function(_, K, Z) {
        var j = t.unstable_now();
        switch (typeof Z == "object" && Z !== null ? (Z = Z.delay, Z = typeof Z == "number" && 0 < Z ? j + Z : j) : Z = j, _) {
          case 1:
            var B = -1;
            break;
          case 2:
            B = 250;
            break;
          case 5:
            B = 1073741823;
            break;
          case 4:
            B = 1e4;
            break;
          default:
            B = 5e3;
        }
        return B = Z + B, _ = {
          id: f++,
          callback: K,
          priorityLevel: _,
          startTime: Z,
          expirationTime: B,
          sortIndex: -1
        }, Z > j ? (_.sortIndex = Z, e(c, _), n(l) === null && _ === n(c) && (m ? (C(D), D = -1) : m = true, k(E, Z - j))) : (_.sortIndex = B, e(l, _), v || g || (v = true, b || (b = true, N()))), _;
      }, t.unstable_shouldYield = O, t.unstable_wrapCallback = function(_) {
        var K = h;
        return function() {
          var Z = h;
          h = K;
          try {
            return _.apply(this, arguments);
          } finally {
            h = Z;
          }
        };
      };
    })(H3)), H3;
  }
  var Aw;
  function OF() {
    return Aw || (Aw = 1, W3.exports = RF()), W3.exports;
  }
  var j3 = {
    exports: {}
  }, wi = {};
  var Ew;
  function IF() {
    if (Ew) return wi;
    Ew = 1;
    var t = F6();
    function e(l) {
      var c = "https://react.dev/errors/" + l;
      if (1 < arguments.length) {
        c += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var f = 2; f < arguments.length; f++) c += "&args[]=" + encodeURIComponent(arguments[f]);
      }
      return "Minified React error #" + l + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function n() {
    }
    var r = {
      d: {
        f: n,
        r: function() {
          throw Error(e(522));
        },
        D: n,
        C: n,
        L: n,
        m: n,
        X: n,
        S: n,
        M: n
      },
      p: 0,
      findDOMNode: null
    }, i = Symbol.for("react.portal");
    function a(l, c, f) {
      var u = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: i,
        key: u == null ? null : "" + u,
        children: l,
        containerInfo: c,
        implementation: f
      };
    }
    var s = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function o(l, c) {
      if (l === "font") return "";
      if (typeof c == "string") return c === "use-credentials" ? c : "";
    }
    return wi.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, wi.createPortal = function(l, c) {
      var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11) throw Error(e(299));
      return a(l, c, null, f);
    }, wi.flushSync = function(l) {
      var c = s.T, f = r.p;
      try {
        if (s.T = null, r.p = 2, l) return l();
      } finally {
        s.T = c, r.p = f, r.d.f();
      }
    }, wi.preconnect = function(l, c) {
      typeof l == "string" && (c ? (c = c.crossOrigin, c = typeof c == "string" ? c === "use-credentials" ? c : "" : void 0) : c = null, r.d.C(l, c));
    }, wi.prefetchDNS = function(l) {
      typeof l == "string" && r.d.D(l);
    }, wi.preinit = function(l, c) {
      if (typeof l == "string" && c && typeof c.as == "string") {
        var f = c.as, u = o(f, c.crossOrigin), h = typeof c.integrity == "string" ? c.integrity : void 0, g = typeof c.fetchPriority == "string" ? c.fetchPriority : void 0;
        f === "style" ? r.d.S(l, typeof c.precedence == "string" ? c.precedence : void 0, {
          crossOrigin: u,
          integrity: h,
          fetchPriority: g
        }) : f === "script" && r.d.X(l, {
          crossOrigin: u,
          integrity: h,
          fetchPriority: g,
          nonce: typeof c.nonce == "string" ? c.nonce : void 0
        });
      }
    }, wi.preinitModule = function(l, c) {
      if (typeof l == "string") if (typeof c == "object" && c !== null) {
        if (c.as == null || c.as === "script") {
          var f = o(c.as, c.crossOrigin);
          r.d.M(l, {
            crossOrigin: f,
            integrity: typeof c.integrity == "string" ? c.integrity : void 0,
            nonce: typeof c.nonce == "string" ? c.nonce : void 0
          });
        }
      } else c == null && r.d.M(l);
    }, wi.preload = function(l, c) {
      if (typeof l == "string" && typeof c == "object" && c !== null && typeof c.as == "string") {
        var f = c.as, u = o(f, c.crossOrigin);
        r.d.L(l, f, {
          crossOrigin: u,
          integrity: typeof c.integrity == "string" ? c.integrity : void 0,
          nonce: typeof c.nonce == "string" ? c.nonce : void 0,
          type: typeof c.type == "string" ? c.type : void 0,
          fetchPriority: typeof c.fetchPriority == "string" ? c.fetchPriority : void 0,
          referrerPolicy: typeof c.referrerPolicy == "string" ? c.referrerPolicy : void 0,
          imageSrcSet: typeof c.imageSrcSet == "string" ? c.imageSrcSet : void 0,
          imageSizes: typeof c.imageSizes == "string" ? c.imageSizes : void 0,
          media: typeof c.media == "string" ? c.media : void 0
        });
      }
    }, wi.preloadModule = function(l, c) {
      if (typeof l == "string") if (c) {
        var f = o(c.as, c.crossOrigin);
        r.d.m(l, {
          as: typeof c.as == "string" && c.as !== "script" ? c.as : void 0,
          crossOrigin: f,
          integrity: typeof c.integrity == "string" ? c.integrity : void 0
        });
      } else r.d.m(l);
    }, wi.requestFormReset = function(l) {
      r.d.r(l);
    }, wi.unstable_batchedUpdates = function(l, c) {
      return l(c);
    }, wi.useFormState = function(l, c, f) {
      return s.H.useFormState(l, c, f);
    }, wi.useFormStatus = function() {
      return s.H.useHostTransitionStatus();
    }, wi.version = "19.1.1", wi;
  }
  var bw;
  function VF() {
    if (bw) return j3.exports;
    bw = 1;
    function t() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
    }
    return t(), j3.exports = IF(), j3.exports;
  }
  var Dw;
  function NF() {
    if (Dw) return a1;
    Dw = 1;
    var t = OF(), e = F6(), n = VF();
    function r(d) {
      var p = "https://react.dev/errors/" + d;
      if (1 < arguments.length) {
        p += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var x = 2; x < arguments.length; x++) p += "&args[]=" + encodeURIComponent(arguments[x]);
      }
      return "Minified React error #" + d + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function i(d) {
      return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11);
    }
    function a(d) {
      var p = d, x = d;
      if (d.alternate) for (; p.return; ) p = p.return;
      else {
        d = p;
        do
          p = d, (p.flags & 4098) !== 0 && (x = p.return), d = p.return;
        while (d);
      }
      return p.tag === 3 ? x : null;
    }
    function s(d) {
      if (d.tag === 13) {
        var p = d.memoizedState;
        if (p === null && (d = d.alternate, d !== null && (p = d.memoizedState)), p !== null) return p.dehydrated;
      }
      return null;
    }
    function o(d) {
      if (a(d) !== d) throw Error(r(188));
    }
    function l(d) {
      var p = d.alternate;
      if (!p) {
        if (p = a(d), p === null) throw Error(r(188));
        return p !== d ? null : d;
      }
      for (var x = d, A = p; ; ) {
        var M = x.return;
        if (M === null) break;
        var U = M.alternate;
        if (U === null) {
          if (A = M.return, A !== null) {
            x = A;
            continue;
          }
          break;
        }
        if (M.child === U.child) {
          for (U = M.child; U; ) {
            if (U === x) return o(M), d;
            if (U === A) return o(M), p;
            U = U.sibling;
          }
          throw Error(r(188));
        }
        if (x.return !== A.return) x = M, A = U;
        else {
          for (var W = false, Q = M.child; Q; ) {
            if (Q === x) {
              W = true, x = M, A = U;
              break;
            }
            if (Q === A) {
              W = true, A = M, x = U;
              break;
            }
            Q = Q.sibling;
          }
          if (!W) {
            for (Q = U.child; Q; ) {
              if (Q === x) {
                W = true, x = U, A = M;
                break;
              }
              if (Q === A) {
                W = true, A = U, x = M;
                break;
              }
              Q = Q.sibling;
            }
            if (!W) throw Error(r(189));
          }
        }
        if (x.alternate !== A) throw Error(r(190));
      }
      if (x.tag !== 3) throw Error(r(188));
      return x.stateNode.current === x ? d : p;
    }
    function c(d) {
      var p = d.tag;
      if (p === 5 || p === 26 || p === 27 || p === 6) return d;
      for (d = d.child; d !== null; ) {
        if (p = c(d), p !== null) return p;
        d = d.sibling;
      }
      return null;
    }
    var f = Object.assign, u = Symbol.for("react.element"), h = Symbol.for("react.transitional.element"), g = Symbol.for("react.portal"), v = Symbol.for("react.fragment"), m = Symbol.for("react.strict_mode"), y = Symbol.for("react.profiler"), w = Symbol.for("react.provider"), C = Symbol.for("react.consumer"), T = Symbol.for("react.context"), S = Symbol.for("react.forward_ref"), E = Symbol.for("react.suspense"), b = Symbol.for("react.suspense_list"), D = Symbol.for("react.memo"), R = Symbol.for("react.lazy"), I = Symbol.for("react.activity"), O = Symbol.for("react.memo_cache_sentinel"), L = Symbol.iterator;
    function N(d) {
      return d === null || typeof d != "object" ? null : (d = L && d[L] || d["@@iterator"], typeof d == "function" ? d : null);
    }
    var F = Symbol.for("react.client.reference");
    function V(d) {
      if (d == null) return null;
      if (typeof d == "function") return d.$$typeof === F ? null : d.displayName || d.name || null;
      if (typeof d == "string") return d;
      switch (d) {
        case v:
          return "Fragment";
        case y:
          return "Profiler";
        case m:
          return "StrictMode";
        case E:
          return "Suspense";
        case b:
          return "SuspenseList";
        case I:
          return "Activity";
      }
      if (typeof d == "object") switch (d.$$typeof) {
        case g:
          return "Portal";
        case T:
          return (d.displayName || "Context") + ".Provider";
        case C:
          return (d._context.displayName || "Context") + ".Consumer";
        case S:
          var p = d.render;
          return d = d.displayName, d || (d = p.displayName || p.name || "", d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef"), d;
        case D:
          return p = d.displayName || null, p !== null ? p : V(d.type) || "Memo";
        case R:
          p = d._payload, d = d._init;
          try {
            return V(d(p));
          } catch {
          }
      }
      return null;
    }
    var k = Array.isArray, _ = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, K = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Z = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, j = [], B = -1;
    function Y(d) {
      return {
        current: d
      };
    }
    function X(d) {
      0 > B || (d.current = j[B], j[B] = null, B--);
    }
    function ie(d, p) {
      B++, j[B] = d.current, d.current = p;
    }
    var oe = Y(null), he = Y(null), Le = Y(null), Je = Y(null);
    function Pe(d, p) {
      switch (ie(Le, p), ie(he, d), ie(oe, null), p.nodeType) {
        case 9:
        case 11:
          d = (d = p.documentElement) && (d = d.namespaceURI) ? Y7(d) : 0;
          break;
        default:
          if (d = p.tagName, p = p.namespaceURI) p = Y7(p), d = q7(p, d);
          else switch (d) {
            case "svg":
              d = 1;
              break;
            case "math":
              d = 2;
              break;
            default:
              d = 0;
          }
      }
      X(oe), ie(oe, d);
    }
    function ot() {
      X(oe), X(he), X(Le);
    }
    function vt(d) {
      d.memoizedState !== null && ie(Je, d);
      var p = oe.current, x = q7(p, d.type);
      p !== x && (ie(he, d), ie(oe, x));
    }
    function wt(d) {
      he.current === d && (X(oe), X(he)), Je.current === d && (X(Je), $f._currentValue = Z);
    }
    var Qe = Object.prototype.hasOwnProperty, _t6 = t.unstable_scheduleCallback, G = t.unstable_cancelCallback, Se = t.unstable_shouldYield, xe = t.unstable_requestPaint, re = t.unstable_now, ne = t.unstable_getCurrentPriorityLevel, ce = t.unstable_ImmediatePriority, Oe = t.unstable_UserBlockingPriority, Ve = t.unstable_NormalPriority, de = t.unstable_LowPriority, We = t.unstable_IdlePriority, Ze = t.log, Ge = t.unstable_setDisableYieldValue, at = null, ut = null;
    function it(d) {
      if (typeof Ze == "function" && Ge(d), ut && typeof ut.setStrictMode == "function") try {
        ut.setStrictMode(at, d);
      } catch {
      }
    }
    var fn = Math.clz32 ? Math.clz32 : Di, jt = Math.log, mr = Math.LN2;
    function Di(d) {
      return d >>>= 0, d === 0 ? 32 : 31 - (jt(d) / mr | 0) | 0;
    }
    var mn = 256, Wr = 4194304;
    function Ur(d) {
      var p = d & 42;
      if (p !== 0) return p;
      switch (d & -d) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return d & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return d & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return d;
      }
    }
    function ye(d, p, x) {
      var A = d.pendingLanes;
      if (A === 0) return 0;
      var M = 0, U = d.suspendedLanes, W = d.pingedLanes;
      d = d.warmLanes;
      var Q = A & 134217727;
      return Q !== 0 ? (A = Q & ~U, A !== 0 ? M = Ur(A) : (W &= Q, W !== 0 ? M = Ur(W) : x || (x = Q & ~d, x !== 0 && (M = Ur(x))))) : (Q = A & ~U, Q !== 0 ? M = Ur(Q) : W !== 0 ? M = Ur(W) : x || (x = A & ~d, x !== 0 && (M = Ur(x)))), M === 0 ? 0 : p !== 0 && p !== M && (p & U) === 0 && (U = M & -M, x = p & -p, U >= x || U === 32 && (x & 4194048) !== 0) ? p : M;
    }
    function ke(d, p) {
      return (d.pendingLanes & ~(d.suspendedLanes & ~d.pingedLanes) & p) === 0;
    }
    function rt(d, p) {
      switch (d) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return p + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return p + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function sn() {
      var d = mn;
      return mn <<= 1, (mn & 4194048) === 0 && (mn = 256), d;
    }
    function ti() {
      var d = Wr;
      return Wr <<= 1, (Wr & 62914560) === 0 && (Wr = 4194304), d;
    }
    function lr(d) {
      for (var p = [], x = 0; 31 > x; x++) p.push(d);
      return p;
    }
    function vn(d, p) {
      d.pendingLanes |= p, p !== 268435456 && (d.suspendedLanes = 0, d.pingedLanes = 0, d.warmLanes = 0);
    }
    function xa(d, p, x, A, M, U) {
      var W = d.pendingLanes;
      d.pendingLanes = x, d.suspendedLanes = 0, d.pingedLanes = 0, d.warmLanes = 0, d.expiredLanes &= x, d.entangledLanes &= x, d.errorRecoveryDisabledLanes &= x, d.shellSuspendCounter = 0;
      var Q = d.entanglements, ae = d.expirationTimes, ve = d.hiddenUpdates;
      for (x = W & ~x; 0 < x; ) {
        var Ie = 31 - fn(x), Fe = 1 << Ie;
        Q[Ie] = 0, ae[Ie] = -1;
        var we = ve[Ie];
        if (we !== null) for (ve[Ie] = null, Ie = 0; Ie < we.length; Ie++) {
          var Ce = we[Ie];
          Ce !== null && (Ce.lane &= -536870913);
        }
        x &= ~Fe;
      }
      A !== 0 && Mo(d, A, 0), U !== 0 && M === 0 && d.tag !== 0 && (d.suspendedLanes |= U & ~(W & ~p));
    }
    function Mo(d, p, x) {
      d.pendingLanes |= p, d.suspendedLanes &= ~p;
      var A = 31 - fn(p);
      d.entangledLanes |= p, d.entanglements[A] = d.entanglements[A] | 1073741824 | x & 4194090;
    }
    function za(d, p) {
      var x = d.entangledLanes |= p;
      for (d = d.entanglements; x; ) {
        var A = 31 - fn(x), M = 1 << A;
        M & p | d[A] & p && (d[A] |= p), x &= ~M;
      }
    }
    function fs(d) {
      switch (d) {
        case 2:
          d = 1;
          break;
        case 8:
          d = 4;
          break;
        case 32:
          d = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          d = 128;
          break;
        case 268435456:
          d = 134217728;
          break;
        default:
          d = 0;
      }
      return d;
    }
    function Ro(d) {
      return d &= -d, 2 < d ? 8 < d ? (d & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function Oo() {
      var d = K.p;
      return d !== 0 ? d : (d = window.event, d === void 0 ? 32 : dw(d.type));
    }
    function _s(d, p) {
      var x = K.p;
      try {
        return K.p = d, p();
      } finally {
        K.p = x;
      }
    }
    var vr = Math.random().toString(36).slice(2), yr = "__reactFiber$" + vr, Fr = "__reactProps$" + vr, na = "__reactContainer$" + vr, ks = "__reactEvents$" + vr, ff = "__reactListeners$" + vr, ra = "__reactHandles$" + vr, Io = "__reactResources$" + vr, wa = "__reactMarker$" + vr;
    function Vo(d) {
      delete d[yr], delete d[Fr], delete d[ks], delete d[ff], delete d[ra];
    }
    function Wa(d) {
      var p = d[yr];
      if (p) return p;
      for (var x = d.parentNode; x; ) {
        if (p = x[na] || x[yr]) {
          if (x = p.alternate, p.child !== null || x !== null && x.child !== null) for (d = J7(d); d !== null; ) {
            if (x = d[yr]) return x;
            d = J7(d);
          }
          return p;
        }
        d = x, x = d.parentNode;
      }
      return null;
    }
    function ia(d) {
      if (d = d[yr] || d[na]) {
        var p = d.tag;
        if (p === 5 || p === 6 || p === 13 || p === 26 || p === 27 || p === 3) return d;
      }
      return null;
    }
    function Mi(d) {
      var p = d.tag;
      if (p === 5 || p === 26 || p === 27 || p === 6) return d.stateNode;
      throw Error(r(33));
    }
    function hs(d) {
      var p = d[Io];
      return p || (p = d[Io] = {
        hoistableStyles: /* @__PURE__ */ new Map(),
        hoistableScripts: /* @__PURE__ */ new Map()
      }), p;
    }
    function cr(d) {
      d[wa] = true;
    }
    var c0 = /* @__PURE__ */ new Set(), No = {};
    function Ca(d, p) {
      ni(d, p), ni(d + "Capture", p);
    }
    function ni(d, p) {
      for (No[d] = p, d = 0; d < p.length; d++) c0.add(p[d]);
    }
    var u0 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Hl = {}, f0 = {};
    function hf(d) {
      return Qe.call(f0, d) ? true : Qe.call(Hl, d) ? false : u0.test(d) ? f0[d] = true : (Hl[d] = true, false);
    }
    function Ri(d, p, x) {
      if (hf(p)) if (x === null) d.removeAttribute(p);
      else {
        switch (typeof x) {
          case "undefined":
          case "function":
          case "symbol":
            d.removeAttribute(p);
            return;
          case "boolean":
            var A = p.toLowerCase().slice(0, 5);
            if (A !== "data-" && A !== "aria-") {
              d.removeAttribute(p);
              return;
            }
        }
        d.setAttribute(p, "" + x);
      }
    }
    function ds(d, p, x) {
      if (x === null) d.removeAttribute(p);
      else {
        switch (typeof x) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            d.removeAttribute(p);
            return;
        }
        d.setAttribute(p, "" + x);
      }
    }
    function Oi(d, p, x, A) {
      if (A === null) d.removeAttribute(x);
      else {
        switch (typeof A) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            d.removeAttribute(x);
            return;
        }
        d.setAttributeNS(p, x, "" + A);
      }
    }
    var Ha, jl;
    function aa(d) {
      if (Ha === void 0) try {
        throw Error();
      } catch (x) {
        var p = x.stack.trim().match(/\n( *(at )?)/);
        Ha = p && p[1] || "", jl = -1 < x.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return `
` + Ha + d + jl;
    }
    var Hi = false;
    function Ta(d, p) {
      if (!d || Hi) return "";
      Hi = true;
      var x = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var A = {
          DetermineComponentFrameRoot: function() {
            try {
              if (p) {
                var Fe = function() {
                  throw Error();
                };
                if (Object.defineProperty(Fe.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fe, []);
                  } catch (Ce) {
                    var we = Ce;
                  }
                  Reflect.construct(d, [], Fe);
                } else {
                  try {
                    Fe.call();
                  } catch (Ce) {
                    we = Ce;
                  }
                  d.call(Fe.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Ce) {
                  we = Ce;
                }
                (Fe = d()) && typeof Fe.catch == "function" && Fe.catch(function() {
                });
              }
            } catch (Ce) {
              if (Ce && we && typeof Ce.stack == "string") return [
                Ce.stack,
                we.stack
              ];
            }
            return [
              null,
              null
            ];
          }
        };
        A.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var M = Object.getOwnPropertyDescriptor(A.DetermineComponentFrameRoot, "name");
        M && M.configurable && Object.defineProperty(A.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot"
        });
        var U = A.DetermineComponentFrameRoot(), W = U[0], Q = U[1];
        if (W && Q) {
          var ae = W.split(`
`), ve = Q.split(`
`);
          for (M = A = 0; A < ae.length && !ae[A].includes("DetermineComponentFrameRoot"); ) A++;
          for (; M < ve.length && !ve[M].includes("DetermineComponentFrameRoot"); ) M++;
          if (A === ae.length || M === ve.length) for (A = ae.length - 1, M = ve.length - 1; 1 <= A && 0 <= M && ae[A] !== ve[M]; ) M--;
          for (; 1 <= A && 0 <= M; A--, M--) if (ae[A] !== ve[M]) {
            if (A !== 1 || M !== 1) do
              if (A--, M--, 0 > M || ae[A] !== ve[M]) {
                var Ie = `
` + ae[A].replace(" at new ", " at ");
                return d.displayName && Ie.includes("<anonymous>") && (Ie = Ie.replace("<anonymous>", d.displayName)), Ie;
              }
            while (1 <= A && 0 <= M);
            break;
          }
        }
      } finally {
        Hi = false, Error.prepareStackTrace = x;
      }
      return (x = d ? d.displayName || d.name : "") ? aa(x) : "";
    }
    function Kl(d) {
      switch (d.tag) {
        case 26:
        case 27:
        case 5:
          return aa(d.type);
        case 16:
          return aa("Lazy");
        case 13:
          return aa("Suspense");
        case 19:
          return aa("SuspenseList");
        case 0:
        case 15:
          return Ta(d.type, false);
        case 11:
          return Ta(d.type.render, false);
        case 1:
          return Ta(d.type, true);
        case 31:
          return aa("Activity");
        default:
          return "";
      }
    }
    function gs(d) {
      try {
        var p = "";
        do
          p += Kl(d), d = d.return;
        while (d);
        return p;
      } catch (x) {
        return `
Error generating stack: ` + x.message + `
` + x.stack;
      }
    }
    function mi(d) {
      switch (typeof d) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return d;
        case "object":
          return d;
        default:
          return "";
      }
    }
    function h0(d) {
      var p = d.type;
      return (d = d.nodeName) && d.toLowerCase() === "input" && (p === "checkbox" || p === "radio");
    }
    function Yl(d) {
      var p = h0(d) ? "checked" : "value", x = Object.getOwnPropertyDescriptor(d.constructor.prototype, p), A = "" + d[p];
      if (!d.hasOwnProperty(p) && typeof x < "u" && typeof x.get == "function" && typeof x.set == "function") {
        var M = x.get, U = x.set;
        return Object.defineProperty(d, p, {
          configurable: true,
          get: function() {
            return M.call(this);
          },
          set: function(W) {
            A = "" + W, U.call(this, W);
          }
        }), Object.defineProperty(d, p, {
          enumerable: x.enumerable
        }), {
          getValue: function() {
            return A;
          },
          setValue: function(W) {
            A = "" + W;
          },
          stopTracking: function() {
            d._valueTracker = null, delete d[p];
          }
        };
      }
    }
    function Lo(d) {
      d._valueTracker || (d._valueTracker = Yl(d));
    }
    function d0(d) {
      if (!d) return false;
      var p = d._valueTracker;
      if (!p) return true;
      var x = p.getValue(), A = "";
      return d && (A = h0(d) ? d.checked ? "true" : "false" : d.value), d = A, d !== x ? (p.setValue(d), true) : false;
    }
    function Ps(d) {
      if (d = d || (typeof document < "u" ? document : void 0), typeof d > "u") return null;
      try {
        return d.activeElement || d.body;
      } catch {
        return d.body;
      }
    }
    var df = /[\n"\\]/g;
    function vi(d) {
      return d.replace(df, function(p) {
        return "\\" + p.charCodeAt(0).toString(16) + " ";
      });
    }
    function ql(d, p, x, A, M, U, W, Q) {
      d.name = "", W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" ? d.type = W : d.removeAttribute("type"), p != null ? W === "number" ? (p === 0 && d.value === "" || d.value != p) && (d.value = "" + mi(p)) : d.value !== "" + mi(p) && (d.value = "" + mi(p)) : W !== "submit" && W !== "reset" || d.removeAttribute("value"), p != null ? Uo(d, W, mi(p)) : x != null ? Uo(d, W, mi(x)) : A != null && d.removeAttribute("value"), M == null && U != null && (d.defaultChecked = !!U), M != null && (d.checked = M && typeof M != "function" && typeof M != "symbol"), Q != null && typeof Q != "function" && typeof Q != "symbol" && typeof Q != "boolean" ? d.name = "" + mi(Q) : d.removeAttribute("name");
    }
    function Gs(d, p, x, A, M, U, W, Q) {
      if (U != null && typeof U != "function" && typeof U != "symbol" && typeof U != "boolean" && (d.type = U), p != null || x != null) {
        if (!(U !== "submit" && U !== "reset" || p != null)) return;
        x = x != null ? "" + mi(x) : "", p = p != null ? "" + mi(p) : x, Q || p === d.value || (d.value = p), d.defaultValue = p;
      }
      A = A ?? M, A = typeof A != "function" && typeof A != "symbol" && !!A, d.checked = Q ? d.checked : !!A, d.defaultChecked = !!A, W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" && (d.name = W);
    }
    function Uo(d, p, x) {
      p === "number" && Ps(d.ownerDocument) === d || d.defaultValue === "" + x || (d.defaultValue = "" + x);
    }
    function ps(d, p, x, A) {
      if (d = d.options, p) {
        p = {};
        for (var M = 0; M < x.length; M++) p["$" + x[M]] = true;
        for (x = 0; x < d.length; x++) M = p.hasOwnProperty("$" + d[x].value), d[x].selected !== M && (d[x].selected = M), M && A && (d[x].defaultSelected = true);
      } else {
        for (x = "" + mi(x), p = null, M = 0; M < d.length; M++) {
          if (d[M].value === x) {
            d[M].selected = true, A && (d[M].defaultSelected = true);
            return;
          }
          p !== null || d[M].disabled || (p = d[M]);
        }
        p !== null && (p.selected = true);
      }
    }
    function z(d, p, x) {
      if (p != null && (p = "" + mi(p), p !== d.value && (d.value = p), x == null)) {
        d.defaultValue !== p && (d.defaultValue = p);
        return;
      }
      d.defaultValue = x != null ? "" + mi(x) : "";
    }
    function P(d, p, x, A) {
      if (p == null) {
        if (A != null) {
          if (x != null) throw Error(r(92));
          if (k(A)) {
            if (1 < A.length) throw Error(r(93));
            A = A[0];
          }
          x = A;
        }
        x == null && (x = ""), p = x;
      }
      x = mi(p), d.defaultValue = x, A = d.textContent, A === x && A !== "" && A !== null && (d.value = A);
    }
    function q(d, p) {
      if (p) {
        var x = d.firstChild;
        if (x && x === d.lastChild && x.nodeType === 3) {
          x.nodeValue = p;
          return;
        }
      }
      d.textContent = p;
    }
    var te = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function ge(d, p, x) {
      var A = p.indexOf("--") === 0;
      x == null || typeof x == "boolean" || x === "" ? A ? d.setProperty(p, "") : p === "float" ? d.cssFloat = "" : d[p] = "" : A ? d.setProperty(p, x) : typeof x != "number" || x === 0 || te.has(p) ? p === "float" ? d.cssFloat = x : d[p] = ("" + x).trim() : d[p] = x + "px";
    }
    function Ae(d, p, x) {
      if (p != null && typeof p != "object") throw Error(r(62));
      if (d = d.style, x != null) {
        for (var A in x) !x.hasOwnProperty(A) || p != null && p.hasOwnProperty(A) || (A.indexOf("--") === 0 ? d.setProperty(A, "") : A === "float" ? d.cssFloat = "" : d[A] = "");
        for (var M in p) A = p[M], p.hasOwnProperty(M) && x[M] !== A && ge(d, M, A);
      } else for (var U in p) p.hasOwnProperty(U) && ge(d, U, p[U]);
    }
    function Ee(d) {
      if (d.indexOf("-") === -1) return false;
      switch (d) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var De = /* @__PURE__ */ new Map([
      [
        "acceptCharset",
        "accept-charset"
      ],
      [
        "htmlFor",
        "for"
      ],
      [
        "httpEquiv",
        "http-equiv"
      ],
      [
        "crossOrigin",
        "crossorigin"
      ],
      [
        "accentHeight",
        "accent-height"
      ],
      [
        "alignmentBaseline",
        "alignment-baseline"
      ],
      [
        "arabicForm",
        "arabic-form"
      ],
      [
        "baselineShift",
        "baseline-shift"
      ],
      [
        "capHeight",
        "cap-height"
      ],
      [
        "clipPath",
        "clip-path"
      ],
      [
        "clipRule",
        "clip-rule"
      ],
      [
        "colorInterpolation",
        "color-interpolation"
      ],
      [
        "colorInterpolationFilters",
        "color-interpolation-filters"
      ],
      [
        "colorProfile",
        "color-profile"
      ],
      [
        "colorRendering",
        "color-rendering"
      ],
      [
        "dominantBaseline",
        "dominant-baseline"
      ],
      [
        "enableBackground",
        "enable-background"
      ],
      [
        "fillOpacity",
        "fill-opacity"
      ],
      [
        "fillRule",
        "fill-rule"
      ],
      [
        "floodColor",
        "flood-color"
      ],
      [
        "floodOpacity",
        "flood-opacity"
      ],
      [
        "fontFamily",
        "font-family"
      ],
      [
        "fontSize",
        "font-size"
      ],
      [
        "fontSizeAdjust",
        "font-size-adjust"
      ],
      [
        "fontStretch",
        "font-stretch"
      ],
      [
        "fontStyle",
        "font-style"
      ],
      [
        "fontVariant",
        "font-variant"
      ],
      [
        "fontWeight",
        "font-weight"
      ],
      [
        "glyphName",
        "glyph-name"
      ],
      [
        "glyphOrientationHorizontal",
        "glyph-orientation-horizontal"
      ],
      [
        "glyphOrientationVertical",
        "glyph-orientation-vertical"
      ],
      [
        "horizAdvX",
        "horiz-adv-x"
      ],
      [
        "horizOriginX",
        "horiz-origin-x"
      ],
      [
        "imageRendering",
        "image-rendering"
      ],
      [
        "letterSpacing",
        "letter-spacing"
      ],
      [
        "lightingColor",
        "lighting-color"
      ],
      [
        "markerEnd",
        "marker-end"
      ],
      [
        "markerMid",
        "marker-mid"
      ],
      [
        "markerStart",
        "marker-start"
      ],
      [
        "overlinePosition",
        "overline-position"
      ],
      [
        "overlineThickness",
        "overline-thickness"
      ],
      [
        "paintOrder",
        "paint-order"
      ],
      [
        "panose-1",
        "panose-1"
      ],
      [
        "pointerEvents",
        "pointer-events"
      ],
      [
        "renderingIntent",
        "rendering-intent"
      ],
      [
        "shapeRendering",
        "shape-rendering"
      ],
      [
        "stopColor",
        "stop-color"
      ],
      [
        "stopOpacity",
        "stop-opacity"
      ],
      [
        "strikethroughPosition",
        "strikethrough-position"
      ],
      [
        "strikethroughThickness",
        "strikethrough-thickness"
      ],
      [
        "strokeDasharray",
        "stroke-dasharray"
      ],
      [
        "strokeDashoffset",
        "stroke-dashoffset"
      ],
      [
        "strokeLinecap",
        "stroke-linecap"
      ],
      [
        "strokeLinejoin",
        "stroke-linejoin"
      ],
      [
        "strokeMiterlimit",
        "stroke-miterlimit"
      ],
      [
        "strokeOpacity",
        "stroke-opacity"
      ],
      [
        "strokeWidth",
        "stroke-width"
      ],
      [
        "textAnchor",
        "text-anchor"
      ],
      [
        "textDecoration",
        "text-decoration"
      ],
      [
        "textRendering",
        "text-rendering"
      ],
      [
        "transformOrigin",
        "transform-origin"
      ],
      [
        "underlinePosition",
        "underline-position"
      ],
      [
        "underlineThickness",
        "underline-thickness"
      ],
      [
        "unicodeBidi",
        "unicode-bidi"
      ],
      [
        "unicodeRange",
        "unicode-range"
      ],
      [
        "unitsPerEm",
        "units-per-em"
      ],
      [
        "vAlphabetic",
        "v-alphabetic"
      ],
      [
        "vHanging",
        "v-hanging"
      ],
      [
        "vIdeographic",
        "v-ideographic"
      ],
      [
        "vMathematical",
        "v-mathematical"
      ],
      [
        "vectorEffect",
        "vector-effect"
      ],
      [
        "vertAdvY",
        "vert-adv-y"
      ],
      [
        "vertOriginX",
        "vert-origin-x"
      ],
      [
        "vertOriginY",
        "vert-origin-y"
      ],
      [
        "wordSpacing",
        "word-spacing"
      ],
      [
        "writingMode",
        "writing-mode"
      ],
      [
        "xmlnsXlink",
        "xmlns:xlink"
      ],
      [
        "xHeight",
        "x-height"
      ]
    ]), Be = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Me(d) {
      return Be.test("" + d) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : d;
    }
    var _e11 = null;
    function et(d) {
      return d = d.target || d.srcElement || window, d.correspondingUseElement && (d = d.correspondingUseElement), d.nodeType === 3 ? d.parentNode : d;
    }
    var lt = null, St = null;
    function At(d) {
      var p = ia(d);
      if (p && (d = p.stateNode)) {
        var x = d[Fr] || null;
        e: switch (d = p.stateNode, p.type) {
          case "input":
            if (ql(d, x.value, x.defaultValue, x.defaultValue, x.checked, x.defaultChecked, x.type, x.name), p = x.name, x.type === "radio" && p != null) {
              for (x = d; x.parentNode; ) x = x.parentNode;
              for (x = x.querySelectorAll('input[name="' + vi("" + p) + '"][type="radio"]'), p = 0; p < x.length; p++) {
                var A = x[p];
                if (A !== d && A.form === d.form) {
                  var M = A[Fr] || null;
                  if (!M) throw Error(r(90));
                  ql(A, M.value, M.defaultValue, M.defaultValue, M.checked, M.defaultChecked, M.type, M.name);
                }
              }
              for (p = 0; p < x.length; p++) A = x[p], A.form === d.form && d0(A);
            }
            break e;
          case "textarea":
            z(d, x.value, x.defaultValue);
            break e;
          case "select":
            p = x.value, p != null && ps(d, !!x.multiple, p, false);
        }
      }
    }
    var Mt = false;
    function $e(d, p, x) {
      if (Mt) return d(p, x);
      Mt = true;
      try {
        var A = d(p);
        return A;
      } finally {
        if (Mt = false, (lt !== null || St !== null) && (qd(), lt && (p = lt, d = St, St = lt = null, At(p), d))) for (p = 0; p < d.length; p++) At(d[p]);
      }
    }
    function Lt(d, p) {
      var x = d.stateNode;
      if (x === null) return null;
      var A = x[Fr] || null;
      if (A === null) return null;
      x = A[p];
      e: switch (p) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (A = !A.disabled) || (d = d.type, A = !(d === "button" || d === "input" || d === "select" || d === "textarea")), d = !A;
          break e;
        default:
          d = false;
      }
      if (d) return null;
      if (x && typeof x != "function") throw Error(r(231, p, typeof x));
      return x;
    }
    var It = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Kt = false;
    if (It) try {
      var xt = {};
      Object.defineProperty(xt, "passive", {
        get: function() {
          Kt = true;
        }
      }), window.addEventListener("test", xt, xt), window.removeEventListener("test", xt, xt);
    } catch {
      Kt = false;
    }
    var on = null, Qt = null, Pt = null;
    function nt() {
      if (Pt) return Pt;
      var d, p = Qt, x = p.length, A, M = "value" in on ? on.value : on.textContent, U = M.length;
      for (d = 0; d < x && p[d] === M[d]; d++) ;
      var W = x - d;
      for (A = 1; A <= W && p[x - A] === M[U - A]; A++) ;
      return Pt = M.slice(d, 1 < A ? 1 - A : void 0);
    }
    function Nn(d) {
      var p = d.keyCode;
      return "charCode" in d ? (d = d.charCode, d === 0 && p === 13 && (d = 13)) : d = p, d === 10 && (d = 13), 32 <= d || d === 13 ? d : 0;
    }
    function Xt() {
      return true;
    }
    function $() {
      return false;
    }
    function ue(d) {
      function p(x, A, M, U, W) {
        this._reactName = x, this._targetInst = M, this.type = A, this.nativeEvent = U, this.target = W, this.currentTarget = null;
        for (var Q in d) d.hasOwnProperty(Q) && (x = d[Q], this[Q] = x ? x(U) : U[Q]);
        return this.isDefaultPrevented = (U.defaultPrevented != null ? U.defaultPrevented : U.returnValue === false) ? Xt : $, this.isPropagationStopped = $, this;
      }
      return f(p.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var x = this.nativeEvent;
          x && (x.preventDefault ? x.preventDefault() : typeof x.returnValue != "unknown" && (x.returnValue = false), this.isDefaultPrevented = Xt);
        },
        stopPropagation: function() {
          var x = this.nativeEvent;
          x && (x.stopPropagation ? x.stopPropagation() : typeof x.cancelBubble != "unknown" && (x.cancelBubble = true), this.isPropagationStopped = Xt);
        },
        persist: function() {
        },
        isPersistent: Xt
      }), p;
    }
    var Te = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(d) {
        return d.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Xe = ue(Te), Ut = f({}, Te, {
      view: 0,
      detail: 0
    }), Wt = ue(Ut), nn, wn, tr, Xn = f({}, Ut, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: q5,
      button: 0,
      buttons: 0,
      relatedTarget: function(d) {
        return d.relatedTarget === void 0 ? d.fromElement === d.srcElement ? d.toElement : d.fromElement : d.relatedTarget;
      },
      movementX: function(d) {
        return "movementX" in d ? d.movementX : (d !== tr && (tr && d.type === "mousemove" ? (nn = d.screenX - tr.screenX, wn = d.screenY - tr.screenY) : wn = nn = 0, tr = d), nn);
      },
      movementY: function(d) {
        return "movementY" in d ? d.movementY : wn;
      }
    }), xr = ue(Xn), yi = f({}, Xn, {
      dataTransfer: 0
    }), Ii = ue(yi), br = f({}, Ut, {
      relatedTarget: 0
    }), Yn = ue(br), g0 = f({}, Te, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Xl = ue(g0), Fo = f({}, Te, {
      clipboardData: function(d) {
        return "clipboardData" in d ? d.clipboardData : window.clipboardData;
      }
    }), Y5 = ue(Fo), dd = f({}, Te, {
      data: 0
    }), gf = ue(dd), gd = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, FL = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, pf = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function BL(d) {
      var p = this.nativeEvent;
      return p.getModifierState ? p.getModifierState(d) : (d = pf[d]) ? !!p[d] : false;
    }
    function q5() {
      return BL;
    }
    var _L = f({}, Ut, {
      key: function(d) {
        if (d.key) {
          var p = gd[d.key] || d.key;
          if (p !== "Unidentified") return p;
        }
        return d.type === "keypress" ? (d = Nn(d), d === 13 ? "Enter" : String.fromCharCode(d)) : d.type === "keydown" || d.type === "keyup" ? FL[d.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: q5,
      charCode: function(d) {
        return d.type === "keypress" ? Nn(d) : 0;
      },
      keyCode: function(d) {
        return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
      },
      which: function(d) {
        return d.type === "keypress" ? Nn(d) : d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
      }
    }), kL = ue(_L), PL = f({}, Xn, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), t9 = ue(PL), GL = f({}, Ut, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: q5
    }), zL = ue(GL), WL = f({}, Te, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), HL = ue(WL), jL = f({}, Xn, {
      deltaX: function(d) {
        return "deltaX" in d ? d.deltaX : "wheelDeltaX" in d ? -d.wheelDeltaX : 0;
      },
      deltaY: function(d) {
        return "deltaY" in d ? d.deltaY : "wheelDeltaY" in d ? -d.wheelDeltaY : "wheelDelta" in d ? -d.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), KL = ue(jL), YL = f({}, Te, {
      newState: 0,
      oldState: 0
    }), qL = ue(YL), XL = [
      9,
      13,
      27,
      32
    ], X5 = It && "CompositionEvent" in window, mf = null;
    It && "documentMode" in document && (mf = document.documentMode);
    var ZL = It && "TextEvent" in window && !mf, n9 = It && (!X5 || mf && 8 < mf && 11 >= mf), r9 = " ", i9 = false;
    function a9(d, p) {
      switch (d) {
        case "keyup":
          return XL.indexOf(p.keyCode) !== -1;
        case "keydown":
          return p.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function s9(d) {
      return d = d.detail, typeof d == "object" && "data" in d ? d.data : null;
    }
    var p0 = false;
    function QL(d, p) {
      switch (d) {
        case "compositionend":
          return s9(p);
        case "keypress":
          return p.which !== 32 ? null : (i9 = true, r9);
        case "textInput":
          return d = p.data, d === r9 && i9 ? null : d;
        default:
          return null;
      }
    }
    function JL(d, p) {
      if (p0) return d === "compositionend" || !X5 && a9(d, p) ? (d = nt(), Pt = Qt = on = null, p0 = false, d) : null;
      switch (d) {
        case "paste":
          return null;
        case "keypress":
          if (!(p.ctrlKey || p.altKey || p.metaKey) || p.ctrlKey && p.altKey) {
            if (p.char && 1 < p.char.length) return p.char;
            if (p.which) return String.fromCharCode(p.which);
          }
          return null;
        case "compositionend":
          return n9 && p.locale !== "ko" ? null : p.data;
        default:
          return null;
      }
    }
    var $L = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function o9(d) {
      var p = d && d.nodeName && d.nodeName.toLowerCase();
      return p === "input" ? !!$L[d.type] : p === "textarea";
    }
    function l9(d, p, x, A) {
      lt ? St ? St.push(A) : St = [
        A
      ] : lt = A, p = e2(p, "onChange"), 0 < p.length && (x = new Xe("onChange", "change", null, x, A), d.push({
        event: x,
        listeners: p
      }));
    }
    var vf = null, yf = null;
    function eU(d) {
      z7(d, 0);
    }
    function pd(d) {
      var p = Mi(d);
      if (d0(p)) return d;
    }
    function c9(d, p) {
      if (d === "change") return p;
    }
    var u9 = false;
    if (It) {
      var Z5;
      if (It) {
        var Q5 = "oninput" in document;
        if (!Q5) {
          var f9 = document.createElement("div");
          f9.setAttribute("oninput", "return;"), Q5 = typeof f9.oninput == "function";
        }
        Z5 = Q5;
      } else Z5 = false;
      u9 = Z5 && (!document.documentMode || 9 < document.documentMode);
    }
    function h9() {
      vf && (vf.detachEvent("onpropertychange", d9), yf = vf = null);
    }
    function d9(d) {
      if (d.propertyName === "value" && pd(yf)) {
        var p = [];
        l9(p, yf, d, et(d)), $e(eU, p);
      }
    }
    function tU(d, p, x) {
      d === "focusin" ? (h9(), vf = p, yf = x, vf.attachEvent("onpropertychange", d9)) : d === "focusout" && h9();
    }
    function nU(d) {
      if (d === "selectionchange" || d === "keyup" || d === "keydown") return pd(yf);
    }
    function rU(d, p) {
      if (d === "click") return pd(p);
    }
    function iU(d, p) {
      if (d === "input" || d === "change") return pd(p);
    }
    function aU(d, p) {
      return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
    }
    var sa = typeof Object.is == "function" ? Object.is : aU;
    function xf(d, p) {
      if (sa(d, p)) return true;
      if (typeof d != "object" || d === null || typeof p != "object" || p === null) return false;
      var x = Object.keys(d), A = Object.keys(p);
      if (x.length !== A.length) return false;
      for (A = 0; A < x.length; A++) {
        var M = x[A];
        if (!Qe.call(p, M) || !sa(d[M], p[M])) return false;
      }
      return true;
    }
    function g9(d) {
      for (; d && d.firstChild; ) d = d.firstChild;
      return d;
    }
    function p9(d, p) {
      var x = g9(d);
      d = 0;
      for (var A; x; ) {
        if (x.nodeType === 3) {
          if (A = d + x.textContent.length, d <= p && A >= p) return {
            node: x,
            offset: p - d
          };
          d = A;
        }
        e: {
          for (; x; ) {
            if (x.nextSibling) {
              x = x.nextSibling;
              break e;
            }
            x = x.parentNode;
          }
          x = void 0;
        }
        x = g9(x);
      }
    }
    function m9(d, p) {
      return d && p ? d === p ? true : d && d.nodeType === 3 ? false : p && p.nodeType === 3 ? m9(d, p.parentNode) : "contains" in d ? d.contains(p) : d.compareDocumentPosition ? !!(d.compareDocumentPosition(p) & 16) : false : false;
    }
    function v9(d) {
      d = d != null && d.ownerDocument != null && d.ownerDocument.defaultView != null ? d.ownerDocument.defaultView : window;
      for (var p = Ps(d.document); p instanceof d.HTMLIFrameElement; ) {
        try {
          var x = typeof p.contentWindow.location.href == "string";
        } catch {
          x = false;
        }
        if (x) d = p.contentWindow;
        else break;
        p = Ps(d.document);
      }
      return p;
    }
    function J5(d) {
      var p = d && d.nodeName && d.nodeName.toLowerCase();
      return p && (p === "input" && (d.type === "text" || d.type === "search" || d.type === "tel" || d.type === "url" || d.type === "password") || p === "textarea" || d.contentEditable === "true");
    }
    var sU = It && "documentMode" in document && 11 >= document.documentMode, m0 = null, $5 = null, wf = null, em = false;
    function y9(d, p, x) {
      var A = x.window === x ? x.document : x.nodeType === 9 ? x : x.ownerDocument;
      em || m0 == null || m0 !== Ps(A) || (A = m0, "selectionStart" in A && J5(A) ? A = {
        start: A.selectionStart,
        end: A.selectionEnd
      } : (A = (A.ownerDocument && A.ownerDocument.defaultView || window).getSelection(), A = {
        anchorNode: A.anchorNode,
        anchorOffset: A.anchorOffset,
        focusNode: A.focusNode,
        focusOffset: A.focusOffset
      }), wf && xf(wf, A) || (wf = A, A = e2($5, "onSelect"), 0 < A.length && (p = new Xe("onSelect", "select", null, p, x), d.push({
        event: p,
        listeners: A
      }), p.target = m0)));
    }
    function Zl(d, p) {
      var x = {};
      return x[d.toLowerCase()] = p.toLowerCase(), x["Webkit" + d] = "webkit" + p, x["Moz" + d] = "moz" + p, x;
    }
    var v0 = {
      animationend: Zl("Animation", "AnimationEnd"),
      animationiteration: Zl("Animation", "AnimationIteration"),
      animationstart: Zl("Animation", "AnimationStart"),
      transitionrun: Zl("Transition", "TransitionRun"),
      transitionstart: Zl("Transition", "TransitionStart"),
      transitioncancel: Zl("Transition", "TransitionCancel"),
      transitionend: Zl("Transition", "TransitionEnd")
    }, tm = {}, x9 = {};
    It && (x9 = document.createElement("div").style, "AnimationEvent" in window || (delete v0.animationend.animation, delete v0.animationiteration.animation, delete v0.animationstart.animation), "TransitionEvent" in window || delete v0.transitionend.transition);
    function Ql(d) {
      if (tm[d]) return tm[d];
      if (!v0[d]) return d;
      var p = v0[d], x;
      for (x in p) if (p.hasOwnProperty(x) && x in x9) return tm[d] = p[x];
      return d;
    }
    var w9 = Ql("animationend"), C9 = Ql("animationiteration"), T9 = Ql("animationstart"), oU = Ql("transitionrun"), lU = Ql("transitionstart"), cU = Ql("transitioncancel"), S9 = Ql("transitionend"), A9 = /* @__PURE__ */ new Map(), nm = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    nm.push("scrollEnd");
    function ja(d, p) {
      A9.set(d, p), Ca(p, [
        d
      ]);
    }
    var E9 = /* @__PURE__ */ new WeakMap();
    function Sa(d, p) {
      if (typeof d == "object" && d !== null) {
        var x = E9.get(d);
        return x !== void 0 ? x : (p = {
          value: d,
          source: p,
          stack: gs(p)
        }, E9.set(d, p), p);
      }
      return {
        value: d,
        source: p,
        stack: gs(p)
      };
    }
    var Aa = [], y0 = 0, rm = 0;
    function md() {
      for (var d = y0, p = rm = y0 = 0; p < d; ) {
        var x = Aa[p];
        Aa[p++] = null;
        var A = Aa[p];
        Aa[p++] = null;
        var M = Aa[p];
        Aa[p++] = null;
        var U = Aa[p];
        if (Aa[p++] = null, A !== null && M !== null) {
          var W = A.pending;
          W === null ? M.next = M : (M.next = W.next, W.next = M), A.pending = M;
        }
        U !== 0 && b9(x, M, U);
      }
    }
    function vd(d, p, x, A) {
      Aa[y0++] = d, Aa[y0++] = p, Aa[y0++] = x, Aa[y0++] = A, rm |= A, d.lanes |= A, d = d.alternate, d !== null && (d.lanes |= A);
    }
    function im(d, p, x, A) {
      return vd(d, p, x, A), yd(d);
    }
    function x0(d, p) {
      return vd(d, null, null, p), yd(d);
    }
    function b9(d, p, x) {
      d.lanes |= x;
      var A = d.alternate;
      A !== null && (A.lanes |= x);
      for (var M = false, U = d.return; U !== null; ) U.childLanes |= x, A = U.alternate, A !== null && (A.childLanes |= x), U.tag === 22 && (d = U.stateNode, d === null || d._visibility & 1 || (M = true)), d = U, U = U.return;
      return d.tag === 3 ? (U = d.stateNode, M && p !== null && (M = 31 - fn(x), d = U.hiddenUpdates, A = d[M], A === null ? d[M] = [
        p
      ] : A.push(p), p.lane = x | 536870912), U) : null;
    }
    function yd(d) {
      if (50 < jf) throw jf = 0, u3 = null, Error(r(185));
      for (var p = d.return; p !== null; ) d = p, p = d.return;
      return d.tag === 3 ? d.stateNode : null;
    }
    var w0 = {};
    function uU(d, p, x, A) {
      this.tag = d, this.key = x, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = p, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = A, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function oa(d, p, x, A) {
      return new uU(d, p, x, A);
    }
    function am(d) {
      return d = d.prototype, !(!d || !d.isReactComponent);
    }
    function zs(d, p) {
      var x = d.alternate;
      return x === null ? (x = oa(d.tag, p, d.key, d.mode), x.elementType = d.elementType, x.type = d.type, x.stateNode = d.stateNode, x.alternate = d, d.alternate = x) : (x.pendingProps = p, x.type = d.type, x.flags = 0, x.subtreeFlags = 0, x.deletions = null), x.flags = d.flags & 65011712, x.childLanes = d.childLanes, x.lanes = d.lanes, x.child = d.child, x.memoizedProps = d.memoizedProps, x.memoizedState = d.memoizedState, x.updateQueue = d.updateQueue, p = d.dependencies, x.dependencies = p === null ? null : {
        lanes: p.lanes,
        firstContext: p.firstContext
      }, x.sibling = d.sibling, x.index = d.index, x.ref = d.ref, x.refCleanup = d.refCleanup, x;
    }
    function D9(d, p) {
      d.flags &= 65011714;
      var x = d.alternate;
      return x === null ? (d.childLanes = 0, d.lanes = p, d.child = null, d.subtreeFlags = 0, d.memoizedProps = null, d.memoizedState = null, d.updateQueue = null, d.dependencies = null, d.stateNode = null) : (d.childLanes = x.childLanes, d.lanes = x.lanes, d.child = x.child, d.subtreeFlags = 0, d.deletions = null, d.memoizedProps = x.memoizedProps, d.memoizedState = x.memoizedState, d.updateQueue = x.updateQueue, d.type = x.type, p = x.dependencies, d.dependencies = p === null ? null : {
        lanes: p.lanes,
        firstContext: p.firstContext
      }), d;
    }
    function xd(d, p, x, A, M, U) {
      var W = 0;
      if (A = d, typeof d == "function") am(d) && (W = 1);
      else if (typeof d == "string") W = hF(d, x, oe.current) ? 26 : d === "html" || d === "head" || d === "body" ? 27 : 5;
      else e: switch (d) {
        case I:
          return d = oa(31, x, p, M), d.elementType = I, d.lanes = U, d;
        case v:
          return Jl(x.children, M, U, p);
        case m:
          W = 8, M |= 24;
          break;
        case y:
          return d = oa(12, x, p, M | 2), d.elementType = y, d.lanes = U, d;
        case E:
          return d = oa(13, x, p, M), d.elementType = E, d.lanes = U, d;
        case b:
          return d = oa(19, x, p, M), d.elementType = b, d.lanes = U, d;
        default:
          if (typeof d == "object" && d !== null) switch (d.$$typeof) {
            case w:
            case T:
              W = 10;
              break e;
            case C:
              W = 9;
              break e;
            case S:
              W = 11;
              break e;
            case D:
              W = 14;
              break e;
            case R:
              W = 16, A = null;
              break e;
          }
          W = 29, x = Error(r(130, d === null ? "null" : typeof d, "")), A = null;
      }
      return p = oa(W, x, p, M), p.elementType = d, p.type = A, p.lanes = U, p;
    }
    function Jl(d, p, x, A) {
      return d = oa(7, d, A, p), d.lanes = x, d;
    }
    function sm(d, p, x) {
      return d = oa(6, d, null, p), d.lanes = x, d;
    }
    function om(d, p, x) {
      return p = oa(4, d.children !== null ? d.children : [], d.key, p), p.lanes = x, p.stateNode = {
        containerInfo: d.containerInfo,
        pendingChildren: null,
        implementation: d.implementation
      }, p;
    }
    var C0 = [], T0 = 0, wd = null, Cd = 0, Ea = [], ba = 0, $l = null, Ws = 1, Hs = "";
    function ec(d, p) {
      C0[T0++] = Cd, C0[T0++] = wd, wd = d, Cd = p;
    }
    function M9(d, p, x) {
      Ea[ba++] = Ws, Ea[ba++] = Hs, Ea[ba++] = $l, $l = d;
      var A = Ws;
      d = Hs;
      var M = 32 - fn(A) - 1;
      A &= ~(1 << M), x += 1;
      var U = 32 - fn(p) + M;
      if (30 < U) {
        var W = M - M % 5;
        U = (A & (1 << W) - 1).toString(32), A >>= W, M -= W, Ws = 1 << 32 - fn(p) + M | x << M | A, Hs = U + d;
      } else Ws = 1 << U | x << M | A, Hs = d;
    }
    function lm(d) {
      d.return !== null && (ec(d, 1), M9(d, 1, 0));
    }
    function cm(d) {
      for (; d === wd; ) wd = C0[--T0], C0[T0] = null, Cd = C0[--T0], C0[T0] = null;
      for (; d === $l; ) $l = Ea[--ba], Ea[ba] = null, Hs = Ea[--ba], Ea[ba] = null, Ws = Ea[--ba], Ea[ba] = null;
    }
    var Vi = null, ur = null, An = false, tc = null, ms = false, um = Error(r(519));
    function nc(d) {
      var p = Error(r(418, ""));
      throw Sf(Sa(p, d)), um;
    }
    function R9(d) {
      var p = d.stateNode, x = d.type, A = d.memoizedProps;
      switch (p[yr] = d, p[Fr] = A, x) {
        case "dialog":
          cn("cancel", p), cn("close", p);
          break;
        case "iframe":
        case "object":
        case "embed":
          cn("load", p);
          break;
        case "video":
        case "audio":
          for (x = 0; x < Yf.length; x++) cn(Yf[x], p);
          break;
        case "source":
          cn("error", p);
          break;
        case "img":
        case "image":
        case "link":
          cn("error", p), cn("load", p);
          break;
        case "details":
          cn("toggle", p);
          break;
        case "input":
          cn("invalid", p), Gs(p, A.value, A.defaultValue, A.checked, A.defaultChecked, A.type, A.name, true), Lo(p);
          break;
        case "select":
          cn("invalid", p);
          break;
        case "textarea":
          cn("invalid", p), P(p, A.value, A.defaultValue, A.children), Lo(p);
      }
      x = A.children, typeof x != "string" && typeof x != "number" && typeof x != "bigint" || p.textContent === "" + x || A.suppressHydrationWarning === true || K7(p.textContent, x) ? (A.popover != null && (cn("beforetoggle", p), cn("toggle", p)), A.onScroll != null && cn("scroll", p), A.onScrollEnd != null && cn("scrollend", p), A.onClick != null && (p.onclick = t2), p = true) : p = false, p || nc(d);
    }
    function O9(d) {
      for (Vi = d.return; Vi; ) switch (Vi.tag) {
        case 5:
        case 13:
          ms = false;
          return;
        case 27:
        case 3:
          ms = true;
          return;
        default:
          Vi = Vi.return;
      }
    }
    function Cf(d) {
      if (d !== Vi) return false;
      if (!An) return O9(d), An = true, false;
      var p = d.tag, x;
      if ((x = p !== 3 && p !== 27) && ((x = p === 5) && (x = d.type, x = !(x !== "form" && x !== "button") || b3(d.type, d.memoizedProps)), x = !x), x && ur && nc(d), O9(d), p === 13) {
        if (d = d.memoizedState, d = d !== null ? d.dehydrated : null, !d) throw Error(r(317));
        e: {
          for (d = d.nextSibling, p = 0; d; ) {
            if (d.nodeType === 8) if (x = d.data, x === "/$") {
              if (p === 0) {
                ur = Ya(d.nextSibling);
                break e;
              }
              p--;
            } else x !== "$" && x !== "$!" && x !== "$?" || p++;
            d = d.nextSibling;
          }
          ur = null;
        }
      } else p === 27 ? (p = ur, Jo(d.type) ? (d = O3, O3 = null, ur = d) : ur = p) : ur = Vi ? Ya(d.stateNode.nextSibling) : null;
      return true;
    }
    function Tf() {
      ur = Vi = null, An = false;
    }
    function I9() {
      var d = tc;
      return d !== null && (Yi === null ? Yi = d : Yi.push.apply(Yi, d), tc = null), d;
    }
    function Sf(d) {
      tc === null ? tc = [
        d
      ] : tc.push(d);
    }
    var fm = Y(null), rc = null, js = null;
    function Bo(d, p, x) {
      ie(fm, p._currentValue), p._currentValue = x;
    }
    function Ks(d) {
      d._currentValue = fm.current, X(fm);
    }
    function hm(d, p, x) {
      for (; d !== null; ) {
        var A = d.alternate;
        if ((d.childLanes & p) !== p ? (d.childLanes |= p, A !== null && (A.childLanes |= p)) : A !== null && (A.childLanes & p) !== p && (A.childLanes |= p), d === x) break;
        d = d.return;
      }
    }
    function dm(d, p, x, A) {
      var M = d.child;
      for (M !== null && (M.return = d); M !== null; ) {
        var U = M.dependencies;
        if (U !== null) {
          var W = M.child;
          U = U.firstContext;
          e: for (; U !== null; ) {
            var Q = U;
            U = M;
            for (var ae = 0; ae < p.length; ae++) if (Q.context === p[ae]) {
              U.lanes |= x, Q = U.alternate, Q !== null && (Q.lanes |= x), hm(U.return, x, d), A || (W = null);
              break e;
            }
            U = Q.next;
          }
        } else if (M.tag === 18) {
          if (W = M.return, W === null) throw Error(r(341));
          W.lanes |= x, U = W.alternate, U !== null && (U.lanes |= x), hm(W, x, d), W = null;
        } else W = M.child;
        if (W !== null) W.return = M;
        else for (W = M; W !== null; ) {
          if (W === d) {
            W = null;
            break;
          }
          if (M = W.sibling, M !== null) {
            M.return = W.return, W = M;
            break;
          }
          W = W.return;
        }
        M = W;
      }
    }
    function Af(d, p, x, A) {
      d = null;
      for (var M = p, U = false; M !== null; ) {
        if (!U) {
          if ((M.flags & 524288) !== 0) U = true;
          else if ((M.flags & 262144) !== 0) break;
        }
        if (M.tag === 10) {
          var W = M.alternate;
          if (W === null) throw Error(r(387));
          if (W = W.memoizedProps, W !== null) {
            var Q = M.type;
            sa(M.pendingProps.value, W.value) || (d !== null ? d.push(Q) : d = [
              Q
            ]);
          }
        } else if (M === Je.current) {
          if (W = M.alternate, W === null) throw Error(r(387));
          W.memoizedState.memoizedState !== M.memoizedState.memoizedState && (d !== null ? d.push($f) : d = [
            $f
          ]);
        }
        M = M.return;
      }
      d !== null && dm(p, d, x, A), p.flags |= 262144;
    }
    function Td(d) {
      for (d = d.firstContext; d !== null; ) {
        if (!sa(d.context._currentValue, d.memoizedValue)) return true;
        d = d.next;
      }
      return false;
    }
    function ic(d) {
      rc = d, js = null, d = d.dependencies, d !== null && (d.firstContext = null);
    }
    function xi(d) {
      return V9(rc, d);
    }
    function Sd(d, p) {
      return rc === null && ic(d), V9(d, p);
    }
    function V9(d, p) {
      var x = p._currentValue;
      if (p = {
        context: p,
        memoizedValue: x,
        next: null
      }, js === null) {
        if (d === null) throw Error(r(308));
        js = p, d.dependencies = {
          lanes: 0,
          firstContext: p
        }, d.flags |= 524288;
      } else js = js.next = p;
      return x;
    }
    var fU = typeof AbortController < "u" ? AbortController : function() {
      var d = [], p = this.signal = {
        aborted: false,
        addEventListener: function(x, A) {
          d.push(A);
        }
      };
      this.abort = function() {
        p.aborted = true, d.forEach(function(x) {
          return x();
        });
      };
    }, hU = t.unstable_scheduleCallback, dU = t.unstable_NormalPriority, Br = {
      $$typeof: T,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function gm() {
      return {
        controller: new fU(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function Ef(d) {
      d.refCount--, d.refCount === 0 && hU(dU, function() {
        d.controller.abort();
      });
    }
    var bf = null, pm = 0, S0 = 0, A0 = null;
    function gU(d, p) {
      if (bf === null) {
        var x = bf = [];
        pm = 0, S0 = v3(), A0 = {
          status: "pending",
          value: void 0,
          then: function(A) {
            x.push(A);
          }
        };
      }
      return pm++, p.then(N9, N9), p;
    }
    function N9() {
      if (--pm === 0 && bf !== null) {
        A0 !== null && (A0.status = "fulfilled");
        var d = bf;
        bf = null, S0 = 0, A0 = null;
        for (var p = 0; p < d.length; p++) (0, d[p])();
      }
    }
    function pU(d, p) {
      var x = [], A = {
        status: "pending",
        value: null,
        reason: null,
        then: function(M) {
          x.push(M);
        }
      };
      return d.then(function() {
        A.status = "fulfilled", A.value = p;
        for (var M = 0; M < x.length; M++) (0, x[M])(p);
      }, function(M) {
        for (A.status = "rejected", A.reason = M, M = 0; M < x.length; M++) (0, x[M])(void 0);
      }), A;
    }
    var L9 = _.S;
    _.S = function(d, p) {
      typeof p == "object" && p !== null && typeof p.then == "function" && gU(d, p), L9 !== null && L9(d, p);
    };
    var ac = Y(null);
    function mm() {
      var d = ac.current;
      return d !== null ? d : kn.pooledCache;
    }
    function Ad(d, p) {
      p === null ? ie(ac, ac.current) : ie(ac, p.pool);
    }
    function U9() {
      var d = mm();
      return d === null ? null : {
        parent: Br._currentValue,
        pool: d
      };
    }
    var Df = Error(r(460)), F9 = Error(r(474)), Ed = Error(r(542)), vm = {
      then: function() {
      }
    };
    function B9(d) {
      return d = d.status, d === "fulfilled" || d === "rejected";
    }
    function bd() {
    }
    function _9(d, p, x) {
      switch (x = d[x], x === void 0 ? d.push(p) : x !== p && (p.then(bd, bd), p = x), p.status) {
        case "fulfilled":
          return p.value;
        case "rejected":
          throw d = p.reason, P9(d), d;
        default:
          if (typeof p.status == "string") p.then(bd, bd);
          else {
            if (d = kn, d !== null && 100 < d.shellSuspendCounter) throw Error(r(482));
            d = p, d.status = "pending", d.then(function(A) {
              if (p.status === "pending") {
                var M = p;
                M.status = "fulfilled", M.value = A;
              }
            }, function(A) {
              if (p.status === "pending") {
                var M = p;
                M.status = "rejected", M.reason = A;
              }
            });
          }
          switch (p.status) {
            case "fulfilled":
              return p.value;
            case "rejected":
              throw d = p.reason, P9(d), d;
          }
          throw Mf = p, Df;
      }
    }
    var Mf = null;
    function k9() {
      if (Mf === null) throw Error(r(459));
      var d = Mf;
      return Mf = null, d;
    }
    function P9(d) {
      if (d === Df || d === Ed) throw Error(r(483));
    }
    var _o = false;
    function ym(d) {
      d.updateQueue = {
        baseState: d.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          lanes: 0,
          hiddenCallbacks: null
        },
        callbacks: null
      };
    }
    function xm(d, p) {
      d = d.updateQueue, p.updateQueue === d && (p.updateQueue = {
        baseState: d.baseState,
        firstBaseUpdate: d.firstBaseUpdate,
        lastBaseUpdate: d.lastBaseUpdate,
        shared: d.shared,
        callbacks: null
      });
    }
    function ko(d) {
      return {
        lane: d,
        tag: 0,
        payload: null,
        callback: null,
        next: null
      };
    }
    function Po(d, p, x) {
      var A = d.updateQueue;
      if (A === null) return null;
      if (A = A.shared, (On & 2) !== 0) {
        var M = A.pending;
        return M === null ? p.next = p : (p.next = M.next, M.next = p), A.pending = p, p = yd(d), b9(d, null, x), p;
      }
      return vd(d, A, p, x), yd(d);
    }
    function Rf(d, p, x) {
      if (p = p.updateQueue, p !== null && (p = p.shared, (x & 4194048) !== 0)) {
        var A = p.lanes;
        A &= d.pendingLanes, x |= A, p.lanes = x, za(d, x);
      }
    }
    function wm(d, p) {
      var x = d.updateQueue, A = d.alternate;
      if (A !== null && (A = A.updateQueue, x === A)) {
        var M = null, U = null;
        if (x = x.firstBaseUpdate, x !== null) {
          do {
            var W = {
              lane: x.lane,
              tag: x.tag,
              payload: x.payload,
              callback: null,
              next: null
            };
            U === null ? M = U = W : U = U.next = W, x = x.next;
          } while (x !== null);
          U === null ? M = U = p : U = U.next = p;
        } else M = U = p;
        x = {
          baseState: A.baseState,
          firstBaseUpdate: M,
          lastBaseUpdate: U,
          shared: A.shared,
          callbacks: A.callbacks
        }, d.updateQueue = x;
        return;
      }
      d = x.lastBaseUpdate, d === null ? x.firstBaseUpdate = p : d.next = p, x.lastBaseUpdate = p;
    }
    var Cm = false;
    function Of() {
      if (Cm) {
        var d = A0;
        if (d !== null) throw d;
      }
    }
    function If(d, p, x, A) {
      Cm = false;
      var M = d.updateQueue;
      _o = false;
      var U = M.firstBaseUpdate, W = M.lastBaseUpdate, Q = M.shared.pending;
      if (Q !== null) {
        M.shared.pending = null;
        var ae = Q, ve = ae.next;
        ae.next = null, W === null ? U = ve : W.next = ve, W = ae;
        var Ie = d.alternate;
        Ie !== null && (Ie = Ie.updateQueue, Q = Ie.lastBaseUpdate, Q !== W && (Q === null ? Ie.firstBaseUpdate = ve : Q.next = ve, Ie.lastBaseUpdate = ae));
      }
      if (U !== null) {
        var Fe = M.baseState;
        W = 0, Ie = ve = ae = null, Q = U;
        do {
          var we = Q.lane & -536870913, Ce = we !== Q.lane;
          if (Ce ? (Cn & we) === we : (A & we) === we) {
            we !== 0 && we === S0 && (Cm = true), Ie !== null && (Ie = Ie.next = {
              lane: 0,
              tag: Q.tag,
              payload: Q.payload,
              callback: null,
              next: null
            });
            e: {
              var Vt = d, Et = Q;
              we = p;
              var Fn = x;
              switch (Et.tag) {
                case 1:
                  if (Vt = Et.payload, typeof Vt == "function") {
                    Fe = Vt.call(Fn, Fe, we);
                    break e;
                  }
                  Fe = Vt;
                  break e;
                case 3:
                  Vt.flags = Vt.flags & -65537 | 128;
                case 0:
                  if (Vt = Et.payload, we = typeof Vt == "function" ? Vt.call(Fn, Fe, we) : Vt, we == null) break e;
                  Fe = f({}, Fe, we);
                  break e;
                case 2:
                  _o = true;
              }
            }
            we = Q.callback, we !== null && (d.flags |= 64, Ce && (d.flags |= 8192), Ce = M.callbacks, Ce === null ? M.callbacks = [
              we
            ] : Ce.push(we));
          } else Ce = {
            lane: we,
            tag: Q.tag,
            payload: Q.payload,
            callback: Q.callback,
            next: null
          }, Ie === null ? (ve = Ie = Ce, ae = Fe) : Ie = Ie.next = Ce, W |= we;
          if (Q = Q.next, Q === null) {
            if (Q = M.shared.pending, Q === null) break;
            Ce = Q, Q = Ce.next, Ce.next = null, M.lastBaseUpdate = Ce, M.shared.pending = null;
          }
        } while (true);
        Ie === null && (ae = Fe), M.baseState = ae, M.firstBaseUpdate = ve, M.lastBaseUpdate = Ie, U === null && (M.shared.lanes = 0), qo |= W, d.lanes = W, d.memoizedState = Fe;
      }
    }
    function G9(d, p) {
      if (typeof d != "function") throw Error(r(191, d));
      d.call(p);
    }
    function z9(d, p) {
      var x = d.callbacks;
      if (x !== null) for (d.callbacks = null, d = 0; d < x.length; d++) G9(x[d], p);
    }
    var E0 = Y(null), Dd = Y(0);
    function W9(d, p) {
      d = $s, ie(Dd, d), ie(E0, p), $s = d | p.baseLanes;
    }
    function Tm() {
      ie(Dd, $s), ie(E0, E0.current);
    }
    function Sm() {
      $s = Dd.current, X(E0), X(Dd);
    }
    var Go = 0, rn = null, Ln = null, Dr = null, Md = false, b0 = false, sc = false, Rd = 0, Vf = 0, D0 = null, mU = 0;
    function wr() {
      throw Error(r(321));
    }
    function Am(d, p) {
      if (p === null) return false;
      for (var x = 0; x < p.length && x < d.length; x++) if (!sa(d[x], p[x])) return false;
      return true;
    }
    function Em(d, p, x, A, M, U) {
      return Go = U, rn = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, _.H = d === null || d.memoizedState === null ? bx : Dx, sc = false, U = x(A, M), sc = false, b0 && (U = j9(p, x, A, M)), H9(d), U;
    }
    function H9(d) {
      _.H = Ud;
      var p = Ln !== null && Ln.next !== null;
      if (Go = 0, Dr = Ln = rn = null, Md = false, Vf = 0, D0 = null, p) throw Error(r(300));
      d === null || Hr || (d = d.dependencies, d !== null && Td(d) && (Hr = true));
    }
    function j9(d, p, x, A) {
      rn = d;
      var M = 0;
      do {
        if (b0 && (D0 = null), Vf = 0, b0 = false, 25 <= M) throw Error(r(301));
        if (M += 1, Dr = Ln = null, d.updateQueue != null) {
          var U = d.updateQueue;
          U.lastEffect = null, U.events = null, U.stores = null, U.memoCache != null && (U.memoCache.index = 0);
        }
        _.H = SU, U = p(x, A);
      } while (b0);
      return U;
    }
    function vU() {
      var d = _.H, p = d.useState()[0];
      return p = typeof p.then == "function" ? Nf(p) : p, d = d.useState()[0], (Ln !== null ? Ln.memoizedState : null) !== d && (rn.flags |= 1024), p;
    }
    function bm() {
      var d = Rd !== 0;
      return Rd = 0, d;
    }
    function Dm(d, p, x) {
      p.updateQueue = d.updateQueue, p.flags &= -2053, d.lanes &= ~x;
    }
    function Mm(d) {
      if (Md) {
        for (d = d.memoizedState; d !== null; ) {
          var p = d.queue;
          p !== null && (p.pending = null), d = d.next;
        }
        Md = false;
      }
      Go = 0, Dr = Ln = rn = null, b0 = false, Vf = Rd = 0, D0 = null;
    }
    function ji() {
      var d = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Dr === null ? rn.memoizedState = Dr = d : Dr = Dr.next = d, Dr;
    }
    function Mr() {
      if (Ln === null) {
        var d = rn.alternate;
        d = d !== null ? d.memoizedState : null;
      } else d = Ln.next;
      var p = Dr === null ? rn.memoizedState : Dr.next;
      if (p !== null) Dr = p, Ln = d;
      else {
        if (d === null) throw rn.alternate === null ? Error(r(467)) : Error(r(310));
        Ln = d, d = {
          memoizedState: Ln.memoizedState,
          baseState: Ln.baseState,
          baseQueue: Ln.baseQueue,
          queue: Ln.queue,
          next: null
        }, Dr === null ? rn.memoizedState = Dr = d : Dr = Dr.next = d;
      }
      return Dr;
    }
    function Rm() {
      return {
        lastEffect: null,
        events: null,
        stores: null,
        memoCache: null
      };
    }
    function Nf(d) {
      var p = Vf;
      return Vf += 1, D0 === null && (D0 = []), d = _9(D0, d, p), p = rn, (Dr === null ? p.memoizedState : Dr.next) === null && (p = p.alternate, _.H = p === null || p.memoizedState === null ? bx : Dx), d;
    }
    function Od(d) {
      if (d !== null && typeof d == "object") {
        if (typeof d.then == "function") return Nf(d);
        if (d.$$typeof === T) return xi(d);
      }
      throw Error(r(438, String(d)));
    }
    function Om(d) {
      var p = null, x = rn.updateQueue;
      if (x !== null && (p = x.memoCache), p == null) {
        var A = rn.alternate;
        A !== null && (A = A.updateQueue, A !== null && (A = A.memoCache, A != null && (p = {
          data: A.data.map(function(M) {
            return M.slice();
          }),
          index: 0
        })));
      }
      if (p == null && (p = {
        data: [],
        index: 0
      }), x === null && (x = Rm(), rn.updateQueue = x), x.memoCache = p, x = p.data[p.index], x === void 0) for (x = p.data[p.index] = Array(d), A = 0; A < d; A++) x[A] = O;
      return p.index++, x;
    }
    function Ys(d, p) {
      return typeof p == "function" ? p(d) : p;
    }
    function Id(d) {
      var p = Mr();
      return Im(p, Ln, d);
    }
    function Im(d, p, x) {
      var A = d.queue;
      if (A === null) throw Error(r(311));
      A.lastRenderedReducer = x;
      var M = d.baseQueue, U = A.pending;
      if (U !== null) {
        if (M !== null) {
          var W = M.next;
          M.next = U.next, U.next = W;
        }
        p.baseQueue = M = U, A.pending = null;
      }
      if (U = d.baseState, M === null) d.memoizedState = U;
      else {
        p = M.next;
        var Q = W = null, ae = null, ve = p, Ie = false;
        do {
          var Fe = ve.lane & -536870913;
          if (Fe !== ve.lane ? (Cn & Fe) === Fe : (Go & Fe) === Fe) {
            var we = ve.revertLane;
            if (we === 0) ae !== null && (ae = ae.next = {
              lane: 0,
              revertLane: 0,
              action: ve.action,
              hasEagerState: ve.hasEagerState,
              eagerState: ve.eagerState,
              next: null
            }), Fe === S0 && (Ie = true);
            else if ((Go & we) === we) {
              ve = ve.next, we === S0 && (Ie = true);
              continue;
            } else Fe = {
              lane: 0,
              revertLane: ve.revertLane,
              action: ve.action,
              hasEagerState: ve.hasEagerState,
              eagerState: ve.eagerState,
              next: null
            }, ae === null ? (Q = ae = Fe, W = U) : ae = ae.next = Fe, rn.lanes |= we, qo |= we;
            Fe = ve.action, sc && x(U, Fe), U = ve.hasEagerState ? ve.eagerState : x(U, Fe);
          } else we = {
            lane: Fe,
            revertLane: ve.revertLane,
            action: ve.action,
            hasEagerState: ve.hasEagerState,
            eagerState: ve.eagerState,
            next: null
          }, ae === null ? (Q = ae = we, W = U) : ae = ae.next = we, rn.lanes |= Fe, qo |= Fe;
          ve = ve.next;
        } while (ve !== null && ve !== p);
        if (ae === null ? W = U : ae.next = Q, !sa(U, d.memoizedState) && (Hr = true, Ie && (x = A0, x !== null))) throw x;
        d.memoizedState = U, d.baseState = W, d.baseQueue = ae, A.lastRenderedState = U;
      }
      return M === null && (A.lanes = 0), [
        d.memoizedState,
        A.dispatch
      ];
    }
    function Vm(d) {
      var p = Mr(), x = p.queue;
      if (x === null) throw Error(r(311));
      x.lastRenderedReducer = d;
      var A = x.dispatch, M = x.pending, U = p.memoizedState;
      if (M !== null) {
        x.pending = null;
        var W = M = M.next;
        do
          U = d(U, W.action), W = W.next;
        while (W !== M);
        sa(U, p.memoizedState) || (Hr = true), p.memoizedState = U, p.baseQueue === null && (p.baseState = U), x.lastRenderedState = U;
      }
      return [
        U,
        A
      ];
    }
    function K9(d, p, x) {
      var A = rn, M = Mr(), U = An;
      if (U) {
        if (x === void 0) throw Error(r(407));
        x = x();
      } else x = p();
      var W = !sa((Ln || M).memoizedState, x);
      W && (M.memoizedState = x, Hr = true), M = M.queue;
      var Q = X9.bind(null, A, M, d);
      if (Lf(2048, 8, Q, [
        d
      ]), M.getSnapshot !== p || W || Dr !== null && Dr.memoizedState.tag & 1) {
        if (A.flags |= 2048, M0(9, Vd(), q9.bind(null, A, M, x, p), null), kn === null) throw Error(r(349));
        U || (Go & 124) !== 0 || Y9(A, p, x);
      }
      return x;
    }
    function Y9(d, p, x) {
      d.flags |= 16384, d = {
        getSnapshot: p,
        value: x
      }, p = rn.updateQueue, p === null ? (p = Rm(), rn.updateQueue = p, p.stores = [
        d
      ]) : (x = p.stores, x === null ? p.stores = [
        d
      ] : x.push(d));
    }
    function q9(d, p, x, A) {
      p.value = x, p.getSnapshot = A, Z9(p) && Q9(d);
    }
    function X9(d, p, x) {
      return x(function() {
        Z9(p) && Q9(d);
      });
    }
    function Z9(d) {
      var p = d.getSnapshot;
      d = d.value;
      try {
        var x = p();
        return !sa(d, x);
      } catch {
        return true;
      }
    }
    function Q9(d) {
      var p = x0(d, 2);
      p !== null && ha(p, d, 2);
    }
    function Nm(d) {
      var p = ji();
      if (typeof d == "function") {
        var x = d;
        if (d = x(), sc) {
          it(true);
          try {
            x();
          } finally {
            it(false);
          }
        }
      }
      return p.memoizedState = p.baseState = d, p.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ys,
        lastRenderedState: d
      }, p;
    }
    function J9(d, p, x, A) {
      return d.baseState = x, Im(d, Ln, typeof A == "function" ? A : Ys);
    }
    function yU(d, p, x, A, M) {
      if (Ld(d)) throw Error(r(485));
      if (d = p.action, d !== null) {
        var U = {
          payload: M,
          action: d,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(W) {
            U.listeners.push(W);
          }
        };
        _.T !== null ? x(true) : U.isTransition = false, A(U), x = p.pending, x === null ? (U.next = p.pending = U, $9(p, U)) : (U.next = x.next, p.pending = x.next = U);
      }
    }
    function $9(d, p) {
      var x = p.action, A = p.payload, M = d.state;
      if (p.isTransition) {
        var U = _.T, W = {};
        _.T = W;
        try {
          var Q = x(M, A), ae = _.S;
          ae !== null && ae(W, Q), ex(d, p, Q);
        } catch (ve) {
          Lm(d, p, ve);
        } finally {
          _.T = U;
        }
      } else try {
        U = x(M, A), ex(d, p, U);
      } catch (ve) {
        Lm(d, p, ve);
      }
    }
    function ex(d, p, x) {
      x !== null && typeof x == "object" && typeof x.then == "function" ? x.then(function(A) {
        tx(d, p, A);
      }, function(A) {
        return Lm(d, p, A);
      }) : tx(d, p, x);
    }
    function tx(d, p, x) {
      p.status = "fulfilled", p.value = x, nx(p), d.state = x, p = d.pending, p !== null && (x = p.next, x === p ? d.pending = null : (x = x.next, p.next = x, $9(d, x)));
    }
    function Lm(d, p, x) {
      var A = d.pending;
      if (d.pending = null, A !== null) {
        A = A.next;
        do
          p.status = "rejected", p.reason = x, nx(p), p = p.next;
        while (p !== A);
      }
      d.action = null;
    }
    function nx(d) {
      d = d.listeners;
      for (var p = 0; p < d.length; p++) (0, d[p])();
    }
    function rx(d, p) {
      return p;
    }
    function ix(d, p) {
      if (An) {
        var x = kn.formState;
        if (x !== null) {
          e: {
            var A = rn;
            if (An) {
              if (ur) {
                t: {
                  for (var M = ur, U = ms; M.nodeType !== 8; ) {
                    if (!U) {
                      M = null;
                      break t;
                    }
                    if (M = Ya(M.nextSibling), M === null) {
                      M = null;
                      break t;
                    }
                  }
                  U = M.data, M = U === "F!" || U === "F" ? M : null;
                }
                if (M) {
                  ur = Ya(M.nextSibling), A = M.data === "F!";
                  break e;
                }
              }
              nc(A);
            }
            A = false;
          }
          A && (p = x[0]);
        }
      }
      return x = ji(), x.memoizedState = x.baseState = p, A = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: rx,
        lastRenderedState: p
      }, x.queue = A, x = Sx.bind(null, rn, A), A.dispatch = x, A = Nm(false), U = km.bind(null, rn, false, A.queue), A = ji(), M = {
        state: p,
        dispatch: null,
        action: d,
        pending: null
      }, A.queue = M, x = yU.bind(null, rn, M, U, x), M.dispatch = x, A.memoizedState = d, [
        p,
        x,
        false
      ];
    }
    function ax(d) {
      var p = Mr();
      return sx(p, Ln, d);
    }
    function sx(d, p, x) {
      if (p = Im(d, p, rx)[0], d = Id(Ys)[0], typeof p == "object" && p !== null && typeof p.then == "function") try {
        var A = Nf(p);
      } catch (W) {
        throw W === Df ? Ed : W;
      }
      else A = p;
      p = Mr();
      var M = p.queue, U = M.dispatch;
      return x !== p.memoizedState && (rn.flags |= 2048, M0(9, Vd(), xU.bind(null, M, x), null)), [
        A,
        U,
        d
      ];
    }
    function xU(d, p) {
      d.action = p;
    }
    function ox(d) {
      var p = Mr(), x = Ln;
      if (x !== null) return sx(p, x, d);
      Mr(), p = p.memoizedState, x = Mr();
      var A = x.queue.dispatch;
      return x.memoizedState = d, [
        p,
        A,
        false
      ];
    }
    function M0(d, p, x, A) {
      return d = {
        tag: d,
        create: x,
        deps: A,
        inst: p,
        next: null
      }, p = rn.updateQueue, p === null && (p = Rm(), rn.updateQueue = p), x = p.lastEffect, x === null ? p.lastEffect = d.next = d : (A = x.next, x.next = d, d.next = A, p.lastEffect = d), d;
    }
    function Vd() {
      return {
        destroy: void 0,
        resource: void 0
      };
    }
    function lx() {
      return Mr().memoizedState;
    }
    function Nd(d, p, x, A) {
      var M = ji();
      A = A === void 0 ? null : A, rn.flags |= d, M.memoizedState = M0(1 | p, Vd(), x, A);
    }
    function Lf(d, p, x, A) {
      var M = Mr();
      A = A === void 0 ? null : A;
      var U = M.memoizedState.inst;
      Ln !== null && A !== null && Am(A, Ln.memoizedState.deps) ? M.memoizedState = M0(p, U, x, A) : (rn.flags |= d, M.memoizedState = M0(1 | p, U, x, A));
    }
    function cx(d, p) {
      Nd(8390656, 8, d, p);
    }
    function ux(d, p) {
      Lf(2048, 8, d, p);
    }
    function fx(d, p) {
      return Lf(4, 2, d, p);
    }
    function hx(d, p) {
      return Lf(4, 4, d, p);
    }
    function dx(d, p) {
      if (typeof p == "function") {
        d = d();
        var x = p(d);
        return function() {
          typeof x == "function" ? x() : p(null);
        };
      }
      if (p != null) return d = d(), p.current = d, function() {
        p.current = null;
      };
    }
    function gx(d, p, x) {
      x = x != null ? x.concat([
        d
      ]) : null, Lf(4, 4, dx.bind(null, p, d), x);
    }
    function Um() {
    }
    function px(d, p) {
      var x = Mr();
      p = p === void 0 ? null : p;
      var A = x.memoizedState;
      return p !== null && Am(p, A[1]) ? A[0] : (x.memoizedState = [
        d,
        p
      ], d);
    }
    function mx(d, p) {
      var x = Mr();
      p = p === void 0 ? null : p;
      var A = x.memoizedState;
      if (p !== null && Am(p, A[1])) return A[0];
      if (A = d(), sc) {
        it(true);
        try {
          d();
        } finally {
          it(false);
        }
      }
      return x.memoizedState = [
        A,
        p
      ], A;
    }
    function Fm(d, p, x) {
      return x === void 0 || (Go & 1073741824) !== 0 ? d.memoizedState = p : (d.memoizedState = x, d = x7(), rn.lanes |= d, qo |= d, x);
    }
    function vx(d, p, x, A) {
      return sa(x, p) ? x : E0.current !== null ? (d = Fm(d, x, A), sa(d, p) || (Hr = true), d) : (Go & 42) === 0 ? (Hr = true, d.memoizedState = x) : (d = x7(), rn.lanes |= d, qo |= d, p);
    }
    function yx(d, p, x, A, M) {
      var U = K.p;
      K.p = U !== 0 && 8 > U ? U : 8;
      var W = _.T, Q = {};
      _.T = Q, km(d, false, p, x);
      try {
        var ae = M(), ve = _.S;
        if (ve !== null && ve(Q, ae), ae !== null && typeof ae == "object" && typeof ae.then == "function") {
          var Ie = pU(ae, A);
          Uf(d, p, Ie, fa(d));
        } else Uf(d, p, A, fa(d));
      } catch (Fe) {
        Uf(d, p, {
          then: function() {
          },
          status: "rejected",
          reason: Fe
        }, fa());
      } finally {
        K.p = U, _.T = W;
      }
    }
    function wU() {
    }
    function Bm(d, p, x, A) {
      if (d.tag !== 5) throw Error(r(476));
      var M = xx(d).queue;
      yx(d, M, p, Z, x === null ? wU : function() {
        return wx(d), x(A);
      });
    }
    function xx(d) {
      var p = d.memoizedState;
      if (p !== null) return p;
      p = {
        memoizedState: Z,
        baseState: Z,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Ys,
          lastRenderedState: Z
        },
        next: null
      };
      var x = {};
      return p.next = {
        memoizedState: x,
        baseState: x,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Ys,
          lastRenderedState: x
        },
        next: null
      }, d.memoizedState = p, d = d.alternate, d !== null && (d.memoizedState = p), p;
    }
    function wx(d) {
      var p = xx(d).next.queue;
      Uf(d, p, {}, fa());
    }
    function _m() {
      return xi($f);
    }
    function Cx() {
      return Mr().memoizedState;
    }
    function Tx() {
      return Mr().memoizedState;
    }
    function CU(d) {
      for (var p = d.return; p !== null; ) {
        switch (p.tag) {
          case 24:
          case 3:
            var x = fa();
            d = ko(x);
            var A = Po(p, d, x);
            A !== null && (ha(A, p, x), Rf(A, p, x)), p = {
              cache: gm()
            }, d.payload = p;
            return;
        }
        p = p.return;
      }
    }
    function TU(d, p, x) {
      var A = fa();
      x = {
        lane: A,
        revertLane: 0,
        action: x,
        hasEagerState: false,
        eagerState: null,
        next: null
      }, Ld(d) ? Ax(p, x) : (x = im(d, p, x, A), x !== null && (ha(x, d, A), Ex(x, p, A)));
    }
    function Sx(d, p, x) {
      var A = fa();
      Uf(d, p, x, A);
    }
    function Uf(d, p, x, A) {
      var M = {
        lane: A,
        revertLane: 0,
        action: x,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (Ld(d)) Ax(p, M);
      else {
        var U = d.alternate;
        if (d.lanes === 0 && (U === null || U.lanes === 0) && (U = p.lastRenderedReducer, U !== null)) try {
          var W = p.lastRenderedState, Q = U(W, x);
          if (M.hasEagerState = true, M.eagerState = Q, sa(Q, W)) return vd(d, p, M, 0), kn === null && md(), false;
        } catch {
        } finally {
        }
        if (x = im(d, p, M, A), x !== null) return ha(x, d, A), Ex(x, p, A), true;
      }
      return false;
    }
    function km(d, p, x, A) {
      if (A = {
        lane: 2,
        revertLane: v3(),
        action: A,
        hasEagerState: false,
        eagerState: null,
        next: null
      }, Ld(d)) {
        if (p) throw Error(r(479));
      } else p = im(d, x, A, 2), p !== null && ha(p, d, 2);
    }
    function Ld(d) {
      var p = d.alternate;
      return d === rn || p !== null && p === rn;
    }
    function Ax(d, p) {
      b0 = Md = true;
      var x = d.pending;
      x === null ? p.next = p : (p.next = x.next, x.next = p), d.pending = p;
    }
    function Ex(d, p, x) {
      if ((x & 4194048) !== 0) {
        var A = p.lanes;
        A &= d.pendingLanes, x |= A, p.lanes = x, za(d, x);
      }
    }
    var Ud = {
      readContext: xi,
      use: Od,
      useCallback: wr,
      useContext: wr,
      useEffect: wr,
      useImperativeHandle: wr,
      useLayoutEffect: wr,
      useInsertionEffect: wr,
      useMemo: wr,
      useReducer: wr,
      useRef: wr,
      useState: wr,
      useDebugValue: wr,
      useDeferredValue: wr,
      useTransition: wr,
      useSyncExternalStore: wr,
      useId: wr,
      useHostTransitionStatus: wr,
      useFormState: wr,
      useActionState: wr,
      useOptimistic: wr,
      useMemoCache: wr,
      useCacheRefresh: wr
    }, bx = {
      readContext: xi,
      use: Od,
      useCallback: function(d, p) {
        return ji().memoizedState = [
          d,
          p === void 0 ? null : p
        ], d;
      },
      useContext: xi,
      useEffect: cx,
      useImperativeHandle: function(d, p, x) {
        x = x != null ? x.concat([
          d
        ]) : null, Nd(4194308, 4, dx.bind(null, p, d), x);
      },
      useLayoutEffect: function(d, p) {
        return Nd(4194308, 4, d, p);
      },
      useInsertionEffect: function(d, p) {
        Nd(4, 2, d, p);
      },
      useMemo: function(d, p) {
        var x = ji();
        p = p === void 0 ? null : p;
        var A = d();
        if (sc) {
          it(true);
          try {
            d();
          } finally {
            it(false);
          }
        }
        return x.memoizedState = [
          A,
          p
        ], A;
      },
      useReducer: function(d, p, x) {
        var A = ji();
        if (x !== void 0) {
          var M = x(p);
          if (sc) {
            it(true);
            try {
              x(p);
            } finally {
              it(false);
            }
          }
        } else M = p;
        return A.memoizedState = A.baseState = M, d = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: d,
          lastRenderedState: M
        }, A.queue = d, d = d.dispatch = TU.bind(null, rn, d), [
          A.memoizedState,
          d
        ];
      },
      useRef: function(d) {
        var p = ji();
        return d = {
          current: d
        }, p.memoizedState = d;
      },
      useState: function(d) {
        d = Nm(d);
        var p = d.queue, x = Sx.bind(null, rn, p);
        return p.dispatch = x, [
          d.memoizedState,
          x
        ];
      },
      useDebugValue: Um,
      useDeferredValue: function(d, p) {
        var x = ji();
        return Fm(x, d, p);
      },
      useTransition: function() {
        var d = Nm(false);
        return d = yx.bind(null, rn, d.queue, true, false), ji().memoizedState = d, [
          false,
          d
        ];
      },
      useSyncExternalStore: function(d, p, x) {
        var A = rn, M = ji();
        if (An) {
          if (x === void 0) throw Error(r(407));
          x = x();
        } else {
          if (x = p(), kn === null) throw Error(r(349));
          (Cn & 124) !== 0 || Y9(A, p, x);
        }
        M.memoizedState = x;
        var U = {
          value: x,
          getSnapshot: p
        };
        return M.queue = U, cx(X9.bind(null, A, U, d), [
          d
        ]), A.flags |= 2048, M0(9, Vd(), q9.bind(null, A, U, x, p), null), x;
      },
      useId: function() {
        var d = ji(), p = kn.identifierPrefix;
        if (An) {
          var x = Hs, A = Ws;
          x = (A & ~(1 << 32 - fn(A) - 1)).toString(32) + x, p = "\xAB" + p + "R" + x, x = Rd++, 0 < x && (p += "H" + x.toString(32)), p += "\xBB";
        } else x = mU++, p = "\xAB" + p + "r" + x.toString(32) + "\xBB";
        return d.memoizedState = p;
      },
      useHostTransitionStatus: _m,
      useFormState: ix,
      useActionState: ix,
      useOptimistic: function(d) {
        var p = ji();
        p.memoizedState = p.baseState = d;
        var x = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return p.queue = x, p = km.bind(null, rn, true, x), x.dispatch = p, [
          d,
          p
        ];
      },
      useMemoCache: Om,
      useCacheRefresh: function() {
        return ji().memoizedState = CU.bind(null, rn);
      }
    }, Dx = {
      readContext: xi,
      use: Od,
      useCallback: px,
      useContext: xi,
      useEffect: ux,
      useImperativeHandle: gx,
      useInsertionEffect: fx,
      useLayoutEffect: hx,
      useMemo: mx,
      useReducer: Id,
      useRef: lx,
      useState: function() {
        return Id(Ys);
      },
      useDebugValue: Um,
      useDeferredValue: function(d, p) {
        var x = Mr();
        return vx(x, Ln.memoizedState, d, p);
      },
      useTransition: function() {
        var d = Id(Ys)[0], p = Mr().memoizedState;
        return [
          typeof d == "boolean" ? d : Nf(d),
          p
        ];
      },
      useSyncExternalStore: K9,
      useId: Cx,
      useHostTransitionStatus: _m,
      useFormState: ax,
      useActionState: ax,
      useOptimistic: function(d, p) {
        var x = Mr();
        return J9(x, Ln, d, p);
      },
      useMemoCache: Om,
      useCacheRefresh: Tx
    }, SU = {
      readContext: xi,
      use: Od,
      useCallback: px,
      useContext: xi,
      useEffect: ux,
      useImperativeHandle: gx,
      useInsertionEffect: fx,
      useLayoutEffect: hx,
      useMemo: mx,
      useReducer: Vm,
      useRef: lx,
      useState: function() {
        return Vm(Ys);
      },
      useDebugValue: Um,
      useDeferredValue: function(d, p) {
        var x = Mr();
        return Ln === null ? Fm(x, d, p) : vx(x, Ln.memoizedState, d, p);
      },
      useTransition: function() {
        var d = Vm(Ys)[0], p = Mr().memoizedState;
        return [
          typeof d == "boolean" ? d : Nf(d),
          p
        ];
      },
      useSyncExternalStore: K9,
      useId: Cx,
      useHostTransitionStatus: _m,
      useFormState: ox,
      useActionState: ox,
      useOptimistic: function(d, p) {
        var x = Mr();
        return Ln !== null ? J9(x, Ln, d, p) : (x.baseState = d, [
          d,
          x.queue.dispatch
        ]);
      },
      useMemoCache: Om,
      useCacheRefresh: Tx
    }, R0 = null, Ff = 0;
    function Fd(d) {
      var p = Ff;
      return Ff += 1, R0 === null && (R0 = []), _9(R0, d, p);
    }
    function Bf(d, p) {
      p = p.props.ref, d.ref = p !== void 0 ? p : null;
    }
    function Bd(d, p) {
      throw p.$$typeof === u ? Error(r(525)) : (d = Object.prototype.toString.call(p), Error(r(31, d === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : d)));
    }
    function Mx(d) {
      var p = d._init;
      return p(d._payload);
    }
    function Rx(d) {
      function p(fe, le) {
        if (d) {
          var pe = fe.deletions;
          pe === null ? (fe.deletions = [
            le
          ], fe.flags |= 16) : pe.push(le);
        }
      }
      function x(fe, le) {
        if (!d) return null;
        for (; le !== null; ) p(fe, le), le = le.sibling;
        return null;
      }
      function A(fe) {
        for (var le = /* @__PURE__ */ new Map(); fe !== null; ) fe.key !== null ? le.set(fe.key, fe) : le.set(fe.index, fe), fe = fe.sibling;
        return le;
      }
      function M(fe, le) {
        return fe = zs(fe, le), fe.index = 0, fe.sibling = null, fe;
      }
      function U(fe, le, pe) {
        return fe.index = pe, d ? (pe = fe.alternate, pe !== null ? (pe = pe.index, pe < le ? (fe.flags |= 67108866, le) : pe) : (fe.flags |= 67108866, le)) : (fe.flags |= 1048576, le);
      }
      function W(fe) {
        return d && fe.alternate === null && (fe.flags |= 67108866), fe;
      }
      function Q(fe, le, pe, Ne) {
        return le === null || le.tag !== 6 ? (le = sm(pe, fe.mode, Ne), le.return = fe, le) : (le = M(le, pe), le.return = fe, le);
      }
      function ae(fe, le, pe, Ne) {
        var ct = pe.type;
        return ct === v ? Ie(fe, le, pe.props.children, Ne, pe.key) : le !== null && (le.elementType === ct || typeof ct == "object" && ct !== null && ct.$$typeof === R && Mx(ct) === le.type) ? (le = M(le, pe.props), Bf(le, pe), le.return = fe, le) : (le = xd(pe.type, pe.key, pe.props, null, fe.mode, Ne), Bf(le, pe), le.return = fe, le);
      }
      function ve(fe, le, pe, Ne) {
        return le === null || le.tag !== 4 || le.stateNode.containerInfo !== pe.containerInfo || le.stateNode.implementation !== pe.implementation ? (le = om(pe, fe.mode, Ne), le.return = fe, le) : (le = M(le, pe.children || []), le.return = fe, le);
      }
      function Ie(fe, le, pe, Ne, ct) {
        return le === null || le.tag !== 7 ? (le = Jl(pe, fe.mode, Ne, ct), le.return = fe, le) : (le = M(le, pe), le.return = fe, le);
      }
      function Fe(fe, le, pe) {
        if (typeof le == "string" && le !== "" || typeof le == "number" || typeof le == "bigint") return le = sm("" + le, fe.mode, pe), le.return = fe, le;
        if (typeof le == "object" && le !== null) {
          switch (le.$$typeof) {
            case h:
              return pe = xd(le.type, le.key, le.props, null, fe.mode, pe), Bf(pe, le), pe.return = fe, pe;
            case g:
              return le = om(le, fe.mode, pe), le.return = fe, le;
            case R:
              var Ne = le._init;
              return le = Ne(le._payload), Fe(fe, le, pe);
          }
          if (k(le) || N(le)) return le = Jl(le, fe.mode, pe, null), le.return = fe, le;
          if (typeof le.then == "function") return Fe(fe, Fd(le), pe);
          if (le.$$typeof === T) return Fe(fe, Sd(fe, le), pe);
          Bd(fe, le);
        }
        return null;
      }
      function we(fe, le, pe, Ne) {
        var ct = le !== null ? le.key : null;
        if (typeof pe == "string" && pe !== "" || typeof pe == "number" || typeof pe == "bigint") return ct !== null ? null : Q(fe, le, "" + pe, Ne);
        if (typeof pe == "object" && pe !== null) {
          switch (pe.$$typeof) {
            case h:
              return pe.key === ct ? ae(fe, le, pe, Ne) : null;
            case g:
              return pe.key === ct ? ve(fe, le, pe, Ne) : null;
            case R:
              return ct = pe._init, pe = ct(pe._payload), we(fe, le, pe, Ne);
          }
          if (k(pe) || N(pe)) return ct !== null ? null : Ie(fe, le, pe, Ne, null);
          if (typeof pe.then == "function") return we(fe, le, Fd(pe), Ne);
          if (pe.$$typeof === T) return we(fe, le, Sd(fe, pe), Ne);
          Bd(fe, pe);
        }
        return null;
      }
      function Ce(fe, le, pe, Ne, ct) {
        if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number" || typeof Ne == "bigint") return fe = fe.get(pe) || null, Q(le, fe, "" + Ne, ct);
        if (typeof Ne == "object" && Ne !== null) {
          switch (Ne.$$typeof) {
            case h:
              return fe = fe.get(Ne.key === null ? pe : Ne.key) || null, ae(le, fe, Ne, ct);
            case g:
              return fe = fe.get(Ne.key === null ? pe : Ne.key) || null, ve(le, fe, Ne, ct);
            case R:
              var an = Ne._init;
              return Ne = an(Ne._payload), Ce(fe, le, pe, Ne, ct);
          }
          if (k(Ne) || N(Ne)) return fe = fe.get(pe) || null, Ie(le, fe, Ne, ct, null);
          if (typeof Ne.then == "function") return Ce(fe, le, pe, Fd(Ne), ct);
          if (Ne.$$typeof === T) return Ce(fe, le, pe, Sd(le, Ne), ct);
          Bd(le, Ne);
        }
        return null;
      }
      function Vt(fe, le, pe, Ne) {
        for (var ct = null, an = null, mt = le, Rt = le = 0, Kr = null; mt !== null && Rt < pe.length; Rt++) {
          mt.index > Rt ? (Kr = mt, mt = null) : Kr = mt.sibling;
          var Tn = we(fe, mt, pe[Rt], Ne);
          if (Tn === null) {
            mt === null && (mt = Kr);
            break;
          }
          d && mt && Tn.alternate === null && p(fe, mt), le = U(Tn, le, Rt), an === null ? ct = Tn : an.sibling = Tn, an = Tn, mt = Kr;
        }
        if (Rt === pe.length) return x(fe, mt), An && ec(fe, Rt), ct;
        if (mt === null) {
          for (; Rt < pe.length; Rt++) mt = Fe(fe, pe[Rt], Ne), mt !== null && (le = U(mt, le, Rt), an === null ? ct = mt : an.sibling = mt, an = mt);
          return An && ec(fe, Rt), ct;
        }
        for (mt = A(mt); Rt < pe.length; Rt++) Kr = Ce(mt, fe, Rt, pe[Rt], Ne), Kr !== null && (d && Kr.alternate !== null && mt.delete(Kr.key === null ? Rt : Kr.key), le = U(Kr, le, Rt), an === null ? ct = Kr : an.sibling = Kr, an = Kr);
        return d && mt.forEach(function(rl) {
          return p(fe, rl);
        }), An && ec(fe, Rt), ct;
      }
      function Et(fe, le, pe, Ne) {
        if (pe == null) throw Error(r(151));
        for (var ct = null, an = null, mt = le, Rt = le = 0, Kr = null, Tn = pe.next(); mt !== null && !Tn.done; Rt++, Tn = pe.next()) {
          mt.index > Rt ? (Kr = mt, mt = null) : Kr = mt.sibling;
          var rl = we(fe, mt, Tn.value, Ne);
          if (rl === null) {
            mt === null && (mt = Kr);
            break;
          }
          d && mt && rl.alternate === null && p(fe, mt), le = U(rl, le, Rt), an === null ? ct = rl : an.sibling = rl, an = rl, mt = Kr;
        }
        if (Tn.done) return x(fe, mt), An && ec(fe, Rt), ct;
        if (mt === null) {
          for (; !Tn.done; Rt++, Tn = pe.next()) Tn = Fe(fe, Tn.value, Ne), Tn !== null && (le = U(Tn, le, Rt), an === null ? ct = Tn : an.sibling = Tn, an = Tn);
          return An && ec(fe, Rt), ct;
        }
        for (mt = A(mt); !Tn.done; Rt++, Tn = pe.next()) Tn = Ce(mt, fe, Rt, Tn.value, Ne), Tn !== null && (d && Tn.alternate !== null && mt.delete(Tn.key === null ? Rt : Tn.key), le = U(Tn, le, Rt), an === null ? ct = Tn : an.sibling = Tn, an = Tn);
        return d && mt.forEach(function(AF) {
          return p(fe, AF);
        }), An && ec(fe, Rt), ct;
      }
      function Fn(fe, le, pe, Ne) {
        if (typeof pe == "object" && pe !== null && pe.type === v && pe.key === null && (pe = pe.props.children), typeof pe == "object" && pe !== null) {
          switch (pe.$$typeof) {
            case h:
              e: {
                for (var ct = pe.key; le !== null; ) {
                  if (le.key === ct) {
                    if (ct = pe.type, ct === v) {
                      if (le.tag === 7) {
                        x(fe, le.sibling), Ne = M(le, pe.props.children), Ne.return = fe, fe = Ne;
                        break e;
                      }
                    } else if (le.elementType === ct || typeof ct == "object" && ct !== null && ct.$$typeof === R && Mx(ct) === le.type) {
                      x(fe, le.sibling), Ne = M(le, pe.props), Bf(Ne, pe), Ne.return = fe, fe = Ne;
                      break e;
                    }
                    x(fe, le);
                    break;
                  } else p(fe, le);
                  le = le.sibling;
                }
                pe.type === v ? (Ne = Jl(pe.props.children, fe.mode, Ne, pe.key), Ne.return = fe, fe = Ne) : (Ne = xd(pe.type, pe.key, pe.props, null, fe.mode, Ne), Bf(Ne, pe), Ne.return = fe, fe = Ne);
              }
              return W(fe);
            case g:
              e: {
                for (ct = pe.key; le !== null; ) {
                  if (le.key === ct) if (le.tag === 4 && le.stateNode.containerInfo === pe.containerInfo && le.stateNode.implementation === pe.implementation) {
                    x(fe, le.sibling), Ne = M(le, pe.children || []), Ne.return = fe, fe = Ne;
                    break e;
                  } else {
                    x(fe, le);
                    break;
                  }
                  else p(fe, le);
                  le = le.sibling;
                }
                Ne = om(pe, fe.mode, Ne), Ne.return = fe, fe = Ne;
              }
              return W(fe);
            case R:
              return ct = pe._init, pe = ct(pe._payload), Fn(fe, le, pe, Ne);
          }
          if (k(pe)) return Vt(fe, le, pe, Ne);
          if (N(pe)) {
            if (ct = N(pe), typeof ct != "function") throw Error(r(150));
            return pe = ct.call(pe), Et(fe, le, pe, Ne);
          }
          if (typeof pe.then == "function") return Fn(fe, le, Fd(pe), Ne);
          if (pe.$$typeof === T) return Fn(fe, le, Sd(fe, pe), Ne);
          Bd(fe, pe);
        }
        return typeof pe == "string" && pe !== "" || typeof pe == "number" || typeof pe == "bigint" ? (pe = "" + pe, le !== null && le.tag === 6 ? (x(fe, le.sibling), Ne = M(le, pe), Ne.return = fe, fe = Ne) : (x(fe, le), Ne = sm(pe, fe.mode, Ne), Ne.return = fe, fe = Ne), W(fe)) : x(fe, le);
      }
      return function(fe, le, pe, Ne) {
        try {
          Ff = 0;
          var ct = Fn(fe, le, pe, Ne);
          return R0 = null, ct;
        } catch (mt) {
          if (mt === Df || mt === Ed) throw mt;
          var an = oa(29, mt, null, fe.mode);
          return an.lanes = Ne, an.return = fe, an;
        } finally {
        }
      };
    }
    var O0 = Rx(true), Ox = Rx(false), Da = Y(null), vs = null;
    function zo(d) {
      var p = d.alternate;
      ie(_r2, _r2.current & 1), ie(Da, d), vs === null && (p === null || E0.current !== null || p.memoizedState !== null) && (vs = d);
    }
    function Ix(d) {
      if (d.tag === 22) {
        if (ie(_r2, _r2.current), ie(Da, d), vs === null) {
          var p = d.alternate;
          p !== null && p.memoizedState !== null && (vs = d);
        }
      } else Wo();
    }
    function Wo() {
      ie(_r2, _r2.current), ie(Da, Da.current);
    }
    function qs(d) {
      X(Da), vs === d && (vs = null), X(_r2);
    }
    var _r2 = Y(0);
    function _d(d) {
      for (var p = d; p !== null; ) {
        if (p.tag === 13) {
          var x = p.memoizedState;
          if (x !== null && (x = x.dehydrated, x === null || x.data === "$?" || R3(x))) return p;
        } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
          if ((p.flags & 128) !== 0) return p;
        } else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === d) break;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === d) return null;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
      return null;
    }
    function Pm(d, p, x, A) {
      p = d.memoizedState, x = x(A, p), x = x == null ? p : f({}, p, x), d.memoizedState = x, d.lanes === 0 && (d.updateQueue.baseState = x);
    }
    var Gm = {
      enqueueSetState: function(d, p, x) {
        d = d._reactInternals;
        var A = fa(), M = ko(A);
        M.payload = p, x != null && (M.callback = x), p = Po(d, M, A), p !== null && (ha(p, d, A), Rf(p, d, A));
      },
      enqueueReplaceState: function(d, p, x) {
        d = d._reactInternals;
        var A = fa(), M = ko(A);
        M.tag = 1, M.payload = p, x != null && (M.callback = x), p = Po(d, M, A), p !== null && (ha(p, d, A), Rf(p, d, A));
      },
      enqueueForceUpdate: function(d, p) {
        d = d._reactInternals;
        var x = fa(), A = ko(x);
        A.tag = 2, p != null && (A.callback = p), p = Po(d, A, x), p !== null && (ha(p, d, x), Rf(p, d, x));
      }
    };
    function Vx(d, p, x, A, M, U, W) {
      return d = d.stateNode, typeof d.shouldComponentUpdate == "function" ? d.shouldComponentUpdate(A, U, W) : p.prototype && p.prototype.isPureReactComponent ? !xf(x, A) || !xf(M, U) : true;
    }
    function Nx(d, p, x, A) {
      d = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(x, A), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(x, A), p.state !== d && Gm.enqueueReplaceState(p, p.state, null);
    }
    function oc(d, p) {
      var x = p;
      if ("ref" in p) {
        x = {};
        for (var A in p) A !== "ref" && (x[A] = p[A]);
      }
      if (d = d.defaultProps) {
        x === p && (x = f({}, x));
        for (var M in d) x[M] === void 0 && (x[M] = d[M]);
      }
      return x;
    }
    var kd = typeof reportError == "function" ? reportError : function(d) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var p = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof d == "object" && d !== null && typeof d.message == "string" ? String(d.message) : String(d),
          error: d
        });
        if (!window.dispatchEvent(p)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", d);
        return;
      }
      console.error(d);
    };
    function Lx(d) {
      kd(d);
    }
    function Ux(d) {
      console.error(d);
    }
    function Fx(d) {
      kd(d);
    }
    function Pd(d, p) {
      try {
        var x = d.onUncaughtError;
        x(p.value, {
          componentStack: p.stack
        });
      } catch (A) {
        setTimeout(function() {
          throw A;
        });
      }
    }
    function Bx(d, p, x) {
      try {
        var A = d.onCaughtError;
        A(x.value, {
          componentStack: x.stack,
          errorBoundary: p.tag === 1 ? p.stateNode : null
        });
      } catch (M) {
        setTimeout(function() {
          throw M;
        });
      }
    }
    function zm(d, p, x) {
      return x = ko(x), x.tag = 3, x.payload = {
        element: null
      }, x.callback = function() {
        Pd(d, p);
      }, x;
    }
    function _x(d) {
      return d = ko(d), d.tag = 3, d;
    }
    function kx(d, p, x, A) {
      var M = x.type.getDerivedStateFromError;
      if (typeof M == "function") {
        var U = A.value;
        d.payload = function() {
          return M(U);
        }, d.callback = function() {
          Bx(p, x, A);
        };
      }
      var W = x.stateNode;
      W !== null && typeof W.componentDidCatch == "function" && (d.callback = function() {
        Bx(p, x, A), typeof M != "function" && (Xo === null ? Xo = /* @__PURE__ */ new Set([
          this
        ]) : Xo.add(this));
        var Q = A.stack;
        this.componentDidCatch(A.value, {
          componentStack: Q !== null ? Q : ""
        });
      });
    }
    function AU(d, p, x, A, M) {
      if (x.flags |= 32768, A !== null && typeof A == "object" && typeof A.then == "function") {
        if (p = x.alternate, p !== null && Af(p, x, M, true), x = Da.current, x !== null) {
          switch (x.tag) {
            case 13:
              return vs === null ? h3() : x.alternate === null && fr === 0 && (fr = 3), x.flags &= -257, x.flags |= 65536, x.lanes = M, A === vm ? x.flags |= 16384 : (p = x.updateQueue, p === null ? x.updateQueue = /* @__PURE__ */ new Set([
                A
              ]) : p.add(A), g3(d, A, M)), false;
            case 22:
              return x.flags |= 65536, A === vm ? x.flags |= 16384 : (p = x.updateQueue, p === null ? (p = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([
                  A
                ])
              }, x.updateQueue = p) : (x = p.retryQueue, x === null ? p.retryQueue = /* @__PURE__ */ new Set([
                A
              ]) : x.add(A)), g3(d, A, M)), false;
          }
          throw Error(r(435, x.tag));
        }
        return g3(d, A, M), h3(), false;
      }
      if (An) return p = Da.current, p !== null ? ((p.flags & 65536) === 0 && (p.flags |= 256), p.flags |= 65536, p.lanes = M, A !== um && (d = Error(r(422), {
        cause: A
      }), Sf(Sa(d, x)))) : (A !== um && (p = Error(r(423), {
        cause: A
      }), Sf(Sa(p, x))), d = d.current.alternate, d.flags |= 65536, M &= -M, d.lanes |= M, A = Sa(A, x), M = zm(d.stateNode, A, M), wm(d, M), fr !== 4 && (fr = 2)), false;
      var U = Error(r(520), {
        cause: A
      });
      if (U = Sa(U, x), Hf === null ? Hf = [
        U
      ] : Hf.push(U), fr !== 4 && (fr = 2), p === null) return true;
      A = Sa(A, x), x = p;
      do {
        switch (x.tag) {
          case 3:
            return x.flags |= 65536, d = M & -M, x.lanes |= d, d = zm(x.stateNode, A, d), wm(x, d), false;
          case 1:
            if (p = x.type, U = x.stateNode, (x.flags & 128) === 0 && (typeof p.getDerivedStateFromError == "function" || U !== null && typeof U.componentDidCatch == "function" && (Xo === null || !Xo.has(U)))) return x.flags |= 65536, M &= -M, x.lanes |= M, M = _x(M), kx(M, d, x, A), wm(x, M), false;
        }
        x = x.return;
      } while (x !== null);
      return false;
    }
    var Px = Error(r(461)), Hr = false;
    function ri(d, p, x, A) {
      p.child = d === null ? Ox(p, null, x, A) : O0(p, d.child, x, A);
    }
    function Gx(d, p, x, A, M) {
      x = x.render;
      var U = p.ref;
      if ("ref" in A) {
        var W = {};
        for (var Q in A) Q !== "ref" && (W[Q] = A[Q]);
      } else W = A;
      return ic(p), A = Em(d, p, x, W, U, M), Q = bm(), d !== null && !Hr ? (Dm(d, p, M), Xs(d, p, M)) : (An && Q && lm(p), p.flags |= 1, ri(d, p, A, M), p.child);
    }
    function zx(d, p, x, A, M) {
      if (d === null) {
        var U = x.type;
        return typeof U == "function" && !am(U) && U.defaultProps === void 0 && x.compare === null ? (p.tag = 15, p.type = U, Wx(d, p, U, A, M)) : (d = xd(x.type, null, A, p, p.mode, M), d.ref = p.ref, d.return = p, p.child = d);
      }
      if (U = d.child, !Zm(d, M)) {
        var W = U.memoizedProps;
        if (x = x.compare, x = x !== null ? x : xf, x(W, A) && d.ref === p.ref) return Xs(d, p, M);
      }
      return p.flags |= 1, d = zs(U, A), d.ref = p.ref, d.return = p, p.child = d;
    }
    function Wx(d, p, x, A, M) {
      if (d !== null) {
        var U = d.memoizedProps;
        if (xf(U, A) && d.ref === p.ref) if (Hr = false, p.pendingProps = A = U, Zm(d, M)) (d.flags & 131072) !== 0 && (Hr = true);
        else return p.lanes = d.lanes, Xs(d, p, M);
      }
      return Wm(d, p, x, A, M);
    }
    function Hx(d, p, x) {
      var A = p.pendingProps, M = A.children, U = d !== null ? d.memoizedState : null;
      if (A.mode === "hidden") {
        if ((p.flags & 128) !== 0) {
          if (A = U !== null ? U.baseLanes | x : x, d !== null) {
            for (M = p.child = d.child, U = 0; M !== null; ) U = U | M.lanes | M.childLanes, M = M.sibling;
            p.childLanes = U & ~A;
          } else p.childLanes = 0, p.child = null;
          return jx(d, p, A, x);
        }
        if ((x & 536870912) !== 0) p.memoizedState = {
          baseLanes: 0,
          cachePool: null
        }, d !== null && Ad(p, U !== null ? U.cachePool : null), U !== null ? W9(p, U) : Tm(), Ix(p);
        else return p.lanes = p.childLanes = 536870912, jx(d, p, U !== null ? U.baseLanes | x : x, x);
      } else U !== null ? (Ad(p, U.cachePool), W9(p, U), Wo(), p.memoizedState = null) : (d !== null && Ad(p, null), Tm(), Wo());
      return ri(d, p, M, x), p.child;
    }
    function jx(d, p, x, A) {
      var M = mm();
      return M = M === null ? null : {
        parent: Br._currentValue,
        pool: M
      }, p.memoizedState = {
        baseLanes: x,
        cachePool: M
      }, d !== null && Ad(p, null), Tm(), Ix(p), d !== null && Af(d, p, A, true), null;
    }
    function Gd(d, p) {
      var x = p.ref;
      if (x === null) d !== null && d.ref !== null && (p.flags |= 4194816);
      else {
        if (typeof x != "function" && typeof x != "object") throw Error(r(284));
        (d === null || d.ref !== x) && (p.flags |= 4194816);
      }
    }
    function Wm(d, p, x, A, M) {
      return ic(p), x = Em(d, p, x, A, void 0, M), A = bm(), d !== null && !Hr ? (Dm(d, p, M), Xs(d, p, M)) : (An && A && lm(p), p.flags |= 1, ri(d, p, x, M), p.child);
    }
    function Kx(d, p, x, A, M, U) {
      return ic(p), p.updateQueue = null, x = j9(p, A, x, M), H9(d), A = bm(), d !== null && !Hr ? (Dm(d, p, U), Xs(d, p, U)) : (An && A && lm(p), p.flags |= 1, ri(d, p, x, U), p.child);
    }
    function Yx(d, p, x, A, M) {
      if (ic(p), p.stateNode === null) {
        var U = w0, W = x.contextType;
        typeof W == "object" && W !== null && (U = xi(W)), U = new x(A, U), p.memoizedState = U.state !== null && U.state !== void 0 ? U.state : null, U.updater = Gm, p.stateNode = U, U._reactInternals = p, U = p.stateNode, U.props = A, U.state = p.memoizedState, U.refs = {}, ym(p), W = x.contextType, U.context = typeof W == "object" && W !== null ? xi(W) : w0, U.state = p.memoizedState, W = x.getDerivedStateFromProps, typeof W == "function" && (Pm(p, x, W, A), U.state = p.memoizedState), typeof x.getDerivedStateFromProps == "function" || typeof U.getSnapshotBeforeUpdate == "function" || typeof U.UNSAFE_componentWillMount != "function" && typeof U.componentWillMount != "function" || (W = U.state, typeof U.componentWillMount == "function" && U.componentWillMount(), typeof U.UNSAFE_componentWillMount == "function" && U.UNSAFE_componentWillMount(), W !== U.state && Gm.enqueueReplaceState(U, U.state, null), If(p, A, U, M), Of(), U.state = p.memoizedState), typeof U.componentDidMount == "function" && (p.flags |= 4194308), A = true;
      } else if (d === null) {
        U = p.stateNode;
        var Q = p.memoizedProps, ae = oc(x, Q);
        U.props = ae;
        var ve = U.context, Ie = x.contextType;
        W = w0, typeof Ie == "object" && Ie !== null && (W = xi(Ie));
        var Fe = x.getDerivedStateFromProps;
        Ie = typeof Fe == "function" || typeof U.getSnapshotBeforeUpdate == "function", Q = p.pendingProps !== Q, Ie || typeof U.UNSAFE_componentWillReceiveProps != "function" && typeof U.componentWillReceiveProps != "function" || (Q || ve !== W) && Nx(p, U, A, W), _o = false;
        var we = p.memoizedState;
        U.state = we, If(p, A, U, M), Of(), ve = p.memoizedState, Q || we !== ve || _o ? (typeof Fe == "function" && (Pm(p, x, Fe, A), ve = p.memoizedState), (ae = _o || Vx(p, x, ae, A, we, ve, W)) ? (Ie || typeof U.UNSAFE_componentWillMount != "function" && typeof U.componentWillMount != "function" || (typeof U.componentWillMount == "function" && U.componentWillMount(), typeof U.UNSAFE_componentWillMount == "function" && U.UNSAFE_componentWillMount()), typeof U.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof U.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = A, p.memoizedState = ve), U.props = A, U.state = ve, U.context = W, A = ae) : (typeof U.componentDidMount == "function" && (p.flags |= 4194308), A = false);
      } else {
        U = p.stateNode, xm(d, p), W = p.memoizedProps, Ie = oc(x, W), U.props = Ie, Fe = p.pendingProps, we = U.context, ve = x.contextType, ae = w0, typeof ve == "object" && ve !== null && (ae = xi(ve)), Q = x.getDerivedStateFromProps, (ve = typeof Q == "function" || typeof U.getSnapshotBeforeUpdate == "function") || typeof U.UNSAFE_componentWillReceiveProps != "function" && typeof U.componentWillReceiveProps != "function" || (W !== Fe || we !== ae) && Nx(p, U, A, ae), _o = false, we = p.memoizedState, U.state = we, If(p, A, U, M), Of();
        var Ce = p.memoizedState;
        W !== Fe || we !== Ce || _o || d !== null && d.dependencies !== null && Td(d.dependencies) ? (typeof Q == "function" && (Pm(p, x, Q, A), Ce = p.memoizedState), (Ie = _o || Vx(p, x, Ie, A, we, Ce, ae) || d !== null && d.dependencies !== null && Td(d.dependencies)) ? (ve || typeof U.UNSAFE_componentWillUpdate != "function" && typeof U.componentWillUpdate != "function" || (typeof U.componentWillUpdate == "function" && U.componentWillUpdate(A, Ce, ae), typeof U.UNSAFE_componentWillUpdate == "function" && U.UNSAFE_componentWillUpdate(A, Ce, ae)), typeof U.componentDidUpdate == "function" && (p.flags |= 4), typeof U.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof U.componentDidUpdate != "function" || W === d.memoizedProps && we === d.memoizedState || (p.flags |= 4), typeof U.getSnapshotBeforeUpdate != "function" || W === d.memoizedProps && we === d.memoizedState || (p.flags |= 1024), p.memoizedProps = A, p.memoizedState = Ce), U.props = A, U.state = Ce, U.context = ae, A = Ie) : (typeof U.componentDidUpdate != "function" || W === d.memoizedProps && we === d.memoizedState || (p.flags |= 4), typeof U.getSnapshotBeforeUpdate != "function" || W === d.memoizedProps && we === d.memoizedState || (p.flags |= 1024), A = false);
      }
      return U = A, Gd(d, p), A = (p.flags & 128) !== 0, U || A ? (U = p.stateNode, x = A && typeof x.getDerivedStateFromError != "function" ? null : U.render(), p.flags |= 1, d !== null && A ? (p.child = O0(p, d.child, null, M), p.child = O0(p, null, x, M)) : ri(d, p, x, M), p.memoizedState = U.state, d = p.child) : d = Xs(d, p, M), d;
    }
    function qx(d, p, x, A) {
      return Tf(), p.flags |= 256, ri(d, p, x, A), p.child;
    }
    var Hm = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function jm(d) {
      return {
        baseLanes: d,
        cachePool: U9()
      };
    }
    function Km(d, p, x) {
      return d = d !== null ? d.childLanes & ~x : 0, p && (d |= Ma), d;
    }
    function Xx(d, p, x) {
      var A = p.pendingProps, M = false, U = (p.flags & 128) !== 0, W;
      if ((W = U) || (W = d !== null && d.memoizedState === null ? false : (_r2.current & 2) !== 0), W && (M = true, p.flags &= -129), W = (p.flags & 32) !== 0, p.flags &= -33, d === null) {
        if (An) {
          if (M ? zo(p) : Wo(), An) {
            var Q = ur, ae;
            if (ae = Q) {
              e: {
                for (ae = Q, Q = ms; ae.nodeType !== 8; ) {
                  if (!Q) {
                    Q = null;
                    break e;
                  }
                  if (ae = Ya(ae.nextSibling), ae === null) {
                    Q = null;
                    break e;
                  }
                }
                Q = ae;
              }
              Q !== null ? (p.memoizedState = {
                dehydrated: Q,
                treeContext: $l !== null ? {
                  id: Ws,
                  overflow: Hs
                } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, ae = oa(18, null, null, 0), ae.stateNode = Q, ae.return = p, p.child = ae, Vi = p, ur = null, ae = true) : ae = false;
            }
            ae || nc(p);
          }
          if (Q = p.memoizedState, Q !== null && (Q = Q.dehydrated, Q !== null)) return R3(Q) ? p.lanes = 32 : p.lanes = 536870912, null;
          qs(p);
        }
        return Q = A.children, A = A.fallback, M ? (Wo(), M = p.mode, Q = zd({
          mode: "hidden",
          children: Q
        }, M), A = Jl(A, M, x, null), Q.return = p, A.return = p, Q.sibling = A, p.child = Q, M = p.child, M.memoizedState = jm(x), M.childLanes = Km(d, W, x), p.memoizedState = Hm, A) : (zo(p), Ym(p, Q));
      }
      if (ae = d.memoizedState, ae !== null && (Q = ae.dehydrated, Q !== null)) {
        if (U) p.flags & 256 ? (zo(p), p.flags &= -257, p = qm(d, p, x)) : p.memoizedState !== null ? (Wo(), p.child = d.child, p.flags |= 128, p = null) : (Wo(), M = A.fallback, Q = p.mode, A = zd({
          mode: "visible",
          children: A.children
        }, Q), M = Jl(M, Q, x, null), M.flags |= 2, A.return = p, M.return = p, A.sibling = M, p.child = A, O0(p, d.child, null, x), A = p.child, A.memoizedState = jm(x), A.childLanes = Km(d, W, x), p.memoizedState = Hm, p = M);
        else if (zo(p), R3(Q)) {
          if (W = Q.nextSibling && Q.nextSibling.dataset, W) var ve = W.dgst;
          W = ve, A = Error(r(419)), A.stack = "", A.digest = W, Sf({
            value: A,
            source: null,
            stack: null
          }), p = qm(d, p, x);
        } else if (Hr || Af(d, p, x, false), W = (x & d.childLanes) !== 0, Hr || W) {
          if (W = kn, W !== null && (A = x & -x, A = (A & 42) !== 0 ? 1 : fs(A), A = (A & (W.suspendedLanes | x)) !== 0 ? 0 : A, A !== 0 && A !== ae.retryLane)) throw ae.retryLane = A, x0(d, A), ha(W, d, A), Px;
          Q.data === "$?" || h3(), p = qm(d, p, x);
        } else Q.data === "$?" ? (p.flags |= 192, p.child = d.child, p = null) : (d = ae.treeContext, ur = Ya(Q.nextSibling), Vi = p, An = true, tc = null, ms = false, d !== null && (Ea[ba++] = Ws, Ea[ba++] = Hs, Ea[ba++] = $l, Ws = d.id, Hs = d.overflow, $l = p), p = Ym(p, A.children), p.flags |= 4096);
        return p;
      }
      return M ? (Wo(), M = A.fallback, Q = p.mode, ae = d.child, ve = ae.sibling, A = zs(ae, {
        mode: "hidden",
        children: A.children
      }), A.subtreeFlags = ae.subtreeFlags & 65011712, ve !== null ? M = zs(ve, M) : (M = Jl(M, Q, x, null), M.flags |= 2), M.return = p, A.return = p, A.sibling = M, p.child = A, A = M, M = p.child, Q = d.child.memoizedState, Q === null ? Q = jm(x) : (ae = Q.cachePool, ae !== null ? (ve = Br._currentValue, ae = ae.parent !== ve ? {
        parent: ve,
        pool: ve
      } : ae) : ae = U9(), Q = {
        baseLanes: Q.baseLanes | x,
        cachePool: ae
      }), M.memoizedState = Q, M.childLanes = Km(d, W, x), p.memoizedState = Hm, A) : (zo(p), x = d.child, d = x.sibling, x = zs(x, {
        mode: "visible",
        children: A.children
      }), x.return = p, x.sibling = null, d !== null && (W = p.deletions, W === null ? (p.deletions = [
        d
      ], p.flags |= 16) : W.push(d)), p.child = x, p.memoizedState = null, x);
    }
    function Ym(d, p) {
      return p = zd({
        mode: "visible",
        children: p
      }, d.mode), p.return = d, d.child = p;
    }
    function zd(d, p) {
      return d = oa(22, d, null, p), d.lanes = 0, d.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, d;
    }
    function qm(d, p, x) {
      return O0(p, d.child, null, x), d = Ym(p, p.pendingProps.children), d.flags |= 2, p.memoizedState = null, d;
    }
    function Zx(d, p, x) {
      d.lanes |= p;
      var A = d.alternate;
      A !== null && (A.lanes |= p), hm(d.return, p, x);
    }
    function Xm(d, p, x, A, M) {
      var U = d.memoizedState;
      U === null ? d.memoizedState = {
        isBackwards: p,
        rendering: null,
        renderingStartTime: 0,
        last: A,
        tail: x,
        tailMode: M
      } : (U.isBackwards = p, U.rendering = null, U.renderingStartTime = 0, U.last = A, U.tail = x, U.tailMode = M);
    }
    function Qx(d, p, x) {
      var A = p.pendingProps, M = A.revealOrder, U = A.tail;
      if (ri(d, p, A.children, x), A = _r2.current, (A & 2) !== 0) A = A & 1 | 2, p.flags |= 128;
      else {
        if (d !== null && (d.flags & 128) !== 0) e: for (d = p.child; d !== null; ) {
          if (d.tag === 13) d.memoizedState !== null && Zx(d, x, p);
          else if (d.tag === 19) Zx(d, x, p);
          else if (d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
          if (d === p) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === p) break e;
            d = d.return;
          }
          d.sibling.return = d.return, d = d.sibling;
        }
        A &= 1;
      }
      switch (ie(_r2, A), M) {
        case "forwards":
          for (x = p.child, M = null; x !== null; ) d = x.alternate, d !== null && _d(d) === null && (M = x), x = x.sibling;
          x = M, x === null ? (M = p.child, p.child = null) : (M = x.sibling, x.sibling = null), Xm(p, false, M, x, U);
          break;
        case "backwards":
          for (x = null, M = p.child, p.child = null; M !== null; ) {
            if (d = M.alternate, d !== null && _d(d) === null) {
              p.child = M;
              break;
            }
            d = M.sibling, M.sibling = x, x = M, M = d;
          }
          Xm(p, true, x, null, U);
          break;
        case "together":
          Xm(p, false, null, null, void 0);
          break;
        default:
          p.memoizedState = null;
      }
      return p.child;
    }
    function Xs(d, p, x) {
      if (d !== null && (p.dependencies = d.dependencies), qo |= p.lanes, (x & p.childLanes) === 0) if (d !== null) {
        if (Af(d, p, x, false), (x & p.childLanes) === 0) return null;
      } else return null;
      if (d !== null && p.child !== d.child) throw Error(r(153));
      if (p.child !== null) {
        for (d = p.child, x = zs(d, d.pendingProps), p.child = x, x.return = p; d.sibling !== null; ) d = d.sibling, x = x.sibling = zs(d, d.pendingProps), x.return = p;
        x.sibling = null;
      }
      return p.child;
    }
    function Zm(d, p) {
      return (d.lanes & p) !== 0 ? true : (d = d.dependencies, !!(d !== null && Td(d)));
    }
    function EU(d, p, x) {
      switch (p.tag) {
        case 3:
          Pe(p, p.stateNode.containerInfo), Bo(p, Br, d.memoizedState.cache), Tf();
          break;
        case 27:
        case 5:
          vt(p);
          break;
        case 4:
          Pe(p, p.stateNode.containerInfo);
          break;
        case 10:
          Bo(p, p.type, p.memoizedProps.value);
          break;
        case 13:
          var A = p.memoizedState;
          if (A !== null) return A.dehydrated !== null ? (zo(p), p.flags |= 128, null) : (x & p.child.childLanes) !== 0 ? Xx(d, p, x) : (zo(p), d = Xs(d, p, x), d !== null ? d.sibling : null);
          zo(p);
          break;
        case 19:
          var M = (d.flags & 128) !== 0;
          if (A = (x & p.childLanes) !== 0, A || (Af(d, p, x, false), A = (x & p.childLanes) !== 0), M) {
            if (A) return Qx(d, p, x);
            p.flags |= 128;
          }
          if (M = p.memoizedState, M !== null && (M.rendering = null, M.tail = null, M.lastEffect = null), ie(_r2, _r2.current), A) break;
          return null;
        case 22:
        case 23:
          return p.lanes = 0, Hx(d, p, x);
        case 24:
          Bo(p, Br, d.memoizedState.cache);
      }
      return Xs(d, p, x);
    }
    function Jx(d, p, x) {
      if (d !== null) if (d.memoizedProps !== p.pendingProps) Hr = true;
      else {
        if (!Zm(d, x) && (p.flags & 128) === 0) return Hr = false, EU(d, p, x);
        Hr = (d.flags & 131072) !== 0;
      }
      else Hr = false, An && (p.flags & 1048576) !== 0 && M9(p, Cd, p.index);
      switch (p.lanes = 0, p.tag) {
        case 16:
          e: {
            d = p.pendingProps;
            var A = p.elementType, M = A._init;
            if (A = M(A._payload), p.type = A, typeof A == "function") am(A) ? (d = oc(A, d), p.tag = 1, p = Yx(null, p, A, d, x)) : (p.tag = 0, p = Wm(null, p, A, d, x));
            else {
              if (A != null) {
                if (M = A.$$typeof, M === S) {
                  p.tag = 11, p = Gx(null, p, A, d, x);
                  break e;
                } else if (M === D) {
                  p.tag = 14, p = zx(null, p, A, d, x);
                  break e;
                }
              }
              throw p = V(A) || A, Error(r(306, p, ""));
            }
          }
          return p;
        case 0:
          return Wm(d, p, p.type, p.pendingProps, x);
        case 1:
          return A = p.type, M = oc(A, p.pendingProps), Yx(d, p, A, M, x);
        case 3:
          e: {
            if (Pe(p, p.stateNode.containerInfo), d === null) throw Error(r(387));
            A = p.pendingProps;
            var U = p.memoizedState;
            M = U.element, xm(d, p), If(p, A, null, x);
            var W = p.memoizedState;
            if (A = W.cache, Bo(p, Br, A), A !== U.cache && dm(p, [
              Br
            ], x, true), Of(), A = W.element, U.isDehydrated) if (U = {
              element: A,
              isDehydrated: false,
              cache: W.cache
            }, p.updateQueue.baseState = U, p.memoizedState = U, p.flags & 256) {
              p = qx(d, p, A, x);
              break e;
            } else if (A !== M) {
              M = Sa(Error(r(424)), p), Sf(M), p = qx(d, p, A, x);
              break e;
            } else {
              switch (d = p.stateNode.containerInfo, d.nodeType) {
                case 9:
                  d = d.body;
                  break;
                default:
                  d = d.nodeName === "HTML" ? d.ownerDocument.body : d;
              }
              for (ur = Ya(d.firstChild), Vi = p, An = true, tc = null, ms = true, x = Ox(p, null, A, x), p.child = x; x; ) x.flags = x.flags & -3 | 4096, x = x.sibling;
            }
            else {
              if (Tf(), A === M) {
                p = Xs(d, p, x);
                break e;
              }
              ri(d, p, A, x);
            }
            p = p.child;
          }
          return p;
        case 26:
          return Gd(d, p), d === null ? (x = nw(p.type, null, p.pendingProps, null)) ? p.memoizedState = x : An || (x = p.type, d = p.pendingProps, A = n2(Le.current).createElement(x), A[yr] = p, A[Fr] = d, ai(A, x, d), cr(A), p.stateNode = A) : p.memoizedState = nw(p.type, d.memoizedProps, p.pendingProps, d.memoizedState), null;
        case 27:
          return vt(p), d === null && An && (A = p.stateNode = $7(p.type, p.pendingProps, Le.current), Vi = p, ms = true, M = ur, Jo(p.type) ? (O3 = M, ur = Ya(A.firstChild)) : ur = M), ri(d, p, p.pendingProps.children, x), Gd(d, p), d === null && (p.flags |= 4194304), p.child;
        case 5:
          return d === null && An && ((M = A = ur) && (A = $U(A, p.type, p.pendingProps, ms), A !== null ? (p.stateNode = A, Vi = p, ur = Ya(A.firstChild), ms = false, M = true) : M = false), M || nc(p)), vt(p), M = p.type, U = p.pendingProps, W = d !== null ? d.memoizedProps : null, A = U.children, b3(M, U) ? A = null : W !== null && b3(M, W) && (p.flags |= 32), p.memoizedState !== null && (M = Em(d, p, vU, null, null, x), $f._currentValue = M), Gd(d, p), ri(d, p, A, x), p.child;
        case 6:
          return d === null && An && ((d = x = ur) && (x = eF(x, p.pendingProps, ms), x !== null ? (p.stateNode = x, Vi = p, ur = null, d = true) : d = false), d || nc(p)), null;
        case 13:
          return Xx(d, p, x);
        case 4:
          return Pe(p, p.stateNode.containerInfo), A = p.pendingProps, d === null ? p.child = O0(p, null, A, x) : ri(d, p, A, x), p.child;
        case 11:
          return Gx(d, p, p.type, p.pendingProps, x);
        case 7:
          return ri(d, p, p.pendingProps, x), p.child;
        case 8:
          return ri(d, p, p.pendingProps.children, x), p.child;
        case 12:
          return ri(d, p, p.pendingProps.children, x), p.child;
        case 10:
          return A = p.pendingProps, Bo(p, p.type, A.value), ri(d, p, A.children, x), p.child;
        case 9:
          return M = p.type._context, A = p.pendingProps.children, ic(p), M = xi(M), A = A(M), p.flags |= 1, ri(d, p, A, x), p.child;
        case 14:
          return zx(d, p, p.type, p.pendingProps, x);
        case 15:
          return Wx(d, p, p.type, p.pendingProps, x);
        case 19:
          return Qx(d, p, x);
        case 31:
          return A = p.pendingProps, x = p.mode, A = {
            mode: A.mode,
            children: A.children
          }, d === null ? (x = zd(A, x), x.ref = p.ref, p.child = x, x.return = p, p = x) : (x = zs(d.child, A), x.ref = p.ref, p.child = x, x.return = p, p = x), p;
        case 22:
          return Hx(d, p, x);
        case 24:
          return ic(p), A = xi(Br), d === null ? (M = mm(), M === null && (M = kn, U = gm(), M.pooledCache = U, U.refCount++, U !== null && (M.pooledCacheLanes |= x), M = U), p.memoizedState = {
            parent: A,
            cache: M
          }, ym(p), Bo(p, Br, M)) : ((d.lanes & x) !== 0 && (xm(d, p), If(p, null, null, x), Of()), M = d.memoizedState, U = p.memoizedState, M.parent !== A ? (M = {
            parent: A,
            cache: A
          }, p.memoizedState = M, p.lanes === 0 && (p.memoizedState = p.updateQueue.baseState = M), Bo(p, Br, A)) : (A = U.cache, Bo(p, Br, A), A !== M.cache && dm(p, [
            Br
          ], x, true))), ri(d, p, p.pendingProps.children, x), p.child;
        case 29:
          throw p.pendingProps;
      }
      throw Error(r(156, p.tag));
    }
    function Zs(d) {
      d.flags |= 4;
    }
    function $x(d, p) {
      if (p.type !== "stylesheet" || (p.state.loading & 4) !== 0) d.flags &= -16777217;
      else if (d.flags |= 16777216, !ow(p)) {
        if (p = Da.current, p !== null && ((Cn & 4194048) === Cn ? vs !== null : (Cn & 62914560) !== Cn && (Cn & 536870912) === 0 || p !== vs)) throw Mf = vm, F9;
        d.flags |= 8192;
      }
    }
    function Wd(d, p) {
      p !== null && (d.flags |= 4), d.flags & 16384 && (p = d.tag !== 22 ? ti() : 536870912, d.lanes |= p, L0 |= p);
    }
    function _f(d, p) {
      if (!An) switch (d.tailMode) {
        case "hidden":
          p = d.tail;
          for (var x = null; p !== null; ) p.alternate !== null && (x = p), p = p.sibling;
          x === null ? d.tail = null : x.sibling = null;
          break;
        case "collapsed":
          x = d.tail;
          for (var A = null; x !== null; ) x.alternate !== null && (A = x), x = x.sibling;
          A === null ? p || d.tail === null ? d.tail = null : d.tail.sibling = null : A.sibling = null;
      }
    }
    function nr(d) {
      var p = d.alternate !== null && d.alternate.child === d.child, x = 0, A = 0;
      if (p) for (var M = d.child; M !== null; ) x |= M.lanes | M.childLanes, A |= M.subtreeFlags & 65011712, A |= M.flags & 65011712, M.return = d, M = M.sibling;
      else for (M = d.child; M !== null; ) x |= M.lanes | M.childLanes, A |= M.subtreeFlags, A |= M.flags, M.return = d, M = M.sibling;
      return d.subtreeFlags |= A, d.childLanes = x, p;
    }
    function bU(d, p, x) {
      var A = p.pendingProps;
      switch (cm(p), p.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return nr(p), null;
        case 1:
          return nr(p), null;
        case 3:
          return x = p.stateNode, A = null, d !== null && (A = d.memoizedState.cache), p.memoizedState.cache !== A && (p.flags |= 2048), Ks(Br), ot(), x.pendingContext && (x.context = x.pendingContext, x.pendingContext = null), (d === null || d.child === null) && (Cf(p) ? Zs(p) : d === null || d.memoizedState.isDehydrated && (p.flags & 256) === 0 || (p.flags |= 1024, I9())), nr(p), null;
        case 26:
          return x = p.memoizedState, d === null ? (Zs(p), x !== null ? (nr(p), $x(p, x)) : (nr(p), p.flags &= -16777217)) : x ? x !== d.memoizedState ? (Zs(p), nr(p), $x(p, x)) : (nr(p), p.flags &= -16777217) : (d.memoizedProps !== A && Zs(p), nr(p), p.flags &= -16777217), null;
        case 27:
          wt(p), x = Le.current;
          var M = p.type;
          if (d !== null && p.stateNode != null) d.memoizedProps !== A && Zs(p);
          else {
            if (!A) {
              if (p.stateNode === null) throw Error(r(166));
              return nr(p), null;
            }
            d = oe.current, Cf(p) ? R9(p) : (d = $7(M, A, x), p.stateNode = d, Zs(p));
          }
          return nr(p), null;
        case 5:
          if (wt(p), x = p.type, d !== null && p.stateNode != null) d.memoizedProps !== A && Zs(p);
          else {
            if (!A) {
              if (p.stateNode === null) throw Error(r(166));
              return nr(p), null;
            }
            if (d = oe.current, Cf(p)) R9(p);
            else {
              switch (M = n2(Le.current), d) {
                case 1:
                  d = M.createElementNS("http://www.w3.org/2000/svg", x);
                  break;
                case 2:
                  d = M.createElementNS("http://www.w3.org/1998/Math/MathML", x);
                  break;
                default:
                  switch (x) {
                    case "svg":
                      d = M.createElementNS("http://www.w3.org/2000/svg", x);
                      break;
                    case "math":
                      d = M.createElementNS("http://www.w3.org/1998/Math/MathML", x);
                      break;
                    case "script":
                      d = M.createElement("div"), d.innerHTML = "<script><\/script>", d = d.removeChild(d.firstChild);
                      break;
                    case "select":
                      d = typeof A.is == "string" ? M.createElement("select", {
                        is: A.is
                      }) : M.createElement("select"), A.multiple ? d.multiple = true : A.size && (d.size = A.size);
                      break;
                    default:
                      d = typeof A.is == "string" ? M.createElement(x, {
                        is: A.is
                      }) : M.createElement(x);
                  }
              }
              d[yr] = p, d[Fr] = A;
              e: for (M = p.child; M !== null; ) {
                if (M.tag === 5 || M.tag === 6) d.appendChild(M.stateNode);
                else if (M.tag !== 4 && M.tag !== 27 && M.child !== null) {
                  M.child.return = M, M = M.child;
                  continue;
                }
                if (M === p) break e;
                for (; M.sibling === null; ) {
                  if (M.return === null || M.return === p) break e;
                  M = M.return;
                }
                M.sibling.return = M.return, M = M.sibling;
              }
              p.stateNode = d;
              e: switch (ai(d, x, A), x) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!A.autoFocus;
                  break e;
                case "img":
                  d = true;
                  break e;
                default:
                  d = false;
              }
              d && Zs(p);
            }
          }
          return nr(p), p.flags &= -16777217, null;
        case 6:
          if (d && p.stateNode != null) d.memoizedProps !== A && Zs(p);
          else {
            if (typeof A != "string" && p.stateNode === null) throw Error(r(166));
            if (d = Le.current, Cf(p)) {
              if (d = p.stateNode, x = p.memoizedProps, A = null, M = Vi, M !== null) switch (M.tag) {
                case 27:
                case 5:
                  A = M.memoizedProps;
              }
              d[yr] = p, d = !!(d.nodeValue === x || A !== null && A.suppressHydrationWarning === true || K7(d.nodeValue, x)), d || nc(p);
            } else d = n2(d).createTextNode(A), d[yr] = p, p.stateNode = d;
          }
          return nr(p), null;
        case 13:
          if (A = p.memoizedState, d === null || d.memoizedState !== null && d.memoizedState.dehydrated !== null) {
            if (M = Cf(p), A !== null && A.dehydrated !== null) {
              if (d === null) {
                if (!M) throw Error(r(318));
                if (M = p.memoizedState, M = M !== null ? M.dehydrated : null, !M) throw Error(r(317));
                M[yr] = p;
              } else Tf(), (p.flags & 128) === 0 && (p.memoizedState = null), p.flags |= 4;
              nr(p), M = false;
            } else M = I9(), d !== null && d.memoizedState !== null && (d.memoizedState.hydrationErrors = M), M = true;
            if (!M) return p.flags & 256 ? (qs(p), p) : (qs(p), null);
          }
          if (qs(p), (p.flags & 128) !== 0) return p.lanes = x, p;
          if (x = A !== null, d = d !== null && d.memoizedState !== null, x) {
            A = p.child, M = null, A.alternate !== null && A.alternate.memoizedState !== null && A.alternate.memoizedState.cachePool !== null && (M = A.alternate.memoizedState.cachePool.pool);
            var U = null;
            A.memoizedState !== null && A.memoizedState.cachePool !== null && (U = A.memoizedState.cachePool.pool), U !== M && (A.flags |= 2048);
          }
          return x !== d && x && (p.child.flags |= 8192), Wd(p, p.updateQueue), nr(p), null;
        case 4:
          return ot(), d === null && C3(p.stateNode.containerInfo), nr(p), null;
        case 10:
          return Ks(p.type), nr(p), null;
        case 19:
          if (X(_r2), M = p.memoizedState, M === null) return nr(p), null;
          if (A = (p.flags & 128) !== 0, U = M.rendering, U === null) if (A) _f(M, false);
          else {
            if (fr !== 0 || d !== null && (d.flags & 128) !== 0) for (d = p.child; d !== null; ) {
              if (U = _d(d), U !== null) {
                for (p.flags |= 128, _f(M, false), d = U.updateQueue, p.updateQueue = d, Wd(p, d), p.subtreeFlags = 0, d = x, x = p.child; x !== null; ) D9(x, d), x = x.sibling;
                return ie(_r2, _r2.current & 1 | 2), p.child;
              }
              d = d.sibling;
            }
            M.tail !== null && re() > Kd && (p.flags |= 128, A = true, _f(M, false), p.lanes = 4194304);
          }
          else {
            if (!A) if (d = _d(U), d !== null) {
              if (p.flags |= 128, A = true, d = d.updateQueue, p.updateQueue = d, Wd(p, d), _f(M, true), M.tail === null && M.tailMode === "hidden" && !U.alternate && !An) return nr(p), null;
            } else 2 * re() - M.renderingStartTime > Kd && x !== 536870912 && (p.flags |= 128, A = true, _f(M, false), p.lanes = 4194304);
            M.isBackwards ? (U.sibling = p.child, p.child = U) : (d = M.last, d !== null ? d.sibling = U : p.child = U, M.last = U);
          }
          return M.tail !== null ? (p = M.tail, M.rendering = p, M.tail = p.sibling, M.renderingStartTime = re(), p.sibling = null, d = _r2.current, ie(_r2, A ? d & 1 | 2 : d & 1), p) : (nr(p), null);
        case 22:
        case 23:
          return qs(p), Sm(), A = p.memoizedState !== null, d !== null ? d.memoizedState !== null !== A && (p.flags |= 8192) : A && (p.flags |= 8192), A ? (x & 536870912) !== 0 && (p.flags & 128) === 0 && (nr(p), p.subtreeFlags & 6 && (p.flags |= 8192)) : nr(p), x = p.updateQueue, x !== null && Wd(p, x.retryQueue), x = null, d !== null && d.memoizedState !== null && d.memoizedState.cachePool !== null && (x = d.memoizedState.cachePool.pool), A = null, p.memoizedState !== null && p.memoizedState.cachePool !== null && (A = p.memoizedState.cachePool.pool), A !== x && (p.flags |= 2048), d !== null && X(ac), null;
        case 24:
          return x = null, d !== null && (x = d.memoizedState.cache), p.memoizedState.cache !== x && (p.flags |= 2048), Ks(Br), nr(p), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(r(156, p.tag));
    }
    function DU(d, p) {
      switch (cm(p), p.tag) {
        case 1:
          return d = p.flags, d & 65536 ? (p.flags = d & -65537 | 128, p) : null;
        case 3:
          return Ks(Br), ot(), d = p.flags, (d & 65536) !== 0 && (d & 128) === 0 ? (p.flags = d & -65537 | 128, p) : null;
        case 26:
        case 27:
        case 5:
          return wt(p), null;
        case 13:
          if (qs(p), d = p.memoizedState, d !== null && d.dehydrated !== null) {
            if (p.alternate === null) throw Error(r(340));
            Tf();
          }
          return d = p.flags, d & 65536 ? (p.flags = d & -65537 | 128, p) : null;
        case 19:
          return X(_r2), null;
        case 4:
          return ot(), null;
        case 10:
          return Ks(p.type), null;
        case 22:
        case 23:
          return qs(p), Sm(), d !== null && X(ac), d = p.flags, d & 65536 ? (p.flags = d & -65537 | 128, p) : null;
        case 24:
          return Ks(Br), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function e7(d, p) {
      switch (cm(p), p.tag) {
        case 3:
          Ks(Br), ot();
          break;
        case 26:
        case 27:
        case 5:
          wt(p);
          break;
        case 4:
          ot();
          break;
        case 13:
          qs(p);
          break;
        case 19:
          X(_r2);
          break;
        case 10:
          Ks(p.type);
          break;
        case 22:
        case 23:
          qs(p), Sm(), d !== null && X(ac);
          break;
        case 24:
          Ks(Br);
      }
    }
    function kf(d, p) {
      try {
        var x = p.updateQueue, A = x !== null ? x.lastEffect : null;
        if (A !== null) {
          var M = A.next;
          x = M;
          do {
            if ((x.tag & d) === d) {
              A = void 0;
              var U = x.create, W = x.inst;
              A = U(), W.destroy = A;
            }
            x = x.next;
          } while (x !== M);
        }
      } catch (Q) {
        Bn(p, p.return, Q);
      }
    }
    function Ho(d, p, x) {
      try {
        var A = p.updateQueue, M = A !== null ? A.lastEffect : null;
        if (M !== null) {
          var U = M.next;
          A = U;
          do {
            if ((A.tag & d) === d) {
              var W = A.inst, Q = W.destroy;
              if (Q !== void 0) {
                W.destroy = void 0, M = p;
                var ae = x, ve = Q;
                try {
                  ve();
                } catch (Ie) {
                  Bn(M, ae, Ie);
                }
              }
            }
            A = A.next;
          } while (A !== U);
        }
      } catch (Ie) {
        Bn(p, p.return, Ie);
      }
    }
    function t7(d) {
      var p = d.updateQueue;
      if (p !== null) {
        var x = d.stateNode;
        try {
          z9(p, x);
        } catch (A) {
          Bn(d, d.return, A);
        }
      }
    }
    function n7(d, p, x) {
      x.props = oc(d.type, d.memoizedProps), x.state = d.memoizedState;
      try {
        x.componentWillUnmount();
      } catch (A) {
        Bn(d, p, A);
      }
    }
    function Pf(d, p) {
      try {
        var x = d.ref;
        if (x !== null) {
          switch (d.tag) {
            case 26:
            case 27:
            case 5:
              var A = d.stateNode;
              break;
            case 30:
              A = d.stateNode;
              break;
            default:
              A = d.stateNode;
          }
          typeof x == "function" ? d.refCleanup = x(A) : x.current = A;
        }
      } catch (M) {
        Bn(d, p, M);
      }
    }
    function ys(d, p) {
      var x = d.ref, A = d.refCleanup;
      if (x !== null) if (typeof A == "function") try {
        A();
      } catch (M) {
        Bn(d, p, M);
      } finally {
        d.refCleanup = null, d = d.alternate, d != null && (d.refCleanup = null);
      }
      else if (typeof x == "function") try {
        x(null);
      } catch (M) {
        Bn(d, p, M);
      }
      else x.current = null;
    }
    function r7(d) {
      var p = d.type, x = d.memoizedProps, A = d.stateNode;
      try {
        e: switch (p) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            x.autoFocus && A.focus();
            break e;
          case "img":
            x.src ? A.src = x.src : x.srcSet && (A.srcset = x.srcSet);
        }
      } catch (M) {
        Bn(d, d.return, M);
      }
    }
    function Qm(d, p, x) {
      try {
        var A = d.stateNode;
        qU(A, d.type, x, p), A[Fr] = p;
      } catch (M) {
        Bn(d, d.return, M);
      }
    }
    function i7(d) {
      return d.tag === 5 || d.tag === 3 || d.tag === 26 || d.tag === 27 && Jo(d.type) || d.tag === 4;
    }
    function Jm(d) {
      e: for (; ; ) {
        for (; d.sibling === null; ) {
          if (d.return === null || i7(d.return)) return null;
          d = d.return;
        }
        for (d.sibling.return = d.return, d = d.sibling; d.tag !== 5 && d.tag !== 6 && d.tag !== 18; ) {
          if (d.tag === 27 && Jo(d.type) || d.flags & 2 || d.child === null || d.tag === 4) continue e;
          d.child.return = d, d = d.child;
        }
        if (!(d.flags & 2)) return d.stateNode;
      }
    }
    function $m(d, p, x) {
      var A = d.tag;
      if (A === 5 || A === 6) d = d.stateNode, p ? (x.nodeType === 9 ? x.body : x.nodeName === "HTML" ? x.ownerDocument.body : x).insertBefore(d, p) : (p = x.nodeType === 9 ? x.body : x.nodeName === "HTML" ? x.ownerDocument.body : x, p.appendChild(d), x = x._reactRootContainer, x != null || p.onclick !== null || (p.onclick = t2));
      else if (A !== 4 && (A === 27 && Jo(d.type) && (x = d.stateNode, p = null), d = d.child, d !== null)) for ($m(d, p, x), d = d.sibling; d !== null; ) $m(d, p, x), d = d.sibling;
    }
    function Hd(d, p, x) {
      var A = d.tag;
      if (A === 5 || A === 6) d = d.stateNode, p ? x.insertBefore(d, p) : x.appendChild(d);
      else if (A !== 4 && (A === 27 && Jo(d.type) && (x = d.stateNode), d = d.child, d !== null)) for (Hd(d, p, x), d = d.sibling; d !== null; ) Hd(d, p, x), d = d.sibling;
    }
    function a7(d) {
      var p = d.stateNode, x = d.memoizedProps;
      try {
        for (var A = d.type, M = p.attributes; M.length; ) p.removeAttributeNode(M[0]);
        ai(p, A, x), p[yr] = d, p[Fr] = x;
      } catch (U) {
        Bn(d, d.return, U);
      }
    }
    var Qs = false, Cr = false, e3 = false, s7 = typeof WeakSet == "function" ? WeakSet : Set, jr = null;
    function MU(d, p) {
      if (d = d.containerInfo, A3 = l2, d = v9(d), J5(d)) {
        if ("selectionStart" in d) var x = {
          start: d.selectionStart,
          end: d.selectionEnd
        };
        else e: {
          x = (x = d.ownerDocument) && x.defaultView || window;
          var A = x.getSelection && x.getSelection();
          if (A && A.rangeCount !== 0) {
            x = A.anchorNode;
            var M = A.anchorOffset, U = A.focusNode;
            A = A.focusOffset;
            try {
              x.nodeType, U.nodeType;
            } catch {
              x = null;
              break e;
            }
            var W = 0, Q = -1, ae = -1, ve = 0, Ie = 0, Fe = d, we = null;
            t: for (; ; ) {
              for (var Ce; Fe !== x || M !== 0 && Fe.nodeType !== 3 || (Q = W + M), Fe !== U || A !== 0 && Fe.nodeType !== 3 || (ae = W + A), Fe.nodeType === 3 && (W += Fe.nodeValue.length), (Ce = Fe.firstChild) !== null; ) we = Fe, Fe = Ce;
              for (; ; ) {
                if (Fe === d) break t;
                if (we === x && ++ve === M && (Q = W), we === U && ++Ie === A && (ae = W), (Ce = Fe.nextSibling) !== null) break;
                Fe = we, we = Fe.parentNode;
              }
              Fe = Ce;
            }
            x = Q === -1 || ae === -1 ? null : {
              start: Q,
              end: ae
            };
          } else x = null;
        }
        x = x || {
          start: 0,
          end: 0
        };
      } else x = null;
      for (E3 = {
        focusedElem: d,
        selectionRange: x
      }, l2 = false, jr = p; jr !== null; ) if (p = jr, d = p.child, (p.subtreeFlags & 1024) !== 0 && d !== null) d.return = p, jr = d;
      else for (; jr !== null; ) {
        switch (p = jr, U = p.alternate, d = p.flags, p.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            if ((d & 1024) !== 0 && U !== null) {
              d = void 0, x = p, M = U.memoizedProps, U = U.memoizedState, A = x.stateNode;
              try {
                var Vt = oc(x.type, M, x.elementType === x.type);
                d = A.getSnapshotBeforeUpdate(Vt, U), A.__reactInternalSnapshotBeforeUpdate = d;
              } catch (Et) {
                Bn(x, x.return, Et);
              }
            }
            break;
          case 3:
            if ((d & 1024) !== 0) {
              if (d = p.stateNode.containerInfo, x = d.nodeType, x === 9) M3(d);
              else if (x === 1) switch (d.nodeName) {
                case "HEAD":
                case "HTML":
                case "BODY":
                  M3(d);
                  break;
                default:
                  d.textContent = "";
              }
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if ((d & 1024) !== 0) throw Error(r(163));
        }
        if (d = p.sibling, d !== null) {
          d.return = p.return, jr = d;
          break;
        }
        jr = p.return;
      }
    }
    function o7(d, p, x) {
      var A = x.flags;
      switch (x.tag) {
        case 0:
        case 11:
        case 15:
          jo(d, x), A & 4 && kf(5, x);
          break;
        case 1:
          if (jo(d, x), A & 4) if (d = x.stateNode, p === null) try {
            d.componentDidMount();
          } catch (W) {
            Bn(x, x.return, W);
          }
          else {
            var M = oc(x.type, p.memoizedProps);
            p = p.memoizedState;
            try {
              d.componentDidUpdate(M, p, d.__reactInternalSnapshotBeforeUpdate);
            } catch (W) {
              Bn(x, x.return, W);
            }
          }
          A & 64 && t7(x), A & 512 && Pf(x, x.return);
          break;
        case 3:
          if (jo(d, x), A & 64 && (d = x.updateQueue, d !== null)) {
            if (p = null, x.child !== null) switch (x.child.tag) {
              case 27:
              case 5:
                p = x.child.stateNode;
                break;
              case 1:
                p = x.child.stateNode;
            }
            try {
              z9(d, p);
            } catch (W) {
              Bn(x, x.return, W);
            }
          }
          break;
        case 27:
          p === null && A & 4 && a7(x);
        case 26:
        case 5:
          jo(d, x), p === null && A & 4 && r7(x), A & 512 && Pf(x, x.return);
          break;
        case 12:
          jo(d, x);
          break;
        case 13:
          jo(d, x), A & 4 && u7(d, x), A & 64 && (d = x.memoizedState, d !== null && (d = d.dehydrated, d !== null && (x = BU.bind(null, x), tF(d, x))));
          break;
        case 22:
          if (A = x.memoizedState !== null || Qs, !A) {
            p = p !== null && p.memoizedState !== null || Cr, M = Qs;
            var U = Cr;
            Qs = A, (Cr = p) && !U ? Ko(d, x, (x.subtreeFlags & 8772) !== 0) : jo(d, x), Qs = M, Cr = U;
          }
          break;
        case 30:
          break;
        default:
          jo(d, x);
      }
    }
    function l7(d) {
      var p = d.alternate;
      p !== null && (d.alternate = null, l7(p)), d.child = null, d.deletions = null, d.sibling = null, d.tag === 5 && (p = d.stateNode, p !== null && Vo(p)), d.stateNode = null, d.return = null, d.dependencies = null, d.memoizedProps = null, d.memoizedState = null, d.pendingProps = null, d.stateNode = null, d.updateQueue = null;
    }
    var Zn = null, Ki = false;
    function Js(d, p, x) {
      for (x = x.child; x !== null; ) c7(d, p, x), x = x.sibling;
    }
    function c7(d, p, x) {
      if (ut && typeof ut.onCommitFiberUnmount == "function") try {
        ut.onCommitFiberUnmount(at, x);
      } catch {
      }
      switch (x.tag) {
        case 26:
          Cr || ys(x, p), Js(d, p, x), x.memoizedState ? x.memoizedState.count-- : x.stateNode && (x = x.stateNode, x.parentNode.removeChild(x));
          break;
        case 27:
          Cr || ys(x, p);
          var A = Zn, M = Ki;
          Jo(x.type) && (Zn = x.stateNode, Ki = false), Js(d, p, x), Xf(x.stateNode), Zn = A, Ki = M;
          break;
        case 5:
          Cr || ys(x, p);
        case 6:
          if (A = Zn, M = Ki, Zn = null, Js(d, p, x), Zn = A, Ki = M, Zn !== null) if (Ki) try {
            (Zn.nodeType === 9 ? Zn.body : Zn.nodeName === "HTML" ? Zn.ownerDocument.body : Zn).removeChild(x.stateNode);
          } catch (U) {
            Bn(x, p, U);
          }
          else try {
            Zn.removeChild(x.stateNode);
          } catch (U) {
            Bn(x, p, U);
          }
          break;
        case 18:
          Zn !== null && (Ki ? (d = Zn, Q7(d.nodeType === 9 ? d.body : d.nodeName === "HTML" ? d.ownerDocument.body : d, x.stateNode), r1(d)) : Q7(Zn, x.stateNode));
          break;
        case 4:
          A = Zn, M = Ki, Zn = x.stateNode.containerInfo, Ki = true, Js(d, p, x), Zn = A, Ki = M;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          Cr || Ho(2, x, p), Cr || Ho(4, x, p), Js(d, p, x);
          break;
        case 1:
          Cr || (ys(x, p), A = x.stateNode, typeof A.componentWillUnmount == "function" && n7(x, p, A)), Js(d, p, x);
          break;
        case 21:
          Js(d, p, x);
          break;
        case 22:
          Cr = (A = Cr) || x.memoizedState !== null, Js(d, p, x), Cr = A;
          break;
        default:
          Js(d, p, x);
      }
    }
    function u7(d, p) {
      if (p.memoizedState === null && (d = p.alternate, d !== null && (d = d.memoizedState, d !== null && (d = d.dehydrated, d !== null)))) try {
        r1(d);
      } catch (x) {
        Bn(p, p.return, x);
      }
    }
    function RU(d) {
      switch (d.tag) {
        case 13:
        case 19:
          var p = d.stateNode;
          return p === null && (p = d.stateNode = new s7()), p;
        case 22:
          return d = d.stateNode, p = d._retryCache, p === null && (p = d._retryCache = new s7()), p;
        default:
          throw Error(r(435, d.tag));
      }
    }
    function t3(d, p) {
      var x = RU(d);
      p.forEach(function(A) {
        var M = _U.bind(null, d, A);
        x.has(A) || (x.add(A), A.then(M, M));
      });
    }
    function la(d, p) {
      var x = p.deletions;
      if (x !== null) for (var A = 0; A < x.length; A++) {
        var M = x[A], U = d, W = p, Q = W;
        e: for (; Q !== null; ) {
          switch (Q.tag) {
            case 27:
              if (Jo(Q.type)) {
                Zn = Q.stateNode, Ki = false;
                break e;
              }
              break;
            case 5:
              Zn = Q.stateNode, Ki = false;
              break e;
            case 3:
            case 4:
              Zn = Q.stateNode.containerInfo, Ki = true;
              break e;
          }
          Q = Q.return;
        }
        if (Zn === null) throw Error(r(160));
        c7(U, W, M), Zn = null, Ki = false, U = M.alternate, U !== null && (U.return = null), M.return = null;
      }
      if (p.subtreeFlags & 13878) for (p = p.child; p !== null; ) f7(p, d), p = p.sibling;
    }
    var Ka = null;
    function f7(d, p) {
      var x = d.alternate, A = d.flags;
      switch (d.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          la(p, d), ca(d), A & 4 && (Ho(3, d, d.return), kf(3, d), Ho(5, d, d.return));
          break;
        case 1:
          la(p, d), ca(d), A & 512 && (Cr || x === null || ys(x, x.return)), A & 64 && Qs && (d = d.updateQueue, d !== null && (A = d.callbacks, A !== null && (x = d.shared.hiddenCallbacks, d.shared.hiddenCallbacks = x === null ? A : x.concat(A))));
          break;
        case 26:
          var M = Ka;
          if (la(p, d), ca(d), A & 512 && (Cr || x === null || ys(x, x.return)), A & 4) {
            var U = x !== null ? x.memoizedState : null;
            if (A = d.memoizedState, x === null) if (A === null) if (d.stateNode === null) {
              e: {
                A = d.type, x = d.memoizedProps, M = M.ownerDocument || M;
                t: switch (A) {
                  case "title":
                    U = M.getElementsByTagName("title")[0], (!U || U[wa] || U[yr] || U.namespaceURI === "http://www.w3.org/2000/svg" || U.hasAttribute("itemprop")) && (U = M.createElement(A), M.head.insertBefore(U, M.querySelector("head > title"))), ai(U, A, x), U[yr] = d, cr(U), A = U;
                    break e;
                  case "link":
                    var W = aw("link", "href", M).get(A + (x.href || ""));
                    if (W) {
                      for (var Q = 0; Q < W.length; Q++) if (U = W[Q], U.getAttribute("href") === (x.href == null || x.href === "" ? null : x.href) && U.getAttribute("rel") === (x.rel == null ? null : x.rel) && U.getAttribute("title") === (x.title == null ? null : x.title) && U.getAttribute("crossorigin") === (x.crossOrigin == null ? null : x.crossOrigin)) {
                        W.splice(Q, 1);
                        break t;
                      }
                    }
                    U = M.createElement(A), ai(U, A, x), M.head.appendChild(U);
                    break;
                  case "meta":
                    if (W = aw("meta", "content", M).get(A + (x.content || ""))) {
                      for (Q = 0; Q < W.length; Q++) if (U = W[Q], U.getAttribute("content") === (x.content == null ? null : "" + x.content) && U.getAttribute("name") === (x.name == null ? null : x.name) && U.getAttribute("property") === (x.property == null ? null : x.property) && U.getAttribute("http-equiv") === (x.httpEquiv == null ? null : x.httpEquiv) && U.getAttribute("charset") === (x.charSet == null ? null : x.charSet)) {
                        W.splice(Q, 1);
                        break t;
                      }
                    }
                    U = M.createElement(A), ai(U, A, x), M.head.appendChild(U);
                    break;
                  default:
                    throw Error(r(468, A));
                }
                U[yr] = d, cr(U), A = U;
              }
              d.stateNode = A;
            } else sw(M, d.type, d.stateNode);
            else d.stateNode = iw(M, A, d.memoizedProps);
            else U !== A ? (U === null ? x.stateNode !== null && (x = x.stateNode, x.parentNode.removeChild(x)) : U.count--, A === null ? sw(M, d.type, d.stateNode) : iw(M, A, d.memoizedProps)) : A === null && d.stateNode !== null && Qm(d, d.memoizedProps, x.memoizedProps);
          }
          break;
        case 27:
          la(p, d), ca(d), A & 512 && (Cr || x === null || ys(x, x.return)), x !== null && A & 4 && Qm(d, d.memoizedProps, x.memoizedProps);
          break;
        case 5:
          if (la(p, d), ca(d), A & 512 && (Cr || x === null || ys(x, x.return)), d.flags & 32) {
            M = d.stateNode;
            try {
              q(M, "");
            } catch (Ce) {
              Bn(d, d.return, Ce);
            }
          }
          A & 4 && d.stateNode != null && (M = d.memoizedProps, Qm(d, M, x !== null ? x.memoizedProps : M)), A & 1024 && (e3 = true);
          break;
        case 6:
          if (la(p, d), ca(d), A & 4) {
            if (d.stateNode === null) throw Error(r(162));
            A = d.memoizedProps, x = d.stateNode;
            try {
              x.nodeValue = A;
            } catch (Ce) {
              Bn(d, d.return, Ce);
            }
          }
          break;
        case 3:
          if (a2 = null, M = Ka, Ka = r2(p.containerInfo), la(p, d), Ka = M, ca(d), A & 4 && x !== null && x.memoizedState.isDehydrated) try {
            r1(p.containerInfo);
          } catch (Ce) {
            Bn(d, d.return, Ce);
          }
          e3 && (e3 = false, h7(d));
          break;
        case 4:
          A = Ka, Ka = r2(d.stateNode.containerInfo), la(p, d), ca(d), Ka = A;
          break;
        case 12:
          la(p, d), ca(d);
          break;
        case 13:
          la(p, d), ca(d), d.child.flags & 8192 && d.memoizedState !== null != (x !== null && x.memoizedState !== null) && (o3 = re()), A & 4 && (A = d.updateQueue, A !== null && (d.updateQueue = null, t3(d, A)));
          break;
        case 22:
          M = d.memoizedState !== null;
          var ae = x !== null && x.memoizedState !== null, ve = Qs, Ie = Cr;
          if (Qs = ve || M, Cr = Ie || ae, la(p, d), Cr = Ie, Qs = ve, ca(d), A & 8192) e: for (p = d.stateNode, p._visibility = M ? p._visibility & -2 : p._visibility | 1, M && (x === null || ae || Qs || Cr || lc(d)), x = null, p = d; ; ) {
            if (p.tag === 5 || p.tag === 26) {
              if (x === null) {
                ae = x = p;
                try {
                  if (U = ae.stateNode, M) W = U.style, typeof W.setProperty == "function" ? W.setProperty("display", "none", "important") : W.display = "none";
                  else {
                    Q = ae.stateNode;
                    var Fe = ae.memoizedProps.style, we = Fe != null && Fe.hasOwnProperty("display") ? Fe.display : null;
                    Q.style.display = we == null || typeof we == "boolean" ? "" : ("" + we).trim();
                  }
                } catch (Ce) {
                  Bn(ae, ae.return, Ce);
                }
              }
            } else if (p.tag === 6) {
              if (x === null) {
                ae = p;
                try {
                  ae.stateNode.nodeValue = M ? "" : ae.memoizedProps;
                } catch (Ce) {
                  Bn(ae, ae.return, Ce);
                }
              }
            } else if ((p.tag !== 22 && p.tag !== 23 || p.memoizedState === null || p === d) && p.child !== null) {
              p.child.return = p, p = p.child;
              continue;
            }
            if (p === d) break e;
            for (; p.sibling === null; ) {
              if (p.return === null || p.return === d) break e;
              x === p && (x = null), p = p.return;
            }
            x === p && (x = null), p.sibling.return = p.return, p = p.sibling;
          }
          A & 4 && (A = d.updateQueue, A !== null && (x = A.retryQueue, x !== null && (A.retryQueue = null, t3(d, x))));
          break;
        case 19:
          la(p, d), ca(d), A & 4 && (A = d.updateQueue, A !== null && (d.updateQueue = null, t3(d, A)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          la(p, d), ca(d);
      }
    }
    function ca(d) {
      var p = d.flags;
      if (p & 2) {
        try {
          for (var x, A = d.return; A !== null; ) {
            if (i7(A)) {
              x = A;
              break;
            }
            A = A.return;
          }
          if (x == null) throw Error(r(160));
          switch (x.tag) {
            case 27:
              var M = x.stateNode, U = Jm(d);
              Hd(d, U, M);
              break;
            case 5:
              var W = x.stateNode;
              x.flags & 32 && (q(W, ""), x.flags &= -33);
              var Q = Jm(d);
              Hd(d, Q, W);
              break;
            case 3:
            case 4:
              var ae = x.stateNode.containerInfo, ve = Jm(d);
              $m(d, ve, ae);
              break;
            default:
              throw Error(r(161));
          }
        } catch (Ie) {
          Bn(d, d.return, Ie);
        }
        d.flags &= -3;
      }
      p & 4096 && (d.flags &= -4097);
    }
    function h7(d) {
      if (d.subtreeFlags & 1024) for (d = d.child; d !== null; ) {
        var p = d;
        h7(p), p.tag === 5 && p.flags & 1024 && p.stateNode.reset(), d = d.sibling;
      }
    }
    function jo(d, p) {
      if (p.subtreeFlags & 8772) for (p = p.child; p !== null; ) o7(d, p.alternate, p), p = p.sibling;
    }
    function lc(d) {
      for (d = d.child; d !== null; ) {
        var p = d;
        switch (p.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Ho(4, p, p.return), lc(p);
            break;
          case 1:
            ys(p, p.return);
            var x = p.stateNode;
            typeof x.componentWillUnmount == "function" && n7(p, p.return, x), lc(p);
            break;
          case 27:
            Xf(p.stateNode);
          case 26:
          case 5:
            ys(p, p.return), lc(p);
            break;
          case 22:
            p.memoizedState === null && lc(p);
            break;
          case 30:
            lc(p);
            break;
          default:
            lc(p);
        }
        d = d.sibling;
      }
    }
    function Ko(d, p, x) {
      for (x = x && (p.subtreeFlags & 8772) !== 0, p = p.child; p !== null; ) {
        var A = p.alternate, M = d, U = p, W = U.flags;
        switch (U.tag) {
          case 0:
          case 11:
          case 15:
            Ko(M, U, x), kf(4, U);
            break;
          case 1:
            if (Ko(M, U, x), A = U, M = A.stateNode, typeof M.componentDidMount == "function") try {
              M.componentDidMount();
            } catch (ve) {
              Bn(A, A.return, ve);
            }
            if (A = U, M = A.updateQueue, M !== null) {
              var Q = A.stateNode;
              try {
                var ae = M.shared.hiddenCallbacks;
                if (ae !== null) for (M.shared.hiddenCallbacks = null, M = 0; M < ae.length; M++) G9(ae[M], Q);
              } catch (ve) {
                Bn(A, A.return, ve);
              }
            }
            x && W & 64 && t7(U), Pf(U, U.return);
            break;
          case 27:
            a7(U);
          case 26:
          case 5:
            Ko(M, U, x), x && A === null && W & 4 && r7(U), Pf(U, U.return);
            break;
          case 12:
            Ko(M, U, x);
            break;
          case 13:
            Ko(M, U, x), x && W & 4 && u7(M, U);
            break;
          case 22:
            U.memoizedState === null && Ko(M, U, x), Pf(U, U.return);
            break;
          case 30:
            break;
          default:
            Ko(M, U, x);
        }
        p = p.sibling;
      }
    }
    function n3(d, p) {
      var x = null;
      d !== null && d.memoizedState !== null && d.memoizedState.cachePool !== null && (x = d.memoizedState.cachePool.pool), d = null, p.memoizedState !== null && p.memoizedState.cachePool !== null && (d = p.memoizedState.cachePool.pool), d !== x && (d != null && d.refCount++, x != null && Ef(x));
    }
    function r3(d, p) {
      d = null, p.alternate !== null && (d = p.alternate.memoizedState.cache), p = p.memoizedState.cache, p !== d && (p.refCount++, d != null && Ef(d));
    }
    function xs(d, p, x, A) {
      if (p.subtreeFlags & 10256) for (p = p.child; p !== null; ) d7(d, p, x, A), p = p.sibling;
    }
    function d7(d, p, x, A) {
      var M = p.flags;
      switch (p.tag) {
        case 0:
        case 11:
        case 15:
          xs(d, p, x, A), M & 2048 && kf(9, p);
          break;
        case 1:
          xs(d, p, x, A);
          break;
        case 3:
          xs(d, p, x, A), M & 2048 && (d = null, p.alternate !== null && (d = p.alternate.memoizedState.cache), p = p.memoizedState.cache, p !== d && (p.refCount++, d != null && Ef(d)));
          break;
        case 12:
          if (M & 2048) {
            xs(d, p, x, A), d = p.stateNode;
            try {
              var U = p.memoizedProps, W = U.id, Q = U.onPostCommit;
              typeof Q == "function" && Q(W, p.alternate === null ? "mount" : "update", d.passiveEffectDuration, -0);
            } catch (ae) {
              Bn(p, p.return, ae);
            }
          } else xs(d, p, x, A);
          break;
        case 13:
          xs(d, p, x, A);
          break;
        case 23:
          break;
        case 22:
          U = p.stateNode, W = p.alternate, p.memoizedState !== null ? U._visibility & 2 ? xs(d, p, x, A) : Gf(d, p) : U._visibility & 2 ? xs(d, p, x, A) : (U._visibility |= 2, I0(d, p, x, A, (p.subtreeFlags & 10256) !== 0)), M & 2048 && n3(W, p);
          break;
        case 24:
          xs(d, p, x, A), M & 2048 && r3(p.alternate, p);
          break;
        default:
          xs(d, p, x, A);
      }
    }
    function I0(d, p, x, A, M) {
      for (M = M && (p.subtreeFlags & 10256) !== 0, p = p.child; p !== null; ) {
        var U = d, W = p, Q = x, ae = A, ve = W.flags;
        switch (W.tag) {
          case 0:
          case 11:
          case 15:
            I0(U, W, Q, ae, M), kf(8, W);
            break;
          case 23:
            break;
          case 22:
            var Ie = W.stateNode;
            W.memoizedState !== null ? Ie._visibility & 2 ? I0(U, W, Q, ae, M) : Gf(U, W) : (Ie._visibility |= 2, I0(U, W, Q, ae, M)), M && ve & 2048 && n3(W.alternate, W);
            break;
          case 24:
            I0(U, W, Q, ae, M), M && ve & 2048 && r3(W.alternate, W);
            break;
          default:
            I0(U, W, Q, ae, M);
        }
        p = p.sibling;
      }
    }
    function Gf(d, p) {
      if (p.subtreeFlags & 10256) for (p = p.child; p !== null; ) {
        var x = d, A = p, M = A.flags;
        switch (A.tag) {
          case 22:
            Gf(x, A), M & 2048 && n3(A.alternate, A);
            break;
          case 24:
            Gf(x, A), M & 2048 && r3(A.alternate, A);
            break;
          default:
            Gf(x, A);
        }
        p = p.sibling;
      }
    }
    var zf = 8192;
    function V0(d) {
      if (d.subtreeFlags & zf) for (d = d.child; d !== null; ) g7(d), d = d.sibling;
    }
    function g7(d) {
      switch (d.tag) {
        case 26:
          V0(d), d.flags & zf && d.memoizedState !== null && gF(Ka, d.memoizedState, d.memoizedProps);
          break;
        case 5:
          V0(d);
          break;
        case 3:
        case 4:
          var p = Ka;
          Ka = r2(d.stateNode.containerInfo), V0(d), Ka = p;
          break;
        case 22:
          d.memoizedState === null && (p = d.alternate, p !== null && p.memoizedState !== null ? (p = zf, zf = 16777216, V0(d), zf = p) : V0(d));
          break;
        default:
          V0(d);
      }
    }
    function p7(d) {
      var p = d.alternate;
      if (p !== null && (d = p.child, d !== null)) {
        p.child = null;
        do
          p = d.sibling, d.sibling = null, d = p;
        while (d !== null);
      }
    }
    function Wf(d) {
      var p = d.deletions;
      if ((d.flags & 16) !== 0) {
        if (p !== null) for (var x = 0; x < p.length; x++) {
          var A = p[x];
          jr = A, v7(A, d);
        }
        p7(d);
      }
      if (d.subtreeFlags & 10256) for (d = d.child; d !== null; ) m7(d), d = d.sibling;
    }
    function m7(d) {
      switch (d.tag) {
        case 0:
        case 11:
        case 15:
          Wf(d), d.flags & 2048 && Ho(9, d, d.return);
          break;
        case 3:
          Wf(d);
          break;
        case 12:
          Wf(d);
          break;
        case 22:
          var p = d.stateNode;
          d.memoizedState !== null && p._visibility & 2 && (d.return === null || d.return.tag !== 13) ? (p._visibility &= -3, jd(d)) : Wf(d);
          break;
        default:
          Wf(d);
      }
    }
    function jd(d) {
      var p = d.deletions;
      if ((d.flags & 16) !== 0) {
        if (p !== null) for (var x = 0; x < p.length; x++) {
          var A = p[x];
          jr = A, v7(A, d);
        }
        p7(d);
      }
      for (d = d.child; d !== null; ) {
        switch (p = d, p.tag) {
          case 0:
          case 11:
          case 15:
            Ho(8, p, p.return), jd(p);
            break;
          case 22:
            x = p.stateNode, x._visibility & 2 && (x._visibility &= -3, jd(p));
            break;
          default:
            jd(p);
        }
        d = d.sibling;
      }
    }
    function v7(d, p) {
      for (; jr !== null; ) {
        var x = jr;
        switch (x.tag) {
          case 0:
          case 11:
          case 15:
            Ho(8, x, p);
            break;
          case 23:
          case 22:
            if (x.memoizedState !== null && x.memoizedState.cachePool !== null) {
              var A = x.memoizedState.cachePool.pool;
              A != null && A.refCount++;
            }
            break;
          case 24:
            Ef(x.memoizedState.cache);
        }
        if (A = x.child, A !== null) A.return = x, jr = A;
        else e: for (x = d; jr !== null; ) {
          A = jr;
          var M = A.sibling, U = A.return;
          if (l7(A), A === x) {
            jr = null;
            break e;
          }
          if (M !== null) {
            M.return = U, jr = M;
            break e;
          }
          jr = U;
        }
      }
    }
    var OU = {
      getCacheForType: function(d) {
        var p = xi(Br), x = p.data.get(d);
        return x === void 0 && (x = d(), p.data.set(d, x)), x;
      }
    }, IU = typeof WeakMap == "function" ? WeakMap : Map, On = 0, kn = null, ln = null, Cn = 0, In = 0, ua = null, Yo = false, N0 = false, i3 = false, $s = 0, fr = 0, qo = 0, cc = 0, a3 = 0, Ma = 0, L0 = 0, Hf = null, Yi = null, s3 = false, o3 = 0, Kd = 1 / 0, Yd = null, Xo = null, ii = 0, Zo = null, U0 = null, F0 = 0, l3 = 0, c3 = null, y7 = null, jf = 0, u3 = null;
    function fa() {
      if ((On & 2) !== 0 && Cn !== 0) return Cn & -Cn;
      if (_.T !== null) {
        var d = S0;
        return d !== 0 ? d : v3();
      }
      return Oo();
    }
    function x7() {
      Ma === 0 && (Ma = (Cn & 536870912) === 0 || An ? sn() : 536870912);
      var d = Da.current;
      return d !== null && (d.flags |= 32), Ma;
    }
    function ha(d, p, x) {
      (d === kn && (In === 2 || In === 9) || d.cancelPendingCommit !== null) && (B0(d, 0), Qo(d, Cn, Ma, false)), vn(d, x), ((On & 2) === 0 || d !== kn) && (d === kn && ((On & 2) === 0 && (cc |= x), fr === 4 && Qo(d, Cn, Ma, false)), ws(d));
    }
    function w7(d, p, x) {
      if ((On & 6) !== 0) throw Error(r(327));
      var A = !x && (p & 124) === 0 && (p & d.expiredLanes) === 0 || ke(d, p), M = A ? LU(d, p) : d3(d, p, true), U = A;
      do {
        if (M === 0) {
          N0 && !A && Qo(d, p, 0, false);
          break;
        } else {
          if (x = d.current.alternate, U && !VU(x)) {
            M = d3(d, p, false), U = false;
            continue;
          }
          if (M === 2) {
            if (U = p, d.errorRecoveryDisabledLanes & U) var W = 0;
            else W = d.pendingLanes & -536870913, W = W !== 0 ? W : W & 536870912 ? 536870912 : 0;
            if (W !== 0) {
              p = W;
              e: {
                var Q = d;
                M = Hf;
                var ae = Q.current.memoizedState.isDehydrated;
                if (ae && (B0(Q, W).flags |= 256), W = d3(Q, W, false), W !== 2) {
                  if (i3 && !ae) {
                    Q.errorRecoveryDisabledLanes |= U, cc |= U, M = 4;
                    break e;
                  }
                  U = Yi, Yi = M, U !== null && (Yi === null ? Yi = U : Yi.push.apply(Yi, U));
                }
                M = W;
              }
              if (U = false, M !== 2) continue;
            }
          }
          if (M === 1) {
            B0(d, 0), Qo(d, p, 0, true);
            break;
          }
          e: {
            switch (A = d, U = M, U) {
              case 0:
              case 1:
                throw Error(r(345));
              case 4:
                if ((p & 4194048) !== p) break;
              case 6:
                Qo(A, p, Ma, !Yo);
                break e;
              case 2:
                Yi = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(r(329));
            }
            if ((p & 62914560) === p && (M = o3 + 300 - re(), 10 < M)) {
              if (Qo(A, p, Ma, !Yo), ye(A, 0, true) !== 0) break e;
              A.timeoutHandle = X7(C7.bind(null, A, x, Yi, Yd, s3, p, Ma, cc, L0, Yo, U, 2, -0, 0), M);
              break e;
            }
            C7(A, x, Yi, Yd, s3, p, Ma, cc, L0, Yo, U, 0, -0, 0);
          }
        }
        break;
      } while (true);
      ws(d);
    }
    function C7(d, p, x, A, M, U, W, Q, ae, ve, Ie, Fe, we, Ce) {
      if (d.timeoutHandle = -1, Fe = p.subtreeFlags, (Fe & 8192 || (Fe & 16785408) === 16785408) && (Jf = {
        stylesheets: null,
        count: 0,
        unsuspend: dF
      }, g7(p), Fe = pF(), Fe !== null)) {
        d.cancelPendingCommit = Fe(M7.bind(null, d, p, U, x, A, M, W, Q, ae, Ie, 1, we, Ce)), Qo(d, U, W, !ve);
        return;
      }
      M7(d, p, U, x, A, M, W, Q, ae);
    }
    function VU(d) {
      for (var p = d; ; ) {
        var x = p.tag;
        if ((x === 0 || x === 11 || x === 15) && p.flags & 16384 && (x = p.updateQueue, x !== null && (x = x.stores, x !== null))) for (var A = 0; A < x.length; A++) {
          var M = x[A], U = M.getSnapshot;
          M = M.value;
          try {
            if (!sa(U(), M)) return false;
          } catch {
            return false;
          }
        }
        if (x = p.child, p.subtreeFlags & 16384 && x !== null) x.return = p, p = x;
        else {
          if (p === d) break;
          for (; p.sibling === null; ) {
            if (p.return === null || p.return === d) return true;
            p = p.return;
          }
          p.sibling.return = p.return, p = p.sibling;
        }
      }
      return true;
    }
    function Qo(d, p, x, A) {
      p &= ~a3, p &= ~cc, d.suspendedLanes |= p, d.pingedLanes &= ~p, A && (d.warmLanes |= p), A = d.expirationTimes;
      for (var M = p; 0 < M; ) {
        var U = 31 - fn(M), W = 1 << U;
        A[U] = -1, M &= ~W;
      }
      x !== 0 && Mo(d, x, p);
    }
    function qd() {
      return (On & 6) === 0 ? (Kf(0), false) : true;
    }
    function f3() {
      if (ln !== null) {
        if (In === 0) var d = ln.return;
        else d = ln, js = rc = null, Mm(d), R0 = null, Ff = 0, d = ln;
        for (; d !== null; ) e7(d.alternate, d), d = d.return;
        ln = null;
      }
    }
    function B0(d, p) {
      var x = d.timeoutHandle;
      x !== -1 && (d.timeoutHandle = -1, ZU(x)), x = d.cancelPendingCommit, x !== null && (d.cancelPendingCommit = null, x()), f3(), kn = d, ln = x = zs(d.current, null), Cn = p, In = 0, ua = null, Yo = false, N0 = ke(d, p), i3 = false, L0 = Ma = a3 = cc = qo = fr = 0, Yi = Hf = null, s3 = false, (p & 8) !== 0 && (p |= p & 32);
      var A = d.entangledLanes;
      if (A !== 0) for (d = d.entanglements, A &= p; 0 < A; ) {
        var M = 31 - fn(A), U = 1 << M;
        p |= d[M], A &= ~U;
      }
      return $s = p, md(), x;
    }
    function T7(d, p) {
      rn = null, _.H = Ud, p === Df || p === Ed ? (p = k9(), In = 3) : p === F9 ? (p = k9(), In = 4) : In = p === Px ? 8 : p !== null && typeof p == "object" && typeof p.then == "function" ? 6 : 1, ua = p, ln === null && (fr = 1, Pd(d, Sa(p, d.current)));
    }
    function S7() {
      var d = _.H;
      return _.H = Ud, d === null ? Ud : d;
    }
    function A7() {
      var d = _.A;
      return _.A = OU, d;
    }
    function h3() {
      fr = 4, Yo || (Cn & 4194048) !== Cn && Da.current !== null || (N0 = true), (qo & 134217727) === 0 && (cc & 134217727) === 0 || kn === null || Qo(kn, Cn, Ma, false);
    }
    function d3(d, p, x) {
      var A = On;
      On |= 2;
      var M = S7(), U = A7();
      (kn !== d || Cn !== p) && (Yd = null, B0(d, p)), p = false;
      var W = fr;
      e: do
        try {
          if (In !== 0 && ln !== null) {
            var Q = ln, ae = ua;
            switch (In) {
              case 8:
                f3(), W = 6;
                break e;
              case 3:
              case 2:
              case 9:
              case 6:
                Da.current === null && (p = true);
                var ve = In;
                if (In = 0, ua = null, _0(d, Q, ae, ve), x && N0) {
                  W = 0;
                  break e;
                }
                break;
              default:
                ve = In, In = 0, ua = null, _0(d, Q, ae, ve);
            }
          }
          NU(), W = fr;
          break;
        } catch (Ie) {
          T7(d, Ie);
        }
      while (true);
      return p && d.shellSuspendCounter++, js = rc = null, On = A, _.H = M, _.A = U, ln === null && (kn = null, Cn = 0, md()), W;
    }
    function NU() {
      for (; ln !== null; ) E7(ln);
    }
    function LU(d, p) {
      var x = On;
      On |= 2;
      var A = S7(), M = A7();
      kn !== d || Cn !== p ? (Yd = null, Kd = re() + 500, B0(d, p)) : N0 = ke(d, p);
      e: do
        try {
          if (In !== 0 && ln !== null) {
            p = ln;
            var U = ua;
            t: switch (In) {
              case 1:
                In = 0, ua = null, _0(d, p, U, 1);
                break;
              case 2:
              case 9:
                if (B9(U)) {
                  In = 0, ua = null, b7(p);
                  break;
                }
                p = function() {
                  In !== 2 && In !== 9 || kn !== d || (In = 7), ws(d);
                }, U.then(p, p);
                break e;
              case 3:
                In = 7;
                break e;
              case 4:
                In = 5;
                break e;
              case 7:
                B9(U) ? (In = 0, ua = null, b7(p)) : (In = 0, ua = null, _0(d, p, U, 7));
                break;
              case 5:
                var W = null;
                switch (ln.tag) {
                  case 26:
                    W = ln.memoizedState;
                  case 5:
                  case 27:
                    var Q = ln;
                    if (!W || ow(W)) {
                      In = 0, ua = null;
                      var ae = Q.sibling;
                      if (ae !== null) ln = ae;
                      else {
                        var ve = Q.return;
                        ve !== null ? (ln = ve, Xd(ve)) : ln = null;
                      }
                      break t;
                    }
                }
                In = 0, ua = null, _0(d, p, U, 5);
                break;
              case 6:
                In = 0, ua = null, _0(d, p, U, 6);
                break;
              case 8:
                f3(), fr = 6;
                break e;
              default:
                throw Error(r(462));
            }
          }
          UU();
          break;
        } catch (Ie) {
          T7(d, Ie);
        }
      while (true);
      return js = rc = null, _.H = A, _.A = M, On = x, ln !== null ? 0 : (kn = null, Cn = 0, md(), fr);
    }
    function UU() {
      for (; ln !== null && !Se(); ) E7(ln);
    }
    function E7(d) {
      var p = Jx(d.alternate, d, $s);
      d.memoizedProps = d.pendingProps, p === null ? Xd(d) : ln = p;
    }
    function b7(d) {
      var p = d, x = p.alternate;
      switch (p.tag) {
        case 15:
        case 0:
          p = Kx(x, p, p.pendingProps, p.type, void 0, Cn);
          break;
        case 11:
          p = Kx(x, p, p.pendingProps, p.type.render, p.ref, Cn);
          break;
        case 5:
          Mm(p);
        default:
          e7(x, p), p = ln = D9(p, $s), p = Jx(x, p, $s);
      }
      d.memoizedProps = d.pendingProps, p === null ? Xd(d) : ln = p;
    }
    function _0(d, p, x, A) {
      js = rc = null, Mm(p), R0 = null, Ff = 0;
      var M = p.return;
      try {
        if (AU(d, M, p, x, Cn)) {
          fr = 1, Pd(d, Sa(x, d.current)), ln = null;
          return;
        }
      } catch (U) {
        if (M !== null) throw ln = M, U;
        fr = 1, Pd(d, Sa(x, d.current)), ln = null;
        return;
      }
      p.flags & 32768 ? (An || A === 1 ? d = true : N0 || (Cn & 536870912) !== 0 ? d = false : (Yo = d = true, (A === 2 || A === 9 || A === 3 || A === 6) && (A = Da.current, A !== null && A.tag === 13 && (A.flags |= 16384))), D7(p, d)) : Xd(p);
    }
    function Xd(d) {
      var p = d;
      do {
        if ((p.flags & 32768) !== 0) {
          D7(p, Yo);
          return;
        }
        d = p.return;
        var x = bU(p.alternate, p, $s);
        if (x !== null) {
          ln = x;
          return;
        }
        if (p = p.sibling, p !== null) {
          ln = p;
          return;
        }
        ln = p = d;
      } while (p !== null);
      fr === 0 && (fr = 5);
    }
    function D7(d, p) {
      do {
        var x = DU(d.alternate, d);
        if (x !== null) {
          x.flags &= 32767, ln = x;
          return;
        }
        if (x = d.return, x !== null && (x.flags |= 32768, x.subtreeFlags = 0, x.deletions = null), !p && (d = d.sibling, d !== null)) {
          ln = d;
          return;
        }
        ln = d = x;
      } while (d !== null);
      fr = 6, ln = null;
    }
    function M7(d, p, x, A, M, U, W, Q, ae) {
      d.cancelPendingCommit = null;
      do
        Zd();
      while (ii !== 0);
      if ((On & 6) !== 0) throw Error(r(327));
      if (p !== null) {
        if (p === d.current) throw Error(r(177));
        if (U = p.lanes | p.childLanes, U |= rm, xa(d, x, U, W, Q, ae), d === kn && (ln = kn = null, Cn = 0), U0 = p, Zo = d, F0 = x, l3 = U, c3 = M, y7 = A, (p.subtreeFlags & 10256) !== 0 || (p.flags & 10256) !== 0 ? (d.callbackNode = null, d.callbackPriority = 0, kU(Ve, function() {
          return N7(), null;
        })) : (d.callbackNode = null, d.callbackPriority = 0), A = (p.flags & 13878) !== 0, (p.subtreeFlags & 13878) !== 0 || A) {
          A = _.T, _.T = null, M = K.p, K.p = 2, W = On, On |= 4;
          try {
            MU(d, p, x);
          } finally {
            On = W, K.p = M, _.T = A;
          }
        }
        ii = 1, R7(), O7(), I7();
      }
    }
    function R7() {
      if (ii === 1) {
        ii = 0;
        var d = Zo, p = U0, x = (p.flags & 13878) !== 0;
        if ((p.subtreeFlags & 13878) !== 0 || x) {
          x = _.T, _.T = null;
          var A = K.p;
          K.p = 2;
          var M = On;
          On |= 4;
          try {
            f7(p, d);
            var U = E3, W = v9(d.containerInfo), Q = U.focusedElem, ae = U.selectionRange;
            if (W !== Q && Q && Q.ownerDocument && m9(Q.ownerDocument.documentElement, Q)) {
              if (ae !== null && J5(Q)) {
                var ve = ae.start, Ie = ae.end;
                if (Ie === void 0 && (Ie = ve), "selectionStart" in Q) Q.selectionStart = ve, Q.selectionEnd = Math.min(Ie, Q.value.length);
                else {
                  var Fe = Q.ownerDocument || document, we = Fe && Fe.defaultView || window;
                  if (we.getSelection) {
                    var Ce = we.getSelection(), Vt = Q.textContent.length, Et = Math.min(ae.start, Vt), Fn = ae.end === void 0 ? Et : Math.min(ae.end, Vt);
                    !Ce.extend && Et > Fn && (W = Fn, Fn = Et, Et = W);
                    var fe = p9(Q, Et), le = p9(Q, Fn);
                    if (fe && le && (Ce.rangeCount !== 1 || Ce.anchorNode !== fe.node || Ce.anchorOffset !== fe.offset || Ce.focusNode !== le.node || Ce.focusOffset !== le.offset)) {
                      var pe = Fe.createRange();
                      pe.setStart(fe.node, fe.offset), Ce.removeAllRanges(), Et > Fn ? (Ce.addRange(pe), Ce.extend(le.node, le.offset)) : (pe.setEnd(le.node, le.offset), Ce.addRange(pe));
                    }
                  }
                }
              }
              for (Fe = [], Ce = Q; Ce = Ce.parentNode; ) Ce.nodeType === 1 && Fe.push({
                element: Ce,
                left: Ce.scrollLeft,
                top: Ce.scrollTop
              });
              for (typeof Q.focus == "function" && Q.focus(), Q = 0; Q < Fe.length; Q++) {
                var Ne = Fe[Q];
                Ne.element.scrollLeft = Ne.left, Ne.element.scrollTop = Ne.top;
              }
            }
            l2 = !!A3, E3 = A3 = null;
          } finally {
            On = M, K.p = A, _.T = x;
          }
        }
        d.current = p, ii = 2;
      }
    }
    function O7() {
      if (ii === 2) {
        ii = 0;
        var d = Zo, p = U0, x = (p.flags & 8772) !== 0;
        if ((p.subtreeFlags & 8772) !== 0 || x) {
          x = _.T, _.T = null;
          var A = K.p;
          K.p = 2;
          var M = On;
          On |= 4;
          try {
            o7(d, p.alternate, p);
          } finally {
            On = M, K.p = A, _.T = x;
          }
        }
        ii = 3;
      }
    }
    function I7() {
      if (ii === 4 || ii === 3) {
        ii = 0, xe();
        var d = Zo, p = U0, x = F0, A = y7;
        (p.subtreeFlags & 10256) !== 0 || (p.flags & 10256) !== 0 ? ii = 5 : (ii = 0, U0 = Zo = null, V7(d, d.pendingLanes));
        var M = d.pendingLanes;
        if (M === 0 && (Xo = null), Ro(x), p = p.stateNode, ut && typeof ut.onCommitFiberRoot == "function") try {
          ut.onCommitFiberRoot(at, p, void 0, (p.current.flags & 128) === 128);
        } catch {
        }
        if (A !== null) {
          p = _.T, M = K.p, K.p = 2, _.T = null;
          try {
            for (var U = d.onRecoverableError, W = 0; W < A.length; W++) {
              var Q = A[W];
              U(Q.value, {
                componentStack: Q.stack
              });
            }
          } finally {
            _.T = p, K.p = M;
          }
        }
        (F0 & 3) !== 0 && Zd(), ws(d), M = d.pendingLanes, (x & 4194090) !== 0 && (M & 42) !== 0 ? d === u3 ? jf++ : (jf = 0, u3 = d) : jf = 0, Kf(0);
      }
    }
    function V7(d, p) {
      (d.pooledCacheLanes &= p) === 0 && (p = d.pooledCache, p != null && (d.pooledCache = null, Ef(p)));
    }
    function Zd(d) {
      return R7(), O7(), I7(), N7();
    }
    function N7() {
      if (ii !== 5) return false;
      var d = Zo, p = l3;
      l3 = 0;
      var x = Ro(F0), A = _.T, M = K.p;
      try {
        K.p = 32 > x ? 32 : x, _.T = null, x = c3, c3 = null;
        var U = Zo, W = F0;
        if (ii = 0, U0 = Zo = null, F0 = 0, (On & 6) !== 0) throw Error(r(331));
        var Q = On;
        if (On |= 4, m7(U.current), d7(U, U.current, W, x), On = Q, Kf(0, false), ut && typeof ut.onPostCommitFiberRoot == "function") try {
          ut.onPostCommitFiberRoot(at, U);
        } catch {
        }
        return true;
      } finally {
        K.p = M, _.T = A, V7(d, p);
      }
    }
    function L7(d, p, x) {
      p = Sa(x, p), p = zm(d.stateNode, p, 2), d = Po(d, p, 2), d !== null && (vn(d, 2), ws(d));
    }
    function Bn(d, p, x) {
      if (d.tag === 3) L7(d, d, x);
      else for (; p !== null; ) {
        if (p.tag === 3) {
          L7(p, d, x);
          break;
        } else if (p.tag === 1) {
          var A = p.stateNode;
          if (typeof p.type.getDerivedStateFromError == "function" || typeof A.componentDidCatch == "function" && (Xo === null || !Xo.has(A))) {
            d = Sa(x, d), x = _x(2), A = Po(p, x, 2), A !== null && (kx(x, A, p, d), vn(A, 2), ws(A));
            break;
          }
        }
        p = p.return;
      }
    }
    function g3(d, p, x) {
      var A = d.pingCache;
      if (A === null) {
        A = d.pingCache = new IU();
        var M = /* @__PURE__ */ new Set();
        A.set(p, M);
      } else M = A.get(p), M === void 0 && (M = /* @__PURE__ */ new Set(), A.set(p, M));
      M.has(x) || (i3 = true, M.add(x), d = FU.bind(null, d, p, x), p.then(d, d));
    }
    function FU(d, p, x) {
      var A = d.pingCache;
      A !== null && A.delete(p), d.pingedLanes |= d.suspendedLanes & x, d.warmLanes &= ~x, kn === d && (Cn & x) === x && (fr === 4 || fr === 3 && (Cn & 62914560) === Cn && 300 > re() - o3 ? (On & 2) === 0 && B0(d, 0) : a3 |= x, L0 === Cn && (L0 = 0)), ws(d);
    }
    function U7(d, p) {
      p === 0 && (p = ti()), d = x0(d, p), d !== null && (vn(d, p), ws(d));
    }
    function BU(d) {
      var p = d.memoizedState, x = 0;
      p !== null && (x = p.retryLane), U7(d, x);
    }
    function _U(d, p) {
      var x = 0;
      switch (d.tag) {
        case 13:
          var A = d.stateNode, M = d.memoizedState;
          M !== null && (x = M.retryLane);
          break;
        case 19:
          A = d.stateNode;
          break;
        case 22:
          A = d.stateNode._retryCache;
          break;
        default:
          throw Error(r(314));
      }
      A !== null && A.delete(p), U7(d, x);
    }
    function kU(d, p) {
      return _t6(d, p);
    }
    var Qd = null, k0 = null, p3 = false, Jd = false, m3 = false, uc = 0;
    function ws(d) {
      d !== k0 && d.next === null && (k0 === null ? Qd = k0 = d : k0 = k0.next = d), Jd = true, p3 || (p3 = true, GU());
    }
    function Kf(d, p) {
      if (!m3 && Jd) {
        m3 = true;
        do
          for (var x = false, A = Qd; A !== null; ) {
            if (d !== 0) {
              var M = A.pendingLanes;
              if (M === 0) var U = 0;
              else {
                var W = A.suspendedLanes, Q = A.pingedLanes;
                U = (1 << 31 - fn(42 | d) + 1) - 1, U &= M & ~(W & ~Q), U = U & 201326741 ? U & 201326741 | 1 : U ? U | 2 : 0;
              }
              U !== 0 && (x = true, k7(A, U));
            } else U = Cn, U = ye(A, A === kn ? U : 0, A.cancelPendingCommit !== null || A.timeoutHandle !== -1), (U & 3) === 0 || ke(A, U) || (x = true, k7(A, U));
            A = A.next;
          }
        while (x);
        m3 = false;
      }
    }
    function PU() {
      F7();
    }
    function F7() {
      Jd = p3 = false;
      var d = 0;
      uc !== 0 && (XU() && (d = uc), uc = 0);
      for (var p = re(), x = null, A = Qd; A !== null; ) {
        var M = A.next, U = B7(A, p);
        U === 0 ? (A.next = null, x === null ? Qd = M : x.next = M, M === null && (k0 = x)) : (x = A, (d !== 0 || (U & 3) !== 0) && (Jd = true)), A = M;
      }
      Kf(d);
    }
    function B7(d, p) {
      for (var x = d.suspendedLanes, A = d.pingedLanes, M = d.expirationTimes, U = d.pendingLanes & -62914561; 0 < U; ) {
        var W = 31 - fn(U), Q = 1 << W, ae = M[W];
        ae === -1 ? ((Q & x) === 0 || (Q & A) !== 0) && (M[W] = rt(Q, p)) : ae <= p && (d.expiredLanes |= Q), U &= ~Q;
      }
      if (p = kn, x = Cn, x = ye(d, d === p ? x : 0, d.cancelPendingCommit !== null || d.timeoutHandle !== -1), A = d.callbackNode, x === 0 || d === p && (In === 2 || In === 9) || d.cancelPendingCommit !== null) return A !== null && A !== null && G(A), d.callbackNode = null, d.callbackPriority = 0;
      if ((x & 3) === 0 || ke(d, x)) {
        if (p = x & -x, p === d.callbackPriority) return p;
        switch (A !== null && G(A), Ro(x)) {
          case 2:
          case 8:
            x = Oe;
            break;
          case 32:
            x = Ve;
            break;
          case 268435456:
            x = We;
            break;
          default:
            x = Ve;
        }
        return A = _7.bind(null, d), x = _t6(x, A), d.callbackPriority = p, d.callbackNode = x, p;
      }
      return A !== null && A !== null && G(A), d.callbackPriority = 2, d.callbackNode = null, 2;
    }
    function _7(d, p) {
      if (ii !== 0 && ii !== 5) return d.callbackNode = null, d.callbackPriority = 0, null;
      var x = d.callbackNode;
      if (Zd() && d.callbackNode !== x) return null;
      var A = Cn;
      return A = ye(d, d === kn ? A : 0, d.cancelPendingCommit !== null || d.timeoutHandle !== -1), A === 0 ? null : (w7(d, A, p), B7(d, re()), d.callbackNode != null && d.callbackNode === x ? _7.bind(null, d) : null);
    }
    function k7(d, p) {
      if (Zd()) return null;
      w7(d, p, true);
    }
    function GU() {
      QU(function() {
        (On & 6) !== 0 ? _t6(ce, PU) : F7();
      });
    }
    function v3() {
      return uc === 0 && (uc = sn()), uc;
    }
    function P7(d) {
      return d == null || typeof d == "symbol" || typeof d == "boolean" ? null : typeof d == "function" ? d : Me("" + d);
    }
    function G7(d, p) {
      var x = p.ownerDocument.createElement("input");
      return x.name = p.name, x.value = p.value, d.id && x.setAttribute("form", d.id), p.parentNode.insertBefore(x, p), d = new FormData(d), x.parentNode.removeChild(x), d;
    }
    function zU(d, p, x, A, M) {
      if (p === "submit" && x && x.stateNode === M) {
        var U = P7((M[Fr] || null).action), W = A.submitter;
        W && (p = (p = W[Fr] || null) ? P7(p.formAction) : W.getAttribute("formAction"), p !== null && (U = p, W = null));
        var Q = new Xe("action", "action", null, A, M);
        d.push({
          event: Q,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (A.defaultPrevented) {
                  if (uc !== 0) {
                    var ae = W ? G7(M, W) : new FormData(M);
                    Bm(x, {
                      pending: true,
                      data: ae,
                      method: M.method,
                      action: U
                    }, null, ae);
                  }
                } else typeof U == "function" && (Q.preventDefault(), ae = W ? G7(M, W) : new FormData(M), Bm(x, {
                  pending: true,
                  data: ae,
                  method: M.method,
                  action: U
                }, U, ae));
              },
              currentTarget: M
            }
          ]
        });
      }
    }
    for (var y3 = 0; y3 < nm.length; y3++) {
      var x3 = nm[y3], WU = x3.toLowerCase(), HU = x3[0].toUpperCase() + x3.slice(1);
      ja(WU, "on" + HU);
    }
    ja(w9, "onAnimationEnd"), ja(C9, "onAnimationIteration"), ja(T9, "onAnimationStart"), ja("dblclick", "onDoubleClick"), ja("focusin", "onFocus"), ja("focusout", "onBlur"), ja(oU, "onTransitionRun"), ja(lU, "onTransitionStart"), ja(cU, "onTransitionCancel"), ja(S9, "onTransitionEnd"), ni("onMouseEnter", [
      "mouseout",
      "mouseover"
    ]), ni("onMouseLeave", [
      "mouseout",
      "mouseover"
    ]), ni("onPointerEnter", [
      "pointerout",
      "pointerover"
    ]), ni("onPointerLeave", [
      "pointerout",
      "pointerover"
    ]), Ca("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), Ca("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), Ca("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), Ca("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), Ca("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), Ca("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Yf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), jU = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Yf));
    function z7(d, p) {
      p = (p & 4) !== 0;
      for (var x = 0; x < d.length; x++) {
        var A = d[x], M = A.event;
        A = A.listeners;
        e: {
          var U = void 0;
          if (p) for (var W = A.length - 1; 0 <= W; W--) {
            var Q = A[W], ae = Q.instance, ve = Q.currentTarget;
            if (Q = Q.listener, ae !== U && M.isPropagationStopped()) break e;
            U = Q, M.currentTarget = ve;
            try {
              U(M);
            } catch (Ie) {
              kd(Ie);
            }
            M.currentTarget = null, U = ae;
          }
          else for (W = 0; W < A.length; W++) {
            if (Q = A[W], ae = Q.instance, ve = Q.currentTarget, Q = Q.listener, ae !== U && M.isPropagationStopped()) break e;
            U = Q, M.currentTarget = ve;
            try {
              U(M);
            } catch (Ie) {
              kd(Ie);
            }
            M.currentTarget = null, U = ae;
          }
        }
      }
    }
    function cn(d, p) {
      var x = p[ks];
      x === void 0 && (x = p[ks] = /* @__PURE__ */ new Set());
      var A = d + "__bubble";
      x.has(A) || (W7(p, d, 2, false), x.add(A));
    }
    function w3(d, p, x) {
      var A = 0;
      p && (A |= 4), W7(x, d, A, p);
    }
    var $d = "_reactListening" + Math.random().toString(36).slice(2);
    function C3(d) {
      if (!d[$d]) {
        d[$d] = true, c0.forEach(function(x) {
          x !== "selectionchange" && (jU.has(x) || w3(x, false, d), w3(x, true, d));
        });
        var p = d.nodeType === 9 ? d : d.ownerDocument;
        p === null || p[$d] || (p[$d] = true, w3("selectionchange", false, p));
      }
    }
    function W7(d, p, x, A) {
      switch (dw(p)) {
        case 2:
          var M = yF;
          break;
        case 8:
          M = xF;
          break;
        default:
          M = U3;
      }
      x = M.bind(null, p, x, d), M = void 0, !Kt || p !== "touchstart" && p !== "touchmove" && p !== "wheel" || (M = true), A ? M !== void 0 ? d.addEventListener(p, x, {
        capture: true,
        passive: M
      }) : d.addEventListener(p, x, true) : M !== void 0 ? d.addEventListener(p, x, {
        passive: M
      }) : d.addEventListener(p, x, false);
    }
    function T3(d, p, x, A, M) {
      var U = A;
      if ((p & 1) === 0 && (p & 2) === 0 && A !== null) e: for (; ; ) {
        if (A === null) return;
        var W = A.tag;
        if (W === 3 || W === 4) {
          var Q = A.stateNode.containerInfo;
          if (Q === M) break;
          if (W === 4) for (W = A.return; W !== null; ) {
            var ae = W.tag;
            if ((ae === 3 || ae === 4) && W.stateNode.containerInfo === M) return;
            W = W.return;
          }
          for (; Q !== null; ) {
            if (W = Wa(Q), W === null) return;
            if (ae = W.tag, ae === 5 || ae === 6 || ae === 26 || ae === 27) {
              A = U = W;
              continue e;
            }
            Q = Q.parentNode;
          }
        }
        A = A.return;
      }
      $e(function() {
        var ve = U, Ie = et(x), Fe = [];
        e: {
          var we = A9.get(d);
          if (we !== void 0) {
            var Ce = Xe, Vt = d;
            switch (d) {
              case "keypress":
                if (Nn(x) === 0) break e;
              case "keydown":
              case "keyup":
                Ce = kL;
                break;
              case "focusin":
                Vt = "focus", Ce = Yn;
                break;
              case "focusout":
                Vt = "blur", Ce = Yn;
                break;
              case "beforeblur":
              case "afterblur":
                Ce = Yn;
                break;
              case "click":
                if (x.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                Ce = xr;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                Ce = Ii;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                Ce = zL;
                break;
              case w9:
              case C9:
              case T9:
                Ce = Xl;
                break;
              case S9:
                Ce = HL;
                break;
              case "scroll":
              case "scrollend":
                Ce = Wt;
                break;
              case "wheel":
                Ce = KL;
                break;
              case "copy":
              case "cut":
              case "paste":
                Ce = Y5;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                Ce = t9;
                break;
              case "toggle":
              case "beforetoggle":
                Ce = qL;
            }
            var Et = (p & 4) !== 0, Fn = !Et && (d === "scroll" || d === "scrollend"), fe = Et ? we !== null ? we + "Capture" : null : we;
            Et = [];
            for (var le = ve, pe; le !== null; ) {
              var Ne = le;
              if (pe = Ne.stateNode, Ne = Ne.tag, Ne !== 5 && Ne !== 26 && Ne !== 27 || pe === null || fe === null || (Ne = Lt(le, fe), Ne != null && Et.push(qf(le, Ne, pe))), Fn) break;
              le = le.return;
            }
            0 < Et.length && (we = new Ce(we, Vt, null, x, Ie), Fe.push({
              event: we,
              listeners: Et
            }));
          }
        }
        if ((p & 7) === 0) {
          e: {
            if (we = d === "mouseover" || d === "pointerover", Ce = d === "mouseout" || d === "pointerout", we && x !== _e11 && (Vt = x.relatedTarget || x.fromElement) && (Wa(Vt) || Vt[na])) break e;
            if ((Ce || we) && (we = Ie.window === Ie ? Ie : (we = Ie.ownerDocument) ? we.defaultView || we.parentWindow : window, Ce ? (Vt = x.relatedTarget || x.toElement, Ce = ve, Vt = Vt ? Wa(Vt) : null, Vt !== null && (Fn = a(Vt), Et = Vt.tag, Vt !== Fn || Et !== 5 && Et !== 27 && Et !== 6) && (Vt = null)) : (Ce = null, Vt = ve), Ce !== Vt)) {
              if (Et = xr, Ne = "onMouseLeave", fe = "onMouseEnter", le = "mouse", (d === "pointerout" || d === "pointerover") && (Et = t9, Ne = "onPointerLeave", fe = "onPointerEnter", le = "pointer"), Fn = Ce == null ? we : Mi(Ce), pe = Vt == null ? we : Mi(Vt), we = new Et(Ne, le + "leave", Ce, x, Ie), we.target = Fn, we.relatedTarget = pe, Ne = null, Wa(Ie) === ve && (Et = new Et(fe, le + "enter", Vt, x, Ie), Et.target = pe, Et.relatedTarget = Fn, Ne = Et), Fn = Ne, Ce && Vt) t: {
                for (Et = Ce, fe = Vt, le = 0, pe = Et; pe; pe = P0(pe)) le++;
                for (pe = 0, Ne = fe; Ne; Ne = P0(Ne)) pe++;
                for (; 0 < le - pe; ) Et = P0(Et), le--;
                for (; 0 < pe - le; ) fe = P0(fe), pe--;
                for (; le--; ) {
                  if (Et === fe || fe !== null && Et === fe.alternate) break t;
                  Et = P0(Et), fe = P0(fe);
                }
                Et = null;
              }
              else Et = null;
              Ce !== null && H7(Fe, we, Ce, Et, false), Vt !== null && Fn !== null && H7(Fe, Fn, Vt, Et, true);
            }
          }
          e: {
            if (we = ve ? Mi(ve) : window, Ce = we.nodeName && we.nodeName.toLowerCase(), Ce === "select" || Ce === "input" && we.type === "file") var ct = c9;
            else if (o9(we)) if (u9) ct = iU;
            else {
              ct = nU;
              var an = tU;
            }
            else Ce = we.nodeName, !Ce || Ce.toLowerCase() !== "input" || we.type !== "checkbox" && we.type !== "radio" ? ve && Ee(ve.elementType) && (ct = c9) : ct = rU;
            if (ct && (ct = ct(d, ve))) {
              l9(Fe, ct, x, Ie);
              break e;
            }
            an && an(d, we, ve), d === "focusout" && ve && we.type === "number" && ve.memoizedProps.value != null && Uo(we, "number", we.value);
          }
          switch (an = ve ? Mi(ve) : window, d) {
            case "focusin":
              (o9(an) || an.contentEditable === "true") && (m0 = an, $5 = ve, wf = null);
              break;
            case "focusout":
              wf = $5 = m0 = null;
              break;
            case "mousedown":
              em = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              em = false, y9(Fe, x, Ie);
              break;
            case "selectionchange":
              if (sU) break;
            case "keydown":
            case "keyup":
              y9(Fe, x, Ie);
          }
          var mt;
          if (X5) e: {
            switch (d) {
              case "compositionstart":
                var Rt = "onCompositionStart";
                break e;
              case "compositionend":
                Rt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Rt = "onCompositionUpdate";
                break e;
            }
            Rt = void 0;
          }
          else p0 ? a9(d, x) && (Rt = "onCompositionEnd") : d === "keydown" && x.keyCode === 229 && (Rt = "onCompositionStart");
          Rt && (n9 && x.locale !== "ko" && (p0 || Rt !== "onCompositionStart" ? Rt === "onCompositionEnd" && p0 && (mt = nt()) : (on = Ie, Qt = "value" in on ? on.value : on.textContent, p0 = true)), an = e2(ve, Rt), 0 < an.length && (Rt = new gf(Rt, d, null, x, Ie), Fe.push({
            event: Rt,
            listeners: an
          }), mt ? Rt.data = mt : (mt = s9(x), mt !== null && (Rt.data = mt)))), (mt = ZL ? QL(d, x) : JL(d, x)) && (Rt = e2(ve, "onBeforeInput"), 0 < Rt.length && (an = new gf("onBeforeInput", "beforeinput", null, x, Ie), Fe.push({
            event: an,
            listeners: Rt
          }), an.data = mt)), zU(Fe, d, ve, x, Ie);
        }
        z7(Fe, p);
      });
    }
    function qf(d, p, x) {
      return {
        instance: d,
        listener: p,
        currentTarget: x
      };
    }
    function e2(d, p) {
      for (var x = p + "Capture", A = []; d !== null; ) {
        var M = d, U = M.stateNode;
        if (M = M.tag, M !== 5 && M !== 26 && M !== 27 || U === null || (M = Lt(d, x), M != null && A.unshift(qf(d, M, U)), M = Lt(d, p), M != null && A.push(qf(d, M, U))), d.tag === 3) return A;
        d = d.return;
      }
      return [];
    }
    function P0(d) {
      if (d === null) return null;
      do
        d = d.return;
      while (d && d.tag !== 5 && d.tag !== 27);
      return d || null;
    }
    function H7(d, p, x, A, M) {
      for (var U = p._reactName, W = []; x !== null && x !== A; ) {
        var Q = x, ae = Q.alternate, ve = Q.stateNode;
        if (Q = Q.tag, ae !== null && ae === A) break;
        Q !== 5 && Q !== 26 && Q !== 27 || ve === null || (ae = ve, M ? (ve = Lt(x, U), ve != null && W.unshift(qf(x, ve, ae))) : M || (ve = Lt(x, U), ve != null && W.push(qf(x, ve, ae)))), x = x.return;
      }
      W.length !== 0 && d.push({
        event: p,
        listeners: W
      });
    }
    var KU = /\r\n?/g, YU = /\u0000|\uFFFD/g;
    function j7(d) {
      return (typeof d == "string" ? d : "" + d).replace(KU, `
`).replace(YU, "");
    }
    function K7(d, p) {
      return p = j7(p), j7(d) === p;
    }
    function t2() {
    }
    function Un(d, p, x, A, M, U) {
      switch (x) {
        case "children":
          typeof A == "string" ? p === "body" || p === "textarea" && A === "" || q(d, A) : (typeof A == "number" || typeof A == "bigint") && p !== "body" && q(d, "" + A);
          break;
        case "className":
          ds(d, "class", A);
          break;
        case "tabIndex":
          ds(d, "tabindex", A);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          ds(d, x, A);
          break;
        case "style":
          Ae(d, A, U);
          break;
        case "data":
          if (p !== "object") {
            ds(d, "data", A);
            break;
          }
        case "src":
        case "href":
          if (A === "" && (p !== "a" || x !== "href")) {
            d.removeAttribute(x);
            break;
          }
          if (A == null || typeof A == "function" || typeof A == "symbol" || typeof A == "boolean") {
            d.removeAttribute(x);
            break;
          }
          A = Me("" + A), d.setAttribute(x, A);
          break;
        case "action":
        case "formAction":
          if (typeof A == "function") {
            d.setAttribute(x, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break;
          } else typeof U == "function" && (x === "formAction" ? (p !== "input" && Un(d, p, "name", M.name, M, null), Un(d, p, "formEncType", M.formEncType, M, null), Un(d, p, "formMethod", M.formMethod, M, null), Un(d, p, "formTarget", M.formTarget, M, null)) : (Un(d, p, "encType", M.encType, M, null), Un(d, p, "method", M.method, M, null), Un(d, p, "target", M.target, M, null)));
          if (A == null || typeof A == "symbol" || typeof A == "boolean") {
            d.removeAttribute(x);
            break;
          }
          A = Me("" + A), d.setAttribute(x, A);
          break;
        case "onClick":
          A != null && (d.onclick = t2);
          break;
        case "onScroll":
          A != null && cn("scroll", d);
          break;
        case "onScrollEnd":
          A != null && cn("scrollend", d);
          break;
        case "dangerouslySetInnerHTML":
          if (A != null) {
            if (typeof A != "object" || !("__html" in A)) throw Error(r(61));
            if (x = A.__html, x != null) {
              if (M.children != null) throw Error(r(60));
              d.innerHTML = x;
            }
          }
          break;
        case "multiple":
          d.multiple = A && typeof A != "function" && typeof A != "symbol";
          break;
        case "muted":
          d.muted = A && typeof A != "function" && typeof A != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (A == null || typeof A == "function" || typeof A == "boolean" || typeof A == "symbol") {
            d.removeAttribute("xlink:href");
            break;
          }
          x = Me("" + A), d.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", x);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          A != null && typeof A != "function" && typeof A != "symbol" ? d.setAttribute(x, "" + A) : d.removeAttribute(x);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          A && typeof A != "function" && typeof A != "symbol" ? d.setAttribute(x, "") : d.removeAttribute(x);
          break;
        case "capture":
        case "download":
          A === true ? d.setAttribute(x, "") : A !== false && A != null && typeof A != "function" && typeof A != "symbol" ? d.setAttribute(x, A) : d.removeAttribute(x);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          A != null && typeof A != "function" && typeof A != "symbol" && !isNaN(A) && 1 <= A ? d.setAttribute(x, A) : d.removeAttribute(x);
          break;
        case "rowSpan":
        case "start":
          A == null || typeof A == "function" || typeof A == "symbol" || isNaN(A) ? d.removeAttribute(x) : d.setAttribute(x, A);
          break;
        case "popover":
          cn("beforetoggle", d), cn("toggle", d), Ri(d, "popover", A);
          break;
        case "xlinkActuate":
          Oi(d, "http://www.w3.org/1999/xlink", "xlink:actuate", A);
          break;
        case "xlinkArcrole":
          Oi(d, "http://www.w3.org/1999/xlink", "xlink:arcrole", A);
          break;
        case "xlinkRole":
          Oi(d, "http://www.w3.org/1999/xlink", "xlink:role", A);
          break;
        case "xlinkShow":
          Oi(d, "http://www.w3.org/1999/xlink", "xlink:show", A);
          break;
        case "xlinkTitle":
          Oi(d, "http://www.w3.org/1999/xlink", "xlink:title", A);
          break;
        case "xlinkType":
          Oi(d, "http://www.w3.org/1999/xlink", "xlink:type", A);
          break;
        case "xmlBase":
          Oi(d, "http://www.w3.org/XML/1998/namespace", "xml:base", A);
          break;
        case "xmlLang":
          Oi(d, "http://www.w3.org/XML/1998/namespace", "xml:lang", A);
          break;
        case "xmlSpace":
          Oi(d, "http://www.w3.org/XML/1998/namespace", "xml:space", A);
          break;
        case "is":
          Ri(d, "is", A);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          (!(2 < x.length) || x[0] !== "o" && x[0] !== "O" || x[1] !== "n" && x[1] !== "N") && (x = De.get(x) || x, Ri(d, x, A));
      }
    }
    function S3(d, p, x, A, M, U) {
      switch (x) {
        case "style":
          Ae(d, A, U);
          break;
        case "dangerouslySetInnerHTML":
          if (A != null) {
            if (typeof A != "object" || !("__html" in A)) throw Error(r(61));
            if (x = A.__html, x != null) {
              if (M.children != null) throw Error(r(60));
              d.innerHTML = x;
            }
          }
          break;
        case "children":
          typeof A == "string" ? q(d, A) : (typeof A == "number" || typeof A == "bigint") && q(d, "" + A);
          break;
        case "onScroll":
          A != null && cn("scroll", d);
          break;
        case "onScrollEnd":
          A != null && cn("scrollend", d);
          break;
        case "onClick":
          A != null && (d.onclick = t2);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!No.hasOwnProperty(x)) e: {
            if (x[0] === "o" && x[1] === "n" && (M = x.endsWith("Capture"), p = x.slice(2, M ? x.length - 7 : void 0), U = d[Fr] || null, U = U != null ? U[x] : null, typeof U == "function" && d.removeEventListener(p, U, M), typeof A == "function")) {
              typeof U != "function" && U !== null && (x in d ? d[x] = null : d.hasAttribute(x) && d.removeAttribute(x)), d.addEventListener(p, A, M);
              break e;
            }
            x in d ? d[x] = A : A === true ? d.setAttribute(x, "") : Ri(d, x, A);
          }
      }
    }
    function ai(d, p, x) {
      switch (p) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          cn("error", d), cn("load", d);
          var A = false, M = false, U;
          for (U in x) if (x.hasOwnProperty(U)) {
            var W = x[U];
            if (W != null) switch (U) {
              case "src":
                A = true;
                break;
              case "srcSet":
                M = true;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, p));
              default:
                Un(d, p, U, W, x, null);
            }
          }
          M && Un(d, p, "srcSet", x.srcSet, x, null), A && Un(d, p, "src", x.src, x, null);
          return;
        case "input":
          cn("invalid", d);
          var Q = U = W = M = null, ae = null, ve = null;
          for (A in x) if (x.hasOwnProperty(A)) {
            var Ie = x[A];
            if (Ie != null) switch (A) {
              case "name":
                M = Ie;
                break;
              case "type":
                W = Ie;
                break;
              case "checked":
                ae = Ie;
                break;
              case "defaultChecked":
                ve = Ie;
                break;
              case "value":
                U = Ie;
                break;
              case "defaultValue":
                Q = Ie;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Ie != null) throw Error(r(137, p));
                break;
              default:
                Un(d, p, A, Ie, x, null);
            }
          }
          Gs(d, U, Q, ae, ve, W, M, false), Lo(d);
          return;
        case "select":
          cn("invalid", d), A = W = U = null;
          for (M in x) if (x.hasOwnProperty(M) && (Q = x[M], Q != null)) switch (M) {
            case "value":
              U = Q;
              break;
            case "defaultValue":
              W = Q;
              break;
            case "multiple":
              A = Q;
            default:
              Un(d, p, M, Q, x, null);
          }
          p = U, x = W, d.multiple = !!A, p != null ? ps(d, !!A, p, false) : x != null && ps(d, !!A, x, true);
          return;
        case "textarea":
          cn("invalid", d), U = M = A = null;
          for (W in x) if (x.hasOwnProperty(W) && (Q = x[W], Q != null)) switch (W) {
            case "value":
              A = Q;
              break;
            case "defaultValue":
              M = Q;
              break;
            case "children":
              U = Q;
              break;
            case "dangerouslySetInnerHTML":
              if (Q != null) throw Error(r(91));
              break;
            default:
              Un(d, p, W, Q, x, null);
          }
          P(d, A, M, U), Lo(d);
          return;
        case "option":
          for (ae in x) if (x.hasOwnProperty(ae) && (A = x[ae], A != null)) switch (ae) {
            case "selected":
              d.selected = A && typeof A != "function" && typeof A != "symbol";
              break;
            default:
              Un(d, p, ae, A, x, null);
          }
          return;
        case "dialog":
          cn("beforetoggle", d), cn("toggle", d), cn("cancel", d), cn("close", d);
          break;
        case "iframe":
        case "object":
          cn("load", d);
          break;
        case "video":
        case "audio":
          for (A = 0; A < Yf.length; A++) cn(Yf[A], d);
          break;
        case "image":
          cn("error", d), cn("load", d);
          break;
        case "details":
          cn("toggle", d);
          break;
        case "embed":
        case "source":
        case "link":
          cn("error", d), cn("load", d);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (ve in x) if (x.hasOwnProperty(ve) && (A = x[ve], A != null)) switch (ve) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(r(137, p));
            default:
              Un(d, p, ve, A, x, null);
          }
          return;
        default:
          if (Ee(p)) {
            for (Ie in x) x.hasOwnProperty(Ie) && (A = x[Ie], A !== void 0 && S3(d, p, Ie, A, x, void 0));
            return;
          }
      }
      for (Q in x) x.hasOwnProperty(Q) && (A = x[Q], A != null && Un(d, p, Q, A, x, null));
    }
    function qU(d, p, x, A) {
      switch (p) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var M = null, U = null, W = null, Q = null, ae = null, ve = null, Ie = null;
          for (Ce in x) {
            var Fe = x[Ce];
            if (x.hasOwnProperty(Ce) && Fe != null) switch (Ce) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                ae = Fe;
              default:
                A.hasOwnProperty(Ce) || Un(d, p, Ce, null, A, Fe);
            }
          }
          for (var we in A) {
            var Ce = A[we];
            if (Fe = x[we], A.hasOwnProperty(we) && (Ce != null || Fe != null)) switch (we) {
              case "type":
                U = Ce;
                break;
              case "name":
                M = Ce;
                break;
              case "checked":
                ve = Ce;
                break;
              case "defaultChecked":
                Ie = Ce;
                break;
              case "value":
                W = Ce;
                break;
              case "defaultValue":
                Q = Ce;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Ce != null) throw Error(r(137, p));
                break;
              default:
                Ce !== Fe && Un(d, p, we, Ce, A, Fe);
            }
          }
          ql(d, W, Q, ae, ve, Ie, U, M);
          return;
        case "select":
          Ce = W = Q = we = null;
          for (U in x) if (ae = x[U], x.hasOwnProperty(U) && ae != null) switch (U) {
            case "value":
              break;
            case "multiple":
              Ce = ae;
            default:
              A.hasOwnProperty(U) || Un(d, p, U, null, A, ae);
          }
          for (M in A) if (U = A[M], ae = x[M], A.hasOwnProperty(M) && (U != null || ae != null)) switch (M) {
            case "value":
              we = U;
              break;
            case "defaultValue":
              Q = U;
              break;
            case "multiple":
              W = U;
            default:
              U !== ae && Un(d, p, M, U, A, ae);
          }
          p = Q, x = W, A = Ce, we != null ? ps(d, !!x, we, false) : !!A != !!x && (p != null ? ps(d, !!x, p, true) : ps(d, !!x, x ? [] : "", false));
          return;
        case "textarea":
          Ce = we = null;
          for (Q in x) if (M = x[Q], x.hasOwnProperty(Q) && M != null && !A.hasOwnProperty(Q)) switch (Q) {
            case "value":
              break;
            case "children":
              break;
            default:
              Un(d, p, Q, null, A, M);
          }
          for (W in A) if (M = A[W], U = x[W], A.hasOwnProperty(W) && (M != null || U != null)) switch (W) {
            case "value":
              we = M;
              break;
            case "defaultValue":
              Ce = M;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (M != null) throw Error(r(91));
              break;
            default:
              M !== U && Un(d, p, W, M, A, U);
          }
          z(d, we, Ce);
          return;
        case "option":
          for (var Vt in x) if (we = x[Vt], x.hasOwnProperty(Vt) && we != null && !A.hasOwnProperty(Vt)) switch (Vt) {
            case "selected":
              d.selected = false;
              break;
            default:
              Un(d, p, Vt, null, A, we);
          }
          for (ae in A) if (we = A[ae], Ce = x[ae], A.hasOwnProperty(ae) && we !== Ce && (we != null || Ce != null)) switch (ae) {
            case "selected":
              d.selected = we && typeof we != "function" && typeof we != "symbol";
              break;
            default:
              Un(d, p, ae, we, A, Ce);
          }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var Et in x) we = x[Et], x.hasOwnProperty(Et) && we != null && !A.hasOwnProperty(Et) && Un(d, p, Et, null, A, we);
          for (ve in A) if (we = A[ve], Ce = x[ve], A.hasOwnProperty(ve) && we !== Ce && (we != null || Ce != null)) switch (ve) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (we != null) throw Error(r(137, p));
              break;
            default:
              Un(d, p, ve, we, A, Ce);
          }
          return;
        default:
          if (Ee(p)) {
            for (var Fn in x) we = x[Fn], x.hasOwnProperty(Fn) && we !== void 0 && !A.hasOwnProperty(Fn) && S3(d, p, Fn, void 0, A, we);
            for (Ie in A) we = A[Ie], Ce = x[Ie], !A.hasOwnProperty(Ie) || we === Ce || we === void 0 && Ce === void 0 || S3(d, p, Ie, we, A, Ce);
            return;
          }
      }
      for (var fe in x) we = x[fe], x.hasOwnProperty(fe) && we != null && !A.hasOwnProperty(fe) && Un(d, p, fe, null, A, we);
      for (Fe in A) we = A[Fe], Ce = x[Fe], !A.hasOwnProperty(Fe) || we === Ce || we == null && Ce == null || Un(d, p, Fe, we, A, Ce);
    }
    var A3 = null, E3 = null;
    function n2(d) {
      return d.nodeType === 9 ? d : d.ownerDocument;
    }
    function Y7(d) {
      switch (d) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function q7(d, p) {
      if (d === 0) switch (p) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
      return d === 1 && p === "foreignObject" ? 0 : d;
    }
    function b3(d, p) {
      return d === "textarea" || d === "noscript" || typeof p.children == "string" || typeof p.children == "number" || typeof p.children == "bigint" || typeof p.dangerouslySetInnerHTML == "object" && p.dangerouslySetInnerHTML !== null && p.dangerouslySetInnerHTML.__html != null;
    }
    var D3 = null;
    function XU() {
      var d = window.event;
      return d && d.type === "popstate" ? d === D3 ? false : (D3 = d, true) : (D3 = null, false);
    }
    var X7 = typeof setTimeout == "function" ? setTimeout : void 0, ZU = typeof clearTimeout == "function" ? clearTimeout : void 0, Z7 = typeof Promise == "function" ? Promise : void 0, QU = typeof queueMicrotask == "function" ? queueMicrotask : typeof Z7 < "u" ? function(d) {
      return Z7.resolve(null).then(d).catch(JU);
    } : X7;
    function JU(d) {
      setTimeout(function() {
        throw d;
      });
    }
    function Jo(d) {
      return d === "head";
    }
    function Q7(d, p) {
      var x = p, A = 0, M = 0;
      do {
        var U = x.nextSibling;
        if (d.removeChild(x), U && U.nodeType === 8) if (x = U.data, x === "/$") {
          if (0 < A && 8 > A) {
            x = A;
            var W = d.ownerDocument;
            if (x & 1 && Xf(W.documentElement), x & 2 && Xf(W.body), x & 4) for (x = W.head, Xf(x), W = x.firstChild; W; ) {
              var Q = W.nextSibling, ae = W.nodeName;
              W[wa] || ae === "SCRIPT" || ae === "STYLE" || ae === "LINK" && W.rel.toLowerCase() === "stylesheet" || x.removeChild(W), W = Q;
            }
          }
          if (M === 0) {
            d.removeChild(U), r1(p);
            return;
          }
          M--;
        } else x === "$" || x === "$?" || x === "$!" ? M++ : A = x.charCodeAt(0) - 48;
        else A = 0;
        x = U;
      } while (x);
      r1(p);
    }
    function M3(d) {
      var p = d.firstChild;
      for (p && p.nodeType === 10 && (p = p.nextSibling); p; ) {
        var x = p;
        switch (p = p.nextSibling, x.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            M3(x), Vo(x);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (x.rel.toLowerCase() === "stylesheet") continue;
        }
        d.removeChild(x);
      }
    }
    function $U(d, p, x, A) {
      for (; d.nodeType === 1; ) {
        var M = x;
        if (d.nodeName.toLowerCase() !== p.toLowerCase()) {
          if (!A && (d.nodeName !== "INPUT" || d.type !== "hidden")) break;
        } else if (A) {
          if (!d[wa]) switch (p) {
            case "meta":
              if (!d.hasAttribute("itemprop")) break;
              return d;
            case "link":
              if (U = d.getAttribute("rel"), U === "stylesheet" && d.hasAttribute("data-precedence")) break;
              if (U !== M.rel || d.getAttribute("href") !== (M.href == null || M.href === "" ? null : M.href) || d.getAttribute("crossorigin") !== (M.crossOrigin == null ? null : M.crossOrigin) || d.getAttribute("title") !== (M.title == null ? null : M.title)) break;
              return d;
            case "style":
              if (d.hasAttribute("data-precedence")) break;
              return d;
            case "script":
              if (U = d.getAttribute("src"), (U !== (M.src == null ? null : M.src) || d.getAttribute("type") !== (M.type == null ? null : M.type) || d.getAttribute("crossorigin") !== (M.crossOrigin == null ? null : M.crossOrigin)) && U && d.hasAttribute("async") && !d.hasAttribute("itemprop")) break;
              return d;
            default:
              return d;
          }
        } else if (p === "input" && d.type === "hidden") {
          var U = M.name == null ? null : "" + M.name;
          if (M.type === "hidden" && d.getAttribute("name") === U) return d;
        } else return d;
        if (d = Ya(d.nextSibling), d === null) break;
      }
      return null;
    }
    function eF(d, p, x) {
      if (p === "") return null;
      for (; d.nodeType !== 3; ) if ((d.nodeType !== 1 || d.nodeName !== "INPUT" || d.type !== "hidden") && !x || (d = Ya(d.nextSibling), d === null)) return null;
      return d;
    }
    function R3(d) {
      return d.data === "$!" || d.data === "$?" && d.ownerDocument.readyState === "complete";
    }
    function tF(d, p) {
      var x = d.ownerDocument;
      if (d.data !== "$?" || x.readyState === "complete") p();
      else {
        var A = function() {
          p(), x.removeEventListener("DOMContentLoaded", A);
        };
        x.addEventListener("DOMContentLoaded", A), d._reactRetry = A;
      }
    }
    function Ya(d) {
      for (; d != null; d = d.nextSibling) {
        var p = d.nodeType;
        if (p === 1 || p === 3) break;
        if (p === 8) {
          if (p = d.data, p === "$" || p === "$!" || p === "$?" || p === "F!" || p === "F") break;
          if (p === "/$") return null;
        }
      }
      return d;
    }
    var O3 = null;
    function J7(d) {
      d = d.previousSibling;
      for (var p = 0; d; ) {
        if (d.nodeType === 8) {
          var x = d.data;
          if (x === "$" || x === "$!" || x === "$?") {
            if (p === 0) return d;
            p--;
          } else x === "/$" && p++;
        }
        d = d.previousSibling;
      }
      return null;
    }
    function $7(d, p, x) {
      switch (p = n2(x), d) {
        case "html":
          if (d = p.documentElement, !d) throw Error(r(452));
          return d;
        case "head":
          if (d = p.head, !d) throw Error(r(453));
          return d;
        case "body":
          if (d = p.body, !d) throw Error(r(454));
          return d;
        default:
          throw Error(r(451));
      }
    }
    function Xf(d) {
      for (var p = d.attributes; p.length; ) d.removeAttributeNode(p[0]);
      Vo(d);
    }
    var Ra = /* @__PURE__ */ new Map(), ew = /* @__PURE__ */ new Set();
    function r2(d) {
      return typeof d.getRootNode == "function" ? d.getRootNode() : d.nodeType === 9 ? d : d.ownerDocument;
    }
    var eo = K.d;
    K.d = {
      f: nF,
      r: rF,
      D: iF,
      C: aF,
      L: sF,
      m: oF,
      X: cF,
      S: lF,
      M: uF
    };
    function nF() {
      var d = eo.f(), p = qd();
      return d || p;
    }
    function rF(d) {
      var p = ia(d);
      p !== null && p.tag === 5 && p.type === "form" ? wx(p) : eo.r(d);
    }
    var G0 = typeof document > "u" ? null : document;
    function tw(d, p, x) {
      var A = G0;
      if (A && typeof p == "string" && p) {
        var M = vi(p);
        M = 'link[rel="' + d + '"][href="' + M + '"]', typeof x == "string" && (M += '[crossorigin="' + x + '"]'), ew.has(M) || (ew.add(M), d = {
          rel: d,
          crossOrigin: x,
          href: p
        }, A.querySelector(M) === null && (p = A.createElement("link"), ai(p, "link", d), cr(p), A.head.appendChild(p)));
      }
    }
    function iF(d) {
      eo.D(d), tw("dns-prefetch", d, null);
    }
    function aF(d, p) {
      eo.C(d, p), tw("preconnect", d, p);
    }
    function sF(d, p, x) {
      eo.L(d, p, x);
      var A = G0;
      if (A && d && p) {
        var M = 'link[rel="preload"][as="' + vi(p) + '"]';
        p === "image" && x && x.imageSrcSet ? (M += '[imagesrcset="' + vi(x.imageSrcSet) + '"]', typeof x.imageSizes == "string" && (M += '[imagesizes="' + vi(x.imageSizes) + '"]')) : M += '[href="' + vi(d) + '"]';
        var U = M;
        switch (p) {
          case "style":
            U = z0(d);
            break;
          case "script":
            U = W0(d);
        }
        Ra.has(U) || (d = f({
          rel: "preload",
          href: p === "image" && x && x.imageSrcSet ? void 0 : d,
          as: p
        }, x), Ra.set(U, d), A.querySelector(M) !== null || p === "style" && A.querySelector(Zf(U)) || p === "script" && A.querySelector(Qf(U)) || (p = A.createElement("link"), ai(p, "link", d), cr(p), A.head.appendChild(p)));
      }
    }
    function oF(d, p) {
      eo.m(d, p);
      var x = G0;
      if (x && d) {
        var A = p && typeof p.as == "string" ? p.as : "script", M = 'link[rel="modulepreload"][as="' + vi(A) + '"][href="' + vi(d) + '"]', U = M;
        switch (A) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            U = W0(d);
        }
        if (!Ra.has(U) && (d = f({
          rel: "modulepreload",
          href: d
        }, p), Ra.set(U, d), x.querySelector(M) === null)) {
          switch (A) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (x.querySelector(Qf(U))) return;
          }
          A = x.createElement("link"), ai(A, "link", d), cr(A), x.head.appendChild(A);
        }
      }
    }
    function lF(d, p, x) {
      eo.S(d, p, x);
      var A = G0;
      if (A && d) {
        var M = hs(A).hoistableStyles, U = z0(d);
        p = p || "default";
        var W = M.get(U);
        if (!W) {
          var Q = {
            loading: 0,
            preload: null
          };
          if (W = A.querySelector(Zf(U))) Q.loading = 5;
          else {
            d = f({
              rel: "stylesheet",
              href: d,
              "data-precedence": p
            }, x), (x = Ra.get(U)) && I3(d, x);
            var ae = W = A.createElement("link");
            cr(ae), ai(ae, "link", d), ae._p = new Promise(function(ve, Ie) {
              ae.onload = ve, ae.onerror = Ie;
            }), ae.addEventListener("load", function() {
              Q.loading |= 1;
            }), ae.addEventListener("error", function() {
              Q.loading |= 2;
            }), Q.loading |= 4, i2(W, p, A);
          }
          W = {
            type: "stylesheet",
            instance: W,
            count: 1,
            state: Q
          }, M.set(U, W);
        }
      }
    }
    function cF(d, p) {
      eo.X(d, p);
      var x = G0;
      if (x && d) {
        var A = hs(x).hoistableScripts, M = W0(d), U = A.get(M);
        U || (U = x.querySelector(Qf(M)), U || (d = f({
          src: d,
          async: true
        }, p), (p = Ra.get(M)) && V3(d, p), U = x.createElement("script"), cr(U), ai(U, "link", d), x.head.appendChild(U)), U = {
          type: "script",
          instance: U,
          count: 1,
          state: null
        }, A.set(M, U));
      }
    }
    function uF(d, p) {
      eo.M(d, p);
      var x = G0;
      if (x && d) {
        var A = hs(x).hoistableScripts, M = W0(d), U = A.get(M);
        U || (U = x.querySelector(Qf(M)), U || (d = f({
          src: d,
          async: true,
          type: "module"
        }, p), (p = Ra.get(M)) && V3(d, p), U = x.createElement("script"), cr(U), ai(U, "link", d), x.head.appendChild(U)), U = {
          type: "script",
          instance: U,
          count: 1,
          state: null
        }, A.set(M, U));
      }
    }
    function nw(d, p, x, A) {
      var M = (M = Le.current) ? r2(M) : null;
      if (!M) throw Error(r(446));
      switch (d) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof x.precedence == "string" && typeof x.href == "string" ? (p = z0(x.href), x = hs(M).hoistableStyles, A = x.get(p), A || (A = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, x.set(p, A)), A) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        case "link":
          if (x.rel === "stylesheet" && typeof x.href == "string" && typeof x.precedence == "string") {
            d = z0(x.href);
            var U = hs(M).hoistableStyles, W = U.get(d);
            if (W || (M = M.ownerDocument || M, W = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: {
                loading: 0,
                preload: null
              }
            }, U.set(d, W), (U = M.querySelector(Zf(d))) && !U._p && (W.instance = U, W.state.loading = 5), Ra.has(d) || (x = {
              rel: "preload",
              as: "style",
              href: x.href,
              crossOrigin: x.crossOrigin,
              integrity: x.integrity,
              media: x.media,
              hrefLang: x.hrefLang,
              referrerPolicy: x.referrerPolicy
            }, Ra.set(d, x), U || fF(M, d, x, W.state))), p && A === null) throw Error(r(528, ""));
            return W;
          }
          if (p && A !== null) throw Error(r(529, ""));
          return null;
        case "script":
          return p = x.async, x = x.src, typeof x == "string" && p && typeof p != "function" && typeof p != "symbol" ? (p = W0(x), x = hs(M).hoistableScripts, A = x.get(p), A || (A = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, x.set(p, A)), A) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        default:
          throw Error(r(444, d));
      }
    }
    function z0(d) {
      return 'href="' + vi(d) + '"';
    }
    function Zf(d) {
      return 'link[rel="stylesheet"][' + d + "]";
    }
    function rw(d) {
      return f({}, d, {
        "data-precedence": d.precedence,
        precedence: null
      });
    }
    function fF(d, p, x, A) {
      d.querySelector('link[rel="preload"][as="style"][' + p + "]") ? A.loading = 1 : (p = d.createElement("link"), A.preload = p, p.addEventListener("load", function() {
        return A.loading |= 1;
      }), p.addEventListener("error", function() {
        return A.loading |= 2;
      }), ai(p, "link", x), cr(p), d.head.appendChild(p));
    }
    function W0(d) {
      return '[src="' + vi(d) + '"]';
    }
    function Qf(d) {
      return "script[async]" + d;
    }
    function iw(d, p, x) {
      if (p.count++, p.instance === null) switch (p.type) {
        case "style":
          var A = d.querySelector('style[data-href~="' + vi(x.href) + '"]');
          if (A) return p.instance = A, cr(A), A;
          var M = f({}, x, {
            "data-href": x.href,
            "data-precedence": x.precedence,
            href: null,
            precedence: null
          });
          return A = (d.ownerDocument || d).createElement("style"), cr(A), ai(A, "style", M), i2(A, x.precedence, d), p.instance = A;
        case "stylesheet":
          M = z0(x.href);
          var U = d.querySelector(Zf(M));
          if (U) return p.state.loading |= 4, p.instance = U, cr(U), U;
          A = rw(x), (M = Ra.get(M)) && I3(A, M), U = (d.ownerDocument || d).createElement("link"), cr(U);
          var W = U;
          return W._p = new Promise(function(Q, ae) {
            W.onload = Q, W.onerror = ae;
          }), ai(U, "link", A), p.state.loading |= 4, i2(U, x.precedence, d), p.instance = U;
        case "script":
          return U = W0(x.src), (M = d.querySelector(Qf(U))) ? (p.instance = M, cr(M), M) : (A = x, (M = Ra.get(U)) && (A = f({}, x), V3(A, M)), d = d.ownerDocument || d, M = d.createElement("script"), cr(M), ai(M, "link", A), d.head.appendChild(M), p.instance = M);
        case "void":
          return null;
        default:
          throw Error(r(443, p.type));
      }
      else p.type === "stylesheet" && (p.state.loading & 4) === 0 && (A = p.instance, p.state.loading |= 4, i2(A, x.precedence, d));
      return p.instance;
    }
    function i2(d, p, x) {
      for (var A = x.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), M = A.length ? A[A.length - 1] : null, U = M, W = 0; W < A.length; W++) {
        var Q = A[W];
        if (Q.dataset.precedence === p) U = Q;
        else if (U !== M) break;
      }
      U ? U.parentNode.insertBefore(d, U.nextSibling) : (p = x.nodeType === 9 ? x.head : x, p.insertBefore(d, p.firstChild));
    }
    function I3(d, p) {
      d.crossOrigin == null && (d.crossOrigin = p.crossOrigin), d.referrerPolicy == null && (d.referrerPolicy = p.referrerPolicy), d.title == null && (d.title = p.title);
    }
    function V3(d, p) {
      d.crossOrigin == null && (d.crossOrigin = p.crossOrigin), d.referrerPolicy == null && (d.referrerPolicy = p.referrerPolicy), d.integrity == null && (d.integrity = p.integrity);
    }
    var a2 = null;
    function aw(d, p, x) {
      if (a2 === null) {
        var A = /* @__PURE__ */ new Map(), M = a2 = /* @__PURE__ */ new Map();
        M.set(x, A);
      } else M = a2, A = M.get(x), A || (A = /* @__PURE__ */ new Map(), M.set(x, A));
      if (A.has(d)) return A;
      for (A.set(d, null), x = x.getElementsByTagName(d), M = 0; M < x.length; M++) {
        var U = x[M];
        if (!(U[wa] || U[yr] || d === "link" && U.getAttribute("rel") === "stylesheet") && U.namespaceURI !== "http://www.w3.org/2000/svg") {
          var W = U.getAttribute(p) || "";
          W = d + W;
          var Q = A.get(W);
          Q ? Q.push(U) : A.set(W, [
            U
          ]);
        }
      }
      return A;
    }
    function sw(d, p, x) {
      d = d.ownerDocument || d, d.head.insertBefore(x, p === "title" ? d.querySelector("head > title") : null);
    }
    function hF(d, p, x) {
      if (x === 1 || p.itemProp != null) return false;
      switch (d) {
        case "meta":
        case "title":
          return true;
        case "style":
          if (typeof p.precedence != "string" || typeof p.href != "string" || p.href === "") break;
          return true;
        case "link":
          if (typeof p.rel != "string" || typeof p.href != "string" || p.href === "" || p.onLoad || p.onError) break;
          switch (p.rel) {
            case "stylesheet":
              return d = p.disabled, typeof p.precedence == "string" && d == null;
            default:
              return true;
          }
        case "script":
          if (p.async && typeof p.async != "function" && typeof p.async != "symbol" && !p.onLoad && !p.onError && p.src && typeof p.src == "string") return true;
      }
      return false;
    }
    function ow(d) {
      return !(d.type === "stylesheet" && (d.state.loading & 3) === 0);
    }
    var Jf = null;
    function dF() {
    }
    function gF(d, p, x) {
      if (Jf === null) throw Error(r(475));
      var A = Jf;
      if (p.type === "stylesheet" && (typeof x.media != "string" || matchMedia(x.media).matches !== false) && (p.state.loading & 4) === 0) {
        if (p.instance === null) {
          var M = z0(x.href), U = d.querySelector(Zf(M));
          if (U) {
            d = U._p, d !== null && typeof d == "object" && typeof d.then == "function" && (A.count++, A = s2.bind(A), d.then(A, A)), p.state.loading |= 4, p.instance = U, cr(U);
            return;
          }
          U = d.ownerDocument || d, x = rw(x), (M = Ra.get(M)) && I3(x, M), U = U.createElement("link"), cr(U);
          var W = U;
          W._p = new Promise(function(Q, ae) {
            W.onload = Q, W.onerror = ae;
          }), ai(U, "link", x), p.instance = U;
        }
        A.stylesheets === null && (A.stylesheets = /* @__PURE__ */ new Map()), A.stylesheets.set(p, d), (d = p.state.preload) && (p.state.loading & 3) === 0 && (A.count++, p = s2.bind(A), d.addEventListener("load", p), d.addEventListener("error", p));
      }
    }
    function pF() {
      if (Jf === null) throw Error(r(475));
      var d = Jf;
      return d.stylesheets && d.count === 0 && N3(d, d.stylesheets), 0 < d.count ? function(p) {
        var x = setTimeout(function() {
          if (d.stylesheets && N3(d, d.stylesheets), d.unsuspend) {
            var A = d.unsuspend;
            d.unsuspend = null, A();
          }
        }, 6e4);
        return d.unsuspend = p, function() {
          d.unsuspend = null, clearTimeout(x);
        };
      } : null;
    }
    function s2() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets) N3(this, this.stylesheets);
        else if (this.unsuspend) {
          var d = this.unsuspend;
          this.unsuspend = null, d();
        }
      }
    }
    var o2 = null;
    function N3(d, p) {
      d.stylesheets = null, d.unsuspend !== null && (d.count++, o2 = /* @__PURE__ */ new Map(), p.forEach(mF, d), o2 = null, s2.call(d));
    }
    function mF(d, p) {
      if (!(p.state.loading & 4)) {
        var x = o2.get(d);
        if (x) var A = x.get(null);
        else {
          x = /* @__PURE__ */ new Map(), o2.set(d, x);
          for (var M = d.querySelectorAll("link[data-precedence],style[data-precedence]"), U = 0; U < M.length; U++) {
            var W = M[U];
            (W.nodeName === "LINK" || W.getAttribute("media") !== "not all") && (x.set(W.dataset.precedence, W), A = W);
          }
          A && x.set(null, A);
        }
        M = p.instance, W = M.getAttribute("data-precedence"), U = x.get(W) || A, U === A && x.set(null, M), x.set(W, M), this.count++, A = s2.bind(this), M.addEventListener("load", A), M.addEventListener("error", A), U ? U.parentNode.insertBefore(M, U.nextSibling) : (d = d.nodeType === 9 ? d.head : d, d.insertBefore(M, d.firstChild)), p.state.loading |= 4;
      }
    }
    var $f = {
      $$typeof: T,
      Provider: null,
      Consumer: null,
      _currentValue: Z,
      _currentValue2: Z,
      _threadCount: 0
    };
    function vF(d, p, x, A, M, U, W, Q) {
      this.tag = 1, this.containerInfo = d, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = lr(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = lr(0), this.hiddenUpdates = lr(null), this.identifierPrefix = A, this.onUncaughtError = M, this.onCaughtError = U, this.onRecoverableError = W, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = Q, this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function lw(d, p, x, A, M, U, W, Q, ae, ve, Ie, Fe) {
      return d = new vF(d, p, x, W, Q, ae, ve, Fe), p = 1, U === true && (p |= 24), U = oa(3, null, null, p), d.current = U, U.stateNode = d, p = gm(), p.refCount++, d.pooledCache = p, p.refCount++, U.memoizedState = {
        element: A,
        isDehydrated: x,
        cache: p
      }, ym(U), d;
    }
    function cw(d) {
      return d ? (d = w0, d) : w0;
    }
    function uw(d, p, x, A, M, U) {
      M = cw(M), A.context === null ? A.context = M : A.pendingContext = M, A = ko(p), A.payload = {
        element: x
      }, U = U === void 0 ? null : U, U !== null && (A.callback = U), x = Po(d, A, p), x !== null && (ha(x, d, p), Rf(x, d, p));
    }
    function fw(d, p) {
      if (d = d.memoizedState, d !== null && d.dehydrated !== null) {
        var x = d.retryLane;
        d.retryLane = x !== 0 && x < p ? x : p;
      }
    }
    function L3(d, p) {
      fw(d, p), (d = d.alternate) && fw(d, p);
    }
    function hw(d) {
      if (d.tag === 13) {
        var p = x0(d, 67108864);
        p !== null && ha(p, d, 67108864), L3(d, 67108864);
      }
    }
    var l2 = true;
    function yF(d, p, x, A) {
      var M = _.T;
      _.T = null;
      var U = K.p;
      try {
        K.p = 2, U3(d, p, x, A);
      } finally {
        K.p = U, _.T = M;
      }
    }
    function xF(d, p, x, A) {
      var M = _.T;
      _.T = null;
      var U = K.p;
      try {
        K.p = 8, U3(d, p, x, A);
      } finally {
        K.p = U, _.T = M;
      }
    }
    function U3(d, p, x, A) {
      if (l2) {
        var M = F3(A);
        if (M === null) T3(d, p, A, c2, x), gw(d, A);
        else if (CF(M, d, p, x, A)) A.stopPropagation();
        else if (gw(d, A), p & 4 && -1 < wF.indexOf(d)) {
          for (; M !== null; ) {
            var U = ia(M);
            if (U !== null) switch (U.tag) {
              case 3:
                if (U = U.stateNode, U.current.memoizedState.isDehydrated) {
                  var W = Ur(U.pendingLanes);
                  if (W !== 0) {
                    var Q = U;
                    for (Q.pendingLanes |= 2, Q.entangledLanes |= 2; W; ) {
                      var ae = 1 << 31 - fn(W);
                      Q.entanglements[1] |= ae, W &= ~ae;
                    }
                    ws(U), (On & 6) === 0 && (Kd = re() + 500, Kf(0));
                  }
                }
                break;
              case 13:
                Q = x0(U, 2), Q !== null && ha(Q, U, 2), qd(), L3(U, 2);
            }
            if (U = F3(A), U === null && T3(d, p, A, c2, x), U === M) break;
            M = U;
          }
          M !== null && A.stopPropagation();
        } else T3(d, p, A, null, x);
      }
    }
    function F3(d) {
      return d = et(d), B3(d);
    }
    var c2 = null;
    function B3(d) {
      if (c2 = null, d = Wa(d), d !== null) {
        var p = a(d);
        if (p === null) d = null;
        else {
          var x = p.tag;
          if (x === 13) {
            if (d = s(p), d !== null) return d;
            d = null;
          } else if (x === 3) {
            if (p.stateNode.current.memoizedState.isDehydrated) return p.tag === 3 ? p.stateNode.containerInfo : null;
            d = null;
          } else p !== d && (d = null);
        }
      }
      return c2 = d, null;
    }
    function dw(d) {
      switch (d) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (ne()) {
            case ce:
              return 2;
            case Oe:
              return 8;
            case Ve:
            case de:
              return 32;
            case We:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var _3 = false, $o = null, el = null, tl = null, e1 = /* @__PURE__ */ new Map(), t1 = /* @__PURE__ */ new Map(), nl = [], wF = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function gw(d, p) {
      switch (d) {
        case "focusin":
        case "focusout":
          $o = null;
          break;
        case "dragenter":
        case "dragleave":
          el = null;
          break;
        case "mouseover":
        case "mouseout":
          tl = null;
          break;
        case "pointerover":
        case "pointerout":
          e1.delete(p.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          t1.delete(p.pointerId);
      }
    }
    function n1(d, p, x, A, M, U) {
      return d === null || d.nativeEvent !== U ? (d = {
        blockedOn: p,
        domEventName: x,
        eventSystemFlags: A,
        nativeEvent: U,
        targetContainers: [
          M
        ]
      }, p !== null && (p = ia(p), p !== null && hw(p)), d) : (d.eventSystemFlags |= A, p = d.targetContainers, M !== null && p.indexOf(M) === -1 && p.push(M), d);
    }
    function CF(d, p, x, A, M) {
      switch (p) {
        case "focusin":
          return $o = n1($o, d, p, x, A, M), true;
        case "dragenter":
          return el = n1(el, d, p, x, A, M), true;
        case "mouseover":
          return tl = n1(tl, d, p, x, A, M), true;
        case "pointerover":
          var U = M.pointerId;
          return e1.set(U, n1(e1.get(U) || null, d, p, x, A, M)), true;
        case "gotpointercapture":
          return U = M.pointerId, t1.set(U, n1(t1.get(U) || null, d, p, x, A, M)), true;
      }
      return false;
    }
    function pw(d) {
      var p = Wa(d.target);
      if (p !== null) {
        var x = a(p);
        if (x !== null) {
          if (p = x.tag, p === 13) {
            if (p = s(x), p !== null) {
              d.blockedOn = p, _s(d.priority, function() {
                if (x.tag === 13) {
                  var A = fa();
                  A = fs(A);
                  var M = x0(x, A);
                  M !== null && ha(M, x, A), L3(x, A);
                }
              });
              return;
            }
          } else if (p === 3 && x.stateNode.current.memoizedState.isDehydrated) {
            d.blockedOn = x.tag === 3 ? x.stateNode.containerInfo : null;
            return;
          }
        }
      }
      d.blockedOn = null;
    }
    function u2(d) {
      if (d.blockedOn !== null) return false;
      for (var p = d.targetContainers; 0 < p.length; ) {
        var x = F3(d.nativeEvent);
        if (x === null) {
          x = d.nativeEvent;
          var A = new x.constructor(x.type, x);
          _e11 = A, x.target.dispatchEvent(A), _e11 = null;
        } else return p = ia(x), p !== null && hw(p), d.blockedOn = x, false;
        p.shift();
      }
      return true;
    }
    function mw(d, p, x) {
      u2(d) && x.delete(p);
    }
    function TF() {
      _3 = false, $o !== null && u2($o) && ($o = null), el !== null && u2(el) && (el = null), tl !== null && u2(tl) && (tl = null), e1.forEach(mw), t1.forEach(mw);
    }
    function f2(d, p) {
      d.blockedOn === p && (d.blockedOn = null, _3 || (_3 = true, t.unstable_scheduleCallback(t.unstable_NormalPriority, TF)));
    }
    var h2 = null;
    function vw(d) {
      h2 !== d && (h2 = d, t.unstable_scheduleCallback(t.unstable_NormalPriority, function() {
        h2 === d && (h2 = null);
        for (var p = 0; p < d.length; p += 3) {
          var x = d[p], A = d[p + 1], M = d[p + 2];
          if (typeof A != "function") {
            if (B3(A || x) === null) continue;
            break;
          }
          var U = ia(x);
          U !== null && (d.splice(p, 3), p -= 3, Bm(U, {
            pending: true,
            data: M,
            method: x.method,
            action: A
          }, A, M));
        }
      }));
    }
    function r1(d) {
      function p(ae) {
        return f2(ae, d);
      }
      $o !== null && f2($o, d), el !== null && f2(el, d), tl !== null && f2(tl, d), e1.forEach(p), t1.forEach(p);
      for (var x = 0; x < nl.length; x++) {
        var A = nl[x];
        A.blockedOn === d && (A.blockedOn = null);
      }
      for (; 0 < nl.length && (x = nl[0], x.blockedOn === null); ) pw(x), x.blockedOn === null && nl.shift();
      if (x = (d.ownerDocument || d).$$reactFormReplay, x != null) for (A = 0; A < x.length; A += 3) {
        var M = x[A], U = x[A + 1], W = M[Fr] || null;
        if (typeof U == "function") W || vw(x);
        else if (W) {
          var Q = null;
          if (U && U.hasAttribute("formAction")) {
            if (M = U, W = U[Fr] || null) Q = W.formAction;
            else if (B3(M) !== null) continue;
          } else Q = W.action;
          typeof Q == "function" ? x[A + 1] = Q : (x.splice(A, 3), A -= 3), vw(x);
        }
      }
    }
    function k3(d) {
      this._internalRoot = d;
    }
    d2.prototype.render = k3.prototype.render = function(d) {
      var p = this._internalRoot;
      if (p === null) throw Error(r(409));
      var x = p.current, A = fa();
      uw(x, A, d, p, null, null);
    }, d2.prototype.unmount = k3.prototype.unmount = function() {
      var d = this._internalRoot;
      if (d !== null) {
        this._internalRoot = null;
        var p = d.containerInfo;
        uw(d.current, 2, null, d, null, null), qd(), p[na] = null;
      }
    };
    function d2(d) {
      this._internalRoot = d;
    }
    d2.prototype.unstable_scheduleHydration = function(d) {
      if (d) {
        var p = Oo();
        d = {
          blockedOn: null,
          target: d,
          priority: p
        };
        for (var x = 0; x < nl.length && p !== 0 && p < nl[x].priority; x++) ;
        nl.splice(x, 0, d), x === 0 && pw(d);
      }
    };
    var yw = e.version;
    if (yw !== "19.1.1") throw Error(r(527, yw, "19.1.1"));
    K.findDOMNode = function(d) {
      var p = d._reactInternals;
      if (p === void 0) throw typeof d.render == "function" ? Error(r(188)) : (d = Object.keys(d).join(","), Error(r(268, d)));
      return d = l(p), d = d !== null ? c(d) : null, d = d === null ? null : d.stateNode, d;
    };
    var SF = {
      bundleType: 0,
      version: "19.1.1",
      rendererPackageName: "react-dom",
      currentDispatcherRef: _,
      reconcilerVersion: "19.1.1"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var g2 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!g2.isDisabled && g2.supportsFiber) try {
        at = g2.inject(SF), ut = g2;
      } catch {
      }
    }
    return a1.createRoot = function(d, p) {
      if (!i(d)) throw Error(r(299));
      var x = false, A = "", M = Lx, U = Ux, W = Fx, Q = null;
      return p != null && (p.unstable_strictMode === true && (x = true), p.identifierPrefix !== void 0 && (A = p.identifierPrefix), p.onUncaughtError !== void 0 && (M = p.onUncaughtError), p.onCaughtError !== void 0 && (U = p.onCaughtError), p.onRecoverableError !== void 0 && (W = p.onRecoverableError), p.unstable_transitionCallbacks !== void 0 && (Q = p.unstable_transitionCallbacks)), p = lw(d, 1, false, null, null, x, A, M, U, W, Q, null), d[na] = p.current, C3(d), new k3(p);
    }, a1.hydrateRoot = function(d, p, x) {
      if (!i(d)) throw Error(r(299));
      var A = false, M = "", U = Lx, W = Ux, Q = Fx, ae = null, ve = null;
      return x != null && (x.unstable_strictMode === true && (A = true), x.identifierPrefix !== void 0 && (M = x.identifierPrefix), x.onUncaughtError !== void 0 && (U = x.onUncaughtError), x.onCaughtError !== void 0 && (W = x.onCaughtError), x.onRecoverableError !== void 0 && (Q = x.onRecoverableError), x.unstable_transitionCallbacks !== void 0 && (ae = x.unstable_transitionCallbacks), x.formState !== void 0 && (ve = x.formState)), p = lw(d, 1, true, p, x ?? null, A, M, U, W, Q, ae, ve), p.context = cw(null), x = p.current, A = fa(), A = fs(A), M = ko(A), M.callback = null, Po(x, M, A), x = A, p.current.lanes = x, vn(p, x), ws(p), d[na] = p.current, C3(d), new d2(p);
    }, a1.version = "19.1.1", a1;
  }
  var Mw;
  function LF() {
    if (Mw) return z3.exports;
    Mw = 1;
    function t() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
    }
    return t(), z3.exports = NF(), z3.exports;
  }
  var UF = LF();
  var Rw = "popstate";
  function FF(t = {}) {
    function e(r, i) {
      let { pathname: a, search: s, hash: o } = r.location;
      return bv("", {
        pathname: a,
        search: s,
        hash: o
      }, i.state && i.state.usr || null, i.state && i.state.key || "default");
    }
    function n(r, i) {
      return typeof i == "string" ? i : yh(i);
    }
    return _F(e, n, null, t);
  }
  function or(t, e) {
    if (t === false || t === null || typeof t > "u") throw new Error(e);
  }
  function Vs(t, e) {
    if (!t) {
      typeof console < "u" && console.warn(e);
      try {
        throw new Error(e);
      } catch {
      }
    }
  }
  function BF() {
    return Math.random().toString(36).substring(2, 10);
  }
  function Ow(t, e) {
    return {
      usr: t.state,
      key: t.key,
      idx: e
    };
  }
  function bv(t, e, n = null, r) {
    return {
      pathname: typeof t == "string" ? t : t.pathname,
      search: "",
      hash: "",
      ...typeof e == "string" ? ju(e) : e,
      state: n,
      key: e && e.key || r || BF()
    };
  }
  function yh({ pathname: t = "/", search: e = "", hash: n = "" }) {
    return e && e !== "?" && (t += e.charAt(0) === "?" ? e : "?" + e), n && n !== "#" && (t += n.charAt(0) === "#" ? n : "#" + n), t;
  }
  function ju(t) {
    let e = {};
    if (t) {
      let n = t.indexOf("#");
      n >= 0 && (e.hash = t.substring(n), t = t.substring(0, n));
      let r = t.indexOf("?");
      r >= 0 && (e.search = t.substring(r), t = t.substring(0, r)), t && (e.pathname = t);
    }
    return e;
  }
  function _F(t, e, n, r = {}) {
    let { window: i = document.defaultView, v5Compat: a = false } = r, s = i.history, o = "POP", l = null, c = f();
    c == null && (c = 0, s.replaceState({
      ...s.state,
      idx: c
    }, ""));
    function f() {
      return (s.state || {
        idx: null
      }).idx;
    }
    function u() {
      o = "POP";
      let y = f(), w = y == null ? null : y - c;
      c = y, l && l({
        action: o,
        location: m.location,
        delta: w
      });
    }
    function h(y, w) {
      o = "PUSH";
      let C = bv(m.location, y, w);
      c = f() + 1;
      let T = Ow(C, c), S = m.createHref(C);
      try {
        s.pushState(T, "", S);
      } catch (E) {
        if (E instanceof DOMException && E.name === "DataCloneError") throw E;
        i.location.assign(S);
      }
      a && l && l({
        action: o,
        location: m.location,
        delta: 1
      });
    }
    function g(y, w) {
      o = "REPLACE";
      let C = bv(m.location, y, w);
      c = f();
      let T = Ow(C, c), S = m.createHref(C);
      s.replaceState(T, "", S), a && l && l({
        action: o,
        location: m.location,
        delta: 0
      });
    }
    function v(y) {
      return kF(y);
    }
    let m = {
      get action() {
        return o;
      },
      get location() {
        return t(i, s);
      },
      listen(y) {
        if (l) throw new Error("A history only accepts one active listener");
        return i.addEventListener(Rw, u), l = y, () => {
          i.removeEventListener(Rw, u), l = null;
        };
      },
      createHref(y) {
        return e(i, y);
      },
      createURL: v,
      encodeLocation(y) {
        let w = v(y);
        return {
          pathname: w.pathname,
          search: w.search,
          hash: w.hash
        };
      },
      push: h,
      replace: g,
      go(y) {
        return s.go(y);
      }
    };
    return m;
  }
  function kF(t, e = false) {
    let n = "http://localhost";
    typeof window < "u" && (n = window.location.origin !== "null" ? window.location.origin : window.location.href), or(n, "No window.location.(origin|href) available to create URL");
    let r = typeof t == "string" ? t : yh(t);
    return r = r.replace(/ $/, "%20"), !e && r.startsWith("//") && (r = n + r), new URL(r, n);
  }
  function sE(t, e, n = "/") {
    return PF(t, e, n, false);
  }
  function PF(t, e, n, r) {
    let i = typeof e == "string" ? ju(e) : e, a = So(i.pathname || "/", n);
    if (a == null) return null;
    let s = oE(t);
    GF(s);
    let o = null;
    for (let l = 0; o == null && l < s.length; ++l) {
      let c = JF(a);
      o = ZF(s[l], c, r);
    }
    return o;
  }
  function oE(t, e = [], n = [], r = "", i = false) {
    let a = (s, o, l = i, c) => {
      let f = {
        relativePath: c === void 0 ? s.path || "" : c,
        caseSensitive: s.caseSensitive === true,
        childrenIndex: o,
        route: s
      };
      if (f.relativePath.startsWith("/")) {
        if (!f.relativePath.startsWith(r) && l) return;
        or(f.relativePath.startsWith(r), `Absolute route path "${f.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), f.relativePath = f.relativePath.slice(r.length);
      }
      let u = po([
        r,
        f.relativePath
      ]), h = n.concat(f);
      s.children && s.children.length > 0 && (or(s.index !== true, `Index routes must not have child routes. Please remove all child routes from route path "${u}".`), oE(s.children, e, h, u, l)), !(s.path == null && !s.index) && e.push({
        path: u,
        score: qF(u, s.index),
        routesMeta: h
      });
    };
    return t.forEach((s, o) => {
      var _a3;
      if (s.path === "" || !((_a3 = s.path) == null ? void 0 : _a3.includes("?"))) a(s, o);
      else for (let l of lE(s.path)) a(s, o, true, l);
    }), e;
  }
  function lE(t) {
    let e = t.split("/");
    if (e.length === 0) return [];
    let [n, ...r] = e, i = n.endsWith("?"), a = n.replace(/\?$/, "");
    if (r.length === 0) return i ? [
      a,
      ""
    ] : [
      a
    ];
    let s = lE(r.join("/")), o = [];
    return o.push(...s.map((l) => l === "" ? a : [
      a,
      l
    ].join("/"))), i && o.push(...s), o.map((l) => t.startsWith("/") && l === "" ? "/" : l);
  }
  function GF(t) {
    t.sort((e, n) => e.score !== n.score ? n.score - e.score : XF(e.routesMeta.map((r) => r.childrenIndex), n.routesMeta.map((r) => r.childrenIndex)));
  }
  var zF = /^:[\w-]+$/, WF = 3, HF = 2, jF = 1, KF = 10, YF = -2, Iw = (t) => t === "*";
  function qF(t, e) {
    let n = t.split("/"), r = n.length;
    return n.some(Iw) && (r += YF), e && (r += HF), n.filter((i) => !Iw(i)).reduce((i, a) => i + (zF.test(a) ? WF : a === "" ? jF : KF), r);
  }
  function XF(t, e) {
    return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0;
  }
  function ZF(t, e, n = false) {
    let { routesMeta: r } = t, i = {}, a = "/", s = [];
    for (let o = 0; o < r.length; ++o) {
      let l = r[o], c = o === r.length - 1, f = a === "/" ? e : e.slice(a.length) || "/", u = Qg({
        path: l.relativePath,
        caseSensitive: l.caseSensitive,
        end: c
      }, f), h = l.route;
      if (!u && c && n && !r[r.length - 1].route.index && (u = Qg({
        path: l.relativePath,
        caseSensitive: l.caseSensitive,
        end: false
      }, f)), !u) return null;
      Object.assign(i, u.params), s.push({
        params: i,
        pathname: po([
          a,
          u.pathname
        ]),
        pathnameBase: nB(po([
          a,
          u.pathnameBase
        ])),
        route: h
      }), u.pathnameBase !== "/" && (a = po([
        a,
        u.pathnameBase
      ]));
    }
    return s;
  }
  function Qg(t, e) {
    typeof t == "string" && (t = {
      path: t,
      caseSensitive: false,
      end: true
    });
    let [n, r] = QF(t.path, t.caseSensitive, t.end), i = e.match(n);
    if (!i) return null;
    let a = i[0], s = a.replace(/(.)\/+$/, "$1"), o = i.slice(1);
    return {
      params: r.reduce((c, { paramName: f, isOptional: u }, h) => {
        if (f === "*") {
          let v = o[h] || "";
          s = a.slice(0, a.length - v.length).replace(/(.)\/+$/, "$1");
        }
        const g = o[h];
        return u && !g ? c[f] = void 0 : c[f] = (g || "").replace(/%2F/g, "/"), c;
      }, {}),
      pathname: a,
      pathnameBase: s,
      pattern: t
    };
  }
  function QF(t, e = false, n = true) {
    Vs(t === "*" || !t.endsWith("*") || t.endsWith("/*"), `Route path "${t}" will be treated as if it were "${t.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${t.replace(/\*$/, "/*")}".`);
    let r = [], i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, o, l) => (r.push({
      paramName: o,
      isOptional: l != null
    }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
    return t.endsWith("*") ? (r.push({
      paramName: "*"
    }), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"), [
      new RegExp(i, e ? void 0 : "i"),
      r
    ];
  }
  function JF(t) {
    try {
      return t.split("/").map((e) => decodeURIComponent(e).replace(/\//g, "%2F")).join("/");
    } catch (e) {
      return Vs(false, `The URL path "${t}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`), t;
    }
  }
  function So(t, e) {
    if (e === "/") return t;
    if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
    let n = e.endsWith("/") ? e.length - 1 : e.length, r = t.charAt(n);
    return r && r !== "/" ? null : t.slice(n) || "/";
  }
  function $F(t, e = "/") {
    let { pathname: n, search: r = "", hash: i = "" } = typeof t == "string" ? ju(t) : t;
    return {
      pathname: n ? n.startsWith("/") ? n : eB(n, e) : e,
      search: rB(r),
      hash: iB(i)
    };
  }
  function eB(t, e) {
    let n = e.replace(/\/+$/, "").split("/");
    return t.split("/").forEach((i) => {
      i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
    }), n.length > 1 ? n.join("/") : "/";
  }
  function K3(t, e, n, r) {
    return `Cannot include a '${t}' character in a manually specified \`to.${e}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
  }
  function tB(t) {
    return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0);
  }
  function cE(t) {
    let e = tB(t);
    return e.map((n, r) => r === e.length - 1 ? n.pathname : n.pathnameBase);
  }
  function uE(t, e, n, r = false) {
    let i;
    typeof t == "string" ? i = ju(t) : (i = {
      ...t
    }, or(!i.pathname || !i.pathname.includes("?"), K3("?", "pathname", "search", i)), or(!i.pathname || !i.pathname.includes("#"), K3("#", "pathname", "hash", i)), or(!i.search || !i.search.includes("#"), K3("#", "search", "hash", i)));
    let a = t === "" || i.pathname === "", s = a ? "/" : i.pathname, o;
    if (s == null) o = n;
    else {
      let u = e.length - 1;
      if (!r && s.startsWith("..")) {
        let h = s.split("/");
        for (; h[0] === ".."; ) h.shift(), u -= 1;
        i.pathname = h.join("/");
      }
      o = u >= 0 ? e[u] : "/";
    }
    let l = $F(i, o), c = s && s !== "/" && s.endsWith("/"), f = (a || s === ".") && n.endsWith("/");
    return !l.pathname.endsWith("/") && (c || f) && (l.pathname += "/"), l;
  }
  var po = (t) => t.join("/").replace(/\/\/+/g, "/"), nB = (t) => t.replace(/\/+$/, "").replace(/^\/*/, "/"), rB = (t) => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, iB = (t) => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t;
  function aB(t) {
    return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t;
  }
  var fE = [
    "POST",
    "PUT",
    "PATCH",
    "DELETE"
  ];
  new Set(fE);
  var sB = [
    "GET",
    ...fE
  ];
  new Set(sB);
  var Ku = me.createContext(null);
  Ku.displayName = "DataRouter";
  var t5 = me.createContext(null);
  t5.displayName = "DataRouterState";
  me.createContext(false);
  var hE = me.createContext({
    isTransitioning: false
  });
  hE.displayName = "ViewTransition";
  var oB = me.createContext(/* @__PURE__ */ new Map());
  oB.displayName = "Fetchers";
  var lB = me.createContext(null);
  lB.displayName = "Await";
  var Us = me.createContext(null);
  Us.displayName = "Navigation";
  var zh = me.createContext(null);
  zh.displayName = "Location";
  var Fs = me.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  Fs.displayName = "Route";
  var B6 = me.createContext(null);
  B6.displayName = "RouteError";
  function cB(t, { relative: e } = {}) {
    or(Wh(), "useHref() may be used only in the context of a <Router> component.");
    let { basename: n, navigator: r } = me.useContext(Us), { hash: i, pathname: a, search: s } = Hh(t, {
      relative: e
    }), o = a;
    return n !== "/" && (o = a === "/" ? n : po([
      n,
      a
    ])), r.createHref({
      pathname: o,
      search: s,
      hash: i
    });
  }
  function Wh() {
    return me.useContext(zh) != null;
  }
  function n0() {
    return or(Wh(), "useLocation() may be used only in the context of a <Router> component."), me.useContext(zh).location;
  }
  var dE = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
  function gE(t) {
    me.useContext(Us).static || me.useLayoutEffect(t);
  }
  function n5() {
    let { isDataRoute: t } = me.useContext(Fs);
    return t ? TB() : uB();
  }
  function uB() {
    or(Wh(), "useNavigate() may be used only in the context of a <Router> component.");
    let t = me.useContext(Ku), { basename: e, navigator: n } = me.useContext(Us), { matches: r } = me.useContext(Fs), { pathname: i } = n0(), a = JSON.stringify(cE(r)), s = me.useRef(false);
    return gE(() => {
      s.current = true;
    }), me.useCallback((l, c = {}) => {
      if (Vs(s.current, dE), !s.current) return;
      if (typeof l == "number") {
        n.go(l);
        return;
      }
      let f = uE(l, JSON.parse(a), i, c.relative === "path");
      t == null && e !== "/" && (f.pathname = f.pathname === "/" ? e : po([
        e,
        f.pathname
      ])), (c.replace ? n.replace : n.push)(f, c.state, c);
    }, [
      e,
      n,
      a,
      i,
      t
    ]);
  }
  me.createContext(null);
  function pE() {
    let { matches: t } = me.useContext(Fs), e = t[t.length - 1];
    return e ? e.params : {};
  }
  function Hh(t, { relative: e } = {}) {
    let { matches: n } = me.useContext(Fs), { pathname: r } = n0(), i = JSON.stringify(cE(n));
    return me.useMemo(() => uE(t, JSON.parse(i), r, e === "path"), [
      t,
      i,
      r,
      e
    ]);
  }
  function fB(t, e) {
    return mE(t, e);
  }
  function mE(t, e, n, r) {
    var _a3;
    or(Wh(), "useRoutes() may be used only in the context of a <Router> component.");
    let { navigator: i } = me.useContext(Us), { matches: a } = me.useContext(Fs), s = a[a.length - 1], o = s ? s.params : {}, l = s ? s.pathname : "/", c = s ? s.pathnameBase : "/", f = s && s.route;
    {
      let w = f && f.path || "";
      vE(l, !f || w.endsWith("*") || w.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${l}" (under <Route path="${w}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${w}"> to <Route path="${w === "/" ? "*" : `${w}/*`}">.`);
    }
    let u = n0(), h;
    if (e) {
      let w = typeof e == "string" ? ju(e) : e;
      or(c === "/" || ((_a3 = w.pathname) == null ? void 0 : _a3.startsWith(c)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${w.pathname}" was given in the \`location\` prop.`), h = w;
    } else h = u;
    let g = h.pathname || "/", v = g;
    if (c !== "/") {
      let w = c.replace(/^\//, "").split("/");
      v = "/" + g.replace(/^\//, "").split("/").slice(w.length).join("/");
    }
    let m = sE(t, {
      pathname: v
    });
    Vs(f || m != null, `No routes matched location "${h.pathname}${h.search}${h.hash}" `), Vs(m == null || m[m.length - 1].route.element !== void 0 || m[m.length - 1].route.Component !== void 0 || m[m.length - 1].route.lazy !== void 0, `Matched leaf route at location "${h.pathname}${h.search}${h.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let y = mB(m && m.map((w) => Object.assign({}, w, {
      params: Object.assign({}, o, w.params),
      pathname: po([
        c,
        i.encodeLocation ? i.encodeLocation(w.pathname).pathname : w.pathname
      ]),
      pathnameBase: w.pathnameBase === "/" ? c : po([
        c,
        i.encodeLocation ? i.encodeLocation(w.pathnameBase).pathname : w.pathnameBase
      ])
    })), a, n, r);
    return e && y ? me.createElement(zh.Provider, {
      value: {
        location: {
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...h
        },
        navigationType: "POP"
      }
    }, y) : y;
  }
  function hB() {
    let t = CB(), e = aB(t) ? `${t.status} ${t.statusText}` : t instanceof Error ? t.message : JSON.stringify(t), n = t instanceof Error ? t.stack : null, r = "rgba(200,200,200, 0.5)", i = {
      padding: "0.5rem",
      backgroundColor: r
    }, a = {
      padding: "2px 4px",
      backgroundColor: r
    }, s = null;
    return console.error("Error handled by React Router default ErrorBoundary:", t), s = me.createElement(me.Fragment, null, me.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), me.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", me.createElement("code", {
      style: a
    }, "ErrorBoundary"), " or", " ", me.createElement("code", {
      style: a
    }, "errorElement"), " prop on your route.")), me.createElement(me.Fragment, null, me.createElement("h2", null, "Unexpected Application Error!"), me.createElement("h3", {
      style: {
        fontStyle: "italic"
      }
    }, e), n ? me.createElement("pre", {
      style: i
    }, n) : null, s);
  }
  var dB = me.createElement(hB, null), gB = class extends me.Component {
    constructor(t) {
      super(t), this.state = {
        location: t.location,
        revalidation: t.revalidation,
        error: t.error
      };
    }
    static getDerivedStateFromError(t) {
      return {
        error: t
      };
    }
    static getDerivedStateFromProps(t, e) {
      return e.location !== t.location || e.revalidation !== "idle" && t.revalidation === "idle" ? {
        error: t.error,
        location: t.location,
        revalidation: t.revalidation
      } : {
        error: t.error !== void 0 ? t.error : e.error,
        location: e.location,
        revalidation: t.revalidation || e.revalidation
      };
    }
    componentDidCatch(t, e) {
      console.error("React Router caught the following error during render", t, e);
    }
    render() {
      return this.state.error !== void 0 ? me.createElement(Fs.Provider, {
        value: this.props.routeContext
      }, me.createElement(B6.Provider, {
        value: this.state.error,
        children: this.props.component
      })) : this.props.children;
    }
  };
  function pB({ routeContext: t, match: e, children: n }) {
    let r = me.useContext(Ku);
    return r && r.static && r.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = e.route.id), me.createElement(Fs.Provider, {
      value: t
    }, n);
  }
  function mB(t, e = [], n = null, r = null) {
    if (t == null) {
      if (!n) return null;
      if (n.errors) t = n.matches;
      else if (e.length === 0 && !n.initialized && n.matches.length > 0) t = n.matches;
      else return null;
    }
    let i = t, a = n == null ? void 0 : n.errors;
    if (a != null) {
      let l = i.findIndex((c) => c.route.id && (a == null ? void 0 : a[c.route.id]) !== void 0);
      or(l >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`), i = i.slice(0, Math.min(i.length, l + 1));
    }
    let s = false, o = -1;
    if (n) for (let l = 0; l < i.length; l++) {
      let c = i[l];
      if ((c.route.HydrateFallback || c.route.hydrateFallbackElement) && (o = l), c.route.id) {
        let { loaderData: f, errors: u } = n, h = c.route.loader && !f.hasOwnProperty(c.route.id) && (!u || u[c.route.id] === void 0);
        if (c.route.lazy || h) {
          s = true, o >= 0 ? i = i.slice(0, o + 1) : i = [
            i[0]
          ];
          break;
        }
      }
    }
    return i.reduceRight((l, c, f) => {
      let u, h = false, g = null, v = null;
      n && (u = a && c.route.id ? a[c.route.id] : void 0, g = c.route.errorElement || dB, s && (o < 0 && f === 0 ? (vE("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration"), h = true, v = null) : o === f && (h = true, v = c.route.hydrateFallbackElement || null)));
      let m = e.concat(i.slice(0, f + 1)), y = () => {
        let w;
        return u ? w = g : h ? w = v : c.route.Component ? w = me.createElement(c.route.Component, null) : c.route.element ? w = c.route.element : w = l, me.createElement(pB, {
          match: c,
          routeContext: {
            outlet: l,
            matches: m,
            isDataRoute: n != null
          },
          children: w
        });
      };
      return n && (c.route.ErrorBoundary || c.route.errorElement || f === 0) ? me.createElement(gB, {
        location: n.location,
        revalidation: n.revalidation,
        component: g,
        error: u,
        children: y(),
        routeContext: {
          outlet: null,
          matches: m,
          isDataRoute: true
        }
      }) : y();
    }, null);
  }
  function _6(t) {
    return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function vB(t) {
    let e = me.useContext(Ku);
    return or(e, _6(t)), e;
  }
  function yB(t) {
    let e = me.useContext(t5);
    return or(e, _6(t)), e;
  }
  function xB(t) {
    let e = me.useContext(Fs);
    return or(e, _6(t)), e;
  }
  function k6(t) {
    let e = xB(t), n = e.matches[e.matches.length - 1];
    return or(n.route.id, `${t} can only be used on routes that contain a unique "id"`), n.route.id;
  }
  function wB() {
    return k6("useRouteId");
  }
  function CB() {
    var _a3;
    let t = me.useContext(B6), e = yB("useRouteError"), n = k6("useRouteError");
    return t !== void 0 ? t : (_a3 = e.errors) == null ? void 0 : _a3[n];
  }
  function TB() {
    let { router: t } = vB("useNavigate"), e = k6("useNavigate"), n = me.useRef(false);
    return gE(() => {
      n.current = true;
    }), me.useCallback(async (i, a = {}) => {
      Vs(n.current, dE), n.current && (typeof i == "number" ? t.navigate(i) : await t.navigate(i, {
        fromRouteId: e,
        ...a
      }));
    }, [
      t,
      e
    ]);
  }
  var Vw = {};
  function vE(t, e, n) {
    !e && !Vw[t] && (Vw[t] = true, Vs(false, n));
  }
  me.memo(SB);
  function SB({ routes: t, future: e, state: n }) {
    return mE(t, void 0, n, e);
  }
  function Dv(t) {
    or(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.");
  }
  function AB({ basename: t = "/", children: e = null, location: n, navigationType: r = "POP", navigator: i, static: a = false }) {
    or(!Wh(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let s = t.replace(/^\/*/, "/"), o = me.useMemo(() => ({
      basename: s,
      navigator: i,
      static: a,
      future: {}
    }), [
      s,
      i,
      a
    ]);
    typeof n == "string" && (n = ju(n));
    let { pathname: l = "/", search: c = "", hash: f = "", state: u = null, key: h = "default" } = n, g = me.useMemo(() => {
      let v = So(l, s);
      return v == null ? null : {
        location: {
          pathname: v,
          search: c,
          hash: f,
          state: u,
          key: h
        },
        navigationType: r
      };
    }, [
      s,
      l,
      c,
      f,
      u,
      h,
      r
    ]);
    return Vs(g != null, `<Router basename="${s}"> is not able to match the URL "${l}${c}${f}" because it does not start with the basename, so the <Router> won't render anything.`), g == null ? null : me.createElement(Us.Provider, {
      value: o
    }, me.createElement(zh.Provider, {
      children: e,
      value: g
    }));
  }
  function EB({ children: t, location: e }) {
    return fB(Mv(t), e);
  }
  function Mv(t, e = []) {
    let n = [];
    return me.Children.forEach(t, (r, i) => {
      if (!me.isValidElement(r)) return;
      let a = [
        ...e,
        i
      ];
      if (r.type === me.Fragment) {
        n.push.apply(n, Mv(r.props.children, a));
        return;
      }
      or(r.type === Dv, `[${typeof r.type == "string" ? r.type : r.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), or(!r.props.index || !r.props.children, "An index route cannot have child routes.");
      let s = {
        id: r.props.id || a.join("-"),
        caseSensitive: r.props.caseSensitive,
        element: r.props.element,
        Component: r.props.Component,
        index: r.props.index,
        path: r.props.path,
        loader: r.props.loader,
        action: r.props.action,
        hydrateFallbackElement: r.props.hydrateFallbackElement,
        HydrateFallback: r.props.HydrateFallback,
        errorElement: r.props.errorElement,
        ErrorBoundary: r.props.ErrorBoundary,
        hasErrorBoundary: r.props.hasErrorBoundary === true || r.props.ErrorBoundary != null || r.props.errorElement != null,
        shouldRevalidate: r.props.shouldRevalidate,
        handle: r.props.handle,
        lazy: r.props.lazy
      };
      r.props.children && (s.children = Mv(r.props.children, a)), n.push(s);
    }), n;
  }
  var gg = "get", pg = "application/x-www-form-urlencoded";
  function r5(t) {
    return t != null && typeof t.tagName == "string";
  }
  function bB(t) {
    return r5(t) && t.tagName.toLowerCase() === "button";
  }
  function DB(t) {
    return r5(t) && t.tagName.toLowerCase() === "form";
  }
  function MB(t) {
    return r5(t) && t.tagName.toLowerCase() === "input";
  }
  function RB(t) {
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  function OB(t, e) {
    return t.button === 0 && (!e || e === "_self") && !RB(t);
  }
  var p2 = null;
  function IB() {
    if (p2 === null) try {
      new FormData(document.createElement("form"), 0), p2 = false;
    } catch {
      p2 = true;
    }
    return p2;
  }
  var VB = /* @__PURE__ */ new Set([
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  ]);
  function Y3(t) {
    return t != null && !VB.has(t) ? (Vs(false, `"${t}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${pg}"`), null) : t;
  }
  function NB(t, e) {
    let n, r, i, a, s;
    if (DB(t)) {
      let o = t.getAttribute("action");
      r = o ? So(o, e) : null, n = t.getAttribute("method") || gg, i = Y3(t.getAttribute("enctype")) || pg, a = new FormData(t);
    } else if (bB(t) || MB(t) && (t.type === "submit" || t.type === "image")) {
      let o = t.form;
      if (o == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
      let l = t.getAttribute("formaction") || o.getAttribute("action");
      if (r = l ? So(l, e) : null, n = t.getAttribute("formmethod") || o.getAttribute("method") || gg, i = Y3(t.getAttribute("formenctype")) || Y3(o.getAttribute("enctype")) || pg, a = new FormData(o, t), !IB()) {
        let { name: c, type: f, value: u } = t;
        if (f === "image") {
          let h = c ? `${c}.` : "";
          a.append(`${h}x`, "0"), a.append(`${h}y`, "0");
        } else c && a.append(c, u);
      }
    } else {
      if (r5(t)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
      n = gg, r = null, i = pg, s = t;
    }
    return a && i === "text/plain" && (s = a, a = void 0), {
      action: r,
      method: n.toLowerCase(),
      encType: i,
      formData: a,
      body: s
    };
  }
  Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
  function P6(t, e) {
    if (t === false || t === null || typeof t > "u") throw new Error(e);
  }
  function LB(t, e, n) {
    let r = typeof t == "string" ? new URL(t, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : t;
    return r.pathname === "/" ? r.pathname = `_root.${n}` : e && So(r.pathname, e) === "/" ? r.pathname = `${e.replace(/\/$/, "")}/_root.${n}` : r.pathname = `${r.pathname.replace(/\/$/, "")}.${n}`, r;
  }
  async function UB(t, e) {
    if (t.id in e) return e[t.id];
    try {
      let n = await import(t.module).then(async (m) => {
        await m.__tla;
        return m;
      });
      return e[t.id] = n, n;
    } catch (n) {
      return console.error(`Error loading route module \`${t.module}\`, reloading page...`), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
      });
    }
  }
  function FB(t) {
    return t == null ? false : t.href == null ? t.rel === "preload" && typeof t.imageSrcSet == "string" && typeof t.imageSizes == "string" : typeof t.rel == "string" && typeof t.href == "string";
  }
  async function BB(t, e, n) {
    let r = await Promise.all(t.map(async (i) => {
      let a = e.routes[i.route.id];
      if (a) {
        let s = await UB(a, n);
        return s.links ? s.links() : [];
      }
      return [];
    }));
    return GB(r.flat(1).filter(FB).filter((i) => i.rel === "stylesheet" || i.rel === "preload").map((i) => i.rel === "stylesheet" ? {
      ...i,
      rel: "prefetch",
      as: "style"
    } : {
      ...i,
      rel: "prefetch"
    }));
  }
  function Nw(t, e, n, r, i, a) {
    let s = (l, c) => n[c] ? l.route.id !== n[c].route.id : true, o = (l, c) => {
      var _a3;
      return n[c].pathname !== l.pathname || ((_a3 = n[c].route.path) == null ? void 0 : _a3.endsWith("*")) && n[c].params["*"] !== l.params["*"];
    };
    return a === "assets" ? e.filter((l, c) => s(l, c) || o(l, c)) : a === "data" ? e.filter((l, c) => {
      var _a3;
      let f = r.routes[l.route.id];
      if (!f || !f.hasLoader) return false;
      if (s(l, c) || o(l, c)) return true;
      if (l.route.shouldRevalidate) {
        let u = l.route.shouldRevalidate({
          currentUrl: new URL(i.pathname + i.search + i.hash, window.origin),
          currentParams: ((_a3 = n[0]) == null ? void 0 : _a3.params) || {},
          nextUrl: new URL(t, window.origin),
          nextParams: l.params,
          defaultShouldRevalidate: true
        });
        if (typeof u == "boolean") return u;
      }
      return true;
    }) : [];
  }
  function _B(t, e, { includeHydrateFallback: n } = {}) {
    return kB(t.map((r) => {
      let i = e.routes[r.route.id];
      if (!i) return [];
      let a = [
        i.module
      ];
      return i.clientActionModule && (a = a.concat(i.clientActionModule)), i.clientLoaderModule && (a = a.concat(i.clientLoaderModule)), n && i.hydrateFallbackModule && (a = a.concat(i.hydrateFallbackModule)), i.imports && (a = a.concat(i.imports)), a;
    }).flat(1));
  }
  function kB(t) {
    return [
      ...new Set(t)
    ];
  }
  function PB(t) {
    let e = {}, n = Object.keys(t).sort();
    for (let r of n) e[r] = t[r];
    return e;
  }
  function GB(t, e) {
    let n = /* @__PURE__ */ new Set();
    return new Set(e), t.reduce((r, i) => {
      let a = JSON.stringify(PB(i));
      return n.has(a) || (n.add(a), r.push({
        key: a,
        link: i
      })), r;
    }, []);
  }
  function yE() {
    let t = me.useContext(Ku);
    return P6(t, "You must render this element inside a <DataRouterContext.Provider> element"), t;
  }
  function zB() {
    let t = me.useContext(t5);
    return P6(t, "You must render this element inside a <DataRouterStateContext.Provider> element"), t;
  }
  var G6 = me.createContext(void 0);
  G6.displayName = "FrameworkContext";
  function xE() {
    let t = me.useContext(G6);
    return P6(t, "You must render this element inside a <HydratedRouter> element"), t;
  }
  function WB(t, e) {
    let n = me.useContext(G6), [r, i] = me.useState(false), [a, s] = me.useState(false), { onFocus: o, onBlur: l, onMouseEnter: c, onMouseLeave: f, onTouchStart: u } = e, h = me.useRef(null);
    me.useEffect(() => {
      if (t === "render" && s(true), t === "viewport") {
        let m = (w) => {
          w.forEach((C) => {
            s(C.isIntersecting);
          });
        }, y = new IntersectionObserver(m, {
          threshold: 0.5
        });
        return h.current && y.observe(h.current), () => {
          y.disconnect();
        };
      }
    }, [
      t
    ]), me.useEffect(() => {
      if (r) {
        let m = setTimeout(() => {
          s(true);
        }, 100);
        return () => {
          clearTimeout(m);
        };
      }
    }, [
      r
    ]);
    let g = () => {
      i(true);
    }, v = () => {
      i(false), s(false);
    };
    return n ? t !== "intent" ? [
      a,
      h,
      {}
    ] : [
      a,
      h,
      {
        onFocus: s1(o, g),
        onBlur: s1(l, v),
        onMouseEnter: s1(c, g),
        onMouseLeave: s1(f, v),
        onTouchStart: s1(u, g)
      }
    ] : [
      false,
      h,
      {}
    ];
  }
  function s1(t, e) {
    return (n) => {
      t && t(n), n.defaultPrevented || e(n);
    };
  }
  function HB({ page: t, ...e }) {
    let { router: n } = yE(), r = me.useMemo(() => sE(n.routes, t, n.basename), [
      n.routes,
      t,
      n.basename
    ]);
    return r ? me.createElement(KB, {
      page: t,
      matches: r,
      ...e
    }) : null;
  }
  function jB(t) {
    let { manifest: e, routeModules: n } = xE(), [r, i] = me.useState([]);
    return me.useEffect(() => {
      let a = false;
      return BB(t, e, n).then((s) => {
        a || i(s);
      }), () => {
        a = true;
      };
    }, [
      t,
      e,
      n
    ]), r;
  }
  function KB({ page: t, matches: e, ...n }) {
    let r = n0(), { manifest: i, routeModules: a } = xE(), { basename: s } = yE(), { loaderData: o, matches: l } = zB(), c = me.useMemo(() => Nw(t, e, l, i, r, "data"), [
      t,
      e,
      l,
      i,
      r
    ]), f = me.useMemo(() => Nw(t, e, l, i, r, "assets"), [
      t,
      e,
      l,
      i,
      r
    ]), u = me.useMemo(() => {
      if (t === r.pathname + r.search + r.hash) return [];
      let v = /* @__PURE__ */ new Set(), m = false;
      if (e.forEach((w) => {
        var _a3;
        let C = i.routes[w.route.id];
        !C || !C.hasLoader || (!c.some((T) => T.route.id === w.route.id) && w.route.id in o && ((_a3 = a[w.route.id]) == null ? void 0 : _a3.shouldRevalidate) || C.hasClientLoader ? m = true : v.add(w.route.id));
      }), v.size === 0) return [];
      let y = LB(t, s, "data");
      return m && v.size > 0 && y.searchParams.set("_routes", e.filter((w) => v.has(w.route.id)).map((w) => w.route.id).join(",")), [
        y.pathname + y.search
      ];
    }, [
      s,
      o,
      r,
      i,
      c,
      e,
      t,
      a
    ]), h = me.useMemo(() => _B(f, i), [
      f,
      i
    ]), g = jB(f);
    return me.createElement(me.Fragment, null, u.map((v) => me.createElement("link", {
      key: v,
      rel: "prefetch",
      as: "fetch",
      href: v,
      ...n
    })), h.map((v) => me.createElement("link", {
      key: v,
      rel: "modulepreload",
      href: v,
      ...n
    })), g.map(({ key: v, link: m }) => me.createElement("link", {
      key: v,
      nonce: n.nonce,
      ...m
    })));
  }
  function YB(...t) {
    return (e) => {
      t.forEach((n) => {
        typeof n == "function" ? n(e) : n != null && (n.current = e);
      });
    };
  }
  var wE = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  try {
    wE && (window.__reactRouterVersion = "7.8.1");
  } catch {
  }
  function qB({ basename: t, children: e, window: n }) {
    let r = me.useRef();
    r.current == null && (r.current = FF({
      window: n,
      v5Compat: true
    }));
    let i = r.current, [a, s] = me.useState({
      action: i.action,
      location: i.location
    }), o = me.useCallback((l) => {
      me.startTransition(() => s(l));
    }, [
      s
    ]);
    return me.useLayoutEffect(() => i.listen(o), [
      i,
      o
    ]), me.createElement(AB, {
      basename: t,
      children: e,
      location: a.location,
      navigationType: a.action,
      navigator: i
    });
  }
  var CE = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, TE = me.forwardRef(function({ onClick: e, discover: n = "render", prefetch: r = "none", relative: i, reloadDocument: a, replace: s, state: o, target: l, to: c, preventScrollReset: f, viewTransition: u, ...h }, g) {
    let { basename: v } = me.useContext(Us), m = typeof c == "string" && CE.test(c), y, w = false;
    if (typeof c == "string" && m && (y = c, wE)) try {
      let I = new URL(window.location.href), O = c.startsWith("//") ? new URL(I.protocol + c) : new URL(c), L = So(O.pathname, v);
      O.origin === I.origin && L != null ? c = L + O.search + O.hash : w = true;
    } catch {
      Vs(false, `<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);
    }
    let C = cB(c, {
      relative: i
    }), [T, S, E] = WB(r, h), b = JB(c, {
      replace: s,
      state: o,
      target: l,
      preventScrollReset: f,
      relative: i,
      viewTransition: u
    });
    function D(I) {
      e && e(I), I.defaultPrevented || b(I);
    }
    let R = me.createElement("a", {
      ...h,
      ...E,
      href: y || C,
      onClick: w || a ? e : D,
      ref: YB(g, S),
      target: l,
      "data-discover": !m && n === "render" ? "true" : void 0
    });
    return T && !m ? me.createElement(me.Fragment, null, R, me.createElement(HB, {
      page: C
    })) : R;
  });
  TE.displayName = "Link";
  var XB = me.forwardRef(function({ "aria-current": e = "page", caseSensitive: n = false, className: r = "", end: i = false, style: a, to: s, viewTransition: o, children: l, ...c }, f) {
    let u = Hh(s, {
      relative: c.relative
    }), h = n0(), g = me.useContext(t5), { navigator: v, basename: m } = me.useContext(Us), y = g != null && r_(u) && o === true, w = v.encodeLocation ? v.encodeLocation(u).pathname : u.pathname, C = h.pathname, T = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
    n || (C = C.toLowerCase(), T = T ? T.toLowerCase() : null, w = w.toLowerCase()), T && m && (T = So(T, m) || T);
    const S = w !== "/" && w.endsWith("/") ? w.length - 1 : w.length;
    let E = C === w || !i && C.startsWith(w) && C.charAt(S) === "/", b = T != null && (T === w || !i && T.startsWith(w) && T.charAt(w.length) === "/"), D = {
      isActive: E,
      isPending: b,
      isTransitioning: y
    }, R = E ? e : void 0, I;
    typeof r == "function" ? I = r(D) : I = [
      r,
      E ? "active" : null,
      b ? "pending" : null,
      y ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let O = typeof a == "function" ? a(D) : a;
    return me.createElement(TE, {
      ...c,
      "aria-current": R,
      className: I,
      ref: f,
      style: O,
      to: s,
      viewTransition: o
    }, typeof l == "function" ? l(D) : l);
  });
  XB.displayName = "NavLink";
  var ZB = me.forwardRef(({ discover: t = "render", fetcherKey: e, navigate: n, reloadDocument: r, replace: i, state: a, method: s = gg, action: o, onSubmit: l, relative: c, preventScrollReset: f, viewTransition: u, ...h }, g) => {
    let v = t_(), m = n_(o, {
      relative: c
    }), y = s.toLowerCase() === "get" ? "get" : "post", w = typeof o == "string" && CE.test(o), C = (T) => {
      if (l && l(T), T.defaultPrevented) return;
      T.preventDefault();
      let S = T.nativeEvent.submitter, E = (S == null ? void 0 : S.getAttribute("formmethod")) || s;
      v(S || T.currentTarget, {
        fetcherKey: e,
        method: E,
        navigate: n,
        replace: i,
        state: a,
        relative: c,
        preventScrollReset: f,
        viewTransition: u
      });
    };
    return me.createElement("form", {
      ref: g,
      method: y,
      action: m,
      onSubmit: r ? l : C,
      ...h,
      "data-discover": !w && t === "render" ? "true" : void 0
    });
  });
  ZB.displayName = "Form";
  function QB(t) {
    return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function SE(t) {
    let e = me.useContext(Ku);
    return or(e, QB(t)), e;
  }
  function JB(t, { target: e, replace: n, state: r, preventScrollReset: i, relative: a, viewTransition: s } = {}) {
    let o = n5(), l = n0(), c = Hh(t, {
      relative: a
    });
    return me.useCallback((f) => {
      if (OB(f, e)) {
        f.preventDefault();
        let u = n !== void 0 ? n : yh(l) === yh(c);
        o(t, {
          replace: u,
          state: r,
          preventScrollReset: i,
          relative: a,
          viewTransition: s
        });
      }
    }, [
      l,
      o,
      c,
      n,
      r,
      e,
      t,
      i,
      a,
      s
    ]);
  }
  var $B = 0, e_ = () => `__${String(++$B)}__`;
  function t_() {
    let { router: t } = SE("useSubmit"), { basename: e } = me.useContext(Us), n = wB();
    return me.useCallback(async (r, i = {}) => {
      let { action: a, method: s, encType: o, formData: l, body: c } = NB(r, e);
      if (i.navigate === false) {
        let f = i.fetcherKey || e_();
        await t.fetch(f, n, i.action || a, {
          preventScrollReset: i.preventScrollReset,
          formData: l,
          body: c,
          formMethod: i.method || s,
          formEncType: i.encType || o,
          flushSync: i.flushSync
        });
      } else await t.navigate(i.action || a, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: c,
        formMethod: i.method || s,
        formEncType: i.encType || o,
        replace: i.replace,
        state: i.state,
        fromRouteId: n,
        flushSync: i.flushSync,
        viewTransition: i.viewTransition
      });
    }, [
      t,
      e,
      n
    ]);
  }
  function n_(t, { relative: e } = {}) {
    let { basename: n } = me.useContext(Us), r = me.useContext(Fs);
    or(r, "useFormAction must be used inside a RouteContext");
    let [i] = r.matches.slice(-1), a = {
      ...Hh(t || ".", {
        relative: e
      })
    }, s = n0();
    if (t == null) {
      a.search = s.search;
      let o = new URLSearchParams(a.search), l = o.getAll("index");
      if (l.some((f) => f === "")) {
        o.delete("index"), l.filter((u) => u).forEach((u) => o.append("index", u));
        let f = o.toString();
        a.search = f ? `?${f}` : "";
      }
    }
    return (!t || t === ".") && i.route.index && (a.search = a.search ? a.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (a.pathname = a.pathname === "/" ? n : po([
      n,
      a.pathname
    ])), yh(a);
  }
  function r_(t, { relative: e } = {}) {
    let n = me.useContext(hE);
    or(n != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let { basename: r } = SE("useViewTransitionState"), i = Hh(t, {
      relative: e
    });
    if (!n.isTransitioning) return false;
    let a = So(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = So(n.nextLocation.pathname, r) || n.nextLocation.pathname;
    return Qg(i.pathname, s) != null || Qg(i.pathname, a) != null;
  }
  const i_ = me.createContext({
    annotationType: "",
    annotationColor: "blue",
    segmentationType: [
      "aorta"
    ],
    segmentationOpacity: 0.5,
    setSegmentationOpacity: () => {
    },
    setAnnotationColor: () => {
    },
    setAnnotationType: () => {
    },
    setSegmentationType: () => {
    }
  }), a_ = ({ children: t }) => {
    const [e, n] = me.useState(""), [r, i] = me.useState("blue"), [a, s] = me.useState(0.5), [o, l] = me.useState([
      "aorta"
    ]);
    return be.jsx(i_.Provider, {
      value: {
        annotationType: e,
        setAnnotationType: n,
        annotationColor: r,
        setAnnotationColor: i,
        segmentationType: o,
        setSegmentationType: l,
        segmentationOpacity: a,
        setSegmentationOpacity: s
      },
      children: t
    });
  }, s_ = me.createContext({
    files: [],
    setFiles: () => {
    }
  }), o_ = ({ children: t }) => {
    const [e, n] = me.useState([]);
    return be.jsx(s_.Provider, {
      value: {
        files: e,
        setFiles: n
      },
      children: t
    });
  };
  function l_({ aboutRef: t }) {
    return be.jsx("section", {
      ref: t,
      className: "flex flex-col gap-4 justify-center items-center w-screen",
      children: be.jsxs("div", {
        className: "flex flex-col gap-1.5 w-6/12 items-center",
        children: [
          be.jsx("div", {
            className: "text-2xl font-bold",
            children: "About PanTS"
          }),
          be.jsxs("p", {
            children: [
              "The Pancreatic Tumor Segmentation Dataset (PanTS) is a multi-institutional dataset created by JHU containing",
              " ",
              be.jsx("span", {
                className: "font-bold",
                children: "36,390"
              }),
              " three-dimensional CT volumes in ",
              be.jsx("span", {
                className: "font-bold",
                children: "145"
              }),
              " medical centers, with expert wise voxel annotations of over",
              " ",
              be.jsx("span", {
                className: "font-bold",
                children: "993,000"
              }),
              " anatomical structures. This website aims to allow users to visualize and explore the dataset."
            ]
          }),
          be.jsx("br", {}),
          be.jsxs("div", {
            children: [
              "If you would like to know more about PanTS, refer to the",
              " ",
              be.jsx("span", {
                className: "font-bold cursor-pointer underline",
                onClick: () => window.location.href = "https://www.cs.jhu.edu/~zongwei/publication/li2025pants.pdf",
                children: "paper"
              })
            ]
          })
        ]
      })
    });
  }
  function c_({ handleAboutClick: t }) {
    const e = n5();
    return be.jsxs("header", {
      className: "flex items-center pl-8 justify-start gap-20 w-screen p-4 bg-black relative",
      children: [
        be.jsx("div", {
          className: "text-4xl cursor-pointer",
          onClick: () => e("/"),
          children: "PanTS Data"
        }),
        be.jsxs("div", {
          className: "flex items-center gap-8 justify-center",
          children: [
            be.jsxs("div", {
              className: "text-lg cursor-pointer group relative",
              children: [
                "Browse Full Catalog",
                be.jsxs("div", {
                  className: "scale-0 flex flex-col rounded gap-2 p-2 w-full transition-all bg-gray-800 absolute top-8 origin-top group-hover:scale-100 duration-100",
                  children: [
                    be.jsx("div", {
                      className: "cursor-pointer hover:bg-gray-700 rounded p-0.5 text-base",
                      children: "Train"
                    }),
                    be.jsx("div", {
                      className: "cursor-pointer hover:bg-gray-700 rounded p-0.5 text-base",
                      onClick: () => e("/"),
                      children: "Test"
                    })
                  ]
                })
              ]
            }),
            be.jsx("div", {
              className: "text-lg cursor-pointer",
              onClick: () => window.location.href = "https://github.com/MrGiovanni/PanTS",
              children: "Github"
            }),
            be.jsx("div", {
              className: "text-lg cursor-pointer",
              onClick: () => t(),
              children: "About"
            })
          ]
        })
      ]
    });
  }
  const i5 = "https://localhost:5001", Rv = [
    "adrenal_gland_left",
    "adrenal_gland_right",
    "aorta",
    "bladder",
    "celiac_artery",
    "colon",
    "common_bile_duct",
    "duodenum",
    "femur_left",
    "femur_right",
    "gall_bladder",
    "kidney_left",
    "kidney_right",
    "liver",
    "lung_left",
    "lung_right",
    "pancreas_body",
    "pancreas_head",
    "pancreas_tail",
    "pancreas",
    "pancreatic_duct",
    "pancreatic_lesion",
    "postcava",
    "prostate",
    "spleen",
    "stomach",
    "superior_mesenteric_artery",
    "veins"
  ], u_ = [
    "Vascular System",
    "Adrenal Glands",
    "Pancreas",
    "Kidneys",
    "Femur",
    "Lung",
    "Digestive System",
    "Other"
  ], Lw = {
    "Vascular System": [
      "aorta",
      "celiac_artery",
      "postcava",
      "superior_mesenteric_artery",
      "veins"
    ],
    "Adrenal Glands": [
      "adrenal_gland_left",
      "adrenal_gland_right"
    ],
    Pancreas: [
      "pancreas_body",
      "pancreas_head",
      "pancreas_tail",
      "pancreas",
      "pancreatic_duct",
      "pancreatic_lesion"
    ],
    Kidneys: [
      "kidney_left",
      "kidney_right"
    ],
    Femur: [
      "femur_left",
      "femur_right"
    ],
    "Digestive System": [
      "colon",
      "common_bile_duct",
      "duodenum",
      "gall_bladder",
      "liver",
      "stomach"
    ],
    Lung: [
      "lung_left",
      "lung_right"
    ],
    Other: [
      "prostate",
      "bladder",
      "spleen"
    ]
  }, f_ = [
    230,
    25,
    75,
    255
  ], h_ = [
    0,
    130,
    200,
    255
  ], d_ = [
    128,
    0,
    0,
    255
  ], g_ = [
    170,
    110,
    40,
    255
  ], p_ = [
    128,
    128,
    0,
    255
  ], m_ = [
    0,
    128,
    128,
    255
  ], v_ = [
    145,
    30,
    180,
    255
  ], y_ = [
    240,
    50,
    230,
    255
  ], x_ = [
    50,
    205,
    50,
    255
  ], Ov = {
    0: [
      0,
      0,
      0,
      0
    ],
    1: f_,
    2: h_,
    3: d_,
    4: g_,
    5: p_,
    6: m_,
    7: v_,
    8: y_,
    9: x_
  }, AE = 128;
  function w_() {
    const t = [], e = [], n = [], r = [], i = [];
    return Object.keys(Ov).forEach((s) => {
      i.push(Number(s));
      const o = Ov[Number(s)];
      t.push(o[0]), e.push(o[1]), n.push(o[2]), s === "0" ? r.push(0) : r.push(AE);
    }), {
      R: t,
      G: e,
      B: n,
      A: r,
      I: i
    };
  }
  const ls = {
    DEFAULT_SEGMENTATION_OPACITY: 0.6,
    API_ORIGIN: i5,
    cornerstoneCustomColorLUT: Ov,
    NVCmapAlpha: AE,
    NVColormap: w_()
  };
  function C_({ id: t, previewMetadata: e }) {
    const n = n5(), [r, i] = me.useState("");
    return me.useEffect(() => {
      (async () => {
        try {
          const s = await fetch(`${i5}/api/get_image_preview/${t}`);
          if (!s.ok) throw new Error(`Failed to fetch preview: ${s.status} ${s.statusText}`);
          const o = await s.blob(), l = URL.createObjectURL(o);
          i(l);
        } catch (s) {
          console.error(s);
        }
      })();
    }, [
      t
    ]), e ? be.jsxs("div", {
      className: "flex flex-col gap-2 shadow-md p-4 rounded bg-blue-950",
      children: [
        be.jsxs("div", {
          className: "flex flex-col gap-1",
          children: [
            be.jsx("div", {
              className: "w-[400px] h-[300px] relative",
              children: be.jsx("img", {
                src: `/case_${t}_slice.png`,
                alt: "Preview",
                className: "w-full h-full object-cover absolute top-0 left-0 opacity-95"
              })
            }),
            be.jsxs("p", {
              className: "font-bold text-lg",
              children: [
                "Case ",
                t
              ]
            }),
            be.jsxs("div", {
              children: [
                "Age: ",
                e.age || "-"
              ]
            }),
            be.jsxs("div", {
              children: [
                "Sex: ",
                e.sex || "-"
              ]
            })
          ]
        }),
        be.jsx("button", {
          onClick: () => n(`/case/${t}`),
          className: "w-full",
          children: "View Case"
        })
      ]
    }) : null;
  }
  const Uw = [
    1,
    17,
    30,
    35,
    121
  ];
  function T_() {
    const [t, e] = me.useState({}), [n, r] = me.useState(true), i = me.useRef(null), s = pE().type || "train";
    me.useEffect(() => {
      (async () => {
        try {
          const f = await (await fetch(`${i5}/api/get_preview/${Uw.join(",")}`)).json();
          for (const u in f) f[u].age = Number(f[u].age), e((h) => ({
            ...h,
            [u]: f[u]
          }));
          r(false);
        } catch (c) {
          console.error(c);
        }
      })();
    }, []);
    const o = () => {
      var _a3;
      (_a3 = i.current) == null ? void 0 : _a3.scrollIntoView({
        behavior: "smooth"
      });
    };
    return s.toLowerCase() !== "test" && (s == null ? void 0 : s.toLowerCase()) !== "train" ? null : be.jsxs("div", {
      className: "flex gap-4 flex-col text-white relative min-h-screen",
      children: [
        be.jsx(c_, {
          handleAboutClick: o
        }),
        be.jsxs("div", {
          className: "flex flex-col gap-4 p-4 justify-center items-center w-screen",
          children: [
            be.jsx("div", {
              className: "text-2xl font-bold",
              children: "Previews"
            }),
            be.jsx("hr", {
              className: "w-screen"
            }),
            be.jsx("div", {
              className: "flex gap-y-4 gap-x-8 p-4 flex-wrap justify-center relative items-center w-full",
              children: n ? be.jsx("div", {
                className: "flex z-3 items-center justify-center w-56 h-56 border border-gray-200 rounded-lg dark:border-gray-700",
                children: be.jsxs("div", {
                  role: "status",
                  children: [
                    be.jsxs("svg", {
                      "aria-hidden": "true",
                      className: "w-8 h-8 text-gray-200 animate-spin dark:text-gray-600 fill-blue-600",
                      viewBox: "0 0 100 101",
                      fill: "none",
                      xmlns: "http://www.w3.org/2000/svg",
                      children: [
                        be.jsx("path", {
                          d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                          fill: "currentColor"
                        }),
                        be.jsx("path", {
                          d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                          fill: "currentFill"
                        })
                      ]
                    }),
                    be.jsx("span", {
                      className: "sr-only",
                      children: "Loading..."
                    })
                  ]
                })
              }) : Uw.map((l, c) => be.jsx(C_, {
                id: l,
                previewMetadata: t[l]
              }, c.toString()))
            })
          ]
        }),
        be.jsx("hr", {
          className: "w-full"
        }),
        be.jsx(l_, {
          aboutRef: i
        })
      ]
    });
  }
  var EE = 1e-6, $r = typeof Float32Array < "u" ? Float32Array : Array;
  function xh(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EE;
    return Math.abs(t - e) <= n * Math.max(1, Math.abs(t), Math.abs(e));
  }
  function S_() {
    var t = new $r(9);
    return $r != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
  }
  function as(t, e, n, r, i, a, s, o, l) {
    var c = new $r(9);
    return c[0] = t, c[1] = e, c[2] = n, c[3] = r, c[4] = i, c[5] = a, c[6] = s, c[7] = o, c[8] = l, c;
  }
  function H0(t) {
    var e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], s = t[5], o = t[6], l = t[7], c = t[8];
    return e * (c * a - s * l) + n * (-c * i + s * o) + r * (l * i - a * o);
  }
  function bE(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], u = e[8], h = n[0], g = n[1], v = n[2], m = n[3], y = n[4], w = n[5], C = n[6], T = n[7], S = n[8];
    return t[0] = h * r + g * s + v * c, t[1] = h * i + g * o + v * f, t[2] = h * a + g * l + v * u, t[3] = m * r + y * s + w * c, t[4] = m * i + y * o + w * f, t[5] = m * a + y * l + w * u, t[6] = C * r + T * s + S * c, t[7] = C * i + T * o + S * f, t[8] = C * a + T * l + S * u, t;
  }
  function Yt() {
    var t = new $r(16);
    return $r != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
  }
  function Tr(t) {
    var e = new $r(16);
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  function Iv(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
  }
  function Qi(t, e, n, r, i, a, s, o, l, c, f, u, h, g, v, m) {
    var y = new $r(16);
    return y[0] = t, y[1] = e, y[2] = n, y[3] = r, y[4] = i, y[5] = a, y[6] = s, y[7] = o, y[8] = l, y[9] = c, y[10] = f, y[11] = u, y[12] = h, y[13] = g, y[14] = v, y[15] = m, y;
  }
  function Jg(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }
  function _i(t, e) {
    if (t === e) {
      var n = e[1], r = e[2], i = e[3], a = e[6], s = e[7], o = e[11];
      t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = a, t[11] = e[14], t[12] = i, t[13] = s, t[14] = o;
    } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
    return t;
  }
  function Ti(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], c = e[7], f = e[8], u = e[9], h = e[10], g = e[11], v = e[12], m = e[13], y = e[14], w = e[15], C = n * o - r * s, T = n * l - i * s, S = n * c - a * s, E = r * l - i * o, b = r * c - a * o, D = i * c - a * l, R = f * m - u * v, I = f * y - h * v, O = f * w - g * v, L = u * y - h * m, N = u * w - g * m, F = h * w - g * y, V = C * F - T * N + S * L + E * O - b * I + D * R;
    return V ? (V = 1 / V, t[0] = (o * F - l * N + c * L) * V, t[1] = (i * N - r * F - a * L) * V, t[2] = (m * D - y * b + w * E) * V, t[3] = (h * b - u * D - g * E) * V, t[4] = (l * O - s * F - c * I) * V, t[5] = (n * F - i * O + a * I) * V, t[6] = (y * S - v * D - w * T) * V, t[7] = (f * D - h * S + g * T) * V, t[8] = (s * N - o * O + c * R) * V, t[9] = (r * O - n * N - a * R) * V, t[10] = (v * b - m * S + w * C) * V, t[11] = (u * S - f * b - g * C) * V, t[12] = (o * I - s * L - l * R) * V, t[13] = (n * L - r * I + i * R) * V, t[14] = (m * T - v * E - y * C) * V, t[15] = (f * E - u * T + h * C) * V, t) : null;
  }
  function ml(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], u = e[8], h = e[9], g = e[10], v = e[11], m = e[12], y = e[13], w = e[14], C = e[15], T = n[0], S = n[1], E = n[2], b = n[3];
    return t[0] = T * r + S * o + E * u + b * m, t[1] = T * i + S * l + E * h + b * y, t[2] = T * a + S * c + E * g + b * w, t[3] = T * s + S * f + E * v + b * C, T = n[4], S = n[5], E = n[6], b = n[7], t[4] = T * r + S * o + E * u + b * m, t[5] = T * i + S * l + E * h + b * y, t[6] = T * a + S * c + E * g + b * w, t[7] = T * s + S * f + E * v + b * C, T = n[8], S = n[9], E = n[10], b = n[11], t[8] = T * r + S * o + E * u + b * m, t[9] = T * i + S * l + E * h + b * y, t[10] = T * a + S * c + E * g + b * w, t[11] = T * s + S * f + E * v + b * C, T = n[12], S = n[13], E = n[14], b = n[15], t[12] = T * r + S * o + E * u + b * m, t[13] = T * i + S * l + E * h + b * y, t[14] = T * a + S * c + E * g + b * w, t[15] = T * s + S * f + E * v + b * C, t;
  }
  function au(t, e, n) {
    var r = n[0], i = n[1], a = n[2], s, o, l, c, f, u, h, g, v, m, y, w;
    return e === t ? (t[12] = e[0] * r + e[4] * i + e[8] * a + e[12], t[13] = e[1] * r + e[5] * i + e[9] * a + e[13], t[14] = e[2] * r + e[6] * i + e[10] * a + e[14], t[15] = e[3] * r + e[7] * i + e[11] * a + e[15]) : (s = e[0], o = e[1], l = e[2], c = e[3], f = e[4], u = e[5], h = e[6], g = e[7], v = e[8], m = e[9], y = e[10], w = e[11], t[0] = s, t[1] = o, t[2] = l, t[3] = c, t[4] = f, t[5] = u, t[6] = h, t[7] = g, t[8] = v, t[9] = m, t[10] = y, t[11] = w, t[12] = s * r + f * i + v * a + e[12], t[13] = o * r + u * i + m * a + e[13], t[14] = l * r + h * i + y * a + e[14], t[15] = c * r + g * i + w * a + e[15]), t;
  }
  function Vv(t, e, n) {
    var r = n[0], i = n[1], a = n[2];
    return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
  }
  function m2(t, e, n) {
    var r = Math.sin(n), i = Math.cos(n), a = e[4], s = e[5], o = e[6], l = e[7], c = e[8], f = e[9], u = e[10], h = e[11];
    return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * i + c * r, t[5] = s * i + f * r, t[6] = o * i + u * r, t[7] = l * i + h * r, t[8] = c * i - a * r, t[9] = f * i - s * r, t[10] = u * i - o * r, t[11] = h * i - l * r, t;
  }
  function v2(t, e, n) {
    var r = Math.sin(n), i = Math.cos(n), a = e[0], s = e[1], o = e[2], l = e[3], c = e[4], f = e[5], u = e[6], h = e[7];
    return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i + c * r, t[1] = s * i + f * r, t[2] = o * i + u * r, t[3] = l * i + h * r, t[4] = c * i - a * r, t[5] = f * i - s * r, t[6] = u * i - o * r, t[7] = h * i - l * r, t;
  }
  function A_(t, e) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t;
  }
  function DE(t, e, n) {
    var r = n[0], i = n[1], a = n[2], s = Math.sqrt(r * r + i * i + a * a), o, l, c;
    return s < EE ? null : (s = 1 / s, r *= s, i *= s, a *= s, o = Math.sin(e), l = Math.cos(e), c = 1 - l, t[0] = r * r * c + l, t[1] = i * r * c + a * o, t[2] = a * r * c - i * o, t[3] = 0, t[4] = r * i * c - a * o, t[5] = i * i * c + l, t[6] = a * i * c + r * o, t[7] = 0, t[8] = r * a * c + i * o, t[9] = i * a * c - r * o, t[10] = a * a * c + l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
  }
  function E_(t, e, n, r, i, a, s) {
    var o = 1 / (e - n), l = 1 / (r - i), c = 1 / (a - s);
    return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (e + n) * o, t[13] = (i + r) * l, t[14] = (s + a) * c, t[15] = 1, t;
  }
  var U1 = E_;
  function b_(t, e, n) {
    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12] * n, t[13] = e[13] * n, t[14] = e[14] * n, t[15] = e[15] * n, t;
  }
  var ME = ml;
  function He() {
    var t = new $r(3);
    return $r != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
  }
  function ki(t) {
    var e = new $r(3);
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
  }
  function Ms(t) {
    var e = t[0], n = t[1], r = t[2];
    return Math.sqrt(e * e + n * n + r * r);
  }
  function Ue(t, e, n) {
    var r = new $r(3);
    return r[0] = t, r[1] = e, r[2] = n, r;
  }
  function Du(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;
  }
  function Ml(t, e, n, r) {
    return t[0] = e, t[1] = n, t[2] = r, t;
  }
  function Ai(t, e, n) {
    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t;
  }
  function Ft(t, e, n) {
    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t;
  }
  function z6(t, e, n) {
    return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t;
  }
  function W6(t, e, n) {
    return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t;
  }
  function a5(t, e, n) {
    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t;
  }
  function Xr(t, e, n, r) {
    return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t;
  }
  function Mu(t, e) {
    var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2];
    return Math.sqrt(n * n + r * r + i * i);
  }
  function Rl(t, e) {
    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;
  }
  function Pr(t, e) {
    var n = e[0], r = e[1], i = e[2], a = n * n + r * r + i * i;
    return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t;
  }
  function Bt(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
  }
  function Vr(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = n[0], o = n[1], l = n[2];
    return t[0] = i * l - a * o, t[1] = a * s - r * l, t[2] = r * o - i * s, t;
  }
  function D_(t, e, n, r) {
    var i = e[0], a = e[1], s = e[2];
    return t[0] = i + r * (n[0] - i), t[1] = a + r * (n[1] - a), t[2] = s + r * (n[2] - s), t;
  }
  function M_(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = n[3] * r + n[7] * i + n[11] * a + n[15];
    return s = s || 1, t[0] = (n[0] * r + n[4] * i + n[8] * a + n[12]) / s, t[1] = (n[1] * r + n[5] * i + n[9] * a + n[13]) / s, t[2] = (n[2] * r + n[6] * i + n[10] * a + n[14]) / s, t;
  }
  function th(t, e) {
    var n = t[0], r = t[1], i = t[2], a = e[0], s = e[1], o = e[2], l = Math.sqrt((n * n + r * r + i * i) * (a * a + s * s + o * o)), c = l && Bt(t, e) / l;
    return Math.acos(Math.min(Math.max(c, -1), 1));
  }
  var hi = Ft, Pc = Ms;
  (function() {
    var t = He();
    return function(e, n, r, i, a, s) {
      var o, l;
      for (n || (n = 3), r || (r = 0), i ? l = Math.min(i * n + r, e.length) : l = e.length, o = r; o < l; o += n) t[0] = e[o], t[1] = e[o + 1], t[2] = e[o + 2], a(t, t, s), e[o] = t[0], e[o + 1] = t[1], e[o + 2] = t[2];
      return e;
    };
  })();
  function Rs() {
    var t = new $r(4);
    return $r != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
  }
  function Tl(t) {
    var e = new $r(4);
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
  }
  function zn(t, e, n, r) {
    var i = new $r(4);
    return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i;
  }
  function Fw(t, e, n) {
    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t;
  }
  function R_(t, e, n) {
    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t;
  }
  function O_(t, e, n) {
    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t;
  }
  function Zr(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3];
    return t[0] = n[0] * r + n[4] * i + n[8] * a + n[12] * s, t[1] = n[1] * r + n[5] * i + n[9] * a + n[13] * s, t[2] = n[2] * r + n[6] * i + n[10] * a + n[14] * s, t[3] = n[3] * r + n[7] * i + n[11] * a + n[15] * s, t;
  }
  var I_ = R_;
  (function() {
    var t = Rs();
    return function(e, n, r, i, a, s) {
      var o, l;
      for (n || (n = 4), r || (r = 0), i ? l = Math.min(i * n + r, e.length) : l = e.length, o = r; o < l; o += n) t[0] = e[o], t[1] = e[o + 1], t[2] = e[o + 2], t[3] = e[o + 3], a(t, t, s), e[o] = t[0], e[o + 1] = t[1], e[o + 2] = t[2], e[o + 3] = t[3];
      return e;
    };
  })();
  function mo() {
    var t = new $r(2);
    return $r != Float32Array && (t[0] = 0, t[1] = 0), t;
  }
  function $g(t, e) {
    var n = new $r(2);
    return n[0] = t, n[1] = e, n;
  }
  function mu(t, e, n) {
    return t[0] = e, t[1] = n, t;
  }
  function H6(t, e, n) {
    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t;
  }
  function Ru(t, e, n) {
    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t;
  }
  function Nv(t, e, n) {
    return t[0] = e[0] * n, t[1] = e[1] * n, t;
  }
  function Jr(t, e) {
    var n = e[0] - t[0], r = e[1] - t[1];
    return Math.sqrt(n * n + r * r);
  }
  function Bw(t) {
    var e = t[0], n = t[1];
    return Math.sqrt(e * e + n * n);
  }
  function j6(t, e) {
    var n = e[0], r = e[1], i = n * n + r * r;
    return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t;
  }
  function V_(t, e) {
    return t[0] * e[0] + t[1] * e[1];
  }
  var ep = Ru, K6 = Jr;
  (function() {
    var t = mo();
    return function(e, n, r, i, a, s) {
      var o, l;
      for (n || (n = 2), r || (r = 0), i ? l = Math.min(i * n + r, e.length) : l = e.length, o = r; o < l; o += n) t[0] = e[o], t[1] = e[o + 1], a(t, t, s), e[o] = t[0], e[o + 1] = t[1];
      return e;
    };
  })();
  var Ic = 256, mg = [], y2;
  for (; Ic--; ) mg[Ic] = (Ic + 256).toString(16).substring(1);
  function Lv() {
    var t = 0, e, n = "";
    if (!y2 || Ic + 16 > 256) {
      for (y2 = Array(t = 256); t--; ) y2[t] = 256 * Math.random() | 0;
      t = Ic = 0;
    }
    for (; t < 16; t++) e = y2[Ic + t], t == 6 ? n += mg[e & 15 | 64] : t == 8 ? n += mg[e & 63 | 128] : n += mg[e], t & 1 && t > 1 && t < 11 && (n += "-");
    return Ic++, n;
  }
  var q3, _w;
  function N_() {
    return _w || (_w = 1, q3 = function(e, n) {
      var r = e.length;
      if (e === n) return true;
      if (r !== n.length) return false;
      for (var i = 0; i < r; i++) if (e[i] !== n[i]) return false;
      return true;
    }), q3;
  }
  var L_ = N_();
  const U_ = t0(L_), RE = -1, s5 = 0, nh = 1, tp = 2, Y6 = 3, q6 = 4, X6 = 5, Z6 = 6, OE = 7, IE = 8, kw = typeof self == "object" ? self : globalThis, F_ = (t, e) => {
    const n = (i, a) => (t.set(a, i), i), r = (i) => {
      if (t.has(i)) return t.get(i);
      const [a, s] = e[i];
      switch (a) {
        case s5:
        case RE:
          return n(s, i);
        case nh: {
          const o = n([], i);
          for (const l of s) o.push(r(l));
          return o;
        }
        case tp: {
          const o = n({}, i);
          for (const [l, c] of s) o[r(l)] = r(c);
          return o;
        }
        case Y6:
          return n(new Date(s), i);
        case q6: {
          const { source: o, flags: l } = s;
          return n(new RegExp(o, l), i);
        }
        case X6: {
          const o = n(/* @__PURE__ */ new Map(), i);
          for (const [l, c] of s) o.set(r(l), r(c));
          return o;
        }
        case Z6: {
          const o = n(/* @__PURE__ */ new Set(), i);
          for (const l of s) o.add(r(l));
          return o;
        }
        case OE: {
          const { name: o, message: l } = s;
          return n(new kw[o](l), i);
        }
        case IE:
          return n(BigInt(s), i);
        case "BigInt":
          return n(Object(BigInt(s)), i);
        case "ArrayBuffer":
          return n(new Uint8Array(s).buffer, s);
        case "DataView": {
          const { buffer: o } = new Uint8Array(s);
          return n(new DataView(o), s);
        }
      }
      return n(new kw[a](s), i);
    };
    return r;
  }, B_ = (t) => F_(/* @__PURE__ */ new Map(), t)(0), j0 = "", { toString: __ } = {}, { keys: k_ } = Object, o1 = (t) => {
    const e = typeof t;
    if (e !== "object" || !t) return [
      s5,
      e
    ];
    const n = __.call(t).slice(8, -1);
    switch (n) {
      case "Array":
        return [
          nh,
          j0
        ];
      case "Object":
        return [
          tp,
          j0
        ];
      case "Date":
        return [
          Y6,
          j0
        ];
      case "RegExp":
        return [
          q6,
          j0
        ];
      case "Map":
        return [
          X6,
          j0
        ];
      case "Set":
        return [
          Z6,
          j0
        ];
      case "DataView":
        return [
          nh,
          n
        ];
    }
    return n.includes("Array") ? [
      nh,
      n
    ] : n.includes("Error") ? [
      OE,
      n
    ] : [
      tp,
      n
    ];
  }, x2 = ([t, e]) => t === s5 && (e === "function" || e === "symbol"), P_ = (t, e, n, r) => {
    const i = (s, o) => {
      const l = r.push(s) - 1;
      return n.set(o, l), l;
    }, a = (s) => {
      if (n.has(s)) return n.get(s);
      let [o, l] = o1(s);
      switch (o) {
        case s5: {
          let f = s;
          switch (l) {
            case "bigint":
              o = IE, f = s.toString();
              break;
            case "function":
            case "symbol":
              if (t) throw new TypeError("unable to serialize " + l);
              f = null;
              break;
            case "undefined":
              return i([
                RE
              ], s);
          }
          return i([
            o,
            f
          ], s);
        }
        case nh: {
          if (l) {
            let h = s;
            return l === "DataView" ? h = new Uint8Array(s.buffer) : l === "ArrayBuffer" && (h = new Uint8Array(s)), i([
              l,
              [
                ...h
              ]
            ], s);
          }
          const f = [], u = i([
            o,
            f
          ], s);
          for (const h of s) f.push(a(h));
          return u;
        }
        case tp: {
          if (l) switch (l) {
            case "BigInt":
              return i([
                l,
                s.toString()
              ], s);
            case "Boolean":
            case "Number":
            case "String":
              return i([
                l,
                s.valueOf()
              ], s);
          }
          if (e && "toJSON" in s) return a(s.toJSON());
          const f = [], u = i([
            o,
            f
          ], s);
          for (const h of k_(s)) (t || !x2(o1(s[h]))) && f.push([
            a(h),
            a(s[h])
          ]);
          return u;
        }
        case Y6:
          return i([
            o,
            s.toISOString()
          ], s);
        case q6: {
          const { source: f, flags: u } = s;
          return i([
            o,
            {
              source: f,
              flags: u
            }
          ], s);
        }
        case X6: {
          const f = [], u = i([
            o,
            f
          ], s);
          for (const [h, g] of s) (t || !(x2(o1(h)) || x2(o1(g)))) && f.push([
            a(h),
            a(g)
          ]);
          return u;
        }
        case Z6: {
          const f = [], u = i([
            o,
            f
          ], s);
          for (const h of s) (t || !x2(o1(h))) && f.push(a(h));
          return u;
        }
      }
      const { message: c } = s;
      return i([
        o,
        {
          name: l,
          message: c
        }
      ], s);
    };
    return a;
  }, G_ = (t, { json: e, lossy: n } = {}) => {
    const r = [];
    return P_(!(e || n), !!e, /* @__PURE__ */ new Map(), r)(t), r;
  };
  var Qr = Uint8Array, cu = Uint16Array, z_ = Int32Array, VE = new Qr([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    0,
    0,
    0
  ]), NE = new Qr([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    0,
    0
  ]), W_ = new Qr([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
  ]), LE = function(t, e) {
    for (var n = new cu(31), r = 0; r < 31; ++r) n[r] = e += 1 << t[r - 1];
    for (var i = new z_(n[30]), r = 1; r < 30; ++r) for (var a = n[r]; a < n[r + 1]; ++a) i[a] = a - n[r] << 5 | r;
    return {
      b: n,
      r: i
    };
  }, UE = LE(VE, 2), FE = UE.b, H_ = UE.r;
  FE[28] = 258, H_[258] = 28;
  var j_ = LE(NE, 0), K_ = j_.b, Uv = new cu(32768);
  for (var qn = 0; qn < 32768; ++qn) {
    var il = (qn & 43690) >> 1 | (qn & 21845) << 1;
    il = (il & 52428) >> 2 | (il & 13107) << 2, il = (il & 61680) >> 4 | (il & 3855) << 4, Uv[qn] = ((il & 65280) >> 8 | (il & 255) << 8) >> 1;
  }
  var rh = (function(t, e, n) {
    for (var r = t.length, i = 0, a = new cu(e); i < r; ++i) t[i] && ++a[t[i] - 1];
    var s = new cu(e);
    for (i = 1; i < e; ++i) s[i] = s[i - 1] + a[i - 1] << 1;
    var o;
    if (n) {
      o = new cu(1 << e);
      var l = 15 - e;
      for (i = 0; i < r; ++i) if (t[i]) for (var c = i << 4 | t[i], f = e - t[i], u = s[t[i] - 1]++ << f, h = u | (1 << f) - 1; u <= h; ++u) o[Uv[u] >> l] = c;
    } else for (o = new cu(r), i = 0; i < r; ++i) t[i] && (o[i] = Uv[s[t[i] - 1]++] >> 15 - t[i]);
    return o;
  }), jh = new Qr(288);
  for (var qn = 0; qn < 144; ++qn) jh[qn] = 8;
  for (var qn = 144; qn < 256; ++qn) jh[qn] = 9;
  for (var qn = 256; qn < 280; ++qn) jh[qn] = 7;
  for (var qn = 280; qn < 288; ++qn) jh[qn] = 8;
  var BE = new Qr(32);
  for (var qn = 0; qn < 32; ++qn) BE[qn] = 5;
  var Y_ = rh(jh, 9, 1), q_ = rh(BE, 5, 1), X3 = function(t) {
    for (var e = t[0], n = 1; n < t.length; ++n) t[n] > e && (e = t[n]);
    return e;
  }, qa = function(t, e, n) {
    var r = e / 8 | 0;
    return (t[r] | t[r + 1] << 8) >> (e & 7) & n;
  }, Z3 = function(t, e) {
    var n = e / 8 | 0;
    return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (e & 7);
  }, _E = function(t) {
    return (t + 7) / 8 | 0;
  }, vg = function(t, e, n) {
    return (e == null || e < 0) && (e = 0), (n == null || n > t.length) && (n = t.length), new Qr(t.subarray(e, n));
  }, X_ = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ], Fi = function(t, e, n) {
    var r = new Error(e || X_[t]);
    if (r.code = t, Error.captureStackTrace && Error.captureStackTrace(r, Fi), !n) throw r;
    return r;
  }, o5 = function(t, e, n, r) {
    var i = t.length, a = 0;
    if (!i || e.f && !e.l) return n || new Qr(0);
    var s = !n, o = s || e.i != 2, l = e.i;
    s && (n = new Qr(i * 3));
    var c = function(wt) {
      var Qe = n.length;
      if (wt > Qe) {
        var _t6 = new Qr(Math.max(Qe * 2, wt));
        _t6.set(n), n = _t6;
      }
    }, f = e.f || 0, u = e.p || 0, h = e.b || 0, g = e.l, v = e.d, m = e.m, y = e.n, w = i * 8;
    do {
      if (!g) {
        f = qa(t, u, 1);
        var C = qa(t, u + 1, 3);
        if (u += 3, C) if (C == 1) g = Y_, v = q_, m = 9, y = 5;
        else if (C == 2) {
          var b = qa(t, u, 31) + 257, D = qa(t, u + 10, 15) + 4, R = b + qa(t, u + 5, 31) + 1;
          u += 14;
          for (var I = new Qr(R), O = new Qr(19), L = 0; L < D; ++L) O[W_[L]] = qa(t, u + L * 3, 7);
          u += D * 3;
          for (var N = X3(O), F = (1 << N) - 1, V = rh(O, N, 1), L = 0; L < R; ) {
            var k = V[qa(t, u, F)];
            u += k & 15;
            var T = k >> 4;
            if (T < 16) I[L++] = T;
            else {
              var _ = 0, K = 0;
              for (T == 16 ? (K = 3 + qa(t, u, 3), u += 2, _ = I[L - 1]) : T == 17 ? (K = 3 + qa(t, u, 7), u += 3) : T == 18 && (K = 11 + qa(t, u, 127), u += 7); K--; ) I[L++] = _;
            }
          }
          var Z = I.subarray(0, b), j = I.subarray(b);
          m = X3(Z), y = X3(j), g = rh(Z, m, 1), v = rh(j, y, 1);
        } else Fi(1);
        else {
          var T = _E(u) + 4, S = t[T - 4] | t[T - 3] << 8, E = T + S;
          if (E > i) {
            l && Fi(0);
            break;
          }
          o && c(h + S), n.set(t.subarray(T, E), h), e.b = h += S, e.p = u = E * 8, e.f = f;
          continue;
        }
        if (u > w) {
          l && Fi(0);
          break;
        }
      }
      o && c(h + 131072);
      for (var B = (1 << m) - 1, Y = (1 << y) - 1, X = u; ; X = u) {
        var _ = g[Z3(t, u) & B], ie = _ >> 4;
        if (u += _ & 15, u > w) {
          l && Fi(0);
          break;
        }
        if (_ || Fi(2), ie < 256) n[h++] = ie;
        else if (ie == 256) {
          X = u, g = null;
          break;
        } else {
          var oe = ie - 254;
          if (ie > 264) {
            var L = ie - 257, he = VE[L];
            oe = qa(t, u, (1 << he) - 1) + FE[L], u += he;
          }
          var Le = v[Z3(t, u) & Y], Je = Le >> 4;
          Le || Fi(3), u += Le & 15;
          var j = K_[Je];
          if (Je > 3) {
            var he = NE[Je];
            j += Z3(t, u) & (1 << he) - 1, u += he;
          }
          if (u > w) {
            l && Fi(0);
            break;
          }
          o && c(h + 131072);
          var Pe = h + oe;
          if (h < j) {
            var ot = a - j, vt = Math.min(j, Pe);
            for (ot + h < 0 && Fi(3); h < vt; ++h) n[h] = r[ot + h];
          }
          for (; h < Pe; ++h) n[h] = n[h - j];
        }
      }
      e.l = g, e.p = X, e.b = h, e.f = f, g && (f = 1, e.m = m, e.d = v, e.n = y);
    } while (!f);
    return h != n.length && s ? vg(n, 0, h) : n.subarray(0, h);
  }, Z_ = new Qr(0), kE = function(t) {
    (t[0] != 31 || t[1] != 139 || t[2] != 8) && Fi(6, "invalid gzip data");
    var e = t[3], n = 10;
    e & 4 && (n += (t[10] | t[11] << 8) + 2);
    for (var r = (e >> 3 & 1) + (e >> 4 & 1); r > 0; r -= !t[n++]) ;
    return n + (e & 2);
  }, Q_ = function(t) {
    var e = t.length;
    return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;
  }, J_ = function(t, e) {
    return ((t[0] & 15) != 8 || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31) && Fi(6, "invalid zlib data"), (t[1] >> 5 & 1) == 1 && Fi(6, "invalid zlib data: " + (t[1] & 32 ? "need" : "unexpected") + " dictionary"), (t[1] >> 3 & 4) + 2;
  }, Q3 = (function() {
    function t(e, n) {
      typeof e == "function" && (n = e, e = {}), this.ondata = n;
      var r = e && e.dictionary && e.dictionary.subarray(-32768);
      this.s = {
        i: 0,
        b: r ? r.length : 0
      }, this.o = new Qr(32768), this.p = new Qr(0), r && this.o.set(r);
    }
    return t.prototype.e = function(e) {
      if (this.ondata || Fi(5), this.d && Fi(4), !this.p.length) this.p = e;
      else if (e.length) {
        var n = new Qr(this.p.length + e.length);
        n.set(this.p), n.set(e, this.p.length), this.p = n;
      }
    }, t.prototype.c = function(e) {
      this.s.i = +(this.d = e || false);
      var n = this.s.b, r = o5(this.p, this.s, this.o);
      this.ondata(vg(r, n, this.s.b), this.d), this.o = vg(r, this.s.b - 32768), this.s.b = this.o.length, this.p = vg(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, t.prototype.push = function(e, n) {
      this.e(e), this.c(n);
    }, t;
  })();
  function $_(t, e) {
    return o5(t, {
      i: 2
    }, e, e);
  }
  var ek = (function() {
    function t(e, n) {
      this.v = 1, this.r = 0, Q3.call(this, e, n);
    }
    return t.prototype.push = function(e, n) {
      if (Q3.prototype.e.call(this, e), this.r += e.length, this.v) {
        var r = this.p.subarray(this.v - 1), i = r.length > 3 ? kE(r) : 4;
        if (i > r.length) {
          if (!n) return;
        } else this.v > 1 && this.onmember && this.onmember(this.r - r.length);
        this.p = r.subarray(i), this.v = 0;
      }
      Q3.prototype.c.call(this, n), this.s.f && !this.s.l && !n && (this.v = _E(this.s.p) + 9, this.s = {
        i: 0
      }, this.o = new Qr(0), this.push(new Qr(0), n));
    }, t;
  })();
  function tk(t, e) {
    var n = kE(t);
    return n + 8 > t.length && Fi(6, "invalid gzip data"), o5(t.subarray(n, -8), {
      i: 2
    }, new Qr(Q_(t)), e);
  }
  function nk(t, e) {
    return o5(t.subarray(J_(t), -4), {
      i: 2
    }, e, e);
  }
  function rk(t, e) {
    return t[0] == 31 && t[1] == 139 && t[2] == 8 ? tk(t, e) : (t[0] & 15) != 8 || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? $_(t, e) : nk(t, e);
  }
  var ik = typeof TextDecoder < "u" && new TextDecoder(), ak = 0;
  try {
    ik.decode(Z_, {
      stream: true
    }), ak = 1;
  } catch {
  }
  class PE {
    constructor(e, n, r, i) {
      __publicField(this, "esize");
      __publicField(this, "ecode");
      __publicField(this, "edata");
      __publicField(this, "littleEndian");
      if (e % 16 != 0) throw new Error("This does not appear to be a NIFTI extension");
      this.esize = e, this.ecode = n, this.edata = r, this.littleEndian = i;
    }
    toArrayBuffer() {
      let e = new Uint8Array(this.esize), n = new Uint8Array(this.edata);
      e.set(n, 8);
      let r = new DataView(e.buffer);
      return r.setInt32(0, this.esize, this.littleEndian), r.setInt32(4, this.ecode, this.littleEndian), e.buffer;
    }
  }
  const _Ye = class _Ye {
    static getStringAt(e, n, r) {
      var i = "", a, s;
      for (a = n; a < r; a += 1) s = e.getUint8(a), s !== 0 && (i += String.fromCharCode(s));
      return i;
    }
    static getIntAt(e, n, r) {
      return e.getInt32(n, r);
    }
    static getFloatAt(e, n, r) {
      return e.getFloat32(n, r);
    }
    static getDoubleAt(e, n, r) {
      return e.getFloat64(n, r);
    }
    static getInt64At(e, n, r) {
      const i = e.getUint32(n, r), a = e.getInt32(n + 4, r);
      let s;
      return r ? s = a * 2 ** 32 + i : s = i * 2 ** 32 + a, a < 0 && (s += -1 * 2 ** 32 * 2 ** 32), s;
    }
    static getUint64At(e, n, r) {
      const i = e.getUint32(n + (r ? 0 : 4), r), a = e.getUint32(n + (r ? 4 : 0), r);
      return r ? a * 2 ** 32 + i : i * 2 ** 32 + a;
    }
    static getExtensionsAt(e, n, r, i) {
      let a = [], s = n;
      for (; s < i; ) {
        let o = r, l = _Ye.getIntAt(e, s, r);
        if (!l) break;
        if (l + s > i && (o = !o, l = _Ye.getIntAt(e, s, o), l + s > i)) throw new Error("This does not appear to be a valid NIFTI extension");
        if (l % 16 != 0) throw new Error("This does not appear to be a NIFTI extension");
        let c = _Ye.getIntAt(e, s + 4, o), f = e.buffer.slice(s + 8, s + l), u = new PE(l, c, f, o);
        a.push(u), s += l;
      }
      return a;
    }
    static toArrayBuffer(e) {
      var n, r, i;
      for (n = new ArrayBuffer(e.length), r = new Uint8Array(n), i = 0; i < e.length; i += 1) r[i] = e[i];
      return n;
    }
    static isString(e) {
      return typeof e == "string" || e instanceof String;
    }
    static formatNumber(e, n = void 0) {
      let r;
      return _Ye.isString(e) ? r = Number(e) : r = e, n ? r = r.toPrecision(5) : r = r.toPrecision(7), parseFloat(r);
    }
    static makeCRCTable() {
      let e, n = [];
      for (var r = 0; r < 256; r++) {
        e = r;
        for (var i = 0; i < 8; i++) e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
        n[r] = e;
      }
      return n;
    }
    static crc32(e) {
      _Ye.crcTable || (_Ye.crcTable = _Ye.makeCRCTable());
      const n = _Ye.crcTable;
      let r = -1;
      for (var i = 0; i < e.byteLength; i++) r = r >>> 8 ^ n[(r ^ e.getUint8(i)) & 255];
      return (r ^ -1) >>> 0;
    }
  };
  __publicField(_Ye, "crcTable", null);
  __publicField(_Ye, "GUNZIP_MAGIC_COOKIE1", 31);
  __publicField(_Ye, "GUNZIP_MAGIC_COOKIE2", 139);
  __publicField(_Ye, "getByteAt", function(e, n) {
    return e.getUint8(n);
  });
  __publicField(_Ye, "getShortAt", function(e, n, r) {
    return e.getInt16(n, r);
  });
  let Ye = _Ye;
  const _tt = class _tt {
    constructor() {
      __publicField(this, "littleEndian", false);
      __publicField(this, "dim_info", 0);
      __publicField(this, "dims", []);
      __publicField(this, "intent_p1", 0);
      __publicField(this, "intent_p2", 0);
      __publicField(this, "intent_p3", 0);
      __publicField(this, "intent_code", 0);
      __publicField(this, "datatypeCode", 0);
      __publicField(this, "numBitsPerVoxel", 0);
      __publicField(this, "slice_start", 0);
      __publicField(this, "slice_end", 0);
      __publicField(this, "slice_code", 0);
      __publicField(this, "pixDims", []);
      __publicField(this, "vox_offset", 0);
      __publicField(this, "scl_slope", 1);
      __publicField(this, "scl_inter", 0);
      __publicField(this, "xyzt_units", 0);
      __publicField(this, "cal_max", 0);
      __publicField(this, "cal_min", 0);
      __publicField(this, "slice_duration", 0);
      __publicField(this, "toffset", 0);
      __publicField(this, "description", "");
      __publicField(this, "aux_file", "");
      __publicField(this, "intent_name", "");
      __publicField(this, "qform_code", 0);
      __publicField(this, "sform_code", 0);
      __publicField(this, "quatern_a", 0);
      __publicField(this, "quatern_b", 0);
      __publicField(this, "quatern_c", 0);
      __publicField(this, "quatern_d", 0);
      __publicField(this, "qoffset_x", 0);
      __publicField(this, "qoffset_y", 0);
      __publicField(this, "qoffset_z", 0);
      __publicField(this, "affine", [
        [
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1
        ]
      ]);
      __publicField(this, "qfac", 1);
      __publicField(this, "quatern_R");
      __publicField(this, "magic", "0");
      __publicField(this, "isHDR", false);
      __publicField(this, "extensionFlag", [
        0,
        0,
        0,
        0
      ]);
      __publicField(this, "extensionSize", 0);
      __publicField(this, "extensionCode", 0);
      __publicField(this, "extensions", []);
      __publicField(this, "getDatatypeCodeString", function(e) {
        return e === _tt.TYPE_UINT8 ? "1-Byte Unsigned Integer" : e === _tt.TYPE_INT16 ? "2-Byte Signed Integer" : e === _tt.TYPE_INT32 ? "4-Byte Signed Integer" : e === _tt.TYPE_FLOAT32 ? "4-Byte Float" : e === _tt.TYPE_FLOAT64 ? "8-Byte Float" : e === _tt.TYPE_RGB24 ? "RGB" : e === _tt.TYPE_INT8 ? "1-Byte Signed Integer" : e === _tt.TYPE_UINT16 ? "2-Byte Unsigned Integer" : e === _tt.TYPE_UINT32 ? "4-Byte Unsigned Integer" : e === _tt.TYPE_INT64 ? "8-Byte Signed Integer" : e === _tt.TYPE_UINT64 ? "8-Byte Unsigned Integer" : "Unknown";
      });
      __publicField(this, "getTransformCodeString", function(e) {
        return e === _tt.XFORM_SCANNER_ANAT ? "Scanner" : e === _tt.XFORM_ALIGNED_ANAT ? "Aligned" : e === _tt.XFORM_TALAIRACH ? "Talairach" : e === _tt.XFORM_MNI_152 ? "MNI" : "Unknown";
      });
      __publicField(this, "getUnitsCodeString", function(e) {
        return e === _tt.UNITS_METER ? "Meters" : e === _tt.UNITS_MM ? "Millimeters" : e === _tt.UNITS_MICRON ? "Microns" : e === _tt.UNITS_SEC ? "Seconds" : e === _tt.UNITS_MSEC ? "Milliseconds" : e === _tt.UNITS_USEC ? "Microseconds" : e === _tt.UNITS_HZ ? "Hz" : e === _tt.UNITS_PPM ? "PPM" : e === _tt.UNITS_RADS ? "Rads" : "Unknown";
      });
      __publicField(this, "nifti_mat33_mul", function(e, n) {
        var r = [
          [
            0,
            0,
            0
          ],
          [
            0,
            0,
            0
          ],
          [
            0,
            0,
            0
          ]
        ], i, a;
        for (i = 0; i < 3; i += 1) for (a = 0; a < 3; a += 1) r[i][a] = e[i][0] * n[0][a] + e[i][1] * n[1][a] + e[i][2] * n[2][a];
        return r;
      });
      __publicField(this, "nifti_mat33_determ", function(e) {
        var n, r, i, a, s, o, l, c, f;
        return n = e[0][0], r = e[0][1], i = e[0][2], a = e[1][0], s = e[1][1], o = e[1][2], l = e[2][0], c = e[2][1], f = e[2][2], n * s * f - n * c * o - a * r * f + a * c * i + l * r * o - l * s * i;
      });
    }
    readHeader(e) {
      var n = new DataView(e), r = Ye.getIntAt(n, 0, this.littleEndian), i, a, s, o;
      if (r !== _tt.MAGIC_COOKIE && (this.littleEndian = true, r = Ye.getIntAt(n, 0, this.littleEndian)), r !== _tt.MAGIC_COOKIE) throw new Error("This does not appear to be a NIFTI file!");
      for (this.dim_info = Ye.getByteAt(n, 39), i = 0; i < 8; i += 1) o = 40 + i * 2, this.dims[i] = Ye.getShortAt(n, o, this.littleEndian);
      for (this.intent_p1 = Ye.getFloatAt(n, 56, this.littleEndian), this.intent_p2 = Ye.getFloatAt(n, 60, this.littleEndian), this.intent_p3 = Ye.getFloatAt(n, 64, this.littleEndian), this.intent_code = Ye.getShortAt(n, 68, this.littleEndian), this.datatypeCode = Ye.getShortAt(n, 70, this.littleEndian), this.numBitsPerVoxel = Ye.getShortAt(n, 72, this.littleEndian), this.slice_start = Ye.getShortAt(n, 74, this.littleEndian), i = 0; i < 8; i += 1) o = 76 + i * 4, this.pixDims[i] = Ye.getFloatAt(n, o, this.littleEndian);
      if (this.vox_offset = Ye.getFloatAt(n, 108, this.littleEndian), this.scl_slope = Ye.getFloatAt(n, 112, this.littleEndian), this.scl_inter = Ye.getFloatAt(n, 116, this.littleEndian), this.slice_end = Ye.getShortAt(n, 120, this.littleEndian), this.slice_code = Ye.getByteAt(n, 122), this.xyzt_units = Ye.getByteAt(n, 123), this.cal_max = Ye.getFloatAt(n, 124, this.littleEndian), this.cal_min = Ye.getFloatAt(n, 128, this.littleEndian), this.slice_duration = Ye.getFloatAt(n, 132, this.littleEndian), this.toffset = Ye.getFloatAt(n, 136, this.littleEndian), this.description = Ye.getStringAt(n, 148, 228), this.aux_file = Ye.getStringAt(n, 228, 252), this.qform_code = Ye.getShortAt(n, 252, this.littleEndian), this.sform_code = Ye.getShortAt(n, 254, this.littleEndian), this.quatern_b = Ye.getFloatAt(n, 256, this.littleEndian), this.quatern_c = Ye.getFloatAt(n, 260, this.littleEndian), this.quatern_d = Ye.getFloatAt(n, 264, this.littleEndian), this.quatern_a = Math.sqrt(1 - (Math.pow(this.quatern_b, 2) + Math.pow(this.quatern_c, 2) + Math.pow(this.quatern_d, 2))), this.qoffset_x = Ye.getFloatAt(n, 268, this.littleEndian), this.qoffset_y = Ye.getFloatAt(n, 272, this.littleEndian), this.qoffset_z = Ye.getFloatAt(n, 276, this.littleEndian), this.qform_code < 1 && this.sform_code < 1 && (this.affine[0][0] = this.pixDims[1], this.affine[1][1] = this.pixDims[2], this.affine[2][2] = this.pixDims[3]), this.qform_code > 0 && this.sform_code < this.qform_code) {
        const l = this.quatern_a, c = this.quatern_b, f = this.quatern_c, u = this.quatern_d;
        for (this.qfac = this.pixDims[0] === 0 ? 1 : this.pixDims[0], this.quatern_R = [
          [
            l * l + c * c - f * f - u * u,
            2 * c * f - 2 * l * u,
            2 * c * u + 2 * l * f
          ],
          [
            2 * c * f + 2 * l * u,
            l * l + f * f - c * c - u * u,
            2 * f * u - 2 * l * c
          ],
          [
            2 * c * u - 2 * l * f,
            2 * f * u + 2 * l * c,
            l * l + u * u - f * f - c * c
          ]
        ], a = 0; a < 3; a += 1) for (s = 0; s < 3; s += 1) this.affine[a][s] = this.quatern_R[a][s] * this.pixDims[s + 1], s === 2 && (this.affine[a][s] *= this.qfac);
        this.affine[0][3] = this.qoffset_x, this.affine[1][3] = this.qoffset_y, this.affine[2][3] = this.qoffset_z;
      } else if (this.sform_code > 0) for (a = 0; a < 3; a += 1) for (s = 0; s < 4; s += 1) o = 280 + (a * 4 + s) * 4, this.affine[a][s] = Ye.getFloatAt(n, o, this.littleEndian);
      if (this.affine[3][0] = 0, this.affine[3][1] = 0, this.affine[3][2] = 0, this.affine[3][3] = 1, this.intent_name = Ye.getStringAt(n, 328, 344), this.magic = Ye.getStringAt(n, 344, 348), this.isHDR = this.magic === String.fromCharCode.apply(null, _tt.MAGIC_NUMBER2), n.byteLength > _tt.MAGIC_COOKIE) {
        this.extensionFlag[0] = Ye.getByteAt(n, 348), this.extensionFlag[1] = Ye.getByteAt(n, 349), this.extensionFlag[2] = Ye.getByteAt(n, 350), this.extensionFlag[3] = Ye.getByteAt(n, 351);
        let l = true;
        !this.isHDR && this.vox_offset <= 352 && (l = false), n.byteLength <= 368 && (l = false), l && this.extensionFlag[0] && (this.extensions = Ye.getExtensionsAt(n, this.getExtensionLocation(), this.littleEndian, this.vox_offset), this.extensionSize = this.extensions[0].esize, this.extensionCode = this.extensions[0].ecode);
      }
    }
    toFormattedString() {
      var e = Ye.formatNumber, n = "";
      return n += "Dim Info = " + this.dim_info + `
`, n += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + `
`, n += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + `
`, n += "Intent Code = " + this.intent_code + `
`, n += "Datatype = " + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + `)
`, n += "Bits Per Voxel = " + this.numBitsPerVoxel + `
`, n += "Slice Start = " + this.slice_start + `
`, n += "Voxel Dimensions (1-8): " + e(this.pixDims[0]) + ", " + e(this.pixDims[1]) + ", " + e(this.pixDims[2]) + ", " + e(this.pixDims[3]) + ", " + e(this.pixDims[4]) + ", " + e(this.pixDims[5]) + ", " + e(this.pixDims[6]) + ", " + e(this.pixDims[7]) + `
`, n += "Image Offset = " + this.vox_offset + `
`, n += "Data Scale:  Slope = " + e(this.scl_slope) + "  Intercept = " + e(this.scl_inter) + `
`, n += "Slice End = " + this.slice_end + `
`, n += "Slice Code = " + this.slice_code + `
`, n += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(_tt.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(_tt.TEMPORAL_UNITS_MASK & this.xyzt_units) + `)
`, n += "Display Range:  Max = " + e(this.cal_max) + "  Min = " + e(this.cal_min) + `
`, n += "Slice Duration = " + this.slice_duration + `
`, n += "Time Axis Shift = " + this.toffset + `
`, n += 'Description: "' + this.description + `"
`, n += 'Auxiliary File: "' + this.aux_file + `"
`, n += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + `)
`, n += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + `)
`, n += "Quaternion Parameters:  b = " + e(this.quatern_b) + "  c = " + e(this.quatern_c) + "  d = " + e(this.quatern_d) + `
`, n += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + `
`, n += "S-Form Parameters X: " + e(this.affine[0][0]) + ", " + e(this.affine[0][1]) + ", " + e(this.affine[0][2]) + ", " + e(this.affine[0][3]) + `
`, n += "S-Form Parameters Y: " + e(this.affine[1][0]) + ", " + e(this.affine[1][1]) + ", " + e(this.affine[1][2]) + ", " + e(this.affine[1][3]) + `
`, n += "S-Form Parameters Z: " + e(this.affine[2][0]) + ", " + e(this.affine[2][1]) + ", " + e(this.affine[2][2]) + ", " + e(this.affine[2][3]) + `
`, n += 'Intent Name: "' + this.intent_name + `"
`, this.extensionFlag[0] && (n += "Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + `
`), n;
    }
    getQformMat() {
      return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x, this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
    }
    convertNiftiQFormToNiftiSForm(e, n, r, i, a, s, o, l, c, f) {
      var u = [
        [
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0
        ]
      ], h, g = e, v = n, m = r, y, w, C;
      return u[3][0] = u[3][1] = u[3][2] = 0, u[3][3] = 1, h = 1 - (g * g + v * v + m * m), h < 1e-7 ? (h = 1 / Math.sqrt(g * g + v * v + m * m), g *= h, v *= h, m *= h, h = 0) : h = Math.sqrt(h), y = o > 0 ? o : 1, w = l > 0 ? l : 1, C = c > 0 ? c : 1, f < 0 && (C = -C), u[0][0] = (h * h + g * g - v * v - m * m) * y, u[0][1] = 2 * (g * v - h * m) * w, u[0][2] = 2 * (g * m + h * v) * C, u[1][0] = 2 * (g * v + h * m) * y, u[1][1] = (h * h + v * v - g * g - m * m) * w, u[1][2] = 2 * (v * m - h * g) * C, u[2][0] = 2 * (g * m - h * v) * y, u[2][1] = 2 * (v * m + h * g) * w, u[2][2] = (h * h + m * m - v * v - g * g) * C, u[0][3] = i, u[1][3] = a, u[2][3] = s, u;
    }
    convertNiftiSFormToNEMA(e) {
      var n, r, i, a, s, o, l, c, f, u, h, g, v, m, y, w, C, T, S, E, b, D, R, I, O, L, N, F, V, k, _, K, Z, j;
      if (y = 0, N = [
        [
          0,
          0,
          0
        ],
        [
          0,
          0,
          0
        ],
        [
          0,
          0,
          0
        ]
      ], F = [
        [
          0,
          0,
          0
        ],
        [
          0,
          0,
          0
        ],
        [
          0,
          0,
          0
        ]
      ], n = e[0][0], r = e[0][1], i = e[0][2], a = e[1][0], s = e[1][1], o = e[1][2], l = e[2][0], c = e[2][1], f = e[2][2], u = Math.sqrt(n * n + a * a + l * l), u === 0 || (n /= u, a /= u, l /= u, u = Math.sqrt(r * r + s * s + c * c), u === 0)) return null;
      if (r /= u, s /= u, c /= u, u = n * r + a * s + l * c, Math.abs(u) > 1e-4) {
        if (r -= u * n, s -= u * a, c -= u * l, u = Math.sqrt(r * r + s * s + c * c), u === 0) return null;
        r /= u, s /= u, c /= u;
      }
      if (u = Math.sqrt(i * i + o * o + f * f), u === 0 ? (i = a * c - l * s, o = l * r - c * n, f = n * s - a * r) : (i /= u, o /= u, f /= u), u = n * i + a * o + l * f, Math.abs(u) > 1e-4) {
        if (i -= u * n, o -= u * a, f -= u * l, u = Math.sqrt(i * i + o * o + f * f), u === 0) return null;
        i /= u, o /= u, f /= u;
      }
      if (u = r * i + s * o + c * f, Math.abs(u) > 1e-4) {
        if (i -= u * r, o -= u * s, f -= u * c, u = Math.sqrt(i * i + o * o + f * f), u === 0) return null;
        i /= u, o /= u, f /= u;
      }
      if (N[0][0] = n, N[0][1] = r, N[0][2] = i, N[1][0] = a, N[1][1] = s, N[1][2] = o, N[2][0] = l, N[2][1] = c, N[2][2] = f, h = this.nifti_mat33_determ(N), h === 0) return null;
      for (L = -666, S = D = R = I = 1, E = 2, b = 3, v = 1; v <= 3; v += 1) for (m = 1; m <= 3; m += 1) if (v !== m) {
        for (y = 1; y <= 3; y += 1) if (!(v === y || m === y)) for (F[0][0] = F[0][1] = F[0][2] = F[1][0] = F[1][1] = F[1][2] = F[2][0] = F[2][1] = F[2][2] = 0, w = -1; w <= 1; w += 2) for (C = -1; C <= 1; C += 2) for (T = -1; T <= 1; T += 2) F[0][v - 1] = w, F[1][m - 1] = C, F[2][y - 1] = T, g = this.nifti_mat33_determ(F), g * h > 0 && (O = this.nifti_mat33_mul(F, N), u = O[0][0] + O[1][1] + O[2][2], u > L && (L = u, S = v, E = m, b = y, D = w, R = C, I = T));
      }
      switch (V = k = _ = K = Z = j = "", S * D) {
        case 1:
          V = "X", K = "+";
          break;
        case -1:
          V = "X", K = "-";
          break;
        case 2:
          V = "Y", K = "+";
          break;
        case -2:
          V = "Y", K = "-";
          break;
        case 3:
          V = "Z", K = "+";
          break;
        case -3:
          V = "Z", K = "-";
          break;
      }
      switch (E * R) {
        case 1:
          k = "X", Z = "+";
          break;
        case -1:
          k = "X", Z = "-";
          break;
        case 2:
          k = "Y", Z = "+";
          break;
        case -2:
          k = "Y", Z = "-";
          break;
        case 3:
          k = "Z", Z = "+";
          break;
        case -3:
          k = "Z", Z = "-";
          break;
      }
      switch (b * I) {
        case 1:
          _ = "X", j = "+";
          break;
        case -1:
          _ = "X", j = "-";
          break;
        case 2:
          _ = "Y", j = "+";
          break;
        case -2:
          _ = "Y", j = "-";
          break;
        case 3:
          _ = "Z", j = "+";
          break;
        case -3:
          _ = "Z", j = "-";
          break;
      }
      return V + k + _ + K + Z + j;
    }
    getExtensionLocation() {
      return _tt.MAGIC_COOKIE + 4;
    }
    getExtensionSize(e) {
      return Ye.getIntAt(e, this.getExtensionLocation(), this.littleEndian);
    }
    getExtensionCode(e) {
      return Ye.getIntAt(e, this.getExtensionLocation() + 4, this.littleEndian);
    }
    addExtension(e, n = -1) {
      n == -1 ? this.extensions.push(e) : this.extensions.splice(n, 0, e), this.vox_offset += e.esize;
    }
    removeExtension(e) {
      let n = this.extensions[e];
      n && (this.vox_offset -= n.esize), this.extensions.splice(e, 1);
    }
    toArrayBuffer(e = false) {
      let i = 352;
      if (e) for (let l of this.extensions) i += l.esize;
      let a = new Uint8Array(i), s = new DataView(a.buffer);
      s.setInt32(0, 348, this.littleEndian), s.setUint8(39, this.dim_info);
      for (let l = 0; l < 8; l++) s.setUint16(40 + 2 * l, this.dims[l], this.littleEndian);
      s.setFloat32(56, this.intent_p1, this.littleEndian), s.setFloat32(60, this.intent_p2, this.littleEndian), s.setFloat32(64, this.intent_p3, this.littleEndian), s.setInt16(68, this.intent_code, this.littleEndian), s.setInt16(70, this.datatypeCode, this.littleEndian), s.setInt16(72, this.numBitsPerVoxel, this.littleEndian), s.setInt16(74, this.slice_start, this.littleEndian);
      for (let l = 0; l < 8; l++) s.setFloat32(76 + 4 * l, this.pixDims[l], this.littleEndian);
      s.setFloat32(108, this.vox_offset, this.littleEndian), s.setFloat32(112, this.scl_slope, this.littleEndian), s.setFloat32(116, this.scl_inter, this.littleEndian), s.setInt16(120, this.slice_end, this.littleEndian), s.setUint8(122, this.slice_code), s.setUint8(123, this.xyzt_units), s.setFloat32(124, this.cal_max, this.littleEndian), s.setFloat32(128, this.cal_min, this.littleEndian), s.setFloat32(132, this.slice_duration, this.littleEndian), s.setFloat32(136, this.toffset, this.littleEndian), a.set(new TextEncoder().encode(this.description), 148), a.set(new TextEncoder().encode(this.aux_file), 228), s.setInt16(252, this.qform_code, this.littleEndian), s.setInt16(254, this.sform_code, this.littleEndian), s.setFloat32(256, this.quatern_b, this.littleEndian), s.setFloat32(260, this.quatern_c, this.littleEndian), s.setFloat32(264, this.quatern_d, this.littleEndian), s.setFloat32(268, this.qoffset_x, this.littleEndian), s.setFloat32(272, this.qoffset_y, this.littleEndian), s.setFloat32(276, this.qoffset_z, this.littleEndian);
      const o = this.affine.flat();
      for (let l = 0; l < 12; l++) s.setFloat32(280 + 4 * l, o[l], this.littleEndian);
      if (a.set(new TextEncoder().encode(this.intent_name), 328), a.set(new TextEncoder().encode(this.magic), 344), e) {
        a.set(Uint8Array.from([
          1,
          0,
          0,
          0
        ]), 348);
        let l = this.getExtensionLocation();
        for (const c of this.extensions) s.setInt32(l, c.esize, c.littleEndian), s.setInt32(l + 4, c.ecode, c.littleEndian), a.set(new Uint8Array(c.edata), l + 8), l += c.esize;
      } else a.set(new Uint8Array(4).fill(0), 348);
      return a.buffer;
    }
  };
  __publicField(_tt, "TYPE_NONE", 0);
  __publicField(_tt, "TYPE_BINARY", 1);
  __publicField(_tt, "TYPE_UINT8", 2);
  __publicField(_tt, "TYPE_INT16", 4);
  __publicField(_tt, "TYPE_INT32", 8);
  __publicField(_tt, "TYPE_FLOAT32", 16);
  __publicField(_tt, "TYPE_COMPLEX64", 32);
  __publicField(_tt, "TYPE_FLOAT64", 64);
  __publicField(_tt, "TYPE_RGB24", 128);
  __publicField(_tt, "TYPE_INT8", 256);
  __publicField(_tt, "TYPE_UINT16", 512);
  __publicField(_tt, "TYPE_UINT32", 768);
  __publicField(_tt, "TYPE_INT64", 1024);
  __publicField(_tt, "TYPE_UINT64", 1280);
  __publicField(_tt, "TYPE_FLOAT128", 1536);
  __publicField(_tt, "TYPE_COMPLEX128", 1792);
  __publicField(_tt, "TYPE_COMPLEX256", 2048);
  __publicField(_tt, "XFORM_UNKNOWN", 0);
  __publicField(_tt, "XFORM_SCANNER_ANAT", 1);
  __publicField(_tt, "XFORM_ALIGNED_ANAT", 2);
  __publicField(_tt, "XFORM_TALAIRACH", 3);
  __publicField(_tt, "XFORM_MNI_152", 4);
  __publicField(_tt, "SPATIAL_UNITS_MASK", 7);
  __publicField(_tt, "TEMPORAL_UNITS_MASK", 56);
  __publicField(_tt, "UNITS_UNKNOWN", 0);
  __publicField(_tt, "UNITS_METER", 1);
  __publicField(_tt, "UNITS_MM", 2);
  __publicField(_tt, "UNITS_MICRON", 3);
  __publicField(_tt, "UNITS_SEC", 8);
  __publicField(_tt, "UNITS_MSEC", 16);
  __publicField(_tt, "UNITS_USEC", 24);
  __publicField(_tt, "UNITS_HZ", 32);
  __publicField(_tt, "UNITS_PPM", 40);
  __publicField(_tt, "UNITS_RADS", 48);
  __publicField(_tt, "MAGIC_COOKIE", 348);
  __publicField(_tt, "STANDARD_HEADER_SIZE", 348);
  __publicField(_tt, "MAGIC_NUMBER_LOCATION", 344);
  __publicField(_tt, "MAGIC_NUMBER", [
    110,
    43,
    49
  ]);
  __publicField(_tt, "MAGIC_NUMBER2", [
    110,
    105,
    49
  ]);
  __publicField(_tt, "EXTENSION_HEADER_SIZE", 8);
  let tt = _tt;
  const _li = class _li {
    constructor() {
      __publicField(this, "littleEndian", false);
      __publicField(this, "dim_info", 0);
      __publicField(this, "dims", []);
      __publicField(this, "intent_p1", 0);
      __publicField(this, "intent_p2", 0);
      __publicField(this, "intent_p3", 0);
      __publicField(this, "intent_code", 0);
      __publicField(this, "datatypeCode", 0);
      __publicField(this, "numBitsPerVoxel", 0);
      __publicField(this, "slice_start", 0);
      __publicField(this, "slice_end", 0);
      __publicField(this, "slice_code", 0);
      __publicField(this, "pixDims", []);
      __publicField(this, "vox_offset", 0);
      __publicField(this, "scl_slope", 1);
      __publicField(this, "scl_inter", 0);
      __publicField(this, "xyzt_units", 0);
      __publicField(this, "cal_max", 0);
      __publicField(this, "cal_min", 0);
      __publicField(this, "slice_duration", 0);
      __publicField(this, "toffset", 0);
      __publicField(this, "description", "");
      __publicField(this, "aux_file", "");
      __publicField(this, "intent_name", "");
      __publicField(this, "qform_code", 0);
      __publicField(this, "sform_code", 0);
      __publicField(this, "quatern_b", 0);
      __publicField(this, "quatern_c", 0);
      __publicField(this, "quatern_d", 0);
      __publicField(this, "qoffset_x", 0);
      __publicField(this, "qoffset_y", 0);
      __publicField(this, "qoffset_z", 0);
      __publicField(this, "affine", [
        [
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1
        ]
      ]);
      __publicField(this, "magic", "0");
      __publicField(this, "extensionFlag", [
        0,
        0,
        0,
        0
      ]);
      __publicField(this, "extensions", []);
      __publicField(this, "extensionSize", 0);
      __publicField(this, "extensionCode", 0);
      __publicField(this, "getExtensionLocation", function() {
        return _li.MAGIC_COOKIE + 4;
      });
      __publicField(this, "getExtensionSize", tt.prototype.getExtensionSize);
      __publicField(this, "getExtensionCode", tt.prototype.getExtensionCode);
      __publicField(this, "addExtension", tt.prototype.addExtension);
      __publicField(this, "removeExtension", tt.prototype.removeExtension);
      __publicField(this, "getDatatypeCodeString", tt.prototype.getDatatypeCodeString);
      __publicField(this, "getTransformCodeString", tt.prototype.getTransformCodeString);
      __publicField(this, "getUnitsCodeString", tt.prototype.getUnitsCodeString);
      __publicField(this, "getQformMat", tt.prototype.getQformMat);
      __publicField(this, "convertNiftiQFormToNiftiSForm", tt.prototype.convertNiftiQFormToNiftiSForm);
      __publicField(this, "convertNiftiSFormToNEMA", tt.prototype.convertNiftiSFormToNEMA);
      __publicField(this, "nifti_mat33_mul", tt.prototype.nifti_mat33_mul);
      __publicField(this, "nifti_mat33_determ", tt.prototype.nifti_mat33_determ);
    }
    readHeader(e) {
      var n = new DataView(e), r = Ye.getIntAt(n, 0, this.littleEndian), i, a, s, o;
      if (r !== _li.MAGIC_COOKIE && (this.littleEndian = true, r = Ye.getIntAt(n, 0, this.littleEndian)), r !== _li.MAGIC_COOKIE) throw new Error("This does not appear to be a NIFTI file!");
      for (this.magic = Ye.getStringAt(n, 4, 12), this.datatypeCode = Ye.getShortAt(n, 12, this.littleEndian), this.numBitsPerVoxel = Ye.getShortAt(n, 14, this.littleEndian), i = 0; i < 8; i += 1) o = 16 + i * 8, this.dims[i] = Ye.getInt64At(n, o, this.littleEndian);
      for (this.intent_p1 = Ye.getDoubleAt(n, 80, this.littleEndian), this.intent_p2 = Ye.getDoubleAt(n, 88, this.littleEndian), this.intent_p3 = Ye.getDoubleAt(n, 96, this.littleEndian), i = 0; i < 8; i += 1) o = 104 + i * 8, this.pixDims[i] = Ye.getDoubleAt(n, o, this.littleEndian);
      for (this.vox_offset = Ye.getInt64At(n, 168, this.littleEndian), this.scl_slope = Ye.getDoubleAt(n, 176, this.littleEndian), this.scl_inter = Ye.getDoubleAt(n, 184, this.littleEndian), this.cal_max = Ye.getDoubleAt(n, 192, this.littleEndian), this.cal_min = Ye.getDoubleAt(n, 200, this.littleEndian), this.slice_duration = Ye.getDoubleAt(n, 208, this.littleEndian), this.toffset = Ye.getDoubleAt(n, 216, this.littleEndian), this.slice_start = Ye.getInt64At(n, 224, this.littleEndian), this.slice_end = Ye.getInt64At(n, 232, this.littleEndian), this.description = Ye.getStringAt(n, 240, 320), this.aux_file = Ye.getStringAt(n, 320, 344), this.qform_code = Ye.getIntAt(n, 344, this.littleEndian), this.sform_code = Ye.getIntAt(n, 348, this.littleEndian), this.quatern_b = Ye.getDoubleAt(n, 352, this.littleEndian), this.quatern_c = Ye.getDoubleAt(n, 360, this.littleEndian), this.quatern_d = Ye.getDoubleAt(n, 368, this.littleEndian), this.qoffset_x = Ye.getDoubleAt(n, 376, this.littleEndian), this.qoffset_y = Ye.getDoubleAt(n, 384, this.littleEndian), this.qoffset_z = Ye.getDoubleAt(n, 392, this.littleEndian), a = 0; a < 3; a += 1) for (s = 0; s < 4; s += 1) o = 400 + (a * 4 + s) * 8, this.affine[a][s] = Ye.getDoubleAt(n, o, this.littleEndian);
      this.affine[3][0] = 0, this.affine[3][1] = 0, this.affine[3][2] = 0, this.affine[3][3] = 1, this.slice_code = Ye.getIntAt(n, 496, this.littleEndian), this.xyzt_units = Ye.getIntAt(n, 500, this.littleEndian), this.intent_code = Ye.getIntAt(n, 504, this.littleEndian), this.intent_name = Ye.getStringAt(n, 508, 524), this.dim_info = Ye.getByteAt(n, 524), n.byteLength > _li.MAGIC_COOKIE && (this.extensionFlag[0] = Ye.getByteAt(n, 540), this.extensionFlag[1] = Ye.getByteAt(n, 541), this.extensionFlag[2] = Ye.getByteAt(n, 542), this.extensionFlag[3] = Ye.getByteAt(n, 543), this.extensionFlag[0] && (this.extensions = Ye.getExtensionsAt(n, this.getExtensionLocation(), this.littleEndian, this.vox_offset), this.extensionSize = this.extensions[0].esize, this.extensionCode = this.extensions[0].ecode));
    }
    toFormattedString() {
      var e = Ye.formatNumber, n = "";
      return n += "Datatype = " + +this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + `)
`, n += "Bits Per Voxel =  = " + this.numBitsPerVoxel + `
`, n += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + `
`, n += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + `
`, n += "Voxel Dimensions (1-8): " + e(this.pixDims[0]) + ", " + e(this.pixDims[1]) + ", " + e(this.pixDims[2]) + ", " + e(this.pixDims[3]) + ", " + e(this.pixDims[4]) + ", " + e(this.pixDims[5]) + ", " + e(this.pixDims[6]) + ", " + e(this.pixDims[7]) + `
`, n += "Image Offset = " + this.vox_offset + `
`, n += "Data Scale:  Slope = " + e(this.scl_slope) + "  Intercept = " + e(this.scl_inter) + `
`, n += "Display Range:  Max = " + e(this.cal_max) + "  Min = " + e(this.cal_min) + `
`, n += "Slice Duration = " + this.slice_duration + `
`, n += "Time Axis Shift = " + this.toffset + `
`, n += "Slice Start = " + this.slice_start + `
`, n += "Slice End = " + this.slice_end + `
`, n += 'Description: "' + this.description + `"
`, n += 'Auxiliary File: "' + this.aux_file + `"
`, n += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + `)
`, n += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + `)
`, n += "Quaternion Parameters:  b = " + e(this.quatern_b) + "  c = " + e(this.quatern_c) + "  d = " + e(this.quatern_d) + `
`, n += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + `
`, n += "S-Form Parameters X: " + e(this.affine[0][0]) + ", " + e(this.affine[0][1]) + ", " + e(this.affine[0][2]) + ", " + e(this.affine[0][3]) + `
`, n += "S-Form Parameters Y: " + e(this.affine[1][0]) + ", " + e(this.affine[1][1]) + ", " + e(this.affine[1][2]) + ", " + e(this.affine[1][3]) + `
`, n += "S-Form Parameters Z: " + e(this.affine[2][0]) + ", " + e(this.affine[2][1]) + ", " + e(this.affine[2][2]) + ", " + e(this.affine[2][3]) + `
`, n += "Slice Code = " + this.slice_code + `
`, n += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(tt.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(tt.TEMPORAL_UNITS_MASK & this.xyzt_units) + `)
`, n += "Intent Code = " + this.intent_code + `
`, n += 'Intent Name: "' + this.intent_name + `"
`, n += "Dim Info = " + this.dim_info + `
`, n;
    }
    toArrayBuffer(e = false) {
      let i = 544;
      if (e) for (let l of this.extensions) i += l.esize;
      let a = new Uint8Array(i), s = new DataView(a.buffer);
      s.setInt32(0, 540, this.littleEndian), a.set(new TextEncoder().encode(this.magic), 4), s.setInt16(12, this.datatypeCode, this.littleEndian), s.setInt16(14, this.numBitsPerVoxel, this.littleEndian);
      for (let l = 0; l < 8; l++) s.setBigInt64(16 + 8 * l, BigInt(this.dims[l]), this.littleEndian);
      s.setFloat64(80, this.intent_p1, this.littleEndian), s.setFloat64(88, this.intent_p2, this.littleEndian), s.setFloat64(96, this.intent_p3, this.littleEndian);
      for (let l = 0; l < 8; l++) s.setFloat64(104 + 8 * l, this.pixDims[l], this.littleEndian);
      s.setBigInt64(168, BigInt(this.vox_offset), this.littleEndian), s.setFloat64(176, this.scl_slope, this.littleEndian), s.setFloat64(184, this.scl_inter, this.littleEndian), s.setFloat64(192, this.cal_max, this.littleEndian), s.setFloat64(200, this.cal_min, this.littleEndian), s.setFloat64(208, this.slice_duration, this.littleEndian), s.setFloat64(216, this.toffset, this.littleEndian), s.setBigInt64(224, BigInt(this.slice_start), this.littleEndian), s.setBigInt64(232, BigInt(this.slice_end), this.littleEndian), a.set(new TextEncoder().encode(this.description), 240), a.set(new TextEncoder().encode(this.aux_file), 320), s.setInt32(344, this.qform_code, this.littleEndian), s.setInt32(348, this.sform_code, this.littleEndian), s.setFloat64(352, this.quatern_b, this.littleEndian), s.setFloat64(360, this.quatern_c, this.littleEndian), s.setFloat64(368, this.quatern_d, this.littleEndian), s.setFloat64(376, this.qoffset_x, this.littleEndian), s.setFloat64(384, this.qoffset_y, this.littleEndian), s.setFloat64(392, this.qoffset_z, this.littleEndian);
      const o = this.affine.flat();
      for (let l = 0; l < 12; l++) s.setFloat64(400 + 8 * l, o[l], this.littleEndian);
      if (s.setInt32(496, this.slice_code, this.littleEndian), s.setInt32(500, this.xyzt_units, this.littleEndian), s.setInt32(504, this.intent_code, this.littleEndian), a.set(new TextEncoder().encode(this.intent_name), 508), s.setUint8(524, this.dim_info), e) {
        a.set(Uint8Array.from([
          1,
          0,
          0,
          0
        ]), 540);
        let l = this.getExtensionLocation();
        for (const c of this.extensions) s.setInt32(l, c.esize, c.littleEndian), s.setInt32(l + 4, c.ecode, c.littleEndian), a.set(new Uint8Array(c.edata), l + 8), l += c.esize;
      } else a.set(new Uint8Array(4).fill(0), 540);
      return a.buffer;
    }
  };
  __publicField(_li, "MAGIC_COOKIE", 540);
  __publicField(_li, "MAGIC_NUMBER_LOCATION", 4);
  __publicField(_li, "MAGIC_NUMBER", [
    110,
    43,
    50,
    0,
    13,
    10,
    26,
    10
  ]);
  __publicField(_li, "MAGIC_NUMBER2", [
    110,
    105,
    50,
    0,
    13,
    10,
    26,
    10
  ]);
  let li = _li;
  function sk(t, e = false) {
    var n, r, i, a;
    return t.byteLength < tt.STANDARD_HEADER_SIZE ? false : (n = new DataView(t), n && (r = n.getUint8(tt.MAGIC_NUMBER_LOCATION)), i = n.getUint8(tt.MAGIC_NUMBER_LOCATION + 1), a = n.getUint8(tt.MAGIC_NUMBER_LOCATION + 2), e && r === tt.MAGIC_NUMBER2[0] && i === tt.MAGIC_NUMBER2[1] && a === tt.MAGIC_NUMBER2[2] ? true : r === tt.MAGIC_NUMBER[0] && i === tt.MAGIC_NUMBER[1] && a === tt.MAGIC_NUMBER[2]);
  }
  function ok(t, e = false) {
    var n, r, i, a;
    return t.byteLength < tt.STANDARD_HEADER_SIZE ? false : (n = new DataView(t), r = n.getUint8(li.MAGIC_NUMBER_LOCATION), i = n.getUint8(li.MAGIC_NUMBER_LOCATION + 1), a = n.getUint8(li.MAGIC_NUMBER_LOCATION + 2), e && r === li.MAGIC_NUMBER2[0] && i === li.MAGIC_NUMBER2[1] && a === li.MAGIC_NUMBER2[2] ? true : r === li.MAGIC_NUMBER[0] && i === li.MAGIC_NUMBER[1] && a === li.MAGIC_NUMBER[2]);
  }
  function Q6(t) {
    var e, n, r;
    return !!(t && (e = new DataView(t), n = e.getUint8(0), r = e.getUint8(1), n === Ye.GUNZIP_MAGIC_COOKIE1 || r === Ye.GUNZIP_MAGIC_COOKIE2));
  }
  function lk(t) {
    return rk(new Uint8Array(t)).buffer;
  }
  async function ck(t) {
    const e = new Uint8Array(t), n = e[0] === 31 && e[1] === 139 && e[2] === 8 ? "gzip" : e[0] === 120 && (e[1] === 1 || e[1] === 94 || e[1] === 156 || e[1] === 218) ? "deflate" : "deflate-raw", r = new DecompressionStream(n), i = r.writable.getWriter();
    i.write(e).catch(console.error);
    const a = i.close().catch(console.error), o = await new Response(r.readable).arrayBuffer();
    return await a, o;
  }
  async function Pw(t, e = 1 / 0) {
    const n = (g) => g[0] === 31 && g[1] === 139 && g[2] === 8 ? "gzip" : g[0] === 120 && [
      1,
      94,
      156,
      218
    ].includes(g[1]) ? "deflate" : "deflate-raw", r = new Uint8Array(t), i = n(r), a = new DecompressionStream(i), s = new TransformStream({
      transform(g, v) {
        v.enqueue(g);
      },
      flush(g) {
        g.terminate();
      }
    }), { readable: o, writable: l } = a, c = l.getWriter(), f = o.pipeThrough(s).getReader();
    c.write(r).catch((g) => {
      g instanceof Error && g.name === "AbortError" || console.error("Error during write:", g);
    });
    const u = [];
    let h = 0;
    try {
      for (; h < e; ) {
        const { done: g, value: v } = await f.read();
        if (g) break;
        const m = e - h, y = v.subarray(0, Math.min(v.length, m));
        if (u.push(y), h += y.length, h >= e) {
          await Promise.all([
            f.cancel().catch(() => {
            }),
            c.abort().catch(() => {
            })
          ]);
          break;
        }
      }
    } catch (g) {
      g instanceof Error && g.name === "AbortError" || console.error("Error during decompression:", g);
    } finally {
      await Promise.allSettled([
        f.cancel().catch(() => {
        }),
        c.close().catch(() => {
        })
      ]);
    }
    return u.length === 1 ? u[0].buffer : u.reduce((g, v) => {
      const m = new Uint8Array(g.byteLength + v.byteLength);
      return m.set(new Uint8Array(g), 0), m.set(v, g.byteLength), m.buffer;
    }, new ArrayBuffer(0));
  }
  function uk(t, e = false) {
    let n = null;
    if (Q6(t) && (t = lk(t)), sk(t, e) ? n = new tt() : ok(t, e) && (n = new li()), n) n.readHeader(t);
    else throw new Error("That file does not appear to be NIFTI!");
    return n;
  }
  async function F1(t, e = false) {
    if (!Q6(t)) return uk(t, e);
    let n = null, r = await Pw(t, 540), i = true, a = true;
    var s = new DataView(r);
    const o = s.getInt32(0, true), l = s.getInt32(0, false);
    if (o !== 348) if (l === 348) i = false;
    else if (o === 540) a = false;
    else if (l === 540) a = false, i = false;
    else throw new Error("That file does not appear to be NIFTI!");
    let c = Math.round(s.getFloat32(108, i));
    return li && (c = Ye.getUint64At(s, 168, i)), c > r.byteLength && (r = await Pw(t, c)), a ? n = new tt() : n = new li(), n.readHeader(r), n;
  }
  function fk(t) {
    return t.extensionFlag[0] != 0;
  }
  function hk(t, e) {
    var n = t.vox_offset, r = 1, i = 1;
    t.dims[4] && (r = t.dims[4]), t.dims[5] && (i = t.dims[5]);
    var a = t.dims[1] * t.dims[2] * t.dims[3] * r * i * (t.numBitsPerVoxel / 8);
    return e.slice(n, n + a);
  }
  function GE(t, e, n, r = {}) {
    return e !== void 0 && n !== void 0 && (r = {
      ...r,
      headers: {
        ...r.headers,
        Range: `bytes=${e}-${e + n - 1}`
      }
    }), fetch(t, r);
  }
  function dk(t, e) {
    return {
      ...t,
      ...e,
      headers: {
        ...t.headers,
        ...e.headers
      }
    };
  }
  function Gw(t, e) {
    const n = typeof t == "string" ? new URL(t) : t;
    n.pathname.endsWith("/") || (n.pathname += "/");
    const r = new URL(e.slice(1), n);
    return r.search = n.search, r;
  }
  async function zw(t) {
    if (t.status !== 404) {
      if (t.status === 200 || t.status === 206) return new Uint8Array(await t.arrayBuffer());
      throw new Error(`Unexpected response status ${t.status} ${t.statusText}`);
    }
  }
  async function gk(t, e, n, r) {
    if (r) return fetch(t, {
      ...n,
      headers: {
        ...n.headers,
        Range: `bytes=-${e}`
      }
    });
    let i = await fetch(t, {
      ...n,
      method: "HEAD"
    });
    if (!i.ok) return i;
    let a = i.headers.get("Content-Length"), s = Number(a);
    return GE(t, s - e, s, n);
  }
  class pk {
    constructor(e, n = {}) {
      __privateAdd(this, _pk_instances);
      __publicField(this, "url");
      __privateAdd(this, _e);
      __privateAdd(this, _t);
      this.url = e, __privateSet(this, _e, n.overrides ?? {}), __privateSet(this, _t, n.useSuffixRequest ?? false);
    }
    async get(e, n = {}) {
      let r = Gw(this.url, e).href, i = await fetch(r, __privateMethod(this, _pk_instances, n_fn).call(this, n));
      return zw(i);
    }
    async getRange(e, n, r = {}) {
      let i = Gw(this.url, e), a = __privateMethod(this, _pk_instances, n_fn).call(this, r), s;
      return "suffixLength" in n ? s = await gk(i, n.suffixLength, a, __privateGet(this, _t)) : s = await GE(i, n.offset, n.length, a), zw(s);
    }
  }
  _e = new WeakMap();
  _t = new WeakMap();
  _pk_instances = new WeakSet();
  n_fn = function(e) {
    return dk(__privateGet(this, _e), e);
  };
  const mk = "modulepreload", vk = function(t) {
    return "/" + t;
  }, Ww = {}, J3 = function(e, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
      let l = function(c) {
        return Promise.all(c.map((f) => Promise.resolve(f).then((u) => ({
          status: "fulfilled",
          value: u
        }), (u) => ({
          status: "rejected",
          reason: u
        }))));
      };
      document.getElementsByTagName("link");
      const s = document.querySelector("meta[property=csp-nonce]"), o = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute("nonce"));
      i = l(n.map((c) => {
        if (c = vk(c), c in Ww) return;
        Ww[c] = true;
        const f = c.endsWith(".css"), u = f ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${c}"]${u}`)) return;
        const h = document.createElement("link");
        if (h.rel = f ? "stylesheet" : mk, f || (h.as = "script"), h.crossOrigin = "", h.href = c, o && h.setAttribute("nonce", o), document.head.appendChild(h), f) return new Promise((g, v) => {
          h.addEventListener("load", g), h.addEventListener("error", () => v(new Error(`Unable to preload CSS for ${c}`)));
        });
      }));
    }
    function a(s) {
      const o = new Event("vite:preloadError", {
        cancelable: true
      });
      if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s;
    }
    return i.then((s) => {
      for (const o of s || []) o.status === "rejected" && a(o.reason);
      return e().catch(a);
    });
  };
  class zE {
    constructor(e, n, r) {
      __privateAdd(this, _e2);
      typeof e == "number" ? __privateSet(this, _e2, new Uint8Array(e)) : e instanceof ArrayBuffer ? __privateSet(this, _e2, new Uint8Array(e, n, r)) : __privateSet(this, _e2, new Uint8Array(Array.from(e, (i) => i ? 1 : 0)));
    }
    get BYTES_PER_ELEMENT() {
      return 1;
    }
    get byteOffset() {
      return __privateGet(this, _e2).byteOffset;
    }
    get byteLength() {
      return __privateGet(this, _e2).byteLength;
    }
    get buffer() {
      return __privateGet(this, _e2).buffer;
    }
    get length() {
      return __privateGet(this, _e2).length;
    }
    get(e) {
      let n = __privateGet(this, _e2)[e];
      return typeof n == "number" ? n !== 0 : n;
    }
    set(e, n) {
      __privateGet(this, _e2)[e] = n ? 1 : 0;
    }
    fill(e) {
      __privateGet(this, _e2).fill(e ? 1 : 0);
    }
    *[Symbol.iterator]() {
      for (let e = 0; e < this.length; e++) yield this.get(e);
    }
  }
  _e2 = new WeakMap();
  class J6 {
    constructor(e, n, r, i) {
      __publicField(this, "_data");
      __publicField(this, "chars");
      __privateAdd(this, _e3);
      if (this.chars = e, __privateSet(this, _e3, new TextEncoder()), typeof n == "number") this._data = new Uint8Array(n * e);
      else if (n instanceof ArrayBuffer) i && (i = i * e), this._data = new Uint8Array(n, r, i);
      else {
        let a = Array.from(n);
        this._data = new Uint8Array(a.length * e);
        for (let s = 0; s < a.length; s++) this.set(s, a[s]);
      }
    }
    get BYTES_PER_ELEMENT() {
      return this.chars;
    }
    get byteOffset() {
      return this._data.byteOffset;
    }
    get byteLength() {
      return this._data.byteLength;
    }
    get buffer() {
      return this._data.buffer;
    }
    get length() {
      return this.byteLength / this.BYTES_PER_ELEMENT;
    }
    get(e) {
      const n = new Uint8Array(this.buffer, this.byteOffset + this.chars * e, this.chars);
      return new TextDecoder().decode(n).replace(/\x00/g, "");
    }
    set(e, n) {
      const r = new Uint8Array(this.buffer, this.byteOffset + this.chars * e, this.chars);
      r.fill(0), r.set(__privateGet(this, _e3).encode(n));
    }
    fill(e) {
      const n = __privateGet(this, _e3).encode(e);
      for (let r = 0; r < this.length; r++) this._data.set(n, r * this.chars);
    }
    *[Symbol.iterator]() {
      for (let e = 0; e < this.length; e++) yield this.get(e);
    }
  }
  _e3 = new WeakMap();
  const _Kh = class _Kh {
    constructor(e, n, r, i) {
      __privateAdd(this, _e4);
      __publicField(this, "chars");
      if (this.chars = e, typeof n == "number") __privateSet(this, _e4, new Int32Array(n * e));
      else if (n instanceof ArrayBuffer) i && (i *= e), __privateSet(this, _e4, new Int32Array(n, r, i));
      else {
        const a = n, s = new _Kh(e, 1);
        __privateSet(this, _e4, new Int32Array((function* () {
          for (let o of a) s.set(0, o), yield* __privateGet(s, _e4);
        })()));
      }
    }
    get BYTES_PER_ELEMENT() {
      return __privateGet(this, _e4).BYTES_PER_ELEMENT * this.chars;
    }
    get byteLength() {
      return __privateGet(this, _e4).byteLength;
    }
    get byteOffset() {
      return __privateGet(this, _e4).byteOffset;
    }
    get buffer() {
      return __privateGet(this, _e4).buffer;
    }
    get length() {
      return __privateGet(this, _e4).length / this.chars;
    }
    get(e) {
      const n = this.chars * e;
      let r = "";
      for (let i = 0; i < this.chars; i++) r += String.fromCodePoint(__privateGet(this, _e4)[n + i]);
      return r.replace(/\u0000/g, "");
    }
    set(e, n) {
      const r = this.chars * e, i = __privateGet(this, _e4).subarray(r, r + this.chars);
      i.fill(0);
      for (let a = 0; a < this.chars; a++) i[a] = n.codePointAt(a) ?? 0;
    }
    fill(e) {
      this.set(0, e);
      let n = __privateGet(this, _e4).subarray(0, this.chars);
      for (let r = 1; r < this.length; r++) __privateGet(this, _e4).set(n, r * this.chars);
    }
    *[Symbol.iterator]() {
      for (let e = 0; e < this.length; e++) yield this.get(e);
    }
  };
  _e4 = new WeakMap();
  let Kh = _Kh;
  function Yh(t) {
    const e = new TextDecoder().decode(t);
    return JSON.parse(e);
  }
  function Hw(t, e) {
    const n = e / 2, r = e - 1;
    let i = 0;
    for (let a = 0; a < t.length; a += e) for (let s = 0; s < n; s += 1) i = t[a + s], t[a + s] = t[a + r - s], t[a + r - s] = i;
  }
  function WE(t) {
    if (t === "v2:object") return globalThis.Array;
    let e = t.match(/v2:([US])(\d+)/);
    if (e) {
      let [, r, i] = e;
      return (r === "U" ? Kh : J6).bind(null, Number(i));
    }
    let n = {
      int8: Int8Array,
      int16: Int16Array,
      int32: Int32Array,
      int64: globalThis.BigInt64Array,
      uint8: Uint8Array,
      uint16: Uint16Array,
      uint32: Uint32Array,
      uint64: globalThis.BigUint64Array,
      float16: globalThis.Float16Array,
      float32: Float32Array,
      float64: Float64Array,
      bool: zE
    }[t];
    return Gr(n, `Unknown or unsupported data_type: ${t}`), n;
  }
  function Gc(t, e) {
    const n = t.length;
    typeof e == "string" && (e = e === "C" ? Array.from({
      length: n
    }, (a, s) => s) : Array.from({
      length: n
    }, (a, s) => n - 1 - s)), Gr(n === e.length, "Order length must match the number of dimensions.");
    let r = 1, i = new Array(n);
    for (let a = e.length - 1; a >= 0; a--) i[e[a]] = r, r *= t[e[a]];
    return i;
  }
  function yk({ name: t, configuration: e }) {
    if (t === "default") {
      const n = (e == null ? void 0 : e.separator) ?? "/";
      return (r) => [
        "c",
        ...r
      ].join(n);
    }
    if (t === "v2") {
      const n = (e == null ? void 0 : e.separator) ?? ".";
      return (r) => r.join(n) || "0";
    }
    throw new Error(`Unknown chunk key encoding: ${t}`);
  }
  function xk(t) {
    if (t === "|O") return {
      data_type: "v2:object"
    };
    let e = t.match(/^([<|>])(.*)$/);
    Gr(e, `Invalid dtype: ${t}`);
    let [, n, r] = e, i = {
      b1: "bool",
      i1: "int8",
      u1: "uint8",
      i2: "int16",
      u2: "uint16",
      i4: "int32",
      u4: "uint32",
      i8: "int64",
      u8: "uint64",
      f2: "float16",
      f4: "float32",
      f8: "float64"
    }[r] ?? (r.startsWith("S") || r.startsWith("U") ? `v2:${r}` : void 0);
    return Gr(i, `Unsupported or unknown dtype: ${t}`), n === "|" ? {
      data_type: i
    } : {
      data_type: i,
      endian: n === "<" ? "little" : "big"
    };
  }
  function wk(t, e = {}) {
    let n = [], r = xk(t.dtype);
    t.order === "F" && n.push({
      name: "transpose",
      configuration: {
        order: "F"
      }
    }), "endian" in r && r.endian === "big" && n.push({
      name: "bytes",
      configuration: {
        endian: "big"
      }
    });
    for (let { id: i, ...a } of t.filters ?? []) n.push({
      name: i,
      configuration: a
    });
    if (t.compressor) {
      let { id: i, ...a } = t.compressor;
      n.push({
        name: i,
        configuration: a
      });
    }
    return {
      zarr_format: 3,
      node_type: "array",
      shape: t.shape,
      data_type: r.data_type,
      chunk_grid: {
        name: "regular",
        configuration: {
          chunk_shape: t.chunks
        }
      },
      chunk_key_encoding: {
        name: "v2",
        configuration: {
          separator: t.dimension_separator ?? "."
        }
      },
      codecs: n,
      fill_value: t.fill_value,
      attributes: e
    };
  }
  function Ck(t, e = {}) {
    return {
      zarr_format: 3,
      node_type: "group",
      attributes: e
    };
  }
  function Tk(t, e) {
    if (e !== "number" && e !== "bigint" && e !== "boolean" && e !== "object" && e !== "string") return t === e;
    let n = t === "bool";
    if (e === "boolean") return n;
    let r = t.startsWith("v2:U") || t.startsWith("v2:S");
    if (e === "string") return r;
    let i = t === "int64" || t === "uint64";
    if (e === "bigint") return i;
    let a = t === "v2:object";
    return e === "object" ? a : !r && !i && !n && !a;
  }
  function Sk(t) {
    return (t == null ? void 0 : t.name) === "sharding_indexed";
  }
  function HE(t) {
    return (t.data_type === "uint64" || t.data_type === "int64") && t.fill_value != null ? BigInt(t.fill_value) : t.fill_value;
  }
  function jE(t, ...e) {
    if (!e.some((n) => t instanceof n)) throw t;
  }
  function Gr(t, e = "") {
    if (!t) throw new Error(e);
  }
  async function KE(t, { format: e, signal: n }) {
    const r = t instanceof Response ? t : new Response(t);
    Gr(r.body, "Response does not contain body.");
    try {
      return await new Response(r.body.pipeThrough(new DecompressionStream(e), {
        signal: n
      })).arrayBuffer();
    } catch {
      throw n == null ? void 0 : n.throwIfAborted(), new Error(`Failed to decode ${e}`);
    }
  }
  class $6 {
    constructor(e, n) {
      __publicField(this, "kind", "array_to_array");
      Gr(e.keepbits >= 0, "keepbits must be zero or positive");
    }
    static fromConfig(e, n) {
      return new $6(e, n);
    }
    encode(e) {
      throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.");
    }
    decode(e) {
      return e;
    }
  }
  const jw = Ak();
  function Ak() {
    const t = new Uint32Array([
      305419896
    ]);
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)[0] !== 18;
  }
  function Kw(t) {
    return "BYTES_PER_ELEMENT" in t ? t.BYTES_PER_ELEMENT : 4;
  }
  const _l5 = class _l5 {
    constructor(e, n) {
      __publicField(this, "kind", "array_to_bytes");
      __privateAdd(this, _e5);
      __privateAdd(this, _t2);
      __privateAdd(this, _n2);
      __privateAdd(this, _i2);
      __privateAdd(this, _r);
      __privateSet(this, _r, e == null ? void 0 : e.endian), __privateSet(this, _t2, WE(n.data_type)), __privateSet(this, _i2, n.shape), __privateSet(this, _e5, Gc(n.shape, "C"));
      const r = new (__privateGet(this, _t2))(0);
      __privateSet(this, _n2, r.BYTES_PER_ELEMENT);
    }
    static fromConfig(e, n) {
      return new _l5(e, n);
    }
    encode(e) {
      let n = new Uint8Array(e.data.buffer);
      return jw && __privateGet(this, _r) === "big" && Hw(n, Kw(__privateGet(this, _t2))), n;
    }
    decode(e) {
      return jw && __privateGet(this, _r) === "big" && Hw(e, Kw(__privateGet(this, _t2))), {
        data: new (__privateGet(this, _t2))(e.buffer, e.byteOffset, e.byteLength / __privateGet(this, _n2)),
        shape: __privateGet(this, _i2),
        stride: __privateGet(this, _e5)
      };
    }
  };
  _e5 = new WeakMap();
  _t2 = new WeakMap();
  _n2 = new WeakMap();
  _i2 = new WeakMap();
  _r = new WeakMap();
  let l5 = _l5;
  class e8 {
    constructor() {
      __publicField(this, "kind", "bytes_to_bytes");
    }
    static fromConfig() {
      return new e8();
    }
    encode(e) {
      throw new Error("Not implemented");
    }
    decode(e) {
      return new Uint8Array(e.buffer, e.byteOffset, e.byteLength - 4);
    }
  }
  class t8 {
    constructor() {
      __publicField(this, "kind", "bytes_to_bytes");
    }
    static fromConfig(e) {
      return new t8();
    }
    encode(e) {
      throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.");
    }
    async decode(e) {
      const n = await KE(e, {
        format: "gzip"
      });
      return new Uint8Array(n);
    }
  }
  function Ek(t, e) {
    return Gr(!Number.isNaN(e), "JsonCodec allow_nan is false but NaN was encountered during encoding."), Gr(e !== Number.POSITIVE_INFINITY, "JsonCodec allow_nan is false but Infinity was encountered during encoding."), Gr(e !== Number.NEGATIVE_INFINITY, "JsonCodec allow_nan is false but -Infinity was encountered during encoding."), e;
  }
  function bk(t, e) {
    return e instanceof Object && !Array.isArray(e) ? Object.keys(e).sort().reduce((n, r) => (n[r] = e[r], n), {}) : e;
  }
  const _n8 = class _n8 {
    constructor(e = {}) {
      __publicField(this, "configuration");
      __publicField(this, "kind", "array_to_bytes");
      __privateAdd(this, _e6);
      __privateAdd(this, _t3);
      this.configuration = e;
      const { encoding: n = "utf-8", skipkeys: r = false, ensure_ascii: i = true, check_circular: a = true, allow_nan: s = true, sort_keys: o = true, indent: l, strict: c = true } = e;
      let f = e.separators;
      f || (l ? f = [
        ", ",
        ": "
      ] : f = [
        ",",
        ":"
      ]), __privateSet(this, _e6, {
        encoding: n,
        skipkeys: r,
        ensure_ascii: i,
        check_circular: a,
        allow_nan: s,
        indent: l,
        separators: f,
        sort_keys: o
      }), __privateSet(this, _t3, {
        strict: c
      });
    }
    static fromConfig(e) {
      return new _n8(e);
    }
    encode(e) {
      const { indent: n, encoding: r, ensure_ascii: i, check_circular: a, allow_nan: s, sort_keys: o } = __privateGet(this, _e6);
      Gr(r === "utf-8", "JsonCodec does not yet support non-utf-8 encoding.");
      const l = [];
      Gr(a, "JsonCodec does not yet support skipping the check for circular references during encoding."), s || l.push(Ek), o && l.push(bk);
      const c = Array.from(e.data);
      c.push("|O"), c.push(e.shape);
      let f;
      l.length && (f = (h, g) => {
        let v = g;
        for (let m of l) v = m(h, v);
        return v;
      });
      let u = JSON.stringify(c, f, n);
      return i && (u = u.replace(/[\u007F-\uFFFF]/g, (h) => {
        const g = `0000${h.charCodeAt(0).toString(16)}`;
        return `\\u${g.substring(g.length - 4)}`;
      })), new TextEncoder().encode(u);
    }
    decode(e) {
      const { strict: n } = __privateGet(this, _t3);
      Gr(n, "JsonCodec does not yet support non-strict decoding.");
      const r = Yh(e), i = r.pop();
      r.pop(), Gr(i, "0D not implemented for JsonCodec.");
      const a = Gc(i, "C");
      return {
        data: r,
        shape: i,
        stride: a
      };
    }
  };
  _e6 = new WeakMap();
  _t3 = new WeakMap();
  let n8 = _n8;
  function Yw(t) {
    return t instanceof zE || t instanceof J6 || t instanceof Kh ? new Proxy(t, {
      get(n, r) {
        return n.get(Number(r));
      },
      set(n, r, i) {
        return n.set(Number(r), i), true;
      }
    }) : t;
  }
  function Dk(t, e) {
    let n;
    return t.data instanceof J6 || t.data instanceof Kh ? n = new t.constructor(t.data.length, t.data.chars) : n = new t.constructor(t.data.length), {
      data: n,
      shape: t.shape,
      stride: Gc(t.shape, e)
    };
  }
  function Mk(t, e) {
    let n = Dk(t, e), r = t.shape.length, i = t.data.length, a = Array(r).fill(0), s = Yw(t.data), o = Yw(n.data);
    for (let l = 0; l < i; l++) {
      let c = 0;
      for (let f = 0; f < r; f++) c += a[f] * n.stride[f];
      o[c] = s[l], a[0] += 1;
      for (let f = 0; f < r; f++) if (a[f] === t.shape[f]) {
        if (f + 1 === r) break;
        a[f] = 0, a[f + 1] += 1;
      }
    }
    return n;
  }
  function Rk(t) {
    let e = t.shape.length;
    return Gr(e === t.stride.length, "Shape and stride must have the same length."), t.stride.map((n, r) => ({
      stride: n,
      index: r
    })).sort((n, r) => r.stride - n.stride).map((n) => n.index);
  }
  function Ok(t, e) {
    let n = Rk(t);
    return Gr(n.length === e.length, "Orders must match"), n.every((r, i) => r === e[i]);
  }
  const _r8 = class _r8 {
    constructor(e, n) {
      __publicField(this, "kind", "array_to_array");
      __privateAdd(this, _e7);
      __privateAdd(this, _t4);
      let r = e.order ?? "C", i = n.shape.length, a = new Array(i), s = new Array(i);
      if (r === "C") for (let o = 0; o < i; ++o) a[o] = o, s[o] = o;
      else if (r === "F") for (let o = 0; o < i; ++o) a[o] = i - o - 1, s[o] = i - o - 1;
      else a = r, a.forEach((o, l) => {
        Gr(s[o] === void 0, `Invalid permutation: ${JSON.stringify(r)}`), s[o] = l;
      });
      __privateSet(this, _e7, a), __privateSet(this, _t4, s);
    }
    static fromConfig(e, n) {
      return new _r8(e, n);
    }
    encode(e) {
      return Ok(e, __privateGet(this, _t4)) ? e : Mk(e, __privateGet(this, _t4));
    }
    decode(e) {
      return {
        data: e.data,
        shape: e.shape,
        stride: Gc(e.shape, __privateGet(this, _e7))
      };
    }
  };
  _e7 = new WeakMap();
  _t4 = new WeakMap();
  let r8 = _r8;
  const _i8 = class _i8 {
    constructor(e) {
      __publicField(this, "kind", "array_to_bytes");
      __privateAdd(this, _e8);
      __privateAdd(this, _t5);
      __privateSet(this, _e8, e), __privateSet(this, _t5, Gc(e, "C"));
    }
    static fromConfig(e, n) {
      return new _i8(n.shape);
    }
    encode(e) {
      throw new Error("Method not implemented.");
    }
    decode(e) {
      let n = new TextDecoder(), r = new DataView(e.buffer), i = Array(r.getUint32(0, true)), a = 4;
      for (let s = 0; s < i.length; s++) {
        let o = r.getUint32(a, true);
        a += 4, i[s] = n.decode(e.buffer.slice(a, a + o)), a += o;
      }
      return {
        data: i,
        shape: __privateGet(this, _e8),
        stride: __privateGet(this, _t5)
      };
    }
  };
  _e8 = new WeakMap();
  _t5 = new WeakMap();
  let i8 = _i8;
  class a8 {
    constructor() {
      __publicField(this, "kind", "bytes_to_bytes");
    }
    static fromConfig(e) {
      return new a8();
    }
    encode(e) {
      throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.");
    }
    async decode(e) {
      const n = await KE(e, {
        format: "deflate"
      });
      return new Uint8Array(n);
    }
  }
  function Ik() {
    return (/* @__PURE__ */ new Map()).set("blosc", () => J3(() => import("./blosc-CrUiACa7.js"), __vite__mapDeps([0,1])).then((t) => t.default)).set("lz4", () => J3(() => import("./lz4-B_Exjfmr.js"), __vite__mapDeps([2,1])).then((t) => t.default)).set("zstd", () => J3(() => import("./zstd-u5eweWyS.js"), __vite__mapDeps([3,1])).then((t) => t.default)).set("gzip", () => t8).set("zlib", () => a8).set("transpose", () => r8).set("bytes", () => l5).set("crc32c", () => e8).set("vlen-utf8", () => i8).set("json2", () => n8).set("bitround", () => $6);
  }
  const Vk = Ik();
  function Fv(t) {
    let e;
    return {
      async encode(n) {
        e || (e = await qw(t));
        for (const i of e.array_to_array) n = await i.encode(n);
        let r = await e.array_to_bytes.encode(n);
        for (const i of e.bytes_to_bytes) r = await i.encode(r);
        return r;
      },
      async decode(n) {
        e || (e = await qw(t));
        for (let i = e.bytes_to_bytes.length - 1; i >= 0; i--) n = await e.bytes_to_bytes[i].decode(n);
        let r = await e.array_to_bytes.decode(n);
        for (let i = e.array_to_array.length - 1; i >= 0; i--) r = await e.array_to_array[i].decode(r);
        return r;
      }
    };
  }
  async function qw(t) {
    let e = t.codecs.map(async (a) => {
      var _a3;
      let s = await ((_a3 = Vk.get(a.name)) == null ? void 0 : _a3());
      return Gr(s, `Unknown codec: ${a.name}`), {
        Codec: s,
        meta: a
      };
    }), n = [], r, i = [];
    for await (let { Codec: a, meta: s } of e) {
      let o = a.fromConfig(s.configuration, t);
      switch (o.kind) {
        case "array_to_array":
          n.push(o);
          break;
        case "array_to_bytes":
          r = o;
          break;
        default:
          i.push(o);
      }
    }
    return r || (Gr(Nk(t), `Cannot encode ${t.data_type} to bytes without a codec`), r = l5.fromConfig({
      endian: "little"
    }, t)), {
      array_to_array: n,
      array_to_bytes: r,
      bytes_to_bytes: i
    };
  }
  function Nk(t) {
    return t.data_type !== "v2:object";
  }
  class qh extends Error {
    constructor(e, n = {}) {
      super(`Node not found: ${e}`, n), this.name = "NodeNotFoundError";
    }
  }
  class s8 extends Error {
    constructor(e) {
      super(`Missing key: ${e}`), this.name = "KeyError";
    }
  }
  const Xw = 18446744073709551615n;
  function Lk(t, e, n, r) {
    Gr(t.store.getRange, "Store does not support range requests");
    let i = t.store.getRange.bind(t.store), a = e.map((l, c) => l / r.chunk_shape[c]), s = Fv({
      data_type: "uint64",
      shape: [
        ...a,
        2
      ],
      codecs: r.index_codecs
    }), o = {};
    return async (l) => {
      let c = l.map((C, T) => Math.floor(C / a[T])), f = t.resolve(n(c)).path, u;
      if (f in o) u = o[f];
      else {
        let C = 4, T = 16 * a.reduce((E, b) => E * b, 1), S = await i(f, {
          suffixLength: T + C
        });
        u = o[f] = S ? await s.decode(S) : null;
      }
      if (u === null) return;
      let { data: h, shape: g, stride: v } = u, m = l.map((C, T) => C % g[T]).reduce((C, T, S) => C + T * v[S], 0), y = h[m], w = h[m + 1];
      if (!(y === Xw && w === Xw)) return i(f, {
        offset: Number(y),
        length: Number(w)
      });
    };
  }
  class r0 {
    constructor(e, n = "/") {
      __publicField(this, "store");
      __publicField(this, "path");
      this.store = e, this.path = n;
    }
    resolve(e) {
      let n = new URL(`file://${this.path.endsWith("/") ? this.path : `${this.path}/`}`);
      return new r0(this.store, new URL(e, n).pathname);
    }
  }
  function Uk(t) {
    return new r0(t ?? /* @__PURE__ */ new Map());
  }
  class o8 extends r0 {
    constructor(e, n, r) {
      super(e, n);
      __publicField(this, "kind", "group");
      __privateAdd(this, _e9);
      __privateSet(this, _e9, r);
    }
    get attrs() {
      return __privateGet(this, _e9).attributes;
    }
  }
  _e9 = new WeakMap();
  function Zw(t) {
    var _a3, _b3;
    return ((_b3 = (_a3 = t.find((n) => n.name === "transpose")) == null ? void 0 : _a3.configuration) == null ? void 0 : _b3.order) ?? "C";
  }
  const B1 = Symbol("zarrita.context");
  function Fk(t) {
    return t[B1];
  }
  function Bk(t, e) {
    let { configuration: n } = e.codecs.find(Sk) ?? {}, r = {
      encode_chunk_key: yk(e.chunk_key_encoding),
      TypedArray: WE(e.data_type),
      fill_value: e.fill_value
    };
    if (n) {
      let a = Zw(n.codecs);
      return {
        ...r,
        kind: "sharded",
        chunk_shape: n.chunk_shape,
        codec: Fv({
          data_type: e.data_type,
          shape: n.chunk_shape,
          codecs: n.codecs
        }),
        get_strides(s) {
          return Gc(s, a);
        },
        get_chunk_bytes: Lk(t, e.chunk_grid.configuration.chunk_shape, r.encode_chunk_key, n)
      };
    }
    let i = Zw(e.codecs);
    return {
      ...r,
      kind: "regular",
      chunk_shape: e.chunk_grid.configuration.chunk_shape,
      codec: Fv({
        data_type: e.data_type,
        shape: e.chunk_grid.configuration.chunk_shape,
        codecs: e.codecs
      }),
      get_strides(a) {
        return Gc(a, i);
      },
      async get_chunk_bytes(a, s) {
        let o = r.encode_chunk_key(a), l = t.resolve(o).path;
        return t.store.get(l, s);
      }
    };
  }
  let np = (_c2 = class extends (_b2 = r0, _a2 = B1, _b2) {
    constructor(e, n, r) {
      super(e, n);
      __publicField(this, "kind", "array");
      __privateAdd(this, _e10);
      __publicField(this, _a2);
      __privateSet(this, _e10, {
        ...r,
        fill_value: HE(r)
      }), this[B1] = Bk(this, r);
    }
    get attrs() {
      return __privateGet(this, _e10).attributes;
    }
    get shape() {
      return __privateGet(this, _e10).shape;
    }
    get chunks() {
      return this[B1].chunk_shape;
    }
    get dtype() {
      return __privateGet(this, _e10).data_type;
    }
    async getChunk(e, n) {
      let r = this[B1], i = await r.get_chunk_bytes(e, n);
      if (!i) {
        let a = r.chunk_shape.reduce((o, l) => o * l, 1), s = new r.TypedArray(a);
        return s.fill(r.fill_value), {
          data: s,
          shape: r.chunk_shape,
          stride: r.get_strides(r.chunk_shape)
        };
      }
      return r.codec.decode(i);
    }
    is(e) {
      return Tk(this.dtype, e);
    }
  }, _e10 = new WeakMap(), _c2);
  function* _k(t, e, n = 1) {
    e === void 0 && (e = t, t = 0);
    for (let r = t; r < e; r += n) yield r;
  }
  function* kk(...t) {
    if (t.length === 0) return;
    const e = t.map((r) => r[Symbol.iterator]()), n = e.map((r) => r.next());
    if (n.some((r) => r.done)) throw new Error("Input contains an empty iterator.");
    for (let r = 0; ; ) {
      if (n[r].done) {
        if (e[r] = t[r][Symbol.iterator](), n[r] = e[r].next(), ++r >= e.length) return;
      } else yield n.map(({ value: i }) => i), r = 0;
      n[r] = e[r].next();
    }
  }
  function Pk({ start: t, stop: e, step: n }, r) {
    if (n === 0) throw new Error("slice step cannot be zero");
    n = n ?? 1;
    const i = n < 0, [a, s] = i ? [
      -1,
      r - 1
    ] : [
      0,
      r
    ];
    return t === null ? t = i ? s : a : t < 0 ? (t += r, t < a && (t = a)) : t > s && (t = s), e === null ? e = i ? a : s : e < 0 ? (e += r, e < a && (e = a)) : e > s && (e = s), [
      t,
      e,
      n
    ];
  }
  function ih(t, e, n = null) {
    return e === void 0 && (e = t, t = null), {
      start: t,
      stop: e,
      step: n
    };
  }
  function Gk() {
    const t = [];
    return {
      add: (e) => t.push(e()),
      onIdle: () => Promise.all(t)
    };
  }
  class l8 extends Error {
    constructor(e) {
      super(e), this.name = "IndexError";
    }
  }
  function zk(t, e) {
    throw new l8(`too many indicies for array; expected ${e.length}, got ${t.length}`);
  }
  function Wk(t) {
    throw new l8(`index out of bounds for dimension with length ${t}`);
  }
  function Hk() {
    throw new l8("only slices with step >= 1 are supported");
  }
  function jk(t, e) {
    t.length > e.length && zk(t, e);
  }
  function Kk(t, e) {
    return t = Math.trunc(t), t < 0 && (t = e + t), (t >= e || t < 0) && Wk(e), t;
  }
  class Yk {
    constructor({ dim_sel: e, dim_len: n, dim_chunk_len: r }) {
      __publicField(this, "dim_sel");
      __publicField(this, "dim_len");
      __publicField(this, "dim_chunk_len");
      __publicField(this, "nitems");
      e = Kk(e, n), this.dim_sel = e, this.dim_len = n, this.dim_chunk_len = r, this.nitems = 1;
    }
    *[Symbol.iterator]() {
      const e = Math.floor(this.dim_sel / this.dim_chunk_len), n = e * this.dim_chunk_len, r = this.dim_sel - n;
      yield {
        dim_chunk_ix: e,
        dim_chunk_sel: r
      };
    }
  }
  class Qw {
    constructor({ dim_sel: e, dim_len: n, dim_chunk_len: r }) {
      __publicField(this, "start");
      __publicField(this, "stop");
      __publicField(this, "step");
      __publicField(this, "dim_len");
      __publicField(this, "dim_chunk_len");
      __publicField(this, "nitems");
      __publicField(this, "nchunks");
      const [i, a, s] = Pk(e, n);
      this.start = i, this.stop = a, this.step = s, this.step < 1 && Hk(), this.dim_len = n, this.dim_chunk_len = r, this.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step)), this.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);
    }
    *[Symbol.iterator]() {
      const e = Math.floor(this.start / this.dim_chunk_len), n = Math.ceil(this.stop / this.dim_chunk_len);
      for (const r of _k(e, n)) {
        const i = r * this.dim_chunk_len, a = Math.min(this.dim_len, (r + 1) * this.dim_chunk_len), s = a - i;
        let o = 0, l = 0;
        if (this.start < i) {
          const g = (i - this.start) % this.step;
          g && (l += this.step - g), o = Math.ceil((i - this.start) / this.step);
        } else l = this.start - i;
        const c = this.stop > a ? s : this.stop - i, f = [
          l,
          c,
          this.step
        ], u = Math.ceil((c - l) / this.step), h = [
          o,
          o + u,
          1
        ];
        yield {
          dim_chunk_ix: r,
          dim_chunk_sel: f,
          dim_out_sel: h
        };
      }
    }
  }
  function qk(t, e) {
    let n = [];
    return t === null ? n = e.map((r) => ih(null)) : Array.isArray(t) && (n = t.map((r) => r ?? ih(null))), jk(n, e), n;
  }
  class Xk {
    constructor({ selection: e, shape: n, chunk_shape: r }) {
      __publicField(this, "dim_indexers");
      __publicField(this, "shape");
      this.dim_indexers = qk(e, n).map((i, a) => new (typeof i == "number" ? Yk : Qw)({
        dim_sel: i,
        dim_len: n[a],
        dim_chunk_len: r[a]
      })), this.shape = this.dim_indexers.filter((i) => i instanceof Qw).map((i) => i.nitems);
    }
    *[Symbol.iterator]() {
      for (const e of kk(...this.dim_indexers)) {
        const n = e.map((i) => i.dim_chunk_ix), r = e.map((i) => "dim_out_sel" in i ? {
          from: i.dim_chunk_sel,
          to: i.dim_out_sel
        } : {
          from: i.dim_chunk_sel,
          to: null
        });
        yield {
          chunk_coords: n,
          mapping: r
        };
      }
    }
  }
  function Zk(t, e) {
    return "get" in t ? t.get(e) : t[e];
  }
  async function Qk(t, e, n, r) {
    var _a3;
    let i = Fk(t), a = new Xk({
      selection: e,
      shape: t.shape,
      chunk_shape: t.chunks
    }), s = r.prepare(new i.TypedArray(a.shape.reduce((l, c) => l * c, 1)), a.shape, i.get_strides(a.shape)), o = ((_a3 = n.create_queue) == null ? void 0 : _a3.call(n)) ?? Gk();
    for (const { chunk_coords: l, mapping: c } of a) o.add(async () => {
      let { data: f, shape: u, stride: h } = await t.getChunk(l, n.opts), g = r.prepare(f, u, h);
      r.set_from_chunk(s, g, c);
    });
    return await o.onIdle(), a.shape.length === 0 ? Zk(s.data, 0) : s;
  }
  function c8(t, e = 0, n) {
    let r = n ?? t.length - e;
    return {
      length: r,
      subarray(i, a = r) {
        return c8(t, e + i, a - i);
      },
      set(i, a = 0) {
        for (let s = 0; s < i.length; s++) t[e + a + s] = i.get(s);
      },
      get(i) {
        return t[e + i];
      }
    };
  }
  function $3(t) {
    return globalThis.Array.isArray(t.data) ? {
      data: c8(t.data),
      stride: t.stride,
      bytes_per_element: 1
    } : {
      data: new Uint8Array(t.data.buffer, t.data.byteOffset, t.data.byteLength),
      stride: t.stride,
      bytes_per_element: t.data.BYTES_PER_ELEMENT
    };
  }
  function Jk(t) {
    return "chars" in t ? t.constructor.bind(null, t.chars) : t.constructor;
  }
  function $k(t, e) {
    if (globalThis.Array.isArray(t.data)) return c8([
      e
    ]);
    let n = Jk(t.data), r = new n([
      e
    ]);
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  }
  const eP = {
    prepare(t, e, n) {
      return {
        data: t,
        shape: e,
        stride: n
      };
    },
    set_scalar(t, e, n) {
      let r = $3(t);
      Bv(r, e, $k(t, n), r.bytes_per_element);
    },
    set_from_chunk(t, e, n) {
      let r = $3(t);
      yg(r, $3(e), r.bytes_per_element, n);
    }
  };
  async function Jw(t, e = null, n = {}) {
    return Qk(t, e, n, eP);
  }
  function YE(t, e, n) {
    return n < 0 && e < t ? Math.floor((t - e - 1) / -n) + 1 : t < e ? Math.floor((e - t - 1) / n) + 1 : 0;
  }
  function Bv(t, e, n, r) {
    if (e.length === 0) {
      t.data.set(n, 0);
      return;
    }
    const [i, ...a] = e, [s, ...o] = t.stride;
    if (typeof i == "number") {
      const h = t.data.subarray(s * i * r);
      Bv({
        data: h,
        stride: o
      }, a, n, r);
      return;
    }
    const [l, c, f] = i, u = YE(l, c, f);
    if (a.length === 0) {
      for (let h = 0; h < u; h++) t.data.set(n, s * (l + f * h) * r);
      return;
    }
    for (let h = 0; h < u; h++) {
      const g = t.data.subarray(s * (l + f * h) * r);
      Bv({
        data: g,
        stride: o
      }, a, n, r);
    }
  }
  function yg(t, e, n, r) {
    const [i, ...a] = r, [s, ...o] = t.stride, [l, ...c] = e.stride;
    if (i.from === null) {
      if (a.length === 0) {
        t.data.set(e.data.subarray(0, n), i.to * n);
        return;
      }
      yg({
        data: t.data.subarray(s * i.to * n),
        stride: o
      }, e, n, a);
      return;
    }
    if (i.to === null) {
      if (a.length === 0) {
        let w = i.from * n;
        t.data.set(e.data.subarray(w, w + n), 0);
        return;
      }
      yg(t, {
        data: e.data.subarray(l * i.from * n),
        stride: c
      }, n, a);
      return;
    }
    const [f, u, h] = i.to, [g, v, m] = i.from, y = YE(f, u, h);
    if (a.length === 0) {
      if (h === 1 && m === 1 && s === 1 && l === 1) {
        let w = g * n, C = y * n;
        t.data.set(e.data.subarray(w, w + C), f * n);
        return;
      }
      for (let w = 0; w < y; w++) {
        let C = l * (g + m * w) * n;
        t.data.set(e.data.subarray(C, C + n), s * (f + h * w) * n);
      }
      return;
    }
    for (let w = 0; w < y; w++) yg({
      data: t.data.subarray(s * (f + w * h) * n),
      stride: o
    }, {
      data: e.data.subarray(l * (g + w * m) * n),
      stride: c
    }, n, a);
  }
  let c5 = tP();
  function tP() {
    let t = /* @__PURE__ */ new WeakMap();
    function e(n) {
      let r = t.get(n) ?? {
        v2: 0,
        v3: 0
      };
      return t.set(n, r), r;
    }
    return {
      increment(n, r) {
        e(n)[r] += 1;
      },
      version_max(n) {
        let r = e(n);
        return r.v3 > r.v2 ? "v3" : "v2";
      }
    };
  }
  async function nP(t) {
    let e = await t.store.get(t.resolve(".zattrs").path);
    return e ? Yh(e) : {};
  }
  async function rP(t, e = {}) {
    let n = "store" in t ? t : new r0(t), r = {};
    return (e.attrs ?? true) && (r = await nP(n)), e.kind === "array" ? $w(n, r) : e.kind === "group" ? eC(n, r) : $w(n, r).catch((i) => (jE(i, qh), eC(n, r)));
  }
  async function $w(t, e) {
    let { path: n } = t.resolve(".zarray"), r = await t.store.get(n);
    if (!r) throw new qh("v2 array", {
      cause: new s8(n)
    });
    return c5.increment(t.store, "v2"), new np(t.store, t.path, wk(Yh(r), e));
  }
  async function eC(t, e) {
    let { path: n } = t.resolve(".zgroup"), r = await t.store.get(n);
    if (!r) throw new qh("v2 group", {
      cause: new s8(n)
    });
    return c5.increment(t.store, "v2"), new o8(t.store, t.path, Ck(Yh(r), e));
  }
  async function iP(t) {
    let { store: e, path: n } = t.resolve("zarr.json"), r = await t.store.get(n);
    if (!r) throw new qh("v3 array or group", {
      cause: new s8(n)
    });
    let i = Yh(r);
    return i.node_type === "array" && (i.fill_value = HE(i)), i.node_type === "array" ? new np(e, t.path, i) : new o8(e, t.path, i);
  }
  async function aP(t, e = {}) {
    let n = "store" in t ? t : new r0(t), r = await iP(n);
    if (c5.increment(n.store, "v3"), e.kind === void 0 || e.kind === "array" && r instanceof np || e.kind === "group" && r instanceof o8) return r;
    let i = r instanceof np ? "array" : "group";
    throw new Error(`Expected node of kind ${e.kind}, found ${i}.`);
  }
  async function Sl(t, e = {}) {
    let n = "store" in t ? t.store : t, r = c5.version_max(n), i = r === "v2" ? Sl.v2 : Sl.v3, a = r === "v2" ? Sl.v3 : Sl.v2;
    return i(t, e).catch((s) => (jE(s, qh), a(t, e)));
  }
  Sl.v2 = rP;
  Sl.v3 = aP;
  var qE = Object.defineProperty, XE = (t) => {
    throw TypeError(t);
  }, sP = (t, e, n) => e in t ? qE(t, e, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: n
  }) : t[e] = n, u5 = (t, e) => {
    for (var n in e) qE(t, n, {
      get: e[n],
      enumerable: true
    });
  }, J = (t, e, n) => sP(t, typeof e != "symbol" ? e + "" : e, n), ZE = (t, e, n) => e.has(t) || XE("Cannot " + n), ht = (t, e, n) => (ZE(t, e, "read from private field"), n ? n.call(t) : e.get(t)), l1 = (t, e, n) => e.has(t) ? XE("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), K0 = (t, e, n, r) => (ZE(t, e, "write to private field"), e.set(t, n), n), oP = {
    version: "0.62.1"
  }, lP = new Float32Array([
    -1,
    -1,
    -1,
    0.28,
    0.28,
    0.28,
    -1,
    -1,
    -1,
    0.28,
    0.28,
    0.28,
    -1,
    1,
    -1,
    0.28,
    0.28,
    0.28,
    1,
    -1,
    -1,
    0.28,
    0.28,
    0.28,
    1,
    1,
    -1,
    0.28,
    0.28,
    0.28,
    1,
    1,
    -1,
    0.28,
    0.28,
    0.28,
    -1,
    -1,
    1,
    0.8,
    0.8,
    0.8,
    -1,
    -1,
    1,
    0.8,
    0.8,
    0.8,
    1,
    -1,
    1,
    0.8,
    0.8,
    0.8,
    -1,
    1,
    1,
    0.8,
    0.8,
    0.8,
    1,
    1,
    1,
    0.8,
    0.8,
    0.8,
    1,
    1,
    1,
    0.8,
    0.8,
    0.8,
    -1,
    1,
    -1,
    0,
    0,
    0.74,
    -1,
    1,
    -1,
    0,
    0,
    0.74,
    -1,
    1,
    1,
    0,
    0,
    0.74,
    1,
    1,
    -1,
    0,
    0,
    0.74,
    1,
    1,
    1,
    0,
    0,
    0.74,
    1,
    1,
    1,
    0,
    0,
    0.74,
    -1,
    -1,
    -1,
    0.42,
    0,
    0.42,
    -1,
    -1,
    -1,
    0.42,
    0,
    0.42,
    1,
    -1,
    -1,
    0.42,
    0,
    0.42,
    -1,
    -1,
    1,
    0.42,
    0,
    0.42,
    1,
    -1,
    1,
    0.42,
    0,
    0.42,
    1,
    -1,
    1,
    0.42,
    0,
    0.42,
    -1,
    -1,
    -1,
    0.64,
    0,
    0,
    -1,
    -1,
    -1,
    0.64,
    0,
    0,
    -1,
    -1,
    1,
    0.64,
    0,
    0,
    -1,
    1,
    -1,
    0.64,
    0,
    0,
    -1,
    1,
    1,
    0.64,
    0,
    0,
    -1,
    1,
    1,
    0.64,
    0,
    0,
    1,
    -1,
    -1,
    0,
    0.5,
    0,
    1,
    -1,
    -1,
    0,
    0.5,
    0,
    1,
    1,
    -1,
    0,
    0.5,
    0,
    1,
    -1,
    1,
    0,
    0.5,
    0,
    1,
    1,
    1,
    0,
    0.5,
    0,
    1,
    1,
    1,
    0,
    0.5,
    0,
    -0.45,
    1,
    -0.8,
    0,
    0,
    0,
    -0.45,
    1,
    -0.8,
    0,
    0,
    0,
    -0.45,
    1,
    0.8,
    0,
    0,
    0,
    -0.25,
    1,
    -0.8,
    0,
    0,
    0,
    -0.25,
    1,
    0.8,
    0,
    0,
    0,
    -0.25,
    1,
    0.8,
    0,
    0,
    0,
    -0.25,
    1,
    0.6,
    0,
    0,
    0,
    -0.25,
    1,
    0.6,
    0,
    0,
    0,
    -0.25,
    1,
    0.8,
    0,
    0,
    0,
    0.45,
    1,
    0.6,
    0,
    0,
    0,
    0.25,
    1,
    0.8,
    0,
    0,
    0,
    0.25,
    1,
    0.8,
    0,
    0,
    0,
    0.25,
    1,
    0.1,
    0,
    0,
    0,
    0.25,
    1,
    0.1,
    0,
    0,
    0,
    0.25,
    1,
    0.6,
    0,
    0,
    0,
    0.45,
    1,
    0.1,
    0,
    0,
    0,
    0.45,
    1,
    0.6,
    0,
    0,
    0,
    0.45,
    1,
    0.6,
    0,
    0,
    0,
    -0.25,
    1,
    -0.1,
    0,
    0,
    0,
    -0.25,
    1,
    -0.1,
    0,
    0,
    0,
    -0.25,
    1,
    0.1,
    0,
    0,
    0,
    0.25,
    1,
    -0.1,
    0,
    0,
    0,
    0.45,
    1,
    0.1,
    0,
    0,
    0,
    0.45,
    1,
    0.1,
    0,
    0,
    0,
    0.45,
    -1,
    -0.8,
    0,
    0,
    0,
    0.45,
    -1,
    -0.8,
    0,
    0,
    0,
    0.05,
    -1,
    0.8,
    0,
    0,
    0,
    0.25,
    -1,
    -0.8,
    0,
    0,
    0,
    -0.15,
    -1,
    0.8,
    0,
    0,
    0,
    -0.15,
    -1,
    0.8,
    0,
    0,
    0,
    -0.25,
    -1,
    -0.8,
    0,
    0,
    0,
    -0.25,
    -1,
    -0.8,
    0,
    0,
    0,
    0.05,
    -1,
    0.8,
    0,
    0,
    0,
    -0.45,
    -1,
    -0.8,
    0,
    0,
    0,
    -0.15,
    -1,
    0.8,
    0,
    0,
    0,
    -0.15,
    -1,
    0.8,
    0,
    0,
    0,
    0.13,
    -1,
    -0.3,
    0,
    0,
    0,
    0.13,
    -1,
    -0.3,
    0,
    0,
    0,
    0.07,
    -1,
    -0.1,
    0,
    0,
    0,
    -0.33,
    -1,
    -0.3,
    0,
    0,
    0,
    -0.27,
    -1,
    -0.1,
    0,
    0,
    0,
    -0.27,
    -1,
    -0.1,
    0,
    0,
    0,
    -0.45,
    0.6,
    1,
    0,
    0,
    0,
    -0.45,
    0.6,
    1,
    0,
    0,
    0,
    -0.45,
    0.4,
    1,
    0,
    0,
    0,
    -0.25,
    0.8,
    1,
    0,
    0,
    0,
    -0.25,
    0.4,
    1,
    0,
    0,
    0,
    -0.25,
    0.4,
    1,
    0,
    0,
    0,
    -0.25,
    0.8,
    1,
    0,
    0,
    0,
    -0.25,
    0.8,
    1,
    0,
    0,
    0,
    -0.25,
    0.6,
    1,
    0,
    0,
    0,
    0.25,
    0.8,
    1,
    0,
    0,
    0,
    0.45,
    0.6,
    1,
    0,
    0,
    0,
    0.45,
    0.6,
    1,
    0,
    0,
    0,
    0.25,
    0.8,
    1,
    0,
    0,
    0,
    0.25,
    0.8,
    1,
    0,
    0,
    0,
    0.25,
    -0.1,
    1,
    0,
    0,
    0,
    0.45,
    0.6,
    1,
    0,
    0,
    0,
    0.45,
    0.1,
    1,
    0,
    0,
    0,
    0.45,
    0.1,
    1,
    0,
    0,
    0,
    -0.25,
    0.1,
    1,
    0,
    0,
    0,
    -0.25,
    0.1,
    1,
    0,
    0,
    0,
    -0.45,
    -0.1,
    1,
    0,
    0,
    0,
    0.25,
    0.1,
    1,
    0,
    0,
    0,
    0.25,
    -0.1,
    1,
    0,
    0,
    0,
    0.25,
    -0.1,
    1,
    0,
    0,
    0,
    -0.45,
    -0.1,
    1,
    0,
    0,
    0,
    -0.45,
    -0.1,
    1,
    0,
    0,
    0,
    -0.45,
    -0.6,
    1,
    0,
    0,
    0,
    -0.25,
    -0.1,
    1,
    0,
    0,
    0,
    -0.25,
    -0.8,
    1,
    0,
    0,
    0,
    -0.25,
    -0.8,
    1,
    0,
    0,
    0,
    -0.25,
    -0.6,
    1,
    0,
    0,
    0,
    -0.25,
    -0.6,
    1,
    0,
    0,
    0,
    -0.25,
    -0.8,
    1,
    0,
    0,
    0,
    0.45,
    -0.6,
    1,
    0,
    0,
    0,
    0.25,
    -0.8,
    1,
    0,
    0,
    0,
    0.25,
    -0.8,
    1,
    0,
    0,
    0,
    0.25,
    -0.4,
    1,
    0,
    0,
    0,
    0.25,
    -0.4,
    1,
    0,
    0,
    0,
    0.25,
    -0.6,
    1,
    0,
    0,
    0,
    0.45,
    -0.4,
    1,
    0,
    0,
    0,
    0.45,
    -0.6,
    1,
    0,
    0,
    0,
    0.45,
    -0.6,
    1,
    0,
    0,
    0,
    -0.1,
    -0.8,
    -1,
    0,
    0,
    0,
    -0.1,
    -0.8,
    -1,
    0,
    0,
    0,
    -0.1,
    0.8,
    -1,
    0,
    0,
    0,
    0.1,
    -0.8,
    -1,
    0,
    0,
    0,
    0.1,
    0.8,
    -1,
    0,
    0,
    0,
    0.1,
    0.8,
    -1,
    0,
    0,
    0,
    -1,
    -0.45,
    -0.8,
    0,
    0,
    0,
    -1,
    -0.45,
    -0.8,
    0,
    0,
    0,
    -1,
    -0.45,
    0.8,
    0,
    0,
    0,
    -1,
    -0.25,
    -0.8,
    0,
    0,
    0,
    -1,
    -0.25,
    0.8,
    0,
    0,
    0,
    -1,
    -0.25,
    0.8,
    0,
    0,
    0,
    -1,
    -0.25,
    -0.8,
    0,
    0,
    0,
    -1,
    -0.25,
    -0.8,
    0,
    0,
    0,
    -1,
    -0.25,
    -0.6,
    0,
    0,
    0,
    -1,
    0.45,
    -0.8,
    0,
    0,
    0,
    -1,
    0.45,
    -0.6,
    0,
    0,
    0,
    -1,
    0.45,
    -0.6,
    0,
    0,
    0,
    1,
    0.45,
    -0.8,
    0,
    0,
    0,
    1,
    0.45,
    -0.8,
    0,
    0,
    0,
    1,
    0.45,
    0.8,
    0,
    0,
    0,
    1,
    0.25,
    -0.8,
    0,
    0,
    0,
    1,
    0.25,
    0.8,
    0,
    0,
    0,
    1,
    0.25,
    0.8,
    0,
    0,
    0,
    1,
    0.25,
    0.6,
    0,
    0,
    0,
    1,
    0.25,
    0.6,
    0,
    0,
    0,
    1,
    0.25,
    0.8,
    0,
    0,
    0,
    1,
    -0.45,
    0.6,
    0,
    0,
    0,
    1,
    -0.25,
    0.8,
    0,
    0,
    0,
    1,
    -0.25,
    0.8,
    0,
    0,
    0,
    1,
    -0.25,
    0.1,
    0,
    0,
    0,
    1,
    -0.25,
    0.1,
    0,
    0,
    0,
    1,
    -0.25,
    0.6,
    0,
    0,
    0,
    1,
    -0.45,
    0.1,
    0,
    0,
    0,
    1,
    -0.45,
    0.6,
    0,
    0,
    0,
    1,
    -0.45,
    0.6,
    0,
    0,
    0,
    1,
    0.25,
    -0.1,
    0,
    0,
    0,
    1,
    0.25,
    -0.1,
    0,
    0,
    0,
    1,
    0.25,
    0.1,
    0,
    0,
    0,
    1,
    -0.25,
    -0.1,
    0,
    0,
    0,
    1,
    -0.45,
    0.1,
    0,
    0,
    0,
    1,
    -0.45,
    0.1,
    0,
    0,
    0,
    1,
    -0.25,
    -0.8,
    0,
    0,
    0,
    1,
    -0.25,
    -0.8,
    0,
    0,
    0,
    1,
    -0.05,
    -0.1,
    0,
    0,
    0,
    1,
    -0.45,
    -0.8,
    0,
    0,
    0,
    1,
    -0.25,
    -0.1,
    0,
    0,
    0,
    1,
    -0.25,
    -0.1,
    0,
    0,
    0
  ]), Sn = class {
    constructor(e, n, r, i, a = null, s = null) {
      J(this, "sphereIdx", []), J(this, "sphereVtx", []), J(this, "renderShaders", []), J(this, "isVisible", true), J(this, "isPickable", true), J(this, "vertexBuffer"), J(this, "indexCount"), J(this, "indexBuffer"), J(this, "vao"), J(this, "mode"), J(this, "glFlags", 0), J(this, "id"), J(this, "colorId"), J(this, "modelMatrix", Yt()), J(this, "scale", [
        1,
        1,
        1
      ]), J(this, "position", [
        0,
        0,
        0
      ]), J(this, "rotation", [
        0,
        0,
        0
      ]), J(this, "rotationRadians", 0), J(this, "extentsMin", []), J(this, "extentsMax", []), J(this, "furthestVertexFromOrigin"), J(this, "originNegate"), J(this, "fieldOfViewDeObliqueMM"), J(this, "mm"), this.vertexBuffer = n, this.indexCount = i, this.indexBuffer = a, this.vao = s, this.mode = r, this.id = e, this.colorId = [
        (e >> 0 & 255) / 255,
        (e >> 8 & 255) / 255,
        (e >> 16 & 255) / 255,
        (e >> 24 & 255) / 255
      ];
    }
  };
  J(Sn, "BLEND", 1);
  J(Sn, "CULL_FACE", 2);
  J(Sn, "CULL_FRONT", 4);
  J(Sn, "CULL_BACK", 8);
  J(Sn, "ENABLE_DEPTH_TEST", 16);
  J(Sn, "generateCrosshairs", function(t, e, n, r, i, a, s = 20, o = 0) {
    const l = Sn.generateCrosshairsGeometry(t, n, r, i, a, s, o);
    return new Sn(e, l.vertexBuffer, t.TRIANGLES, l.indexCount, l.indexBuffer, l.vao);
  });
  J(Sn, "generateCrosshairsGeometry", function(t, e, n, r, i, a = 20, s = 0) {
    const o = [], l = [], c = i * s;
    if (c <= 0) {
      let g = Ue(n[0], e[1], e[2]), v = Ue(r[0], e[1], e[2]);
      Sn.makeCylinder(o, l, g, v, i, a), g = Ue(e[0], n[1], e[2]), v = Ue(e[0], r[1], e[2]), Sn.makeCylinder(o, l, g, v, i, a), g = Ue(e[0], e[1], n[2]), v = Ue(e[0], e[1], r[2]), Sn.makeCylinder(o, l, g, v, i, a);
    } else {
      let g = Ue(n[0], e[1], e[2]), v = Ue(e[0] - c, e[1], e[2]);
      Sn.makeCylinder(o, l, g, v, i, a, false), g = Ue(e[0] + c, e[1], e[2]), v = Ue(r[0], e[1], e[2]), Sn.makeCylinder(o, l, g, v, i, a, false), g = Ue(e[0], n[1], e[2]), v = Ue(e[0], e[1] - c, e[2]), Sn.makeCylinder(o, l, g, v, i, a, false), g = Ue(e[0], e[1] + c, e[2]), v = Ue(e[0], r[1], e[2]), Sn.makeCylinder(o, l, g, v, i, a, false), g = Ue(e[0], e[1], n[2]), v = Ue(e[0], e[1], e[2] - c), Sn.makeCylinder(o, l, g, v, i, a, false), g = Ue(e[0], e[1], e[2] + c), v = Ue(e[0], e[1], r[2]), Sn.makeCylinder(o, l, g, v, i, a, false);
    }
    const f = t.createBuffer();
    if (f === null) throw new Error("could not instantiate vertex buffer");
    t.bindBuffer(t.ARRAY_BUFFER, f), t.bufferData(t.ARRAY_BUFFER, new Float32Array(o), t.STATIC_DRAW);
    const u = t.createBuffer();
    if (u === null) throw new Error("could not instantiate index buffer");
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, u), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint32Array(l), t.STATIC_DRAW);
    const h = t.createVertexArray();
    return t.bindVertexArray(h), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, u), t.bindBuffer(t.ARRAY_BUFFER, f), t.enableVertexAttribArray(0), t.vertexAttribPointer(0, 3, t.FLOAT, false, 0, 0), t.bindVertexArray(null), {
      vertexBuffer: f,
      indexBuffer: u,
      indexCount: l.length,
      vao: h
    };
  });
  J(Sn, "getFirstPerpVector", function(t) {
    const e = Ue(0, 0, 0);
    return t[0] === 0 ? e[0] = 1 : t[1] === 0 ? e[1] = 1 : t[2] === 0 ? e[2] = 1 : (e[0] = t[2], e[1] = t[2], e[2] = -(t[0] + t[1]), Pr(e, e)), e;
  });
  J(Sn, "subdivide", function(t, e) {
    let n = t.length / 3, r = e.length / 3;
    const i = r, a = He(), s = He();
    for (let o = 0; o < i; o++) {
      const l = e[o * 3 + 0], c = e[o * 3 + 1], f = e[o * 3 + 2], u = Ue(t[l * 3 + 0], t[l * 3 + 1], t[l * 3 + 2]), h = Ue(t[c * 3 + 0], t[c * 3 + 1], t[c * 3 + 2]), g = Ue(t[f * 3 + 0], t[f * 3 + 1], t[f * 3 + 2]);
      Ai(a, u, h), Pr(s, a), t.push(...s), Ai(a, h, g), Pr(s, a), t.push(...s), Ai(a, u, g), Pr(s, a), t.push(...s);
      let v = [
        n,
        n + 1,
        n + 2
      ];
      e.push(...v), v = [
        l,
        n,
        n + 2
      ], e.push(...v), v = [
        n,
        c,
        n + 1
      ], e.push(...v), e[o * 3 + 0] = n + 2, e[o * 3 + 1] = n + 1, e[o * 3 + 2] = f, r = r + 3, n = n + 3;
    }
  });
  J(Sn, "weldVertices", function(t, e) {
    const n = t.length / 3;
    let r = 0;
    const i = new Int32Array(n);
    for (let o = 0; o < n - 1; o++) {
      if (i[o] !== 0) continue;
      i[o] = r;
      let l = o * 3;
      const c = t[l], f = t[l + 1], u = t[l + 2];
      for (let h = o + 1; h < n; h++) l += 3, c === t[l] && f === t[l + 1] && u === t[l + 2] && (i[h] = r);
      r++;
    }
    if (r === n) return t;
    const a = e.length;
    for (let o = 0; o < a; o++) e[o] = i[e[o]];
    const s = t.slice(0, r * 3 - 1);
    for (let o = 0; o < n - 1; o++) {
      const l = o * 3, c = i[o] * 3;
      s[c] = t[l], s[c + 1] = t[l + 1], s[c + 2] = t[l + 2];
    }
    return s;
  });
  J(Sn, "makeSphere", function(t, e, n, r = [
    0,
    0,
    0
  ]) {
    let i = [
      0,
      0,
      1,
      0.894,
      0,
      0.447,
      0.276,
      0.851,
      0.447,
      -0.724,
      0.526,
      0.447,
      -0.724,
      -0.526,
      0.447,
      0.276,
      -0.851,
      0.447,
      0.724,
      0.526,
      -0.447,
      -0.276,
      0.851,
      -0.447,
      -0.894,
      0,
      -0.447,
      -0.276,
      -0.851,
      -0.447,
      0.724,
      -0.526,
      -0.447,
      0,
      0,
      -1
    ];
    const a = [
      0,
      1,
      2,
      0,
      2,
      3,
      0,
      3,
      4,
      0,
      4,
      5,
      0,
      5,
      1,
      7,
      6,
      11,
      8,
      7,
      11,
      9,
      8,
      11,
      10,
      9,
      11,
      6,
      10,
      11,
      6,
      2,
      1,
      7,
      3,
      2,
      8,
      4,
      3,
      9,
      5,
      4,
      10,
      1,
      5,
      6,
      7,
      2,
      7,
      8,
      3,
      8,
      9,
      4,
      9,
      10,
      5,
      10,
      6,
      1
    ];
    Sn.subdivide(i, a), Sn.subdivide(i, a), i = Sn.weldVertices(i, a);
    for (let c = 0; c < i.length; c++) i[c] = i[c] * n;
    const s = i.length / 3;
    let o = 0;
    for (let c = 0; c < s; c++) i[o] = i[o] + r[0], o++, i[o] = i[o] + r[1], o++, i[o] = i[o] + r[2], o++;
    const l = Math.floor(t.length / 3);
    for (let c = 0; c < a.length; c++) a[c] = a[c] + l;
    e.push(...a), t.push(...i);
  });
  J(Sn, "makeCylinder", function(t, e, n, r, i, a = 20, s = true) {
    a < 3 && (a = 3);
    const o = He();
    Ft(o, r, n), Pr(o, o);
    const l = Sn.getFirstPerpVector(o), c = He();
    Vr(c, o, l), Pr(c, c);
    let f = 2 * a, u = 2 * a;
    s && (u += 2 * a, f += 2);
    const h = Math.floor(t.length / 3), g = new Uint32Array(u * 3), v = new Float32Array(f * 3);
    function m(E, b) {
      v[E * 3 + 0] = b[0], v[E * 3 + 1] = b[1], v[E * 3 + 2] = b[2];
    }
    function y(E, b, D, R) {
      g[E * 3 + 0] = b + h, g[E * 3 + 1] = D + h, g[E * 3 + 2] = R + h;
    }
    const w = 2 * a, C = w + 1;
    s && (m(w, n), m(C, r));
    const T = He(), S = He();
    for (let E = 0; E < a; E++) {
      const b = Math.cos(E / a * 2 * Math.PI), D = Math.sin(E / a * 2 * Math.PI);
      T[0] = i * (b * l[0] + D * c[0]), T[1] = i * (b * l[1] + D * c[1]), T[2] = i * (b * l[2] + D * c[2]), Ai(S, n, T), m(E, S), Ai(S, r, T), m(E + a, S);
      let R = 0;
      E < a - 1 && (R = E + 1), y(E * 2, E, R, E + a), y(E * 2 + 1, R, R + a, E + a), s && (y(a * 2 + E, E, w, R), y(a * 2 + E + a, C, E + a, R + a));
    }
    e.push(...g), t.push(...v);
  });
  J(Sn, "makeColoredCylinder", function(t, e, n, r, i, a, s = [
    192,
    0,
    0,
    255
  ], o = 20, l = false) {
    let c = t.length / 3;
    Sn.makeCylinder(t, e, r, i, a, o, l), c = t.length / 3 - c;
    const f = [];
    for (let u = 0; u < c * 4 - 1; u += 4) f[u] = s[0], f[u + 1] = s[1], f[u + 2] = s[2], f[u + 3] = s[3];
    n.push(...f);
  });
  J(Sn, "makeColoredSphere", function(t, e, n, r, i = [
    0,
    0,
    0
  ], a = [
    0,
    0,
    192,
    255
  ]) {
    let s = t.length / 3;
    Sn.makeSphere(t, e, r, i), s = t.length / 3 - s;
    const o = [];
    for (let l = 0; l < s * 4 - 1; l += 4) o[l] = a[0], o[l + 1] = a[1], o[l + 2] = a[2], o[l + 3] = a[3];
    n.push(...o);
  });
  var zc = Sn, QE = class Za {
    constructor({ name: e = "niivue", level: n = "info" } = {}) {
      J(this, "level"), J(this, "name"), this.name = `${e}`, this.level = n;
    }
    debug(...e) {
      Za.levels[this.level] > Za.levels.debug || console.debug(`${this.name}-debug`, ...e);
    }
    info(...e) {
      Za.levels[this.level] > Za.levels.info || console.info(`${this.name}-info`, ...e);
    }
    warn(...e) {
      Za.levels[this.level] > Za.levels.warn || console.warn(`${this.name}-warn`, ...e);
    }
    error(...e) {
      Za.levels[this.level] > Za.levels.error || console.error(`${this.name}-error`, ...e);
    }
    fatal(...e) {
      Za.levels[this.level] > Za.levels.fatal || console.error(`${this.name}-fatal`, ...e);
    }
    setLogLevel(e) {
      this.level = e;
    }
    setName(e) {
      this.name = e;
    }
  };
  J(QE, "levels", {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    fatal: 4,
    silent: 1 / 0
  });
  var cP = QE, ee = new cP({
    name: "niivue",
    level: "info"
  }), xg = {};
  u5(xg, {
    $itksnap: () => uP,
    $slicer3d: () => fP,
    actc: () => hP,
    afni_blues_inv: () => EG,
    afni_reds_inv: () => bG,
    batlow: () => dP,
    bcgwhw: () => pP,
    bcgwhw_dark: () => gP,
    blue: () => wP,
    blue2cyan: () => yP,
    blue2magenta: () => vP,
    blue2red: () => mP,
    bluegrn: () => xP,
    bone: () => CP,
    bronze: () => TP,
    cet_l17: () => SP,
    cividis: () => AP,
    cool: () => EP,
    copper: () => DP,
    copper2: () => bP,
    ct_airways: () => MP,
    ct_artery: () => RP,
    ct_bones: () => OP,
    ct_brain: () => VP,
    ct_brain_gray: () => IP,
    ct_cardiac: () => NP,
    ct_head: () => LP,
    ct_kidneys: () => UP,
    ct_liver: () => FP,
    ct_muscles: () => BP,
    ct_scalp: () => _P,
    ct_skull: () => kP,
    ct_soft: () => PP,
    ct_soft_tissue: () => GP,
    ct_surface: () => zP,
    ct_vessels: () => WP,
    ct_w_contrast: () => HP,
    cubehelix: () => jP,
    electric_blue: () => KP,
    freesurfer: () => YP,
    ge_color: () => qP,
    gold: () => XP,
    gray: () => ZP,
    green: () => QP,
    green2cyan: () => JP,
    green2orange: () => $P,
    hot: () => tG,
    hotiron: () => eG,
    hsv: () => nG,
    inferno: () => rG,
    jet: () => iG,
    kry: () => aG,
    linspecer: () => sG,
    lipari: () => oG,
    magma: () => lG,
    mako: () => cG,
    navia: () => uG,
    nih: () => fG,
    plasma: () => hG,
    random: () => dG,
    red: () => gG,
    redyell: () => pG,
    rocket: () => mG,
    roi_i256: () => DG,
    surface: () => vG,
    thermal: () => yG,
    turbo: () => xG,
    violet: () => wG,
    viridis: () => CG,
    warm: () => TG,
    winter: () => SG,
    x_rain: () => AG
  });
  var uP = {
    R: [
      0,
      255,
      0,
      0,
      255,
      0,
      255,
      255,
      0,
      205,
      210,
      102,
      0,
      0,
      46,
      255,
      106,
      221,
      233,
      165,
      255,
      147,
      218,
      75,
      255,
      60,
      255,
      255,
      218,
      0,
      188,
      255,
      255,
      222,
      127,
      139,
      124,
      255,
      70,
      0,
      238,
      238,
      240,
      245,
      184,
      32,
      255,
      25,
      112,
      34,
      248,
      245,
      255,
      144,
      173,
      65,
      255,
      250,
      128,
      50,
      244,
      255,
      123,
      255,
      173,
      255,
      127,
      255,
      143,
      220,
      253,
      255,
      0,
      0,
      128,
      255,
      250,
      148,
      178,
      255,
      135,
      100,
      240,
      250,
      255,
      107,
      135,
      0,
      139,
      245,
      186,
      255,
      255,
      0,
      210,
      255,
      47,
      72,
      175,
      128,
      176,
      255,
      139,
      240,
      255,
      216,
      119,
      219,
      72,
      255,
      199,
      154,
      189,
      240,
      230,
      0,
      85,
      64,
      153,
      205,
      250,
      95,
      0,
      255,
      224,
      176,
      138,
      30,
      240,
      152,
      160
    ],
    G: [
      0,
      0,
      255,
      0,
      255,
      255,
      0,
      239,
      0,
      133,
      180,
      205,
      0,
      139,
      139,
      228,
      90,
      160,
      150,
      42,
      250,
      112,
      112,
      0,
      182,
      179,
      235,
      228,
      165,
      128,
      143,
      105,
      218,
      184,
      255,
      69,
      252,
      255,
      130,
      100,
      130,
      232,
      255,
      222,
      134,
      178,
      20,
      25,
      128,
      139,
      248,
      255,
      160,
      238,
      255,
      105,
      99,
      240,
      0,
      205,
      164,
      255,
      104,
      165,
      216,
      192,
      255,
      140,
      188,
      20,
      245,
      250,
      206,
      255,
      0,
      250,
      128,
      0,
      34,
      127,
      206,
      149,
      230,
      235,
      245,
      142,
      206,
      0,
      0,
      245,
      85,
      228,
      222,
      191,
      105,
      248,
      79,
      61,
      238,
      128,
      224,
      240,
      0,
      255,
      215,
      191,
      136,
      112,
      209,
      0,
      21,
      205,
      183,
      248,
      230,
      250,
      107,
      224,
      50,
      92,
      250,
      158,
      128,
      69,
      255,
      196,
      43,
      144,
      128,
      251,
      82
    ],
    B: [
      0,
      0,
      0,
      255,
      0,
      255,
      255,
      213,
      205,
      63,
      140,
      170,
      128,
      139,
      87,
      225,
      205,
      221,
      122,
      42,
      250,
      219,
      214,
      130,
      193,
      113,
      205,
      196,
      32,
      128,
      143,
      180,
      185,
      135,
      0,
      19,
      0,
      224,
      180,
      0,
      238,
      170,
      240,
      179,
      11,
      170,
      147,
      112,
      144,
      34,
      255,
      250,
      122,
      144,
      47,
      225,
      71,
      230,
      0,
      50,
      96,
      240,
      238,
      0,
      230,
      203,
      212,
      0,
      143,
      60,
      230,
      240,
      209,
      127,
      128,
      205,
      114,
      211,
      34,
      80,
      235,
      237,
      140,
      215,
      238,
      35,
      250,
      139,
      139,
      220,
      211,
      181,
      173,
      255,
      30,
      220,
      79,
      139,
      238,
      0,
      230,
      245,
      0,
      255,
      0,
      216,
      153,
      147,
      204,
      255,
      133,
      50,
      107,
      255,
      250,
      154,
      47,
      208,
      204,
      92,
      210,
      160,
      0,
      0,
      255,
      222,
      226,
      255,
      128,
      152,
      45
    ],
    A: [
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255
    ],
    I: [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      112,
      113,
      114,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130
    ]
  }, fP = {
    labels: [
      "background",
      "tissue",
      "bone",
      "skin",
      "connective tissue",
      "blood",
      "organ",
      "mass",
      "muscle",
      "foreign object",
      "waste",
      "teeth",
      "fat",
      "gray matter",
      "white matter",
      "nerve",
      "vein",
      "artery",
      "capillary",
      "ligament",
      "tendon",
      "cartilage",
      "meniscus",
      "lymph node",
      "lymphatic vessel",
      "cerebro-spinal fluid",
      "bile",
      "urine",
      "feces",
      "gas",
      "fluid",
      "edema",
      "bleeding",
      "necrosis",
      "clot",
      "embolism",
      "head",
      "central nervous system",
      "brain",
      "gray matter of brain",
      "telencephalon",
      "cerebral cortex",
      "right frontal lobe",
      "left frontal lobe",
      "right temporal lobe",
      "left temporal lobe",
      "right parietal lobe",
      "left parietal lobe",
      "right occipital lobe",
      "left occipital lobe",
      "right insular lobe",
      "left insular lobe",
      "right limbic lobe",
      "left limbic lobe",
      "right striatum",
      "left striatum",
      "right caudate nucleus",
      "left caudate nucleus",
      "right putamen",
      "left putamen",
      "right pallidum",
      "left pallidum",
      "right amygdaloid complex",
      "left amygdaloid complex",
      "diencephalon",
      "thalamus",
      "right thalamus",
      "left thalamus",
      "pineal gland",
      "midbrain",
      "substantia nigra",
      "right substantia nigra",
      "left substantia nigra",
      "cerebral white matter",
      "right superior longitudinal fasciculus",
      "left superior longitudinal fasciculus",
      "right inferior longitudinal fasciculus",
      "left inferior longitudinal fasciculus",
      "right arcuate fasciculus",
      "left arcuate fasciculus",
      "right uncinate fasciculus",
      "left uncinate fasciculus",
      "right cingulum bundle",
      "left cingulum bundle",
      "projection fibers",
      "right corticospinal tract",
      "left corticospinal tract",
      "right optic radiation",
      "left optic radiation",
      "right medial lemniscus",
      "left medial lemniscus",
      "right superior cerebellar peduncle",
      "left superior cerebellar peduncle",
      "right middle cerebellar peduncle",
      "left middle cerebellar peduncle",
      "right inferior cerebellar peduncle",
      "left inferior cerebellar peduncle",
      "optic chiasm",
      "right optic tract",
      "left optic tract",
      "right fornix",
      "left fornix",
      "commissural fibers",
      "corpus callosum",
      "posterior commissure",
      "cerebellar white matter",
      "CSF space",
      "ventricles of brain",
      "right lateral ventricle",
      "left lateral ventricle",
      "right third ventricle",
      "left third ventricle",
      "cerebral aqueduct",
      "fourth ventricle",
      "subarachnoid space",
      "spinal cord",
      "gray matter of spinal cord",
      "white matter of spinal cord",
      "endocrine system of brain",
      "pituitary gland",
      "adenohypophysis",
      "neurohypophysis",
      "meninges",
      "dura mater",
      "arachnoid",
      "pia mater",
      "muscles of head",
      "salivary glands",
      "lips",
      "nose",
      "tongue",
      "soft palate",
      "right inner ear",
      "left inner ear",
      "right external ear",
      "left external ear",
      "right middle ear",
      "left middle ear",
      "right eyeball",
      "left eyeball",
      "skull",
      "right frontal bone",
      "left frontal bone",
      "right parietal bone",
      "left parietal bone",
      "right temporal bone",
      "left temporal bone",
      "right sphenoid bone",
      "left sphenoid bone",
      "right ethmoid bone",
      "left ethmoid bone",
      "occipital bone",
      "maxilla",
      "right zygomatic bone",
      "right lacrimal bone",
      "vomer bone",
      "right palatine bone",
      "left palatine bone",
      "mandible",
      "neck",
      "muscles of neck",
      "pharynx",
      "larynx",
      "thyroid gland",
      "right parathyroid glands",
      "left parathyroid glands",
      "skeleton of neck",
      "hyoid bone",
      "cervical vertebral column",
      "thorax",
      "trachea",
      "bronchi",
      "right lung",
      "left lung",
      "superior lobe of right lung",
      "superior lobe of left lung",
      "middle lobe of right lung",
      "inferior lobe of right lung",
      "inferior lobe of left lung",
      "pleura",
      "heart",
      "right atrium",
      "left atrium",
      "atrial septum",
      "ventricular septum",
      "right ventricle of heart",
      "left ventricle of heart",
      "mitral valve",
      "tricuspid valve",
      "aortic valve",
      "pulmonary valve",
      "aorta",
      "pericardium",
      "pericardial cavity",
      "esophagus",
      "thymus",
      "mediastinum",
      "skin of thoracic wall",
      "muscles of thoracic wall",
      "skeleton of thorax",
      "thoracic vertebral column",
      "ribs",
      "sternum",
      "right clavicle",
      "left clavicle",
      "abdominal cavity",
      "abdomen",
      "peritoneum",
      "omentum",
      "peritoneal cavity",
      "retroperitoneal space",
      "stomach",
      "duodenum",
      "small bowel",
      "colon",
      "anus",
      "liver",
      "biliary tree",
      "gallbladder",
      "pancreas",
      "spleen",
      "urinary system",
      "right kidney",
      "left kidney",
      "right ureter",
      "left ureter",
      "urinary bladder",
      "urethra",
      "right adrenal gland",
      "left adrenal gland",
      "female internal genitalia",
      "uterus",
      "right fallopian tube",
      "left fallopian tube",
      "right ovary",
      "left ovary",
      "vagina",
      "male internal genitalia",
      "prostate",
      "right seminal vesicle",
      "left seminal vesicle",
      "right deferent duct",
      "left deferent duct",
      "skin of abdominal wall",
      "muscles of abdominal wall",
      "skeleton of abdomen",
      "lumbar vertebral column",
      "female external genitalia",
      "male external genitalia",
      "skeleton of upper limb",
      "muscles of upper limb",
      "right upper limb",
      "left upper limb",
      "right shoulder",
      "left shoulder",
      "right arm"
    ],
    R: [
      0,
      128,
      241,
      177,
      111,
      216,
      221,
      144,
      192,
      220,
      78,
      255,
      230,
      200,
      250,
      244,
      0,
      216,
      183,
      183,
      152,
      111,
      178,
      68,
      111,
      85,
      0,
      214,
      78,
      218,
      170,
      140,
      188,
      216,
      145,
      150,
      177,
      244,
      250,
      200,
      68,
      128,
      83,
      83,
      162,
      162,
      141,
      141,
      182,
      182,
      188,
      188,
      154,
      154,
      177,
      177,
      30,
      30,
      210,
      210,
      48,
      48,
      98,
      98,
      69,
      166,
      122,
      122,
      253,
      145,
      46,
      0,
      0,
      250,
      127,
      127,
      159,
      159,
      125,
      125,
      106,
      106,
      154,
      154,
      126,
      201,
      201,
      78,
      78,
      174,
      174,
      139,
      139,
      148,
      148,
      186,
      186,
      99,
      156,
      156,
      64,
      64,
      138,
      97,
      126,
      194,
      85,
      88,
      88,
      88,
      88,
      88,
      88,
      88,
      88,
      244,
      200,
      250,
      82,
      57,
      60,
      92,
      255,
      255,
      255,
      255,
      201,
      70,
      188,
      177,
      166,
      182,
      229,
      229,
      174,
      174,
      201,
      201,
      194,
      194,
      241,
      203,
      203,
      229,
      229,
      255,
      255,
      209,
      209,
      248,
      248,
      255,
      196,
      255,
      255,
      255,
      242,
      242,
      222,
      177,
      213,
      184,
      150,
      62,
      62,
      62,
      242,
      250,
      255,
      177,
      182,
      175,
      197,
      197,
      172,
      172,
      202,
      224,
      224,
      255,
      206,
      210,
      203,
      233,
      195,
      181,
      152,
      159,
      166,
      218,
      225,
      224,
      255,
      184,
      211,
      47,
      255,
      173,
      188,
      255,
      226,
      253,
      244,
      205,
      205,
      186,
      177,
      255,
      234,
      204,
      180,
      216,
      255,
      205,
      204,
      255,
      221,
      0,
      139,
      249,
      157,
      203,
      185,
      185,
      247,
      247,
      222,
      124,
      249,
      249,
      244,
      255,
      255,
      227,
      213,
      213,
      193,
      216,
      230,
      245,
      245,
      241,
      241,
      177,
      171,
      217,
      212,
      185,
      185,
      198,
      194,
      177,
      177,
      177,
      177,
      177
    ],
    G: [
      0,
      174,
      214,
      122,
      184,
      101,
      130,
      238,
      104,
      245,
      63,
      250,
      220,
      200,
      250,
      214,
      151,
      101,
      156,
      214,
      189,
      184,
      212,
      172,
      197,
      188,
      145,
      230,
      63,
      255,
      250,
      224,
      65,
      191,
      60,
      98,
      122,
      214,
      250,
      200,
      131,
      174,
      146,
      146,
      115,
      115,
      93,
      93,
      166,
      166,
      135,
      135,
      150,
      150,
      140,
      140,
      111,
      111,
      157,
      157,
      129,
      129,
      153,
      153,
      110,
      113,
      101,
      101,
      135,
      92,
      101,
      108,
      108,
      250,
      150,
      150,
      116,
      116,
      102,
      102,
      174,
      174,
      146,
      146,
      126,
      160,
      160,
      152,
      152,
      140,
      140,
      126,
      126,
      120,
      120,
      135,
      135,
      106,
      171,
      171,
      123,
      123,
      95,
      113,
      161,
      195,
      188,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      214,
      200,
      250,
      174,
      157,
      143,
      162,
      244,
      244,
      244,
      244,
      121,
      163,
      91,
      122,
      84,
      105,
      147,
      147,
      122,
      122,
      112,
      112,
      142,
      142,
      213,
      179,
      179,
      204,
      204,
      243,
      243,
      185,
      185,
      223,
      223,
      230,
      172,
      255,
      250,
      237,
      217,
      217,
      198,
      122,
      124,
      105,
      208,
      162,
      162,
      162,
      206,
      210,
      255,
      122,
      228,
      216,
      165,
      165,
      138,
      138,
      164,
      186,
      186,
      245,
      110,
      115,
      108,
      138,
      100,
      85,
      55,
      63,
      70,
      123,
      130,
      97,
      244,
      122,
      171,
      150,
      244,
      121,
      95,
      239,
      202,
      232,
      217,
      179,
      179,
      124,
      122,
      255,
      234,
      142,
      119,
      132,
      253,
      167,
      168,
      224,
      130,
      145,
      150,
      180,
      108,
      136,
      102,
      102,
      182,
      182,
      154,
      186,
      186,
      186,
      170,
      181,
      190,
      153,
      141,
      141,
      123,
      146,
      158,
      172,
      172,
      172,
      172,
      124,
      85,
      198,
      188,
      135,
      135,
      175,
      98,
      122,
      122,
      122,
      122,
      122
    ],
    B: [
      0,
      128,
      145,
      101,
      210,
      79,
      101,
      144,
      88,
      20,
      0,
      220,
      70,
      235,
      210,
      49,
      206,
      79,
      220,
      211,
      207,
      210,
      242,
      100,
      131,
      255,
      30,
      130,
      0,
      255,
      250,
      228,
      28,
      216,
      66,
      83,
      101,
      49,
      225,
      215,
      98,
      128,
      164,
      164,
      105,
      105,
      137,
      137,
      110,
      110,
      166,
      166,
      201,
      201,
      190,
      190,
      85,
      85,
      166,
      166,
      126,
      126,
      112,
      112,
      53,
      137,
      38,
      38,
      192,
      109,
      131,
      112,
      112,
      225,
      88,
      88,
      163,
      163,
      154,
      154,
      155,
      155,
      83,
      83,
      55,
      133,
      133,
      141,
      141,
      103,
      103,
      177,
      177,
      72,
      72,
      135,
      135,
      24,
      108,
      108,
      147,
      147,
      74,
      158,
      197,
      164,
      255,
      215,
      215,
      215,
      215,
      215,
      215,
      215,
      215,
      49,
      215,
      225,
      128,
      110,
      83,
      109,
      209,
      209,
      209,
      209,
      77,
      117,
      95,
      101,
      94,
      107,
      118,
      118,
      90,
      90,
      73,
      73,
      0,
      0,
      144,
      77,
      77,
      109,
      109,
      152,
      152,
      85,
      85,
      131,
      131,
      138,
      68,
      167,
      160,
      145,
      123,
      123,
      101,
      101,
      109,
      108,
      243,
      114,
      114,
      114,
      142,
      139,
      207,
      101,
      255,
      244,
      145,
      145,
      115,
      115,
      140,
      162,
      162,
      217,
      84,
      89,
      81,
      112,
      73,
      57,
      13,
      27,
      38,
      97,
      104,
      76,
      209,
      154,
      143,
      103,
      209,
      88,
      76,
      172,
      134,
      158,
      154,
      108,
      108,
      161,
      101,
      220,
      194,
      178,
      153,
      105,
      229,
      142,
      143,
      199,
      101,
      30,
      98,
      111,
      162,
      116,
      83,
      83,
      164,
      164,
      132,
      223,
      150,
      150,
      147,
      158,
      165,
      130,
      113,
      113,
      103,
      127,
      140,
      147,
      147,
      151,
      151,
      92,
      68,
      131,
      102,
      134,
      134,
      125,
      79,
      101,
      101,
      101,
      101,
      101
    ],
    A: [
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255
    ],
    I: [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      112,
      113,
      114,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      139,
      140,
      141,
      142,
      143,
      144,
      145,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      155,
      156,
      157,
      158,
      159,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ]
  }, hP = {
    R: [
      0,
      0,
      24,
      248,
      255
    ],
    G: [
      0,
      0,
      177,
      254,
      0
    ],
    B: [
      0,
      136,
      0,
      0,
      0
    ],
    A: [
      0,
      32,
      64,
      78,
      128
    ],
    I: [
      0,
      64,
      128,
      156,
      255
    ]
  }, dP = {
    R: [
      1,
      10,
      15,
      17,
      21,
      27,
      36,
      49,
      65,
      82,
      99,
      118,
      140,
      161,
      183,
      203,
      222,
      238,
      248,
      253,
      253,
      253,
      252,
      250
    ],
    G: [
      25,
      42,
      56,
      68,
      79,
      88,
      97,
      105,
      111,
      116,
      122,
      127,
      133,
      138,
      142,
      146,
      150,
      155,
      162,
      170,
      178,
      186,
      195,
      204
    ],
    B: [
      89,
      92,
      95,
      96,
      98,
      98,
      96,
      91,
      83,
      74,
      64,
      55,
      46,
      43,
      49,
      62,
      79,
      100,
      126,
      151,
      175,
      199,
      223,
      250
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      11,
      22,
      33,
      44,
      55,
      66,
      77,
      88,
      99,
      110,
      121,
      133,
      144,
      155,
      166,
      177,
      188,
      199,
      210,
      221,
      232,
      243,
      255
    ]
  }, gP = {
    R: [
      0,
      248,
      242,
      235,
      229,
      222,
      212,
      202,
      193,
      183,
      173,
      145,
      117,
      78,
      39,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      128,
      191,
      255,
      255,
      255,
      255,
      255,
      238,
      221,
      204,
      214,
      224,
      235,
      245,
      255,
      249,
      242,
      236,
      229,
      223,
      217,
      210,
      204,
      197,
      191,
      184,
      176,
      169,
      161,
      154,
      146,
      139,
      132,
      124,
      117,
      109,
      102,
      0
    ],
    G: [
      0,
      251,
      247,
      243,
      239,
      235,
      235,
      235,
      235,
      235,
      235,
      216,
      197,
      174,
      150,
      127,
      153,
      178,
      204,
      229,
      255,
      255,
      255,
      255,
      255,
      220,
      185,
      150,
      115,
      77,
      38,
      0,
      31,
      61,
      92,
      122,
      153,
      138,
      122,
      107,
      92,
      77,
      61,
      46,
      31,
      15,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    B: [
      0,
      254,
      253,
      252,
      251,
      250,
      251,
      252,
      253,
      254,
      255,
      226,
      198,
      132,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      40,
      80,
      120,
      160,
      200,
      199,
      198,
      197,
      196,
      196,
      195,
      194,
      193,
      192,
      191,
      184,
      176,
      169,
      161,
      154,
      146,
      139,
      132,
      124,
      117,
      109,
      102,
      0
    ],
    A: [
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256
    ],
    I: [
      0,
      4,
      8,
      12,
      16,
      20,
      24,
      28,
      32,
      36,
      40,
      44,
      48,
      52,
      56,
      60,
      64,
      68,
      72,
      76,
      80,
      84,
      88,
      92,
      96,
      100,
      104,
      108,
      112,
      116,
      120,
      124,
      128,
      132,
      136,
      140,
      144,
      148,
      152,
      156,
      160,
      164,
      168,
      172,
      176,
      180,
      184,
      188,
      192,
      196,
      200,
      204,
      208,
      212,
      216,
      220,
      224,
      228,
      232,
      236,
      240,
      244,
      248,
      255
    ]
  }, pP = {
    R: [
      255,
      248,
      242,
      235,
      229,
      222,
      212,
      202,
      193,
      183,
      173,
      145,
      117,
      78,
      39,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      128,
      191,
      255,
      255,
      255,
      255,
      255,
      238,
      221,
      204,
      214,
      224,
      235,
      245,
      255,
      249,
      242,
      236,
      229,
      223,
      217,
      210,
      204,
      197,
      191,
      184,
      176,
      169,
      161,
      154,
      146,
      139,
      132,
      124,
      117,
      109,
      102,
      0
    ],
    G: [
      255,
      251,
      247,
      243,
      239,
      235,
      235,
      235,
      235,
      235,
      235,
      216,
      197,
      174,
      150,
      127,
      153,
      178,
      204,
      229,
      255,
      255,
      255,
      255,
      255,
      220,
      185,
      150,
      115,
      77,
      38,
      0,
      31,
      61,
      92,
      122,
      153,
      138,
      122,
      107,
      92,
      77,
      61,
      46,
      31,
      15,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    B: [
      255,
      254,
      253,
      252,
      251,
      250,
      251,
      252,
      253,
      254,
      255,
      226,
      198,
      132,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      40,
      80,
      120,
      160,
      200,
      199,
      198,
      197,
      196,
      196,
      195,
      194,
      193,
      192,
      191,
      184,
      176,
      169,
      161,
      154,
      146,
      139,
      132,
      124,
      117,
      109,
      102,
      0
    ],
    A: [
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256,
      256
    ],
    I: [
      0,
      4,
      8,
      12,
      16,
      20,
      24,
      28,
      32,
      36,
      40,
      44,
      48,
      52,
      56,
      60,
      64,
      68,
      72,
      76,
      80,
      84,
      88,
      92,
      96,
      100,
      104,
      108,
      112,
      116,
      120,
      124,
      128,
      132,
      136,
      140,
      144,
      148,
      152,
      156,
      160,
      164,
      168,
      172,
      176,
      180,
      184,
      188,
      192,
      196,
      200,
      204,
      208,
      212,
      216,
      220,
      224,
      228,
      232,
      236,
      240,
      244,
      248,
      255
    ]
  }, mP = {
    R: [
      0,
      0,
      0,
      0,
      196,
      255
    ],
    G: [
      0,
      32,
      128,
      128,
      128,
      32
    ],
    B: [
      0,
      255,
      196,
      0,
      0,
      0
    ],
    A: [
      0,
      128,
      64,
      64,
      64,
      128
    ],
    I: [
      0,
      1,
      64,
      128,
      192,
      255
    ]
  }, vP = {
    R: [
      0,
      255
    ],
    G: [
      0,
      0
    ],
    B: [
      255,
      255
    ],
    A: [
      0,
      128
    ],
    I: [
      0,
      255
    ]
  }, yP = {
    R: [
      0,
      0
    ],
    G: [
      0,
      255
    ],
    B: [
      255,
      255
    ],
    A: [
      0,
      128
    ],
    I: [
      0,
      255
    ]
  }, xP = {
    R: [
      0,
      0,
      0,
      0
    ],
    G: [
      0,
      1,
      128,
      255
    ],
    B: [
      0,
      222,
      127,
      32
    ],
    A: [
      0,
      0,
      64,
      128
    ],
    I: [
      0,
      1,
      128,
      255
    ]
  }, wP = {
    R: [
      0,
      0,
      0
    ],
    G: [
      0,
      0,
      0
    ],
    B: [
      0,
      128,
      255
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, CP = {
    R: [
      0,
      103,
      255
    ],
    G: [
      0,
      126,
      255
    ],
    B: [
      0,
      165,
      255
    ],
    A: [
      0,
      76,
      128
    ],
    I: [
      0,
      153,
      255
    ]
  }, TP = {
    R: [
      0,
      43,
      103,
      199,
      216,
      255
    ],
    G: [
      0,
      0,
      37,
      155,
      213,
      255
    ],
    B: [
      0,
      0,
      20,
      97,
      201,
      255
    ],
    A: [
      0,
      44,
      48,
      54,
      56,
      56
    ],
    I: [
      0,
      64,
      128,
      196,
      240,
      255
    ]
  }, SP = {
    R: [
      0,
      9,
      24,
      33,
      40,
      46,
      52,
      57,
      62,
      66,
      70,
      74,
      78,
      81,
      85,
      88,
      91,
      94,
      98,
      101,
      103,
      106,
      109,
      112,
      114,
      117,
      119,
      121,
      124,
      126,
      128,
      130,
      133,
      135,
      137,
      139,
      141,
      143,
      145,
      147,
      149,
      151,
      153,
      155,
      157,
      159,
      161,
      163,
      164,
      166,
      168,
      169,
      171,
      172,
      174,
      175,
      177,
      178,
      180,
      181,
      183,
      184,
      186,
      187,
      189,
      190,
      191,
      193,
      194,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      222,
      223,
      224,
      224,
      225,
      226,
      226,
      227,
      228,
      228,
      229,
      229,
      230,
      231,
      231,
      232,
      233,
      233,
      234,
      234,
      235,
      235,
      236,
      236,
      236,
      237,
      237,
      237,
      238,
      238,
      238,
      239,
      239,
      239,
      240,
      240,
      240,
      241,
      241,
      241,
      242,
      242,
      242,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      245,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      244,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      243,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      241,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      242,
      243,
      243,
      244,
      244,
      245,
      246,
      246,
      247,
      247,
      248,
      249,
      249,
      250,
      250,
      251,
      251,
      252,
      252,
      253,
      253,
      254,
      254,
      254
    ],
    G: [
      42,
      41,
      41,
      41,
      40,
      40,
      40,
      39,
      39,
      39,
      38,
      38,
      37,
      37,
      36,
      36,
      35,
      35,
      34,
      34,
      33,
      32,
      32,
      31,
      30,
      30,
      30,
      30,
      29,
      29,
      29,
      29,
      28,
      28,
      28,
      27,
      27,
      27,
      26,
      26,
      26,
      25,
      25,
      25,
      24,
      24,
      24,
      24,
      24,
      25,
      25,
      26,
      27,
      27,
      28,
      28,
      29,
      30,
      30,
      31,
      31,
      32,
      33,
      33,
      34,
      34,
      35,
      36,
      36,
      37,
      38,
      39,
      40,
      42,
      43,
      44,
      45,
      47,
      48,
      49,
      50,
      51,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      62,
      63,
      64,
      65,
      66,
      68,
      69,
      71,
      72,
      73,
      75,
      76,
      77,
      79,
      80,
      81,
      83,
      84,
      85,
      87,
      88,
      89,
      90,
      92,
      93,
      94,
      95,
      97,
      98,
      100,
      101,
      102,
      104,
      105,
      107,
      108,
      109,
      111,
      112,
      113,
      115,
      116,
      117,
      119,
      120,
      121,
      122,
      124,
      125,
      126,
      128,
      129,
      130,
      132,
      133,
      134,
      136,
      137,
      138,
      140,
      141,
      142,
      144,
      145,
      146,
      147,
      149,
      150,
      151,
      153,
      154,
      155,
      156,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      167,
      168,
      169,
      170,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      181,
      183,
      184,
      185,
      186,
      187,
      189,
      190,
      191,
      192,
      193,
      194,
      196,
      197,
      198,
      199,
      200,
      201,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      238,
      239,
      240,
      241,
      241,
      242,
      243,
      244,
      244,
      245,
      246,
      247,
      248,
      248,
      249,
      250,
      251,
      251,
      252,
      253,
      254,
      255
    ],
    B: [
      167,
      167,
      166,
      166,
      166,
      165,
      165,
      165,
      164,
      164,
      164,
      163,
      163,
      162,
      162,
      162,
      161,
      161,
      161,
      160,
      160,
      160,
      159,
      159,
      158,
      158,
      157,
      157,
      156,
      155,
      155,
      154,
      154,
      153,
      153,
      152,
      151,
      151,
      150,
      150,
      149,
      149,
      148,
      147,
      147,
      146,
      146,
      145,
      144,
      144,
      143,
      143,
      142,
      141,
      141,
      140,
      139,
      139,
      138,
      137,
      137,
      136,
      135,
      135,
      134,
      133,
      133,
      132,
      131,
      131,
      130,
      130,
      129,
      128,
      128,
      127,
      127,
      126,
      125,
      125,
      124,
      124,
      123,
      123,
      122,
      121,
      121,
      120,
      119,
      119,
      118,
      118,
      117,
      116,
      116,
      116,
      115,
      115,
      114,
      114,
      113,
      113,
      113,
      112,
      112,
      111,
      111,
      110,
      110,
      109,
      109,
      109,
      108,
      108,
      107,
      107,
      106,
      106,
      106,
      106,
      106,
      105,
      105,
      105,
      105,
      105,
      105,
      105,
      104,
      104,
      104,
      104,
      104,
      103,
      103,
      103,
      103,
      103,
      102,
      102,
      102,
      103,
      103,
      103,
      103,
      104,
      104,
      104,
      104,
      104,
      105,
      105,
      105,
      105,
      106,
      106,
      106,
      106,
      106,
      107,
      107,
      107,
      107,
      108,
      108,
      109,
      110,
      111,
      111,
      112,
      113,
      113,
      114,
      115,
      115,
      116,
      117,
      117,
      118,
      119,
      120,
      120,
      121,
      122,
      122,
      123,
      124,
      125,
      126,
      128,
      129,
      130,
      131,
      132,
      134,
      135,
      136,
      137,
      138,
      140,
      141,
      142,
      143,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      153,
      155,
      157,
      158,
      160,
      162,
      163,
      165,
      167,
      168,
      170,
      172,
      173,
      175,
      177,
      178,
      180,
      182,
      183,
      185,
      187,
      188,
      190,
      193,
      196,
      199,
      201,
      204,
      207,
      210,
      212,
      215,
      218,
      221,
      224,
      226,
      229,
      232,
      235,
      238,
      240,
      243,
      246,
      249,
      252,
      255
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      112,
      113,
      114,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      139,
      140,
      141,
      142,
      143,
      144,
      145,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      155,
      156,
      157,
      158,
      159,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ]
  }, AP = {
    R: [
      0,
      86,
      166,
      255
    ],
    G: [
      32,
      92,
      156,
      233
    ],
    B: [
      76,
      108,
      117,
      69
    ],
    A: [
      0,
      56,
      80,
      88
    ],
    I: [
      0,
      64,
      192,
      255
    ]
  }, EP = {
    R: [
      0,
      0,
      0
    ],
    G: [
      127,
      196,
      254
    ],
    B: [
      255,
      255,
      255
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, bP = {
    R: [
      0,
      61,
      122,
      183,
      244,
      255
    ],
    G: [
      0,
      41,
      81,
      122,
      163,
      255
    ],
    B: [
      0,
      25,
      51,
      76,
      102,
      255
    ],
    A: [
      0,
      25,
      51,
      71,
      102,
      128
    ],
    I: [
      0,
      51,
      102,
      153,
      204,
      255
    ]
  }, DP = {
    R: [
      0,
      61,
      122,
      183,
      244,
      255
    ],
    G: [
      0,
      41,
      81,
      122,
      163,
      203
    ],
    B: [
      0,
      25,
      51,
      76,
      102,
      127
    ],
    A: [
      0,
      25,
      51,
      71,
      102,
      128
    ],
    I: [
      0,
      51,
      102,
      153,
      204,
      255
    ]
  }, MP = {
    min: -643,
    max: -235,
    R: [
      0,
      0,
      0
    ],
    G: [
      154,
      154,
      154
    ],
    B: [
      179,
      179,
      101
    ],
    A: [
      0,
      32,
      0
    ],
    I: [
      0,
      163,
      255
    ]
  }, RP = {
    min: 114,
    max: 800,
    R: [
      0,
      255,
      255,
      255
    ],
    G: [
      0,
      0,
      129,
      255
    ],
    B: [
      0,
      0,
      0,
      255
    ],
    A: [
      0,
      64,
      88,
      228
    ],
    I: [
      0,
      80,
      160,
      255
    ]
  }, OP = {
    min: 180,
    max: 600,
    R: [
      0,
      0,
      113,
      255
    ],
    G: [
      0,
      0,
      109,
      250
    ],
    B: [
      0,
      0,
      101,
      245
    ],
    A: [
      0,
      0,
      100,
      160
    ],
    I: [
      0,
      1,
      128,
      255
    ]
  }, IP = {
    min: -10,
    max: 110,
    R: [
      0,
      127,
      255
    ],
    G: [
      0,
      127,
      255
    ],
    B: [
      0,
      127,
      255
    ],
    A: [
      0,
      48,
      128
    ],
    I: [
      0,
      124,
      255
    ]
  }, VP = {
    min: -10,
    max: 110,
    R: [
      0,
      199,
      255
    ],
    G: [
      0,
      127,
      255
    ],
    B: [
      0,
      127,
      255
    ],
    A: [
      0,
      48,
      128
    ],
    I: [
      0,
      124,
      255
    ]
  }, NP = {
    min: -80,
    max: 1e3,
    R: [
      0,
      189,
      150,
      150,
      150,
      150,
      255
    ],
    G: [
      0,
      169,
      54,
      54,
      54,
      54,
      240
    ],
    B: [
      0,
      153,
      52,
      52,
      52,
      52,
      242
    ],
    A: [
      0,
      32,
      64,
      0,
      0,
      64,
      64
    ],
    I: [
      0,
      1,
      82,
      92,
      234,
      242,
      255
    ]
  }, LP = {
    min: -590,
    max: 600,
    R: [
      0,
      241,
      241,
      248,
      248,
      178,
      178,
      232,
      255,
      255,
      255
    ],
    G: [
      0,
      156,
      156,
      222,
      222,
      36,
      36,
      51,
      255,
      255,
      255
    ],
    B: [
      0,
      130,
      130,
      169,
      169,
      24,
      24,
      37,
      255,
      255,
      255
    ],
    A: [
      0,
      8,
      0,
      0,
      0,
      64,
      64,
      0,
      0,
      222,
      222
    ],
    I: [
      0,
      2,
      3,
      64,
      122,
      142,
      172,
      182,
      252,
      253,
      255
    ]
  }, UP = {
    min: 114,
    max: 302,
    R: [
      0,
      255,
      255
    ],
    G: [
      0,
      129,
      255
    ],
    B: [
      0,
      0,
      255
    ],
    A: [
      0,
      88,
      228
    ],
    I: [
      0,
      103,
      255
    ]
  }, FP = {
    min: -23,
    max: 246,
    R: [
      0,
      44,
      255,
      255,
      255
    ],
    G: [
      0,
      128,
      90,
      255,
      255
    ],
    B: [
      0,
      0,
      70,
      0,
      255
    ],
    A: [
      0,
      0,
      82,
      184,
      228
    ],
    I: [
      0,
      64,
      131,
      196,
      255
    ]
  }, BP = {
    min: -100,
    max: 246,
    R: [
      0,
      128,
      159,
      255,
      255,
      255,
      255
    ],
    G: [
      0,
      0,
      56,
      90,
      0,
      255,
      255
    ],
    B: [
      0,
      0,
      41,
      70,
      0,
      0,
      255
    ],
    A: [
      0,
      63,
      105,
      135,
      167,
      184,
      228
    ],
    I: [
      0,
      100,
      128,
      155,
      180,
      209,
      255
    ]
  }, _P = {
    min: -590,
    max: 600,
    R: [
      0,
      241,
      241,
      248,
      248,
      178,
      232,
      255,
      255
    ],
    G: [
      0,
      156,
      156,
      222,
      222,
      36,
      51,
      255,
      255
    ],
    B: [
      0,
      130,
      130,
      169,
      169,
      24,
      37,
      255,
      255
    ],
    A: [
      0,
      63,
      105,
      135,
      167,
      184,
      228,
      228,
      228
    ],
    I: [
      0,
      1,
      52,
      127,
      137,
      162,
      172,
      252,
      255
    ]
  }, kP = {
    min: 140,
    max: 1024,
    R: [
      0,
      2,
      113,
      255
    ],
    G: [
      0,
      1,
      109,
      250
    ],
    B: [
      0,
      1,
      101,
      245
    ],
    A: [
      0,
      1,
      96,
      168
    ],
    I: [
      0,
      1,
      128,
      255
    ]
  }, PP = {
    min: -923,
    max: 679,
    R: [
      0,
      0,
      0,
      0,
      0,
      255,
      255,
      255
    ],
    G: [
      154,
      154,
      154,
      154,
      0,
      0,
      254,
      255
    ],
    B: [
      179,
      179,
      179,
      179,
      0,
      0,
      0,
      255
    ],
    A: [
      0,
      3,
      8,
      0,
      0,
      10,
      15,
      20
    ],
    I: [
      0,
      30,
      62,
      88,
      170,
      200,
      232,
      255
    ]
  }, GP = {
    min: -10,
    max: 110,
    R: [
      0,
      199,
      255
    ],
    G: [
      0,
      127,
      255
    ],
    B: [
      0,
      127,
      255
    ],
    A: [
      0,
      48,
      128
    ],
    I: [
      0,
      124,
      255
    ]
  }, zP = {
    min: -600,
    max: 100,
    R: [
      0,
      134,
      255
    ],
    G: [
      0,
      109,
      250
    ],
    B: [
      0,
      101,
      245
    ],
    A: [
      0,
      60,
      148
    ],
    I: [
      0,
      128,
      255
    ]
  }, WP = {
    min: 114,
    max: 246,
    R: [
      0,
      255,
      255
    ],
    G: [
      0,
      128,
      255
    ],
    B: [
      0,
      128,
      255
    ],
    A: [
      0,
      64,
      96
    ],
    I: [
      0,
      87,
      255
    ]
  }, HP = {
    min: 50,
    max: 1e3,
    R: [
      98,
      210,
      169,
      128,
      255
    ],
    G: [
      94,
      26,
      77,
      128,
      255
    ],
    B: [
      45,
      21,
      74,
      128,
      255
    ],
    A: [
      0,
      25,
      0,
      4,
      168
    ],
    I: [
      0,
      41,
      87,
      154,
      255
    ]
  }, jP = {
    R: [
      0,
      13,
      21,
      26,
      27,
      25,
      22,
      21,
      22,
      28,
      39,
      54,
      75,
      98,
      124,
      148,
      171,
      189,
      202,
      210,
      213,
      211,
      206,
      200,
      195,
      193,
      195,
      201,
      211,
      225,
      240,
      255
    ],
    G: [
      0,
      5,
      11,
      20,
      31,
      44,
      58,
      72,
      86,
      99,
      109,
      116,
      120,
      122,
      122,
      122,
      121,
      121,
      124,
      129,
      137,
      147,
      161,
      175,
      190,
      205,
      218,
      229,
      238,
      245,
      251,
      255
    ],
    B: [
      0,
      14,
      30,
      46,
      61,
      71,
      77,
      78,
      75,
      68,
      60,
      52,
      48,
      47,
      53,
      65,
      83,
      105,
      131,
      157,
      183,
      205,
      222,
      235,
      241,
      243,
      242,
      240,
      239,
      240,
      245,
      255
    ],
    A: [
      0,
      4,
      8,
      12,
      17,
      21,
      25,
      29,
      33,
      37,
      41,
      45,
      50,
      54,
      58,
      62,
      66,
      70,
      74,
      78,
      83,
      87,
      91,
      95,
      99,
      103,
      107,
      111,
      116,
      120,
      124,
      128
    ],
    I: [
      0,
      8,
      16,
      25,
      33,
      41,
      49,
      58,
      66,
      74,
      82,
      90,
      99,
      107,
      115,
      123,
      132,
      140,
      148,
      156,
      165,
      173,
      181,
      189,
      197,
      206,
      214,
      222,
      230,
      239,
      247,
      255
    ]
  }, KP = {
    R: [
      0,
      10,
      136,
      255
    ],
    G: [
      0,
      39,
      220,
      255
    ],
    B: [
      0,
      223,
      253,
      255
    ],
    A: [
      0,
      48,
      64,
      70
    ],
    I: [
      0,
      92,
      192,
      255
    ]
  }, YP = {
    R: [
      0,
      245,
      205,
      120,
      196,
      220,
      230,
      0,
      122,
      236,
      12,
      204,
      42,
      119,
      220,
      103,
      60,
      255,
      165,
      160,
      0,
      245,
      205,
      120,
      196,
      220,
      230,
      0,
      122,
      236,
      13,
      220,
      103,
      255,
      165,
      160,
      0,
      120,
      200,
      255,
      255,
      164,
      164,
      164,
      234,
      0,
      0,
      0,
      0,
      0
    ],
    G: [
      0,
      245,
      62,
      18,
      58,
      248,
      148,
      118,
      186,
      13,
      48,
      182,
      204,
      159,
      216,
      255,
      60,
      165,
      42,
      32,
      200,
      245,
      62,
      18,
      58,
      248,
      148,
      118,
      186,
      13,
      48,
      216,
      255,
      165,
      42,
      32,
      200,
      190,
      70,
      148,
      148,
      108,
      108,
      108,
      169,
      0,
      0,
      0,
      0,
      0
    ],
    B: [
      0,
      245,
      78,
      134,
      250,
      164,
      34,
      14,
      220,
      176,
      255,
      142,
      164,
      176,
      20,
      255,
      60,
      0,
      42,
      240,
      200,
      245,
      78,
      134,
      250,
      164,
      34,
      14,
      220,
      176,
      255,
      20,
      255,
      0,
      42,
      240,
      221,
      150,
      255,
      10,
      10,
      226,
      226,
      226,
      30,
      64,
      112,
      160,
      208,
      255
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      2,
      3,
      4,
      5,
      7,
      8,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      24,
      26,
      28,
      30,
      31,
      41,
      42,
      43,
      44,
      46,
      47,
      49,
      50,
      51,
      52,
      53,
      54,
      58,
      60,
      62,
      63,
      72,
      77,
      78,
      79,
      80,
      81,
      82,
      85,
      251,
      252,
      253,
      254,
      255
    ]
  }, qP = {
    R: [
      0,
      0,
      128,
      255,
      255
    ],
    G: [
      0,
      128,
      0,
      128,
      255
    ],
    B: [
      0,
      125,
      255,
      0,
      255
    ],
    A: [
      0,
      32,
      64,
      96,
      128
    ],
    I: [
      0,
      63,
      128,
      192,
      255
    ]
  }, XP = {
    R: [
      0,
      142,
      227,
      255
    ],
    G: [
      0,
      85,
      170,
      255
    ],
    B: [
      0,
      14,
      76,
      255
    ],
    A: [
      0,
      42,
      84,
      128
    ],
    I: [
      0,
      85,
      170,
      255
    ]
  }, ZP = {
    R: [
      0,
      255
    ],
    G: [
      0,
      255
    ],
    B: [
      0,
      255
    ],
    A: [
      0,
      128
    ],
    I: [
      0,
      255
    ]
  }, QP = {
    R: [
      0,
      0,
      0
    ],
    G: [
      0,
      128,
      255
    ],
    B: [
      0,
      0,
      0
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, JP = {
    R: [
      0,
      0,
      0
    ],
    G: [
      72,
      72,
      255
    ],
    B: [
      0,
      255,
      255
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      88,
      255
    ]
  }, $P = {
    R: [
      0,
      255,
      255
    ],
    G: [
      72,
      88,
      255
    ],
    B: [
      0,
      0,
      0
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      88,
      255
    ]
  }, eG = {
    R: [
      0,
      255,
      255,
      255
    ],
    G: [
      0,
      0,
      126,
      255
    ],
    B: [
      0,
      0,
      0,
      255
    ],
    A: [
      0,
      64,
      96,
      128
    ],
    I: [
      0,
      128,
      191,
      255
    ]
  }, tG = {
    R: [
      3,
      255,
      255,
      255
    ],
    G: [
      0,
      0,
      255,
      255
    ],
    B: [
      0,
      0,
      0,
      255
    ],
    A: [
      0,
      48,
      96,
      128
    ],
    I: [
      0,
      95,
      191,
      255
    ]
  }, nG = {
    R: [
      255,
      255,
      0,
      0,
      0,
      255,
      255
    ],
    G: [
      0,
      255,
      255,
      255,
      0,
      0,
      0
    ],
    B: [
      0,
      0,
      0,
      255,
      255,
      255,
      0
    ],
    A: [
      0,
      14,
      28,
      43,
      57,
      71,
      85
    ],
    I: [
      0,
      43,
      85,
      128,
      170,
      213,
      255
    ]
  }, rG = {
    R: [
      0,
      120,
      237,
      240
    ],
    G: [
      0,
      28,
      105,
      249
    ],
    B: [
      4,
      109,
      37,
      33
    ],
    A: [
      0,
      56,
      80,
      88
    ],
    I: [
      0,
      64,
      192,
      255
    ]
  }, iG = {
    R: [
      0,
      0,
      127,
      255,
      127
    ],
    G: [
      0,
      127,
      255,
      127,
      0
    ],
    B: [
      127,
      255,
      127,
      0,
      0
    ],
    A: [
      0,
      32,
      64,
      96,
      128
    ],
    I: [
      0,
      63,
      128,
      192,
      255
    ]
  }, aG = {
    R: [
      0,
      255,
      255
    ],
    G: [
      0,
      0,
      255
    ],
    B: [
      0,
      0,
      0
    ],
    A: [
      0,
      64,
      64
    ],
    I: [
      0,
      86,
      255
    ]
  }, sG = {
    R: [
      94,
      50,
      90,
      152,
      215,
      238,
      249,
      254,
      252,
      241,
      209,
      158
    ],
    G: [
      79,
      131,
      186,
      214,
      240,
      244,
      237,
      210,
      157,
      100,
      57,
      1
    ],
    B: [
      162,
      189,
      167,
      164,
      155,
      169,
      168,
      123,
      86,
      68,
      79,
      66
    ],
    A: [
      0,
      12,
      23,
      35,
      47,
      58,
      70,
      81,
      93,
      105,
      116,
      128
    ],
    I: [
      0,
      23,
      46,
      70,
      93,
      116,
      139,
      162,
      185,
      209,
      232,
      255
    ]
  }, oG = {
    R: [
      3,
      7,
      13,
      25,
      45,
      67,
      84,
      98,
      110,
      124,
      138,
      154,
      173,
      191,
      210,
      225,
      233,
      233,
      231,
      229,
      230,
      235,
      243,
      253
    ],
    G: [
      19,
      33,
      48,
      63,
      77,
      87,
      92,
      94,
      95,
      96,
      96,
      97,
      99,
      101,
      106,
      118,
      133,
      149,
      163,
      177,
      192,
      208,
      225,
      245
    ],
    B: [
      38,
      58,
      79,
      99,
      114,
      122,
      122,
      120,
      117,
      113,
      110,
      105,
      101,
      97,
      94,
      96,
      103,
      112,
      122,
      134,
      149,
      169,
      192,
      218
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      11,
      22,
      33,
      44,
      55,
      66,
      77,
      88,
      99,
      110,
      121,
      133,
      144,
      155,
      166,
      177,
      188,
      199,
      210,
      221,
      232,
      243,
      255
    ]
  }, lG = {
    R: [
      0,
      148,
      183,
      223,
      247,
      252
    ],
    G: [
      0,
      44,
      55,
      74,
      112,
      253
    ],
    B: [
      4,
      128,
      121,
      104,
      92,
      191
    ],
    A: [
      0,
      44,
      53,
      64,
      75,
      107
    ],
    I: [
      0,
      107,
      128,
      154,
      179,
      255
    ]
  }, cG = {
    R: [
      11,
      59,
      55,
      222
    ],
    G: [
      4,
      45,
      165,
      245
    ],
    B: [
      5,
      91,
      172,
      229
    ],
    A: [
      0,
      23,
      70,
      107
    ],
    I: [
      0,
      56,
      167,
      255
    ]
  }, uG = {
    R: [
      3,
      5,
      6,
      8,
      12,
      19,
      28,
      36,
      42,
      48,
      54,
      61,
      68,
      76,
      86,
      96,
      110,
      129,
      154,
      181,
      205,
      224,
      239,
      252
    ],
    G: [
      19,
      32,
      44,
      58,
      72,
      86,
      98,
      108,
      116,
      122,
      128,
      134,
      141,
      149,
      157,
      167,
      178,
      191,
      204,
      216,
      225,
      232,
      239,
      244
    ],
    B: [
      39,
      60,
      82,
      104,
      123,
      137,
      144,
      145,
      142,
      138,
      134,
      130,
      126,
      121,
      116,
      110,
      105,
      104,
      112,
      131,
      155,
      178,
      198,
      217
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      11,
      22,
      33,
      44,
      55,
      66,
      77,
      88,
      99,
      110,
      121,
      133,
      144,
      155,
      166,
      177,
      188,
      199,
      210,
      221,
      232,
      243,
      255
    ]
  }, fG = {
    R: [
      0,
      85,
      0,
      0,
      0,
      0,
      0,
      0,
      85,
      255,
      255,
      255,
      172
    ],
    G: [
      0,
      0,
      0,
      0,
      85,
      170,
      255,
      255,
      255,
      255,
      85,
      0,
      0
    ],
    B: [
      0,
      170,
      85,
      255,
      255,
      170,
      170,
      0,
      85,
      0,
      0,
      0,
      0
    ],
    A: [
      0,
      5,
      10,
      21,
      26,
      32,
      37,
      42,
      48,
      53,
      64,
      72,
      85
    ],
    I: [
      0,
      15,
      31,
      63,
      79,
      95,
      111,
      127,
      143,
      159,
      191,
      217,
      255
    ]
  }, hG = {
    R: [
      13,
      156,
      237,
      240
    ],
    G: [
      8,
      23,
      121,
      249
    ],
    B: [
      135,
      158,
      83,
      33
    ],
    A: [
      0,
      56,
      80,
      88
    ],
    I: [
      0,
      64,
      192,
      255
    ]
  }, dG = {
    R: [
      208,
      71,
      33,
      192,
      32,
      195,
      208,
      173,
      233,
      202,
      25,
      210,
      145,
      89,
      87,
      245,
      246,
      38,
      3,
      25,
      57,
      167,
      245,
      86,
      227,
      208,
      81,
      64,
      90,
      199,
      140,
      48,
      212,
      180,
      70,
      120,
      9,
      192,
      245,
      177,
      65,
      157,
      9,
      193,
      100,
      181,
      125,
      145,
      62,
      8,
      108,
      36,
      140,
      237,
      242,
      248,
      161,
      189,
      41,
      114,
      65,
      121,
      97,
      50,
      238,
      149,
      44,
      214,
      124,
      167,
      40,
      167,
      127,
      178,
      231,
      30,
      173,
      244,
      193,
      203,
      204,
      238,
      139,
      135,
      71,
      234,
      234,
      217,
      66,
      14,
      129,
      19,
      97,
      165,
      112,
      244,
      35,
      73,
      192,
      12,
      149,
      71,
      33,
      192,
      32,
      195,
      208,
      173,
      233,
      202,
      25,
      210,
      145,
      89,
      87,
      245,
      246,
      38,
      3,
      25,
      57,
      167,
      245,
      86,
      227,
      208,
      81,
      64,
      90,
      199,
      140,
      48,
      212,
      180,
      70,
      120,
      9,
      192,
      245,
      177,
      65,
      157,
      9,
      193,
      100,
      181,
      125,
      145,
      62,
      8,
      108,
      36,
      140,
      237,
      242,
      248,
      161,
      189,
      41,
      114,
      65,
      121,
      97,
      50,
      238,
      149,
      44,
      214,
      124,
      167,
      40,
      167,
      127,
      178,
      231,
      30,
      173,
      244,
      193,
      203,
      204,
      238,
      139,
      135,
      71,
      234,
      234,
      217,
      66,
      14,
      129,
      19,
      97,
      165,
      112,
      244,
      35,
      73,
      192,
      12,
      149,
      71,
      33,
      192,
      32,
      195,
      208,
      173,
      233,
      202,
      25,
      210,
      145,
      89,
      87,
      245,
      246,
      38,
      3,
      25,
      57,
      167,
      245,
      86,
      227,
      208,
      81,
      64,
      90,
      199,
      140,
      48,
      212,
      180,
      70,
      120,
      9,
      192,
      245,
      177,
      65,
      157,
      9,
      193,
      100,
      181,
      125,
      145,
      62,
      8,
      108,
      36,
      140,
      237,
      242,
      248
    ],
    G: [
      182,
      46,
      78,
      199,
      79,
      89,
      41,
      208,
      135,
      20,
      154,
      35,
      21,
      43,
      230,
      113,
      191,
      147,
      208,
      37,
      28,
      27,
      86,
      203,
      25,
      209,
      148,
      187,
      139,
      111,
      48,
      102,
      76,
      110,
      106,
      130,
      37,
      160,
      34,
      222,
      90,
      165,
      245,
      222,
      102,
      47,
      19,
      130,
      4,
      232,
      137,
      211,
      240,
      11,
      140,
      21,
      42,
      22,
      241,
      61,
      99,
      115,
      199,
      166,
      114,
      190,
      204,
      60,
      233,
      66,
      115,
      230,
      125,
      103,
      203,
      125,
      13,
      176,
      94,
      131,
      39,
      198,
      167,
      124,
      67,
      175,
      254,
      1,
      15,
      198,
      62,
      237,
      159,
      31,
      218,
      58,
      244,
      47,
      61,
      67,
      94,
      46,
      78,
      199,
      79,
      89,
      41,
      208,
      135,
      20,
      154,
      35,
      21,
      43,
      230,
      113,
      191,
      147,
      208,
      37,
      28,
      27,
      86,
      203,
      25,
      209,
      148,
      187,
      139,
      111,
      48,
      102,
      76,
      110,
      106,
      130,
      37,
      160,
      34,
      222,
      90,
      165,
      245,
      222,
      102,
      47,
      19,
      130,
      4,
      232,
      137,
      211,
      240,
      11,
      140,
      21,
      42,
      22,
      241,
      61,
      99,
      115,
      199,
      166,
      114,
      190,
      204,
      60,
      233,
      66,
      115,
      230,
      125,
      103,
      203,
      125,
      13,
      176,
      94,
      131,
      39,
      198,
      167,
      124,
      67,
      175,
      254,
      1,
      15,
      198,
      62,
      237,
      159,
      31,
      218,
      58,
      244,
      47,
      61,
      67,
      94,
      46,
      78,
      199,
      79,
      89,
      41,
      208,
      135,
      20,
      154,
      35,
      21,
      43,
      230,
      113,
      191,
      147,
      208,
      37,
      28,
      27,
      86,
      203,
      25,
      209,
      148,
      187,
      139,
      111,
      48,
      102,
      76,
      110,
      106,
      130,
      37,
      160,
      34,
      222,
      90,
      165,
      245,
      222,
      102,
      47,
      19,
      130,
      4,
      232,
      137,
      211,
      240,
      11,
      140,
      21
    ],
    B: [
      191,
      154,
      43,
      10,
      207,
      204,
      164,
      231,
      136,
      58,
      239,
      30,
      147,
      230,
      101,
      111,
      150,
      35,
      128,
      57,
      252,
      79,
      173,
      120,
      25,
      126,
      81,
      85,
      8,
      7,
      122,
      237,
      190,
      152,
      246,
      182,
      130,
      219,
      67,
      76,
      167,
      178,
      235,
      250,
      28,
      61,
      186,
      250,
      199,
      67,
      58,
      50,
      86,
      182,
      108,
      77,
      89,
      112,
      59,
      125,
      226,
      50,
      205,
      227,
      125,
      128,
      104,
      27,
      59,
      66,
      53,
      133,
      159,
      203,
      97,
      125,
      139,
      159,
      158,
      7,
      215,
      47,
      140,
      226,
      223,
      231,
      44,
      110,
      184,
      61,
      233,
      47,
      67,
      148,
      22,
      120,
      173,
      156,
      117,
      181,
      94,
      154,
      43,
      10,
      207,
      204,
      164,
      231,
      136,
      58,
      239,
      30,
      147,
      230,
      101,
      111,
      150,
      35,
      128,
      57,
      252,
      79,
      173,
      120,
      25,
      126,
      81,
      85,
      8,
      7,
      122,
      237,
      190,
      152,
      246,
      182,
      130,
      219,
      67,
      76,
      167,
      178,
      235,
      250,
      28,
      61,
      186,
      250,
      199,
      67,
      58,
      50,
      86,
      182,
      108,
      77,
      89,
      112,
      59,
      125,
      226,
      50,
      205,
      227,
      125,
      128,
      104,
      27,
      59,
      66,
      53,
      133,
      159,
      203,
      97,
      125,
      139,
      159,
      158,
      7,
      215,
      47,
      140,
      226,
      223,
      231,
      44,
      110,
      184,
      61,
      233,
      47,
      67,
      148,
      22,
      120,
      173,
      156,
      117,
      181,
      94,
      154,
      43,
      10,
      207,
      204,
      164,
      231,
      136,
      58,
      239,
      30,
      147,
      230,
      101,
      111,
      150,
      35,
      128,
      57,
      252,
      79,
      173,
      120,
      25,
      126,
      81,
      85,
      8,
      7,
      122,
      237,
      190,
      152,
      246,
      182,
      130,
      219,
      67,
      76,
      167,
      178,
      235,
      250,
      28,
      61,
      186,
      250,
      199,
      67,
      58,
      50,
      86,
      182,
      108,
      77
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      112,
      113,
      114,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      139,
      140,
      141,
      142,
      143,
      144,
      145,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      155,
      156,
      157,
      158,
      159,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ]
  }, gG = {
    R: [
      0,
      128,
      255
    ],
    G: [
      0,
      0,
      0
    ],
    B: [
      0,
      0,
      0
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, pG = {
    R: [
      192,
      224,
      255
    ],
    G: [
      1,
      128,
      255
    ],
    B: [
      0,
      0,
      0
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, mG = {
    R: [
      3,
      112,
      144,
      188,
      236,
      246,
      255
    ],
    G: [
      5,
      31,
      29,
      22,
      76,
      158,
      250
    ],
    B: [
      26,
      87,
      91,
      86,
      62,
      117,
      235
    ],
    A: [
      0,
      30,
      38,
      49,
      67,
      85,
      107
    ],
    I: [
      0,
      73,
      92,
      118,
      160,
      205,
      255
    ]
  }, vG = {
    R: [
      1,
      240,
      255
    ],
    G: [
      1,
      128,
      255
    ],
    B: [
      1,
      128,
      255
    ],
    A: [
      0,
      76,
      128
    ],
    I: [
      0,
      153,
      255
    ]
  }, yG = {
    R: [
      0,
      5,
      18,
      34,
      53,
      72,
      90,
      107,
      126,
      144,
      161,
      178,
      194,
      209,
      222,
      233,
      242,
      248,
      251,
      251,
      249,
      244,
      241,
      252
    ],
    G: [
      0,
      4,
      10,
      11,
      9,
      11,
      17,
      23,
      30,
      36,
      43,
      50,
      59,
      70,
      83,
      98,
      117,
      136,
      157,
      177,
      199,
      220,
      240,
      254
    ],
    B: [
      3,
      24,
      50,
      76,
      96,
      106,
      109,
      110,
      108,
      104,
      97,
      89,
      79,
      67,
      55,
      42,
      26,
      12,
      6,
      22,
      47,
      79,
      121,
      164
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      11,
      22,
      33,
      44,
      55,
      66,
      77,
      88,
      99,
      110,
      121,
      133,
      144,
      155,
      166,
      177,
      188,
      199,
      210,
      221,
      232,
      243,
      255
    ]
  }, xG = {
    R: [
      48,
      48,
      64,
      70,
      65,
      25,
      132,
      195,
      244,
      254,
      218,
      122
    ],
    G: [
      18,
      18,
      64,
      107,
      150,
      226,
      255,
      241,
      199,
      158,
      57,
      4
    ],
    B: [
      59,
      59,
      162,
      227,
      255,
      187,
      81,
      52,
      58,
      47,
      7,
      3
    ],
    A: [
      0,
      22,
      26,
      30,
      34,
      43,
      52,
      57,
      63,
      67,
      77,
      86
    ],
    I: [
      0,
      1,
      16,
      32,
      49,
      83,
      118,
      140,
      164,
      181,
      219,
      255
    ]
  }, wG = {
    R: [
      0,
      128,
      255
    ],
    G: [
      0,
      0,
      0
    ],
    B: [
      0,
      128,
      255
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, CG = {
    R: [
      68,
      49,
      53,
      253
    ],
    G: [
      1,
      104,
      183,
      231
    ],
    B: [
      84,
      142,
      121,
      37
    ],
    A: [
      0,
      56,
      80,
      88
    ],
    I: [
      0,
      64,
      192,
      255
    ]
  }, TG = {
    R: [
      255,
      255,
      255
    ],
    G: [
      127,
      196,
      254
    ],
    B: [
      0,
      0,
      0
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, SG = {
    R: [
      0,
      0,
      0
    ],
    G: [
      0,
      128,
      255
    ],
    B: [
      255,
      196,
      128
    ],
    A: [
      0,
      64,
      128
    ],
    I: [
      0,
      128,
      255
    ]
  }, AG = {
    R: [
      3,
      64,
      0,
      0,
      255,
      255,
      255
    ],
    G: [
      0,
      0,
      0,
      255,
      255,
      192,
      3
    ],
    B: [
      0,
      32,
      48,
      56,
      64,
      96,
      128
    ],
    A: [
      0,
      8,
      16,
      24,
      32,
      52,
      80
    ],
    I: [
      0,
      32,
      64,
      96,
      160,
      192,
      255
    ]
  }, EG = {
    min: 0,
    max: 0,
    R: [
      0,
      37
    ],
    G: [
      242,
      0
    ],
    B: [
      255,
      255
    ],
    A: [
      0,
      64
    ],
    I: [
      0,
      255
    ]
  }, bG = {
    R: [
      255,
      255
    ],
    G: [
      255,
      11
    ],
    B: [
      0,
      0
    ],
    A: [
      0,
      64
    ],
    I: [
      0,
      255
    ]
  }, DG = {
    min: 0,
    max: 0,
    R: [
      65,
      10,
      223,
      120,
      216,
      207,
      251,
      93,
      252,
      217,
      21,
      253,
      131,
      165,
      173,
      143,
      144,
      217,
      86,
      89,
      63,
      254,
      172,
      1,
      142,
      107,
      42,
      78,
      221,
      8,
      222,
      71,
      127,
      126,
      167,
      33,
      104,
      2,
      208,
      216,
      0,
      251,
      7,
      105,
      2,
      101,
      248,
      190,
      253,
      62,
      255,
      224,
      166,
      37,
      110,
      138,
      45,
      34,
      6,
      37,
      69,
      201,
      43,
      122,
      199,
      37,
      173,
      194,
      103,
      211,
      75,
      159,
      96,
      4,
      239,
      98,
      110,
      193,
      253,
      166,
      40,
      255,
      48,
      130,
      140,
      243,
      101,
      9,
      177,
      220,
      133,
      32,
      4,
      81,
      48,
      48,
      210,
      109,
      60,
      132,
      1,
      119,
      1,
      159,
      247,
      33,
      212,
      187,
      253,
      144,
      196,
      254,
      168,
      79,
      64,
      196,
      39,
      97,
      73,
      173,
      104,
      216,
      217,
      43,
      101,
      119,
      254,
      5,
      237,
      103,
      203,
      122,
      57,
      87,
      251,
      164,
      19,
      75,
      200,
      2,
      252,
      150,
      66,
      0,
      255,
      157,
      23,
      254,
      55,
      16,
      240,
      161,
      69,
      253,
      207,
      195,
      5,
      60,
      255,
      251,
      200,
      217,
      134,
      123,
      253,
      180,
      27,
      246,
      130,
      136,
      250,
      232,
      4,
      125,
      140,
      22,
      253,
      255,
      13,
      180,
      123,
      61,
      254,
      111,
      10,
      185,
      76,
      192,
      255,
      223,
      186,
      61,
      198,
      5,
      172,
      13,
      83,
      172,
      171,
      6,
      23,
      73,
      134,
      133,
      109,
      61,
      213,
      55,
      57,
      132,
      36,
      209,
      2,
      144,
      1,
      253,
      68,
      155,
      3,
      160,
      2,
      77,
      121,
      70,
      67,
      176,
      223,
      131,
      4,
      162,
      232,
      255,
      150,
      94,
      235,
      191,
      207,
      10,
      246,
      0,
      225,
      4,
      209,
      116,
      57,
      112,
      172,
      253,
      1,
      6,
      92,
      227,
      73,
      62,
      135,
      223
    ],
    G: [
      162,
      50,
      112,
      245,
      4,
      124,
      176,
      243,
      56,
      125,
      183,
      139,
      182,
      68,
      189,
      4,
      225,
      10,
      20,
      223,
      7,
      46,
      31,
      193,
      225,
      250,
      219,
      41,
      2,
      100,
      83,
      181,
      34,
      150,
      72,
      223,
      168,
      248,
      80,
      253,
      7,
      117,
      214,
      2,
      248,
      10,
      3,
      59,
      179,
      160,
      90,
      244,
      146,
      4,
      207,
      4,
      125,
      255,
      96,
      100,
      1,
      208,
      130,
      51,
      116,
      181,
      236,
      53,
      244,
      5,
      165,
      28,
      181,
      86,
      96,
      42,
      254,
      1,
      134,
      194,
      214,
      92,
      41,
      204,
      137,
      86,
      207,
      3,
      143,
      3,
      100,
      239,
      164,
      94,
      65,
      251,
      131,
      244,
      173,
      57,
      143,
      107,
      217,
      53,
      210,
      0,
      148,
      250,
      45,
      198,
      81,
      40,
      61,
      218,
      252,
      88,
      171,
      0,
      248,
      24,
      248,
      4,
      41,
      100,
      187,
      46,
      208,
      145,
      43,
      168,
      121,
      46,
      175,
      250,
      125,
      107,
      233,
      112,
      207,
      231,
      174,
      215,
      53,
      9,
      43,
      153,
      52,
      124,
      128,
      65,
      210,
      147,
      255,
      147,
      63,
      200,
      148,
      254,
      0,
      179,
      241,
      42,
      239,
      2,
      230,
      8,
      82,
      135,
      87,
      16,
      3,
      87,
      86,
      151,
      254,
      8,
      255,
      86,
      53,
      19,
      7,
      192,
      171,
      201,
      253,
      247,
      197,
      103,
      251,
      126,
      0,
      149,
      54,
      183,
      61,
      126,
      79,
      113,
      10,
      103,
      184,
      75,
      11,
      195,
      222,
      136,
      149,
      131,
      8,
      99,
      240,
      177,
      252,
      255,
      198,
      16,
      7,
      68,
      178,
      66,
      191,
      150,
      73,
      26,
      211,
      109,
      78,
      209,
      240,
      254,
      1,
      166,
      247,
      131,
      2,
      0,
      167,
      127,
      133,
      10,
      43,
      99,
      235,
      3,
      214,
      142,
      176,
      82,
      132,
      38,
      10,
      249,
      255,
      215,
      44,
      81
    ],
    B: [
      176,
      182,
      248,
      37,
      117,
      35,
      96,
      69,
      32,
      152,
      108,
      20,
      237,
      250,
      2,
      89,
      141,
      216,
      111,
      251,
      211,
      149,
      10,
      44,
      214,
      103,
      31,
      251,
      3,
      32,
      252,
      246,
      97,
      1,
      219,
      167,
      197,
      4,
      36,
      116,
      206,
      118,
      106,
      43,
      205,
      204,
      114,
      69,
      127,
      205,
      87,
      80,
      41,
      251,
      145,
      204,
      253,
      161,
      247,
      1,
      149,
      9,
      43,
      253,
      97,
      72,
      136,
      161,
      171,
      181,
      26,
      255,
      108,
      80,
      218,
      214,
      231,
      255,
      84,
      31,
      109,
      4,
      218,
      3,
      217,
      36,
      68,
      85,
      241,
      39,
      221,
      2,
      240,
      2,
      173,
      42,
      206,
      5,
      110,
      46,
      103,
      27,
      212,
      184,
      2,
      207,
      246,
      45,
      116,
      72,
      110,
      253,
      38,
      105,
      248,
      159,
      243,
      81,
      192,
      93,
      141,
      145,
      24,
      157,
      234,
      131,
      57,
      178,
      62,
      75,
      65,
      176,
      148,
      40,
      253,
      66,
      76,
      240,
      51,
      154,
      17,
      251,
      139,
      253,
      207,
      9,
      114,
      49,
      200,
      254,
      96,
      73,
      138,
      118,
      204,
      102,
      137,
      89,
      145,
      161,
      4,
      112,
      66,
      234,
      147,
      178,
      212,
      205,
      185,
      11,
      203,
      131,
      2,
      250,
      118,
      169,
      1,
      185,
      154,
      53,
      171,
      197,
      61,
      175,
      249,
      96,
      15,
      254,
      95,
      5,
      222,
      75,
      246,
      194,
      2,
      61,
      180,
      25,
      133,
      165,
      15,
      233,
      59,
      35,
      221,
      140,
      109,
      7,
      114,
      255,
      198,
      0,
      115,
      168,
      252,
      23,
      242,
      80,
      75,
      142,
      137,
      255,
      12,
      182,
      68,
      201,
      4,
      111,
      37,
      228,
      83,
      248,
      24,
      192,
      249,
      5,
      54,
      223,
      160,
      122,
      160,
      114,
      145,
      119,
      252,
      31,
      253,
      250,
      10,
      214,
      8,
      47,
      0,
      142,
      222,
      70
    ],
    A: [
      0,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64,
      64
    ],
    I: [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      112,
      113,
      114,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      139,
      140,
      141,
      142,
      143,
      144,
      145,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      155,
      156,
      157,
      158,
      159,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ]
  }, MG = class {
    constructor() {
      J(this, "gamma", 1), J(this, "version", 0.1), J(this, "cluts", {});
      const e = Object.keys(xg).filter((n) => !n.startsWith("$")).sort(new Intl.Collator("en").compare);
      for (const n of e) this.cluts[n] = xg[n];
    }
    addColormap(t, e) {
      this.cluts[t] = e;
    }
    colormaps() {
      return Object.keys(this.cluts);
    }
    colorMaps() {
      return this.colormaps();
    }
    colormapFromKey(t) {
      let e = this.cluts[t];
      return e !== void 0 || (e = this.cluts[t.toLowerCase()], e !== void 0) ? e : (t.length > 0 && ee.warn("No color map named " + t), {
        min: 0,
        max: 0,
        R: [
          0,
          255
        ],
        G: [
          0,
          255
        ],
        B: [
          0,
          255
        ],
        A: [
          0,
          255
        ],
        I: [
          0,
          255
        ]
      });
    }
    colormap(t = "", e = false) {
      const n = this.colormapFromKey(t);
      return this.makeLut(n.R, n.G, n.B, n.A, n.I, e);
    }
    makeLabelLut(t, e = 255) {
      if (t.R === void 0 || t.G === void 0 || t.B === void 0) throw new Error(`Invalid colormap table: ${t}`);
      const n = t.R.length, r = t.I ?? [
        ...Array(n).keys()
      ];
      if (n !== t.G.length || n !== t.B.length || n !== r.length) throw new Error(`colormap does not make sense: ${t} Rs ${t.R.length} Gs ${t.G.length} Bs ${t.B.length} Is ${r.length}`);
      let i = new Uint8ClampedArray(n).fill(e);
      i[0] = 0, t.A !== void 0 && (i = Uint8ClampedArray.from(t.A));
      const a = Math.min(...r), s = Math.max(...r), o = s - a + 1, l = new Uint8ClampedArray(o * 4).fill(0);
      for (let f = 0; f < n; f++) {
        let u = (r[f] - a) * 4;
        l[u++] = t.R[f], l[u++] = t.G[f], l[u++] = t.B[f], l[u++] = i[f];
      }
      const c = {
        lut: l,
        min: a,
        max: s
      };
      if (t.labels) {
        const f = t.labels.length;
        if (f === o) c.labels = t.labels;
        else if (f === n) {
          c.labels = Array(o).fill("?");
          for (let u = 0; u < n; u++) {
            const h = r[u];
            c.labels[h] = t.labels[u];
          }
        }
      }
      return c;
    }
    async makeLabelLutFromUrl(t) {
      const n = await (await fetch(t)).json();
      return this.makeLabelLut(n);
    }
    makeDrawLut(t) {
      let e = typeof t == "object" ? t : xg[t];
      e === void 0 && (ee.warn("colormap undefined ", t), e = this.colormapFromKey(""));
      const n = this.makeLabelLut(e, 255);
      if (n.labels === void 0 && (n.labels = []), n.labels.length < 256) {
        const s = n.labels.length;
        for (let o = s; o < 256; o++) n.labels.push(o.toString());
      }
      const r = new Uint8ClampedArray(256 * 4);
      let i = 0;
      for (let s = 0; s < 256; s++) r[i++] = 255, r[i++] = 0, r[i++] = 0, r[i++] = 255;
      r[3] = 0;
      const a = Math.min(n.lut.length, 256 * 4);
      if (a > 0) for (let s = 0; s < a; s++) r[s] = n.lut[s];
      return {
        lut: r,
        labels: n.labels
      };
    }
    makeLut(t, e, n, r, i, a) {
      const s = t.length, o = [
        ...t
      ], l = [
        ...e
      ], c = [
        ...n
      ];
      if (!i) {
        i = new Array(s);
        for (let g = 0; g < s; g++) i[g] = g / (s - 1) * 255;
      }
      r || (r = new Array(s).fill(64), r[0] = 0);
      let f = Uint8ClampedArray.from(r), u = Uint8ClampedArray.from(i);
      if (a) for (let g = 0; g < s; g++) o[g] = t[s - 1 - g], l[g] = e[s - 1 - g], c[g] = n[s - 1 - g], f[g] = 255 - r[s - 1 - g], u[g] = 255 - i[s - 1 - g];
      const h = new Uint8ClampedArray(256 * 4);
      if (typeof u > "u") {
        u = new Uint8ClampedArray(s).fill(0);
        for (let g = 0; g < s; g++) u[g] = Math.round(g * 255 / (s - 1));
      }
      typeof f > "u" && (f = new Uint8ClampedArray(s).fill(64), f[0] = 0);
      for (let g = 0; g < s - 1; g++) {
        const v = u[g];
        let m = u[g + 1];
        g === 0 && v !== 0 && ee.warn("colormap issue: indices expected to start with 0 not ", v), g === u.length - 2 && m !== 255 && (ee.warn("padding colormap: indices expected end with 255 not ", m), m = 255);
        const y = m - v;
        let w = v * 4;
        for (let C = v; C <= m; C++) {
          const T = (C - v) / y;
          h[w++] = o[g] + T * (o[g + 1] - o[g]), h[w++] = l[g] + T * (l[g + 1] - l[g]), h[w++] = c[g] + T * (c[g + 1] - c[g]), h[w++] = f[g] + T * (f[g + 1] - f[g]);
        }
      }
      if (this.gamma === 1) return h;
      for (let g = 0; g < 1020; g++) g % 4 !== 3 && (h[g] = Math.pow(h[g] / 255, 1 / this.gamma) * 255);
      return h;
    }
  }, Mn = new MG(), Ec = class {
    static getClusterBoundaryU8(t, e) {
      const n = new Array(t.length).fill(false), r = new Array(t.length).fill(false);
      for (let s = 0; s < t.length; s++) t[s] > 0 && (r[s] = true);
      const i = e.length / 3;
      let a = 0;
      for (let s = 0; s < i; s++) {
        const o = e[a], l = e[a + 1], c = e[a + 2];
        a += 3, !(r[o] === r[l] && r[o] === r[c] && r[l] === r[c]) && (n[o] = true, n[l] = true, n[c] = true);
      }
      return n;
    }
    static async gzip(t) {
      const e = new CompressionStream("gzip"), n = e.writable.getWriter();
      n.write(t).catch(console.error);
      const r = n.close().catch(console.error), i = new Response(e.readable), a = new Uint8Array(await i.arrayBuffer());
      return await r, a;
    }
    static createMZ3(t, e, n = false, r = null) {
      const a = r instanceof Uint8Array && r.length === t.length / 3 * 4, s = a ? 7 : 3, o = e.length / 3, l = t.length / 3, c = 0, f = 16, u = o * 3 * 4, h = l * 3 * 4, g = f + u + h, v = new ArrayBuffer(g), m = new DataView(v);
      m.setUint16(0, 23117, true), m.setUint16(2, s, true), m.setUint32(4, o, true), m.setUint32(8, l, true), m.setUint32(12, c, true);
      let y = f;
      if (new Uint32Array(v, y, e.length).set(e), y += u, new Float32Array(v, y, t.length).set(t), a && (y += h, new Uint8Array(v, y, r.length).set(r)), n) throw new Error("Call async createMZ3Async() for compression");
      return v;
    }
    static async createMZ3Async(t, e, n = false, r = null) {
      const i = this.createMZ3(t, e, n, r);
      return n ? await this.gzip(new Uint8Array(i)) : i;
    }
    static createOBJ(t, e) {
      let n = "";
      for (let a = 0; a < t.length; a += 3) n += `v ${t[a]} ${t[a + 1]} ${t[a + 2]}
`;
      for (let a = 0; a < e.length; a += 3) n += `f ${e[a] + 1} ${e[a + 1] + 1} ${e[a + 2] + 1}
`;
      return new TextEncoder().encode(n).buffer;
    }
    static createSTL(t, e) {
      const n = e.length / 3, r = 84 + n * 50, i = new ArrayBuffer(r), a = new DataView(i);
      for (let o = 0; o < 80; o++) a.setUint8(o, 0);
      a.setUint32(80, n, true);
      let s = 84;
      for (let o = 0; o < e.length; o += 3) {
        const l = e[o] * 3, c = e[o + 1] * 3, f = e[o + 2] * 3;
        a.setFloat32(s, 0, true), a.setFloat32(s + 4, 0, true), a.setFloat32(s + 8, 0, true), s += 12, a.setFloat32(s, t[l], true), a.setFloat32(s + 4, t[l + 1], true), a.setFloat32(s + 8, t[l + 2], true), s += 12, a.setFloat32(s, t[c], true), a.setFloat32(s + 4, t[c + 1], true), a.setFloat32(s + 8, t[c + 2], true), s += 12, a.setFloat32(s, t[f], true), a.setFloat32(s + 4, t[f + 1], true), a.setFloat32(s + 8, t[f + 2], true), s += 12, a.setUint16(s, 0, true), s += 2;
      }
      return i;
    }
    static downloadArrayBuffer(t, e) {
      const n = new Blob([
        t
      ], {
        type: "application/octet-stream"
      }), r = URL.createObjectURL(n), i = document.createElement("a");
      i.href = r, i.download = e, document.body.appendChild(i), i.style.display = "none", i.click(), setTimeout(() => {
        document.body.removeChild(i), URL.revokeObjectURL(r);
      }, 0);
    }
    static async saveMesh(t, e, n = ".mz3", r = false) {
      let i = new ArrayBuffer(0);
      return /\.obj$/i.test(n) ? i = this.createOBJ(t, e) : /\.stl$/i.test(n) ? i = this.createSTL(t, e) : (/\.mz3$/i.test(n) || (n += ".mz3"), i = await this.createMZ3Async(t, e, r)), n.length > 4 && this.downloadArrayBuffer(i, n), i;
    }
    static getClusterBoundary(t, e) {
      const n = new Uint32Array(t.buffer), r = new Array(n.length).fill(false), i = e.length / 3;
      let a = 0;
      for (let s = 0; s < i; s++) {
        const o = e[a], l = e[a + 1], c = e[a + 2];
        a += 3, !(n[o] === n[l] && n[o] === n[c] && n[l] === n[c]) && (r[o] = true, r[l] = true, r[c] = true);
      }
      return r;
    }
    static getExtents(t) {
      if (!ArrayBuffer.isView(t) && !Array.isArray(t) || t.length < 3) return {
        mxDx: 0,
        extentsMin: 0,
        extentsMax: 0
      };
      let e = 0;
      const n = Ue(t[0], t[1], t[2]), r = Ue(t[0], t[1], t[2]);
      for (let s = 0; s < t.length; s += 3) {
        const o = Ue(t[s], t[s + 1], t[s + 2]);
        e = Math.max(e, Pc(o)), z6(n, n, o), W6(r, r, o);
      }
      const i = [
        n[0],
        n[1],
        n[2]
      ], a = [
        r[0],
        r[1],
        r[2]
      ];
      return {
        mxDx: e,
        extentsMin: i,
        extentsMax: a
      };
    }
    static generateNormals(t, e) {
      const n = [];
      let r;
      const i = t.length;
      let a, s, o, l, c, f, u, h, g;
      const v = new Float32Array(i), m = e.length;
      for (r = 0; r < m; r += 3) {
        u = e[r] * 3, h = e[r + 1] * 3, g = e[r + 2] * 3;
        const y = [
          t[u],
          t[u + 1],
          t[u + 2]
        ], w = [
          t[h],
          t[h + 1],
          t[h + 2]
        ], C = [
          t[g],
          t[g + 1],
          t[g + 2]
        ];
        a = w[0] - y[0], s = w[1] - y[1], o = w[2] - y[2], l = C[0] - y[0], c = C[1] - y[1], f = C[2] - y[2], n[0] = c * o - f * s, n[1] = f * a - l * o, n[2] = l * s - c * a, v[u] += n[0], v[u + 1] += n[1], v[u + 2] += n[2], v[h] += n[0], v[h + 1] += n[1], v[h + 2] += n[2], v[g] += n[0], v[g + 1] += n[1], v[g + 2] += n[2];
      }
      for (r = 0; r < i; r += 3) {
        n[0] = -1 * v[r], n[1] = -1 * v[r + 1], n[2] = -1 * v[r + 2];
        let y = n[0] * n[0] + n[1] * n[1] + n[2] * n[2];
        y > 0 && (y = 1 / Math.sqrt(y), n[0] *= y, n[1] *= y, n[2] *= y), v[r] = n[0], v[r + 1] = n[1], v[r + 2] = n[2];
      }
      return v;
    }
  }, Dt, Xi, wg, _v, _1, JE = class {
    constructor(t) {
      l1(this, Dt), l1(this, Xi, 0), l1(this, wg, []), l1(this, _v, []), l1(this, _1), K0(this, Dt, new DataView(t)), this.read();
    }
    async extract(t) {
      const e = new Uint8Array(ht(this, Dt).buffer.slice(t.startsAt, t.startsAt + t.compressedSize));
      if (t.compressionMethod === 0) return e;
      if (t.compressionMethod === 8) {
        const n = new DecompressionStream("deflate-raw"), r = n.writable.getWriter();
        r.write(e).catch(console.error);
        const i = r.close().catch(console.error), a = new Response(n.readable), s = new Uint8Array(await a.arrayBuffer());
        return await i, s;
      }
      throw new Error(`Unsupported compression method: ${t.compressionMethod}`);
    }
    read() {
      for (; !ht(this, _1) && ht(this, Xi) < ht(this, Dt).byteLength; ) {
        const t = ht(this, Dt).getUint32(ht(this, Xi), true);
        if (t === 67324752) {
          const e = this.readLocalFile(ht(this, Xi));
          e.extract = this.extract.bind(this, e), ht(this, wg).push(e);
          const n = (e.generalPurpose & 8) !== 0;
          if (e.startsAt = ht(this, Xi) + 30 + e.fileNameLength + e.extraLength, e.compressedSize === 0 && n) {
            let r = e.startsAt;
            for (; r + 20 <= ht(this, Dt).byteLength; ) {
              if (ht(this, Dt).getUint32(r, true) === 134695760 && ht(this, Dt).getUint16(r + 16, true) === 19280) {
                r += 4;
                break;
              }
              r++;
            }
            e.crc = ht(this, Dt).getUint32(r, true), e.compressedSize = ht(this, Dt).getUint32(r + 4, true), e.uncompressedSize = ht(this, Dt).getUint32(r + 8, true), K0(this, Xi, r + 12);
          } else K0(this, Xi, e.startsAt + e.compressedSize);
        } else if (t === 33639248) {
          const e = this.readCentralDirectory(ht(this, Xi));
          ht(this, _v).push(e), K0(this, Xi, ht(this, Xi) + (46 + e.fileNameLength + e.extraLength + e.fileCommentLength));
        } else if (t === 101010256) {
          K0(this, _1, this.readEndCentralDirectory(ht(this, Xi)));
          break;
        } else if (t === 101075792) {
          K0(this, _1, this.readEndCentralDirectory64(ht(this, Xi)));
          break;
        } else {
          console.error(`Unexpected ZIP signature 0x${t.toString(16).padStart(8, "0")} at index ${ht(this, Xi)}`);
          break;
        }
      }
    }
    readLocalFile(t) {
      let e = ht(this, Dt).getUint32(t + 18, true), n = ht(this, Dt).getUint32(t + 22, true);
      const r = ht(this, Dt).getUint16(t + 26, true), i = ht(this, Dt).getUint16(t + 28, true), a = t + 30 + r;
      if (this.readString(a, i), e === 4294967295 && n === 4294967295) {
        let s = a, o = false;
        for (; s < a + i - 4; ) {
          const l = ht(this, Dt).getUint16(s, true), c = ht(this, Dt).getUint16(s + 2, true);
          if (s += 4, l === 1) if (c >= 16) {
            n = Number(ht(this, Dt).getBigUint64(s, true)), s += 8, e = Number(ht(this, Dt).getBigUint64(s, true)), o = true;
            break;
          } else throw new Error(`ZIP64 extra field found but is too small (expected at least 16 bytes, got ${c}).`);
          s += c;
        }
        if (!o) throw new Error("ZIP64 format missing extra field with signature 0x0001.");
      }
      return {
        signature: this.readString(t, 4),
        version: ht(this, Dt).getUint16(t + 4, true),
        generalPurpose: ht(this, Dt).getUint16(t + 6, true),
        compressionMethod: ht(this, Dt).getUint16(t + 8, true),
        lastModifiedTime: ht(this, Dt).getUint16(t + 10, true),
        lastModifiedDate: ht(this, Dt).getUint16(t + 12, true),
        crc: ht(this, Dt).getUint32(t + 14, true),
        compressedSize: e,
        uncompressedSize: n,
        fileNameLength: r,
        extraLength: i,
        fileName: this.readString(t + 30, r),
        extra: this.readString(t + 30 + r, i)
      };
    }
    readCentralDirectory(t) {
      return {
        versionCreated: ht(this, Dt).getUint16(t + 4, true),
        versionNeeded: ht(this, Dt).getUint16(t + 6, true),
        fileNameLength: ht(this, Dt).getUint16(t + 28, true),
        extraLength: ht(this, Dt).getUint16(t + 30, true),
        fileCommentLength: ht(this, Dt).getUint16(t + 32, true),
        diskNumber: ht(this, Dt).getUint16(t + 34, true),
        internalAttributes: ht(this, Dt).getUint16(t + 36, true),
        externalAttributes: ht(this, Dt).getUint32(t + 38, true),
        offset: ht(this, Dt).getUint32(t + 42, true),
        comments: this.readString(t + 46, ht(this, Dt).getUint16(t + 32, true))
      };
    }
    readEndCentralDirectory(t) {
      const e = ht(this, Dt).getUint16(t + 20, true);
      return {
        numberOfDisks: ht(this, Dt).getUint16(t + 4, true),
        centralDirectoryStartDisk: ht(this, Dt).getUint16(t + 6, true),
        numberCentralDirectoryRecordsOnThisDisk: ht(this, Dt).getUint16(t + 8, true),
        numberCentralDirectoryRecords: ht(this, Dt).getUint16(t + 10, true),
        centralDirectorySize: ht(this, Dt).getUint32(t + 12, true),
        centralDirectoryOffset: ht(this, Dt).getUint32(t + 16, true),
        commentLength: e,
        comment: this.readString(t + 22, e)
      };
    }
    readEndCentralDirectory64(t) {
      const e = Number(ht(this, Dt).getBigUint64(t + 0, true));
      return {
        numberOfDisks: ht(this, Dt).getUint32(t + 16, true),
        centralDirectoryStartDisk: ht(this, Dt).getUint32(t + 20, true),
        numberCentralDirectoryRecordsOnThisDisk: Number(ht(this, Dt).getBigUint64(t + 24, true)),
        numberCentralDirectoryRecords: Number(ht(this, Dt).getBigUint64(t + 32, true)),
        centralDirectorySize: Number(ht(this, Dt).getBigUint64(t + 40, true)),
        centralDirectoryOffset: Number(ht(this, Dt).getBigUint64(t + 48, true)),
        commentLength: e,
        comment: ""
      };
    }
    readString(t, e) {
      return Array.from({
        length: e
      }, (n, r) => String.fromCharCode(ht(this, Dt).getUint8(t + r))).join("");
    }
    get entries() {
      return ht(this, wg);
    }
  };
  Dt = /* @__PURE__ */ new WeakMap();
  Xi = /* @__PURE__ */ new WeakMap();
  wg = /* @__PURE__ */ new WeakMap();
  _v = /* @__PURE__ */ new WeakMap();
  _1 = /* @__PURE__ */ new WeakMap();
  var ft = class su {
    static arrayBufferToBase64(e) {
      const n = new Uint8Array(e);
      return su.uint8tob64(n);
    }
    static async decompress(e) {
      const n = e[0] === 31 && e[1] === 139 && e[2] === 8 ? "gzip" : e[0] === 120 && (e[1] === 1 || e[1] === 94 || e[1] === 156 || e[1] === 218) ? "deflate" : "deflate-raw", r = new DecompressionStream(n), i = r.writable.getWriter();
      i.write(e).catch(console.error);
      const a = i.close().catch(console.error), s = new Response(r.readable), o = new Uint8Array(await s.arrayBuffer());
      return await a, o;
    }
    static async decompressToBuffer(e) {
      const n = await su.decompress(e);
      return n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
    }
    static async readMatV4(e, n = false) {
      let r = e.byteLength;
      if (r < 40) throw new Error("File too small to be MAT v4: bytes = " + e.byteLength);
      let i = new DataView(e), a = i.getUint16(0, true), s = e;
      if (a === 35615 || a === 8075) {
        const v = await this.decompress(new Uint8Array(e));
        i = new DataView(v.buffer), a = i.getUint16(0, true), s = v.buffer, r = s.byteLength;
      }
      const o = new TextDecoder("utf-8"), l = new Uint8Array(s);
      let c = 0;
      const f = {};
      function u(v) {
        return Math.floor(v / 10) % 10;
      }
      function h(v, m, y) {
        const w = new Uint8Array(l.subarray(m, y));
        return v === 1 ? new Float32Array(w.buffer) : v === 2 ? new Int32Array(w.buffer) : v === 3 ? new Int16Array(w.buffer) : v === 4 ? new Uint16Array(w.buffer) : v === 5 ? new Uint8Array(w.buffer) : new Float64Array(w.buffer);
      }
      function g() {
        const v = i.getUint32(c, true), m = i.getUint32(c + 4, true), y = i.getUint32(c + 8, true), w = i.getUint32(c + 12, true), C = i.getUint32(c + 16, true);
        if (c += 20, w !== 0) throw new Error("Matlab V4 reader does not support imaginary numbers");
        const T = m * y;
        if (T < 1) throw new Error("mrows * ncols must be greater than one");
        const S = new Uint8Array(l.subarray(c, c + C));
        let E = o.decode(S).trim().replaceAll("\0", "");
        n && (E = E.replaceAll(".", "_"));
        const b = u(v);
        let D = 8;
        if (b >= 1 && b <= 2) D = 4;
        else if (b >= 3 && b <= 4) D = 2;
        else if (b === 5) D = 1;
        else if (b !== 0) throw new Error("impossible Matlab v4 datatype");
        if (c += C, v > 50) throw new Error("Does not appear to be little-endian V4 Matlab file");
        const R = c + T * D;
        f[E] = h(b, c, R), c = R;
      }
      for (; c + 20 < r; ) g();
      return f;
    }
    static b64toUint8(e) {
      const n = atob(e), r = n.length, i = new Uint8Array(r);
      for (let a = 0; a < r; a++) i[a] = n.charCodeAt(a);
      return i;
    }
    static uint8tob64(e) {
      let n = "";
      const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = e.byteLength, a = i % 3, s = i - a;
      let o, l, c, f, u;
      for (let h = 0; h < s; h = h + 3) u = e[h] << 16 | e[h + 1] << 8 | e[h + 2], o = (u & 16515072) >> 18, l = (u & 258048) >> 12, c = (u & 4032) >> 6, f = u & 63, n += r[o] + r[l] + r[c] + r[f];
      return a === 1 ? (u = e[s], o = (u & 252) >> 2, l = (u & 3) << 4, n += r[o] + r[l] + "==") : a === 2 && (u = e[s] << 8 | e[s + 1], o = (u & 64512) >> 10, l = (u & 1008) >> 4, c = (u & 15) << 2, n += r[o] + r[l] + r[c] + "="), n;
    }
    static download(e, n, r) {
      const i = document.createElement("a"), a = Array.isArray(e) ? e : [
        e
      ], s = new Blob(a, {
        type: r
      });
      i.href = URL.createObjectURL(s), i.download = n, i.click();
    }
    static readFileAsync(e) {
      return new Promise((n, r) => {
        const i = new FileReader();
        i.onload = () => {
          n(i.result);
        }, i.onerror = r, i.readAsArrayBuffer(e);
      });
    }
    static blobToBase64(e) {
      return new Promise((n) => {
        const r = new FileReader();
        r.onloadend = () => n(r.result), r.readAsDataURL(e);
      });
    }
    static async decompressBase64String(e) {
      const n = atob(e), r = new ArrayBuffer(n.length), i = new Uint8Array(r);
      for (let a = 0; a < n.length; a++) i[a] = n.charCodeAt(a);
      return su.decompressArrayBuffer(i);
    }
    static async compressToBase64String(e) {
      const n = await su.compressStringToArrayBuffer(e);
      return su.uint8tob64(new Uint8Array(n));
    }
    static strToU8(e, n) {
      if (n) {
        const l = new Uint8Array(e.length);
        for (let c = 0; c < e.length; ++c) l[c] = e.charCodeAt(c);
        return l;
      }
      const r = e.length, i = (l, c, f) => ((f == null || f > l.length) && (f = l.length), new Uint8Array(l.subarray(c, f)));
      let a = new Uint8Array(e.length + (e.length >> 1)), s = 0;
      const o = (l) => {
        a[s++] = l;
      };
      for (let l = 0; l < r; ++l) {
        if (s + 5 > a.length) {
          const f = new Uint8Array(s + 8 + (r - l << 1));
          f.set(a), a = f;
        }
        let c = e.charCodeAt(l);
        c < 128 || n ? o(c) : c < 2048 ? (o(192 | c >> 6), o(128 | c & 63)) : (c > 55295 && c < 57344, c = 65536 + (c & 1047552) | e.charCodeAt(++l) & 1023, o(240 | c >> 18), o(128 | c >> 12 & 63), o(128 | c >> 6 & 63), o(128 | c & 63));
      }
      return i(a, 0, s);
    }
    static async compress(e, n = "gzip") {
      const r = new CompressionStream(n), i = r.writable.getWriter();
      i.write(e).catch(console.error);
      const a = i.close().catch(console.error), o = await new Response(r.readable).arrayBuffer();
      return await a, o;
    }
    static async compressStringToArrayBuffer(e) {
      const n = this.strToU8(e);
      return await this.compress(n);
    }
    static isArrayBufferCompressed(e) {
      if (e && e.byteLength) {
        const n = new Uint8Array(e);
        return (n[0] << 8 | n[1]) === 8075;
      } else return false;
    }
    static strFromU8(e, n) {
      if (n) {
        let r = "";
        for (let i = 0; i < e.length; i += 16384) r += String.fromCharCode.apply(null, e.subarray(i, i + 16384));
        return r;
      } else {
        const r = (o, l, c) => ((l == null || l < 0) && (l = 0), (c == null || c > o.length) && (c = o.length), new Uint8Array(o.subarray(l, c))), i = (o) => {
          for (let l = "", c = 0; ; ) {
            let f = o[c++];
            const u = (f > 127) + (f > 223) + (f > 239);
            if (c + u > o.length) return {
              s: l,
              r: r(o, c - 1)
            };
            u ? u === 3 ? (f = ((f & 15) << 18 | (o[c++] & 63) << 12 | (o[c++] & 63) << 6 | o[c++] & 63) - 65536, l += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023)) : u & 1 ? l += String.fromCharCode((f & 31) << 6 | o[c++] & 63) : l += String.fromCharCode((f & 15) << 12 | (o[c++] & 63) << 6 | o[c++] & 63) : l += String.fromCharCode(f);
          }
        }, { s: a, r: s } = i(e);
        if (s.length) throw new Error("Unexpected trailing bytes in UTF-8 decoding");
        return a;
      }
    }
    static async decompressArrayBuffer(e) {
      const n = await this.decompress(new Uint8Array(e));
      return this.strFromU8(n);
    }
    static arraysAreEqual(e, n) {
      return U_(e, n);
    }
    static range(e, n, r) {
      return Array.from({
        length: (n - e) / r + 1
      }, (i, a) => e + a * r);
    }
    static sph2cartDeg(e, n) {
      const r = -n * (Math.PI / 180), i = (e - 90) % 360 * (Math.PI / 180), a = [
        Math.cos(r) * Math.cos(i),
        Math.cos(r) * Math.sin(i),
        Math.sin(r)
      ], s = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      return s <= 0 || (a[0] /= s, a[1] /= s, a[2] /= s), a;
    }
    static vox2mm(e, n) {
      const r = Tr(n);
      _i(r, r);
      const i = zn(e[0], e[1], e[2], 1);
      return Zr(i, i, r), Ue(i[0], i[1], i[2]);
    }
  }, c1 = ee, Qn = class qr {
    static readTRACT(e) {
      const n = e.byteLength;
      if (n < 20) throw new Error("File too small to be niml.tract: bytes = " + n);
      const r = new DataView(e), i = new Uint8Array(e);
      let a = 0;
      function s() {
        for (; a < n && i[a] !== 60; ) a++;
        const m = a;
        for (; a < n && i[a] !== 62; ) a++;
        return a++, a - m < 1 ? "" : new TextDecoder().decode(e.slice(m, a - 1)).trim();
      }
      let o = s();
      function l(m) {
        const y = o.indexOf(m);
        if (y < 0) return 0;
        const w = o.indexOf('"', y) + 1, C = o.indexOf('"', w), T = o.slice(w, C);
        return parseInt(T);
      }
      const c = l("N_tracts=");
      (!o.startsWith("<network") || c < 1) && ee.warn("This is not a valid niml.tract file " + o);
      let f = 0;
      const u = [];
      u.push(f);
      const h = [], g = [];
      for (let m = 0; m < c; m++) {
        o = s();
        const y = l("ni_dimen="), w = l("Bundle_Tag="), C = o.includes("binary.lsbfirst");
        for (let T = 0; T < y; T++) {
          a += 4;
          const S = r.getUint32(a, C) / 3;
          a += 4;
          for (let E = 0; E < S; E++) h.push(r.getFloat32(a, C)), a += 4, h.push(-r.getFloat32(a, C)), a += 4, h.push(r.getFloat32(a, C)), a += 4;
          f += S, u.push(f), g.push(w);
        }
        o = s();
      }
      const v = [];
      return v.push({
        id: "tract",
        vals: Float32Array.from(g)
      }), {
        pts: new Float32Array(h),
        offsetPt0: new Uint32Array(u),
        dps: v
      };
    }
    static async readTT(e) {
      let n = new Uint32Array(0), r = new Float32Array(0);
      const i = await ft.readMatV4(e);
      if (!("trans_to_mni" in i)) throw new Error("TT format file must have 'trans_to_mni'");
      if (!("voxel_size" in i)) throw new Error("TT format file must have 'voxel_size'");
      if (!("track" in i)) throw new Error("TT format file must have 'track'");
      let a = Yt();
      const s = i.trans_to_mni;
      a = Qi(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]), _i(a, a);
      function o(l) {
        const c = new DataView(l.buffer), f = [];
        let u = 0, h = 0;
        for (; h < l.length; ) {
          f.push(h);
          const m = c.getUint32(h, true);
          h = h + m + 13, u += m;
        }
        n = new Uint32Array(f.length + 1), r = new Float32Array(u);
        let g = 0;
        for (let m = 0; m < f.length; m++) {
          n[m] = g / 3;
          let y = f[m];
          const w = c.getUint32(y, true) / 3;
          let C = c.getInt32(y + 4, true), T = c.getInt32(y + 8, true), S = c.getInt32(y + 12, true);
          y += 16, r[g++] = C, r[g++] = T, r[g++] = S;
          for (let E = 2; E <= w; E++) C = C + c.getInt8(y++), T = T + c.getInt8(y++), S = S + c.getInt8(y++), r[g++] = C, r[g++] = T, r[g++] = S;
        }
        for (let m = 0; m < g; m++) r[m] = r[m] / 32;
        let v = 0;
        for (let m = 0; m < g / 3; m++) {
          const y = zn(r[v], r[v + 1], r[v + 2], 1);
          Zr(y, y, a), r[v++] = y[0], r[v++] = y[1], r[v++] = y[2];
        }
        n[f.length] = g / 3;
      }
      return o(i.track), {
        pts: r,
        offsetPt0: n
      };
    }
    static async readTRX(e) {
      function n(g) {
        const v = (g & 31744) >> 10, m = g & 1023;
        return (g >> 15 ? -1 : 1) * (v ? v === 31 ? m ? NaN : 1 / 0 : Math.pow(2, v - 15) * (1 + m / 1024) : 6103515625e-14 * (m / 1024));
      }
      let r = 0, i = 0, a = new Float32Array([]);
      const s = [], o = [], l = [], c = [];
      let f = [], u = false;
      const h = new JE(e);
      for (let g = 0; g < h.entries.length; g++) {
        const v = h.entries[g];
        if (v.uncompressedSize === 0) continue;
        const m = v.fileName.split("/"), y = m.slice(-1)[0];
        if (y.startsWith(".")) continue;
        const w = m.slice(-2)[0], C = y.split(".")[0], T = await v.extract();
        if (y.includes("header.json")) {
          const b = new TextDecoder().decode(T);
          f = JSON.parse(b);
          continue;
        }
        let S = 0, E = [];
        if (y.endsWith(".uint64") || y.endsWith(".int64")) {
          S = T.length / 8, E = new Uint32Array(S);
          const b = new Uint32Array(T.buffer);
          let D = 0;
          for (let R = 0; R < S; R++) E[R] = b[D], b[D + 1] !== 0 && (u = true), D += 2;
        } else if (y.endsWith(".uint32")) E = new Uint32Array(T.buffer);
        else if (y.endsWith(".uint16")) E = new Uint16Array(T.buffer);
        else if (y.endsWith(".uint8")) E = new Uint8Array(T.buffer);
        else if (y.endsWith(".int32")) E = new Int32Array(T.buffer);
        else if (y.endsWith(".int16")) E = new Int16Array(T.buffer);
        else if (y.endsWith(".int8")) E = new Int8Array(T.buffer);
        else if (y.endsWith(".float64")) E = new Float64Array(T.buffer);
        else if (y.endsWith(".float32")) E = new Float32Array(T.buffer);
        else if (y.endsWith(".float16")) {
          S = T.length / 2, E = new Float32Array(S);
          const b = new Uint16Array(T.buffer), D = new Float32Array(65536);
          for (let R = 0; R < 65536; R++) D[R] = n(R);
          for (let R = 0; R < S; R++) E[R] = D[b[R]];
        } else continue;
        if (S = E.length, w.includes("groups")) {
          o.push({
            id: C,
            vals: Float32Array.from(E.slice())
          });
          continue;
        }
        if (w.includes("dpv")) {
          c.push({
            id: C,
            vals: Float32Array.from(E.slice())
          });
          continue;
        }
        if (w.includes("dps")) {
          l.push({
            id: C,
            vals: Float32Array.from(E.slice())
          });
          continue;
        }
        if (y.startsWith("offsets.")) {
          r = S;
          for (let b = 0; b < S; b++) s[b] = E[b];
        }
        y.startsWith("positions.3.") && (i = S, a = new Float32Array(E));
      }
      if (r === 0 || i === 0) throw new Error("Failure reading TRX format (no offsets or points).");
      if (u) throw new Error("Too many vertices: JavaScript does not support 64 bit integers");
      return s[r] = i / 3, {
        pts: a,
        offsetPt0: new Uint32Array(s),
        dpg: o,
        dps: l,
        dpv: c,
        header: f
      };
    }
    static readTSF(e, n = 0) {
      const r = new Float32Array(n), i = e.byteLength;
      if (i < 20) throw new Error("File too small to be TSF: bytes = " + i);
      const a = new Uint8Array(e);
      let s = 0;
      function o() {
        for (; s < i && a[s] === 10; ) s++;
        const h = s;
        for (; s < i && a[s] !== 10; ) s++;
        return s++, s - h < 1 ? "" : new TextDecoder().decode(e.slice(h, s - 1));
      }
      let l = o();
      if (!l.includes("mrtrix track scalars")) throw new Error("Not a valid TSF file");
      let c = -1;
      for (; s < i && !l.includes("END"); ) if (l = o(), l.toLowerCase().startsWith("file:") && (c = parseInt(l.split(" ").pop())), l.toLowerCase().startsWith("datatype:") && !l.endsWith("Float32LE")) throw new Error("Only supports TSF files with Float32LE");
      if (c < 20) throw new Error("Not a valid TSF file (missing file offset)");
      s = c;
      const f = new DataView(e);
      let u = 0;
      for (; s + 4 <= i && u < n; ) {
        const h = f.getFloat32(s, true);
        if (s += 4, isFinite(h)) r[u++] = h;
        else if (!isNaN(h)) break;
      }
      return r;
    }
    static readTCK(e) {
      const n = e.byteLength;
      if (n < 20) throw new Error("File too small to be TCK: bytes = " + n);
      const r = new Uint8Array(e);
      let i = 0;
      function a() {
        for (; i < n && r[i] === 10; ) i++;
        const v = i;
        for (; i < n && r[i] !== 10; ) i++;
        return i++, i - v < 1 ? "" : new TextDecoder().decode(e.slice(v, i - 1));
      }
      let s = a();
      if (!s.includes("mrtrix tracks")) throw new Error("Not a valid TCK file");
      let o = -1;
      for (; i < n && !s.includes("END"); ) s = a(), s.toLowerCase().startsWith("file:") && (o = parseInt(s.split(" ").pop()));
      if (o < 20) throw new Error("Not a valid TCK file (missing file offset)");
      i = o;
      const l = new DataView(e);
      let c = 0, f = new Uint32Array(n / 16), u = 0, h = 0, g = new Float32Array(n / 4);
      for (f[0] = 0; i + 12 < n; ) {
        const v = l.getFloat32(i, true);
        i += 4;
        const m = l.getFloat32(i, true);
        i += 4;
        const y = l.getFloat32(i, true);
        if (i += 4, isFinite(v)) g[h++] = v, g[h++] = m, g[h++] = y, c++;
        else if (f[u++] = c, !isNaN(v)) break;
      }
      return g = g.slice(0, h), f = f.slice(0, u), {
        pts: g,
        offsetPt0: f
      };
    }
    static async readTRK(e) {
      let n = new DataView(e), r = n.getUint32(0, true);
      if (r !== 1128354388) {
        let L;
        if (r === 4247762216) throw new Error("zstd TRK decompression is not supported");
        L = await ft.decompress(new Uint8Array(e)), e = L.buffer, n = new DataView(e), r = n.getUint32(0, true);
      }
      const i = n.getUint32(992, true), a = n.getUint32(996, true);
      if (i > 2 || a !== 1e3 || r !== 1128354388) throw new Error("Not a valid TRK file");
      const s = n.getInt16(36, true), o = [];
      for (let L = 0; L < s; L++) {
        const N = new Uint8Array(e.slice(38 + L * 20, 58 + L * 20)), F = new TextDecoder().decode(N).split("\0").shift();
        o.push({
          id: F.trim(),
          vals: []
        });
      }
      const l = n.getFloat32(12, true), c = n.getFloat32(16, true), f = n.getFloat32(20, true), u = Qi(1 / l, 0, 0, -0.5, 0, 1 / c, 0, -0.5, 0, 0, 1 / f, -0.5, 0, 0, 0, 1), h = n.getInt16(238, true), g = [];
      for (let L = 0; L < h; L++) {
        const N = new Uint8Array(e.slice(240 + L * 20, 260 + L * 20)), F = new TextDecoder().decode(N).split("\0").shift();
        g.push({
          id: F.trim(),
          vals: []
        });
      }
      const v = Yt();
      for (let L = 0; L < 16; L++) v[L] = n.getFloat32(440 + L * 4, true);
      v[15] === 0 && (ee.warn("TRK vox_to_ras not set"), Jg(v));
      const m = Yt();
      ME(m, u, v);
      let y = null, w = null;
      y = new Int32Array(e.slice(a)), w = new Float32Array(y.buffer);
      const C = y.length;
      if (C < 1) throw new Error("Empty TRK file.");
      let T = 0, S = 0, E = new Uint32Array(y.length / 4), b = 0, D = new Float32Array(y.length), R = 0;
      for (; T < C; ) {
        const L = y[T];
        T = T + 1, E[b++] = S;
        for (let N = 0; N < L; N++) {
          const F = w[T + 0], V = w[T + 1], k = w[T + 2];
          if (T += 3, D[R++] = F * m[0] + V * m[1] + k * m[2] + m[3], D[R++] = F * m[4] + V * m[5] + k * m[6] + m[7], D[R++] = F * m[8] + V * m[9] + k * m[10] + m[11], s > 0) for (let _ = 0; _ < s; _++) o[_].vals.push(w[T]), T++;
          S++;
        }
        if (h > 0) for (let N = 0; N < h; N++) g[N].vals.push(w[T]), T++;
      }
      const I = [];
      for (let L = 0; L < g.length; L++) I.push({
        id: g[L].id,
        vals: Float32Array.from(g[L].vals)
      });
      const O = [];
      for (let L = 0; L < o.length; L++) O.push({
        id: o[L].id,
        vals: Float32Array.from(o[L].vals)
      });
      return E[b++] = S, D = D.slice(0, R), E = E.slice(0, b), {
        pts: D,
        offsetPt0: E,
        dps: I,
        dpv: O
      };
    }
    static readTxtVTK(e) {
      const i = new TextDecoder("utf-8").decode(e).split(`
`);
      if (i.length < 7 || !i[0].startsWith("# vtk DataFile")) throw new Error("Invalid VTK image");
      if (!i[2].startsWith("ASCII")) throw new Error("Not ASCII VTK mesh");
      let s = 3;
      for (; i[s].length < 1; ) s++;
      if (!i[s].includes("POLYDATA")) throw new Error("Not ASCII VTK polydata");
      for (s++; i[s].length < 1; ) s++;
      if (!i[s].startsWith("POINTS")) throw new Error("Not VTK POINTS");
      let o = i[s].trim().split(/\s+/);
      const l = parseInt(o[1]), c = l * 3, f = new Float32Array(l * 3);
      let u = 0;
      for (; u < l * 3; ) {
        s++;
        const m = i[s].trim().trim().split(/\s+/);
        for (let y = 0; y < m.length && !(u >= c); y++) f[u] = parseFloat(m[y]), u++;
      }
      const h = [];
      for (s++; i[s].length < 1; ) s++;
      if (i[s].startsWith("METADATA")) {
        for (; i[s].length > 1; ) s++;
        s++;
      }
      if (o = i[s].trim().split(/\s+/), s++, o[0].includes("LINES")) {
        const v = parseInt(o[1]);
        if (v < 1) throw new Error("Corrupted VTK ASCII");
        let m = i[s].trim();
        const y = [];
        let w = [];
        if (m.startsWith("OFFSETS")) {
          s++;
          let C = 0;
          for (; C < v; ) {
            m = i[s].trim(), s++;
            const T = m.trim().split(/\s+/);
            for (let S = 0; S < T.length && (y[C] = parseInt(T[S]), C++, !(C >= v)); S++) ;
          }
          w = Array.from(f);
        } else {
          let C = function() {
            m = i[s].trim();
            const b = m.trim().split(/\s+/);
            S = [];
            for (let D = 0; D < b.length; D++) S.push(parseInt(b[D]));
            E = 0, s++;
          }, T = 0;
          y[0] = 0;
          let S = [], E = 0;
          C();
          for (let b = 0; b < v; b++) {
            E >= S.length && C();
            const D = S[E++];
            T += D, y[b + 1] = T;
            for (let R = 0; R < D; R++) {
              E >= S.length && C();
              const I = S[E++] * 3;
              w.push(f[I + 0]), w.push(f[I + 1]), w.push(f[I + 2]);
            }
          }
        }
        return {
          pts: Float32Array.from(w),
          offsetPt0: Uint32Array.from(y)
        };
      } else if (o[0].includes("TRIANGLE_STRIPS")) {
        const v = parseInt(o[1]);
        for (let m = 0; m < v; m++) {
          const y = i[s].trim();
          s++;
          const w = y.trim().split(/\s+/), C = parseInt(w[0]) - 2;
          let T = 1;
          for (let S = 0; S < C; S++) S % 2 ? (h.push(parseInt(w[T + 2])), h.push(parseInt(w[T + 1])), h.push(parseInt(w[T]))) : (h.push(parseInt(w[T])), h.push(parseInt(w[T + 1])), h.push(parseInt(w[T + 2]))), T += 1;
        }
      } else if (o[0].includes("POLYGONS")) {
        const v = parseInt(o[1]);
        for (let m = 0; m < v; m++) {
          const y = i[s].trim();
          s++;
          const w = y.trim().split(/\s+/), C = parseInt(w[0]) - 2, T = parseInt(w[1]);
          let S = parseInt(w[2]);
          for (let E = 0; E < C; E++) {
            const b = parseInt(w[3 + E]);
            h.push(T), h.push(S), h.push(b), S = b;
          }
        }
      } else throw new Error("Unsupported ASCII VTK datatype " + o[0]);
      const g = new Uint32Array(h);
      return {
        positions: f,
        indices: g
      };
    }
    static async readLayer(e = "", n, r, i = 0.5, a = "warm", s = "winter", o = false, l = null, c = null, f = 0) {
      const u = {
        ...kG,
        colormapInvert: false,
        colormapType: 0,
        isTransparentBelowCalMin: true,
        isAdditiveBlend: false,
        colorbarVisible: true,
        colormapLabel: null
      }, h = /(?:\.([^.]+))?$/;
      let g = h.exec(e)[1];
      g = g.toUpperCase(), g === "GZ" && (g = h.exec(e.slice(0, -3))[1], g = g.toUpperCase());
      const v = r.vertexCount / 3;
      if (r.offsetPt0) {
        if (g !== "TSF") throw new Error("readLayer for streamlines only supports TSF files.");
        const w = r.pts.length / 3, C = e.split("/");
        let T = "Unknown";
        C.length > 1 && C.pop() && (T = T.split(".").slice(0, -1).join("."));
        const S = qr.readTSF(n, w);
        r.dpv || (r.dpv = []);
        const E = S.reduce((D, R) => Math.min(D, R)), b = S.reduce((D, R) => Math.max(D, R));
        return r.dpv.push({
          id: T,
          vals: Float32Array.from(S.slice()),
          global_min: E,
          global_max: b,
          cal_min: E,
          cal_max: b
        }), u;
      }
      if (v < 3) {
        ee.error("n_vert < 3 in layer");
        return;
      }
      if (g === "MZ3") {
        const w = await qr.readMZ3(n, v);
        u.values = w.scalars, "colormapLabel" in w && (u.colormapLabel = w.colormapLabel);
      } else if (g === "ANNOT") {
        const w = qr.readANNOT(n, v, true);
        w instanceof Uint32Array ? u.values = w : (u.values = w.scalars, u.colormapLabel = w.colormapLabel);
      } else if (g === "CRV" || g === "CURV" || g === "THICKNESS" || g === "AREA") u.values = qr.readCURV(n, v), u.isTransparentBelowCalMin = false;
      else if (g === "GII") {
        const w = await qr.readGII(n, v);
        u.values = w.scalars, u.colormapLabel = w.colormapLabel;
      } else if (g === "MGH" || g === "MGZ") {
        const w = await qr.readMGH(n, v, true);
        "scalars" in w ? (u.values = w.scalars, u.colormapLabel = w.colormapLabel) : u.values = w;
      } else if (g === "NII") u.values = await qr.readNII(n, v, r.anatomicalStructurePrimary);
      else if (g === "SMP") u.values = await qr.readSMP(n, v);
      else if (g === "STC") u.values = qr.readSTC(n, v);
      else if (qr.isCurv(n)) u.values = qr.readCURV(n, v), u.isTransparentBelowCalMin = false;
      else return ee.warn("Unknown layer overlay format " + e), u;
      if (!u.values) {
        ee.error("no values in layer");
        return;
      }
      u.nFrame4D = u.values.length / v, u.frame4D = 0, u.outlineBorder = f;
      let m = u.values[0], y = u.values[0];
      for (let w = 0; w < u.values.length; w++) m = Math.min(m, u.values[w]), y = Math.max(y, u.values[w]);
      return u.global_min = m, u.global_max = y, u.cal_min = l || 0, l || (u.cal_min = m), u.cal_max = c || 0, c || (u.cal_max = y), u.cal_minNeg = NaN, u.cal_maxNeg = NaN, u.opacity = i, u.colormap = a, u.colormapNegative = s, u.useNegativeCmap = o, u;
    }
    static async readSMP(e, n) {
      const r = e.byteLength;
      let i = new DataView(e), a = i.getUint16(0, true);
      if (a > 5) {
        const u = await ft.decompress(new Uint8Array(e));
        i = new DataView(u.buffer), a = i.getUint16(0, true), e = u.buffer;
      }
      a > 5 && ee.error("Unsupported or invalid BrainVoyager SMP version " + a);
      const s = i.getUint32(2, true);
      s !== n && ee.error("SMP file has " + s + " vertices, background mesh has " + n);
      const o = i.getUint16(6, true), l = new Float32Array(s * o);
      let c = 9;
      function f() {
        const u = c;
        for (; c < r && i.getUint8(c) !== 0; ) c++;
        return c++, new TextDecoder().decode(e.slice(u, c - 1));
      }
      f();
      for (let u = 0; u < o; u++) {
        const h = {};
        h.mapType = i.getUint32(c, true), c += 4, a >= 3 && h.mapType === 3 && (h.nLags = i.getUint32(c, true), c += 4, h.mnLag = i.getUint32(c, true), c += 4, h.mxLag = i.getUint32(c, true), c += 4, h.ccOverlay = i.getUint32(c, true), c += 4), h.clusterSize = i.getUint32(c, true), c += 4, h.clusterCheck = i.getUint8(c), c += 1, h.critThresh = i.getFloat32(c, true), c += 4, h.maxThresh = i.getFloat32(c, true), c += 4, a >= 4 && (h.includeValuesGreaterThreshMax = i.getUint32(c, true), c += 4), h.df1 = i.getUint32(c, true), c += 4, h.df2 = i.getUint32(c, true), c += 4, a >= 5 ? (h.posNegFlag = i.getUint32(c, true), c += 4) : h.posNegFlag = 3, h.cortexBonferroni = i.getUint32(c, true), c += 4, h.posMinRGB = [
          0,
          0,
          0
        ], h.posMaxRGB = [
          0,
          0,
          0
        ], h.negMinRGB = [
          0,
          0,
          0
        ], h.negMaxRGB = [
          0,
          0,
          0
        ], a >= 2 && (h.posMinRGB[0] = i.getUint8(c), c++, h.posMinRGB[1] = i.getUint8(c), c++, h.posMinRGB[2] = i.getUint8(c), c++, h.posMaxRGB[0] = i.getUint8(c), c++, h.posMaxRGB[1] = i.getUint8(c), c++, h.posMaxRGB[2] = i.getUint8(c), c++, a >= 4 && (h.negMinRGB[0] = i.getUint8(c), c++, h.negMinRGB[1] = i.getUint8(c), c++, h.negMinRGB[2] = i.getUint8(c), c++, h.negMaxRGB[0] = i.getUint8(c), c++, h.negMaxRGB[1] = i.getUint8(c), c++, h.negMaxRGB[2] = i.getUint8(c), c++), h.enableSMPColor = i.getUint8(c), c++, a >= 4 && (h.lut = f()), h.colorAlpha = i.getFloat32(c, true), c += 4), h.name = f();
        const g = new Float32Array(e, c, s);
        l.set(g, u * s), c += s * 4;
      }
      return l;
    }
    static readSTC(e, n) {
      const r = new DataView(e), i = r.getInt32(8, false);
      if (i !== n) throw new Error("Overlay has " + i + " vertices, expected " + n);
      let a = 12 + i * 4;
      const s = r.getUint32(a, false);
      a += 4;
      const o = new Float32Array(s * i);
      for (let l = 0; l < s * i; l++) o[l] = r.getFloat32(a, false), a += 4;
      return o;
    }
    static isCurv(e) {
      const n = new DataView(e), r = n.getUint8(0), i = n.getUint8(1), a = n.getUint8(2);
      return r !== 255 || i !== 255 || a !== 255 ? (c1.debug("Unable to recognize file type: does not appear to be FreeSurfer format."), false) : true;
    }
    static readCURV(e, n) {
      const r = new DataView(e), i = r.getUint8(0), a = r.getUint8(1), s = r.getUint8(2), o = r.getUint32(3, false), l = r.getUint32(11, false);
      if ((i !== 255 || a !== 255 || s !== 255) && c1.debug("Unable to recognize file type: does not appear to be FreeSurfer format."), n !== o) throw new Error("CURV file has different number of vertices ( " + o + ")than mesh (" + n + ")");
      if (e.byteLength < 15 + 4 * o * l) throw new Error("CURV file smaller than specified");
      const c = new Float32Array(l * o);
      let f = 15;
      for (let v = 0; v < l * o; v++) c[v] = r.getFloat32(f, false), f += 4;
      let u = c[0], h = c[0];
      for (let v = 0; v < c.length; v++) u = Math.min(u, c[v]), h = Math.max(h, c[v]);
      const g = 1 / (h - u);
      for (let v = 0; v < c.length; v++) c[v] = 1 - (c[v] - u) * g;
      return c;
    }
    static readANNOT(e, n, r = false) {
      const i = new DataView(e), a = i.getUint32(0, false), s = this.decimateLayerVertices(a, n);
      if (n !== s) throw new Error("ANNOT file has different number of vertices than mesh");
      if (e.byteLength < 4 + 8 * a) throw new Error("ANNOT file smaller than specified");
      let o = 0;
      const l = new Uint32Array(a);
      for (let T = 0; T < a; T++) {
        const S = i.getUint32(o += 4, false);
        l[S] = i.getUint32(o += 4, false);
      }
      if (!r) return l;
      let c = 0;
      try {
        c = i.getInt32(o += 4, false);
      } catch {
        return l;
      }
      if (c !== 1 || i.getInt32(o += 4, false) > 0) return l;
      const h = i.getInt32(o += 4, false), g = i.getInt32(o += 4, false);
      o += g;
      const v = i.getInt32(o += 4, false);
      if (v < 1) return l;
      const m = {
        R: Array(h).fill(0),
        G: Array(h).fill(0),
        B: Array(h).fill(0),
        A: Array(h).fill(0),
        I: Array(h).fill(0),
        labels: Array(h).fill("")
      };
      for (let T = 0; T < v; T++) {
        const S = i.getInt32(o += 4, false), E = i.getInt32(o += 4, false);
        o += 4;
        let b = "";
        for (let L = 0; L < E; L++) {
          const N = i.getUint8(o++);
          if (N === 0) break;
          b += String.fromCharCode(N);
        }
        o -= 4;
        const D = i.getInt32(o += 4, false), R = i.getInt32(o += 4, false), I = i.getInt32(o += 4, false), O = i.getInt32(o += 4, false);
        if (S < 0 || S >= h) {
          ee.warn("annot entry out of range");
          continue;
        }
        m.R[S] = D, m.G[S] = R, m.B[S] = I, m.A[S] = O, m.I[S] = (O << 24) + (I << 16) + (R << 8) + D, m.labels[S] = b;
      }
      const y = new Float32Array(a);
      y.fill(-1);
      let w = 0;
      for (let T = 0; T < n; T++) {
        const S = l[T];
        for (let E = 0; E < h; E++) if (m.I[E] === S) {
          y[T] = E;
          break;
        }
        y[T] < 0 && (w++, y[T] = 0);
      }
      w > 0 && ee.error(`annot vertex colors do not match ${w} of ${a} vertices.`);
      for (let T = 0; T < h; T++) m.I[T] = T;
      const C = Mn.makeLabelLut(m);
      return {
        scalars: y,
        colormapLabel: C
      };
    }
    static readNV(e) {
      const n = e.byteLength, r = new Uint8Array(e);
      let i = 0;
      function a() {
        for (; i < n && r[i] === 10; ) i++;
        const h = i;
        for (; i < n && r[i] !== 10; ) i++;
        return i++, i - h < 1 ? "" : new TextDecoder().decode(e.slice(h, i - 1));
      }
      let s = 0, o = 0, l = 0, c = 0, f, u;
      for (; i < n; ) {
        const h = a();
        if (h.startsWith("#")) continue;
        const g = h.trim().split(/\s+/);
        if (s < 1) {
          s = parseInt(g[0]), f = new Float32Array(s * 3);
          continue;
        }
        if (l < s * 3) {
          f[l] = parseFloat(g[0]), f[l + 1] = parseFloat(g[1]), f[l + 2] = parseFloat(g[2]), l += 3;
          continue;
        }
        if (o < 1) {
          o = parseInt(g[0]), u = new Uint32Array(o * 3);
          continue;
        }
        if (c >= o * 3) break;
        u[c + 2] = parseInt(g[0]) - 1, u[c + 1] = parseInt(g[1]) - 1, u[c + 0] = parseInt(g[2]) - 1, c += 3;
      }
      return {
        positions: f,
        indices: u
      };
    }
    static readASC(e) {
      const n = e.byteLength, r = new Uint8Array(e);
      let i = 0;
      function a() {
        for (; i < n && r[i] === 10; ) i++;
        const g = i;
        for (; i < n && r[i] !== 10; ) i++;
        return i++, i - g < 1 ? "" : new TextDecoder().decode(e.slice(g, i - 1));
      }
      let s = a();
      s.startsWith("#!ascii") || ee.warn("Invalid ASC mesh"), s = a();
      let o = s.trim().split(/\s+/);
      const l = parseInt(o[0]), c = parseInt(o[1]), f = new Float32Array(l * 3);
      let u = 0;
      for (let g = 0; g < l; g++) s = a(), o = s.trim().split(/\s+/), f[u] = parseFloat(o[0]), f[u + 1] = parseFloat(o[1]), f[u + 2] = parseFloat(o[2]), u += 3;
      const h = new Uint32Array(c * 3);
      u = 0;
      for (let g = 0; g < c; g++) s = a(), o = s.trim().split(/\s+/), h[u] = parseInt(o[0]), h[u + 1] = parseInt(o[1]), h[u + 2] = parseInt(o[2]), u += 3;
      return {
        positions: f,
        indices: h
      };
    }
    static readVTK(e) {
      const n = e.byteLength;
      if (n < 20) throw new Error("File too small to be VTK: bytes = " + e.byteLength);
      const r = new Uint8Array(e);
      let i = 0;
      function a(m = true) {
        if (m) for (; i < n && r[i] === 10; ) i++;
        const y = i;
        for (; i < n && r[i] !== 10; ) i++;
        return i++, i - y < 1 ? "" : new TextDecoder().decode(e.slice(y, i - 1));
      }
      let s = a();
      if (!s.startsWith("# vtk DataFile")) throw new Error("Invalid VTK mesh");
      if (s = a(false), s = a(), s.startsWith("ASCII")) return qr.readTxtVTK(e);
      if (!s.startsWith("BINARY")) throw new Error("Invalid VTK image, expected ASCII or BINARY " + s);
      if (s = a(), !s.includes("POLYDATA")) throw new Error("Only able to read VTK POLYDATA " + s);
      s = a(), (!s.includes("POINTS") || !s.includes("double") && !s.includes("float")) && ee.warn("Only able to read VTK float or double POINTS" + s);
      const o = s.includes("double");
      let l = s.trim().split(/\s+/);
      const f = parseInt(l[1]) * 3, u = new Float32Array(f), h = new DataView(e);
      if (o) for (let m = 0; m < f; m++) u[m] = h.getFloat64(i, false), i += 8;
      else for (let m = 0; m < f; m++) u[m] = h.getFloat32(i, false), i += 4;
      s = a(), l = s.trim().split(/\s+/);
      const g = [];
      if (l[0].includes("LINES")) {
        const m = parseInt(l[1]), y = i;
        if (s = a(), s.startsWith("OFFSETS")) {
          let S = false;
          s.includes("int64") && (S = true);
          const E = new Uint32Array(m);
          if (S) {
            let D = false;
            for (let R = 0; R < m; R++) {
              let I = h.getInt32(i, false);
              I !== 0 && (D = true), i += 4, I = h.getInt32(i, false), i += 4, E[R] = I;
            }
            D && ee.warn("int32 overflow: JavaScript does not support int64");
          } else for (let D = 0; D < m; D++) {
            const R = h.getInt32(i, false);
            i += 4, E[D] = R;
          }
          return {
            pts: u,
            offsetPt0: E
          };
        }
        i = y;
        let w = 0;
        const C = [], T = [];
        C.push(w);
        for (let S = 0; S < m; S++) {
          const E = h.getInt32(i, false);
          i += 4, w += E, C.push(w);
          for (let b = 0; b < E; b++) {
            const D = h.getInt32(i, false) * 3;
            i += 4, T.push(u[D + 0]), T.push(u[D + 1]), T.push(u[D + 2]);
          }
        }
        return {
          pts: Float32Array.from(T),
          offsetPt0: Uint32Array.from(C)
        };
      } else if (l[0].includes("TRIANGLE_STRIPS")) {
        const m = parseInt(l[1]);
        for (let y = 0; y < m; y++) {
          const w = h.getInt32(i, false) - 2;
          i += 4;
          for (let C = 0; C < w; C++) C % 2 ? (g.push(h.getInt32(i + 8, false)), g.push(h.getInt32(i + 4, false)), g.push(h.getInt32(i, false))) : (g.push(h.getInt32(i, false)), g.push(h.getInt32(i + 4, false)), g.push(h.getInt32(i + 8, false))), i += 4;
          i += 8;
        }
      } else if (l[0].includes("POLYGONS")) {
        const m = parseInt(l[1]), y = i, w = a();
        if (w.startsWith("OFFSETS")) {
          let C = w.includes("int64");
          const T = new Uint32Array(m);
          let S = false;
          for (let R = 0; R < m; R++) C && (h.getInt32(i, false) !== 0 && (S = true), i += 4), T[R] = h.getInt32(i, false), i += 4;
          if (!Number.isSafeInteger(m) || m >= 2147483648 || S) throw new Error("values exceed 2GB limit");
          const E = a();
          if (!E.startsWith("CONNECTIVITY")) throw new Error("Expected CONNECTIVITY after OFFSETS");
          C = E.includes("int64");
          const b = T[m - 1], D = new Uint32Array(b);
          for (let R = 0; R < b; R++) C && (i += 4), D[R] = h.getInt32(i, false), i += 4;
          for (let R = 0; R < m; R++) {
            const I = R === 0 ? 0 : T[R - 1], O = T[R];
            for (let L = 1; L < O - I - 1; L++) g.push(D[I]), g.push(D[I + L]), g.push(D[I + L + 1]);
          }
        } else {
          i = y;
          for (let C = 0; C < m; C++) {
            const T = h.getInt32(i, false) - 2;
            if (C === 0 && T > 65535) throw new Error("Invalid VTK binary polygons using little-endian data (MRtrix)");
            i += 4;
            const S = h.getInt32(i, false);
            i += 4;
            let E = h.getInt32(i, false);
            i += 4;
            for (let b = 0; b < T; b++) {
              const D = h.getInt32(i, false);
              i += 4, g.push(S, E, D), E = D;
            }
          }
        }
      } else throw new Error("Unsupported binary VTK datatype " + l[0]);
      const v = new Uint32Array(g);
      return {
        positions: u,
        indices: v
      };
    }
    static readWRL(e) {
      const n = new TextDecoder("utf-8").decode(e), r = /coord\s+Coordinate\s*\{\s*point\s*\[([\s\S]*?)\]/, i = /coordIndex\s*\[([\s\S]*?)\]/, a = /color\s+Color\s*\{\s*color\s*\[([\s\S]*?)\]/, s = r.exec(n), o = i.exec(n), l = a.exec(n);
      if (!s || !o) throw new Error("Invalid WRL file: Could not find vertices or indices.");
      const c = new Float32Array(s[1].trim().split(/[\s,]+/).map(Number));
      let f = null;
      if (l) {
        f = new Float32Array(l[1].trim().split(/[\s,]+/).map(Number));
        const h = c.length / 3;
        f.length !== h * 3 && (console.warn(`Unexpected color count: expected ${h * 3}, got ${f.length}`), f = null);
      }
      const u = new Uint32Array(o[1].trim().split(/[\s,]+/).map(Number).filter((h) => h !== -1));
      return {
        positions: c,
        indices: u,
        colors: f
      };
    }
    static readDFS(e) {
      const n = new DataView(e), r = n.getUint32(0, true), i = n.getUint16(4, true);
      (r !== 1599292996 || i !== 17740) && ee.warn("Not a little-endian brainsuite DFS mesh");
      const a = n.getUint32(12, true), s = n.getUint32(24, true), o = n.getUint32(28, true), l = n.getUint32(48, true);
      let c = a;
      const f = new Uint32Array(e, c, s * 3);
      c += s * 3 * 4;
      const u = new Float32Array(e, c, o * 3);
      for (let g = 0; g < o * 3; g += 3) {
        const v = u[g];
        u[g] = u[g + 1], u[g + 1] = v;
      }
      let h;
      return l >= 0 && (h = new Float32Array(e, l, o * 3)), {
        positions: u,
        indices: f,
        colors: h
      };
    }
    static async readMZ3(e, n = 0) {
      if (e.byteLength < 20) throw new Error("File too small to be mz3: bytes = " + e.byteLength);
      let r = new DataView(e), i = e, a = r.getUint16(0, true);
      if (a === 35615 || a === 8075) {
        const I = await ft.decompress(new Uint8Array(e));
        r = new DataView(I.buffer), a = r.getUint16(0, true), i = I.buffer;
      }
      const s = r.getUint16(2, true), o = r.getUint32(4, true);
      let l = r.getUint32(8, true);
      const c = r.getUint32(12, true);
      if (c1.debug("MZ3 magic %d attr %d face %d vert %d skip %d", a, s, o, l, c), a !== 23117) throw new Error("Invalid MZ3 file");
      const f = (s & 1) !== 0, u = (s & 2) !== 0, h = (s & 4) !== 0;
      let g = (s & 8) !== 0;
      const v = (s & 16) !== 0, m = (s & 32) !== 0, y = (s & 64) !== 0;
      if (c1.debug(`isFace=${f} isVert=${u} isRGBA=${h} isSCALAR=${g} isDOUBLE=${v} isAOMAP=${m} isLOOKUP=${y}`), s > 127) throw new Error("Unsupported future version of MZ3 file");
      let w = 4;
      v && (w = 8);
      let C = 0;
      if (n > 0 && !f && o < 1 && !h && (g = true), g) {
        const I = n || l, O = 16 + c + (f ? o * 12 : 0) + (u ? I * 12 : 0) + (h ? I * 4 : 0), L = Math.floor((i.byteLength - O) / w);
        l !== n && L % n === 0 && (l = n), C = Math.floor(L / l), C < 1 && (ee.warn("Corrupt MZ3: file reports NSCALAR but not enough bytes"), g = false);
      }
      if (l < 3 && n < 3) throw new Error("Not a mesh MZ3 file (maybe scalar)");
      n > 0 && n !== l && ee.warn("Layer has " + l + "vertices, but background mesh has " + n);
      let T = 16 + c;
      const S = new DataView(i);
      let E = null;
      if (f) {
        E = new Uint32Array(o * 3);
        for (let I = 0; I < o * 3; I++) E[I] = S.getUint32(T, true), T += 4;
      }
      let b = null;
      if (u) {
        b = new Float32Array(l * 3);
        for (let I = 0; I < l * 3; I++) b[I] = S.getFloat32(T, true), T += 4;
      }
      let D = null;
      if (h) {
        D = new Float32Array(l * 3);
        for (let I = 0; I < l; I++) {
          for (let O = 0; O < 3; O++) D[I * 3 + O] = S.getUint8(T++) / 255;
          T++;
        }
      }
      let R = new Float32Array();
      if (g && C > 0) if (v) {
        const I = new Float64Array(C * l);
        for (let O = 0; O < C * l; O++) I[O] = S.getFloat64(T, true), T += 8;
        R = Float32Array.from(I);
      } else {
        R = new Float32Array(C * l);
        for (let I = 0; I < C * l; I++) R[I] = S.getFloat32(T, true), T += 4;
      }
      if (n > 0 && y && g) {
        const I = new TextDecoder("utf-8"), O = new Uint8Array(i, 16, c), L = I.decode(O), N = JSON.parse(L), F = Mn.makeLabelLut(N);
        return {
          scalars: R,
          colormapLabel: F
        };
      }
      if (n > 0 && h && g) {
        let I = R[0];
        for (let N = 0; N < l; N++) I = Math.max(I, R[N]);
        const O = {
          R: [],
          G: [],
          B: [],
          A: [],
          I: [],
          labels: []
        };
        for (let N = 0; N <= I; N++) for (let F = 0; F < l; F++) if (N === R[F]) {
          const V = F * 3;
          O.I.push(N), O.R.push(D[V] * 255), O.G.push(D[V + 1] * 255), O.B.push(D[V + 2] * 255), O.A.push(255), O.labels.push(`${N}`);
          break;
        }
        const L = Mn.makeLabelLut(O);
        return {
          scalars: R,
          colormapLabel: L
        };
      }
      return n > 0 ? {
        scalars: R
      } : {
        positions: b,
        indices: E,
        scalars: R,
        colors: D
      };
    }
    static readPLY(e) {
      const n = e.byteLength, r = new Uint8Array(e);
      let i = 0;
      function a() {
        for (; i < n && r[i] === 10; ) i++;
        const R = i;
        for (; i < n && r[i] !== 10; ) i++;
        return i++, i - R < 1 ? "" : new TextDecoder().decode(e.slice(R, i - 1));
      }
      let s = a();
      if (!s.startsWith("ply")) throw new Error("Not a valid PLY file");
      s = a();
      const o = s.includes("ascii");
      function l(R) {
        if (R === "char" || R === "uchar" || R === "int8" || R === "uint8") return 1;
        if (R === "short" || R === "ushort" || R === "int16" || R === "uint16") return 2;
        if (R === "int" || R === "uint" || R === "int32" || R === "uint32" || R === "float" || R === "float32") return 4;
        if (R === "double") return 8;
        throw new Error("Unknown data type: " + R);
      }
      const c = s.includes("binary_little_endian");
      let f = 0, u = false, h = 0, g = 0, v = 0, m = 0, y = 0, w = 0, C = 0;
      for (; i < n && !s.startsWith("end_header"); ) {
        if (s = a(), s.startsWith("comment")) continue;
        let R = s.split(/\s/);
        if (s.startsWith("element vertex")) for (f = parseInt(R[R.length - 1]), s = a(), R = s.split(/\s/); s.startsWith("property"); ) {
          const I = R[1];
          R[2] === "x" && I.startsWith("double") ? u = true : R[2] === "x" && !I.startsWith("float") && ee.error("Error: expect ply xyz to be float or double: " + s), h += l(I), s = a(), R = s.split(/\s/);
        }
        if (s.startsWith("element face")) for (C = parseInt(R[R.length - 1]), s = a(), R = s.split(/\s/); s.startsWith("property"); ) {
          if (R[1] === "list") v = l(R[2]), m = l(R[3]), g += v + 3 * m;
          else {
            const I = l(R[1]);
            g += I, m === 0 && (y += I, w++);
          }
          s = a(), R = s.split(/\s/);
        }
      }
      if (o) {
        C < 1 && ee.error(`Malformed ply format: faces ${C} `);
        const R = new Float32Array(f * 3);
        let I = 0;
        for (let N = 0; N < f; N++) {
          s = a();
          const F = s.split(/\s/);
          R[I] = parseFloat(F[0]), R[I + 1] = parseFloat(F[1]), R[I + 2] = parseFloat(F[2]), I += 3;
        }
        let O = new Uint32Array(C * 3), L = 0;
        for (let N = 0; N < C; N++) {
          s = a();
          const F = s.split(/\s/), V = parseInt(F[w]) - 2;
          if (V < 1) break;
          if (L + V * 3 > O.length) {
            const K = new Uint32Array(O.length + O.length);
            K.set(O), O = K.slice();
          }
          const k = parseInt(F[w + 1]);
          let _ = parseInt(F[w + 2]);
          for (let K = 0; K < V; K++) {
            const Z = parseInt(F[w + 3 + K]);
            O[L + 0] = k, O[L + 1] = _, O[L + 2] = Z, _ = Z, L += 3;
          }
        }
        return O.length !== L && (O = O.slice(0, L)), {
          positions: R,
          indices: O
        };
      }
      (h < 12 || v < 1 || m < 1 || C < 1) && ee.warn(`Malformed ply format: stride ${h} count ${v} iBytes ${m} iStrideBytes ${g} iPadBytes ${y} faces ${C}`);
      const T = new DataView(e);
      let S;
      if (i % 4 === 0 && h === 12 && c) S = new Float32Array(e, i, f * 3), i += f * h;
      else {
        S = new Float32Array(f * 3);
        let R = 0;
        for (let I = 0; I < f; I++) u ? (S[R] = T.getFloat64(i, c), S[R + 1] = T.getFloat64(i + 8, c), S[R + 2] = T.getFloat64(i + 16, c)) : (S[R] = T.getFloat32(i, c), S[R + 1] = T.getFloat32(i + 4, c), S[R + 2] = T.getFloat32(i + 8, c)), R += 3, i += h;
      }
      const E = new Uint32Array(C * 3);
      let b = true, D = 0;
      if (v === 1 && m === 4 && g === 13) for (let R = 0; R < C; R++) {
        const I = T.getUint8(i);
        i += v, I !== 3 && (b = false), E[D] = T.getUint32(i, c), i += 4, E[D + 1] = T.getUint32(i, c), i += 4, E[D + 2] = T.getUint32(i, c), i += 4, D += 3;
      }
      else {
        let R = i;
        for (let I = 0; I < C; I++) {
          i = R + y;
          let O = 0;
          v === 1 ? O = T.getUint8(i) : v === 2 ? O = T.getUint16(i, c) : v === 4 && (O = T.getUint32(i, c)), i += v, O !== 3 && (b = false);
          for (let L = 0; L < 3; L++) m === 1 ? E[D] = T.getUint8(i) : m === 2 ? E[D] = T.getUint16(i, c) : m === 4 && (E[D] = T.getUint32(i, c)), D++, i += m;
          R += g;
        }
      }
      return b || ee.warn("Only able to read PLY meshes limited to triangles."), {
        positions: S,
        indices: E
      };
    }
    static readICO(e) {
      const i = new TextDecoder("utf-8").decode(e).split(`
`);
      let a = i[0].trim().split(/\s+/);
      a.length > 1 && ee.warn("This is not a valid FreeSurfer ICO/TRI mesh.");
      const s = parseInt(a[0]), o = new Float32Array(s * 3);
      let l = 1;
      for (let u = 0; u < s; u++) {
        const h = i[l].trim().split(/\s+/);
        l++;
        let g = parseInt(h[0]) - 1;
        const v = parseFloat(h[1]), m = parseFloat(h[2]), y = parseFloat(h[3]);
        if (g < 0 || g >= s) {
          ee.error("ICO vertices corrupted");
          break;
        }
        g *= 3, o[g] = v, o[g + 1] = m, o[g + 2] = y;
      }
      a = i[l].trim().split(/\s+/), l++;
      const c = parseInt(a[0]), f = new Uint32Array(c * 3);
      for (let u = 0; u < c; u++) {
        const h = i[l].trim().split(/\s+/);
        l++;
        let g = parseInt(h[0]) - 1;
        const v = parseInt(h[1]) - 1, m = parseInt(h[2]) - 1, y = parseInt(h[3]) - 1;
        if (g < 0 || g >= c) {
          ee.error("ICO indices corrupted");
          break;
        }
        g *= 3, f[g] = v, f[g + 1] = m, f[g + 2] = y;
      }
      for (let u = 0; u < f.length; u += 3) {
        const h = f[u];
        f[u] = f[u + 1], f[u + 1] = h;
      }
      return {
        positions: o,
        indices: f
      };
    }
    static readGEO(e, n = false) {
      const a = new TextDecoder("utf-8").decode(e).split(`
`), s = a[0].trim().split(/\s+/), o = parseInt(s[0]);
      let l = parseInt(s[1]), c = parseInt(s[2]);
      const f = parseInt(s[3]);
      (o > 1 || f !== c * 3) && ee.warn("Multi-part BYU/GEO header or not a triangular mesh.");
      const u = [];
      l *= 3;
      let h = 0, g = 2;
      for (; h < l; ) {
        const C = a[g].trim().split(/\s+/);
        g++;
        for (let T = 0; T < C.length && (u.push(parseFloat(C[T])), h++, !(h >= l)); T++) ;
      }
      const v = [];
      c *= 3;
      let m = 0;
      for (; m < c; ) {
        const C = a[g].trim().split(/\s+/);
        g++;
        for (let T = 0; T < C.length && (v.push(Math.abs(parseInt(C[T])) - 1), m++, !(m >= c)); T++) ;
      }
      if (n) for (let C = 0; C < v.length; C += 3) {
        const T = v[C];
        v[C] = v[C + 1], v[C + 1] = T;
      }
      const y = new Float32Array(u), w = new Uint32Array(v);
      return {
        positions: y,
        indices: w
      };
    }
    static readOFF(e) {
      const i = new TextDecoder("utf-8").decode(e).split(`
`), a = [], s = [];
      let o = 0;
      i[o].includes("OFF") ? o++ : ee.warn("File does not start with OFF");
      let l = i[o].trim().split(/\s+/);
      const c = parseInt(l[0]), f = parseInt(l[1]);
      o++;
      for (let g = 0; g < c; g++) l = i[o].trim().split(/\s+/), a.push(parseFloat(l[0])), a.push(parseFloat(l[1])), a.push(parseFloat(l[2])), o++;
      for (let g = 0; g < f; g++) l = i[o].trim().split(/\s+/), parseInt(l[0]) !== 3 && ee.warn("Only able to read OFF files with triangular meshes"), s.push(parseInt(l[1])), s.push(parseInt(l[2])), s.push(parseInt(l[3])), o++;
      const u = new Float32Array(a), h = new Uint32Array(s);
      return {
        positions: u,
        indices: h
      };
    }
    static readOBJMNI(e) {
      const i = new TextDecoder("utf-8").decode(e).trim().split(/\s*,\s*|\s+/);
      (i.length < 1 || i[0] !== "P") && ee.warn("This is not a valid MNI OBJ mesh.");
      let a = 6;
      const s = parseInt(i[a++]), o = s * 3, l = new Float32Array(o);
      for (let v = 0; v < o; v++) l[v] = parseFloat(i[a++]);
      a += o;
      const c = parseInt(i[a++]), f = parseInt(i[a++]);
      (c < 1 || f < 0 || f > 2) && ee.warn("This is not a valid MNI OBJ mesh.");
      let u = 1;
      f === 1 ? u = c : f === 1 && (u = s), a += u * 4, a += c;
      const h = c * 3, g = new Uint32Array(h);
      for (let v = 0; v < h; v++) g[v] = parseInt(i[a++]);
      return {
        positions: l,
        indices: g
      };
    }
    static async readOBJ(e) {
      const n = new Uint8Array(e, 0, 2);
      n[0] === 31 && n[1] === 139 && (e = await ft.decompressToBuffer(new Uint8Array(e)));
      const i = new TextDecoder("utf-8").decode(e);
      if (i[0] === "P") return this.readOBJMNI(e);
      const a = i.split(`
`), s = a.length, o = [], l = [];
      for (let g = 0; g < s; g++) {
        const v = a[g];
        if (v[0] === "v" && v[1] === " ") {
          const m = v.trim().split(/\s+/);
          o.push(parseFloat(m[1])), o.push(parseFloat(m[2])), o.push(parseFloat(m[3]));
        }
        if (v[0] === "f") {
          const m = v.trim().split(/\s+/), y = m.length - 3;
          if (y < 1) break;
          let w = m[1].split("/");
          const C = parseInt(w[0]) - 1;
          w = m[2].split("/");
          let T = parseInt(w[0]) - 1;
          for (let S = 0; S < y; S++) {
            w = m[3 + S].split("/");
            const E = parseInt(w[0]) - 1;
            l.push(C), l.push(T), l.push(E), T = E;
          }
        }
      }
      const c = new Float32Array(o), f = new Uint32Array(l);
      let u = f[0], h = f[0];
      for (let g = 1; g < f.length; g++) f[g] < u && (u = f[g]), f[g] > h && (h = f[g]);
      if (h - u + 1 > c.length / 3) throw new Error("Not a valid OBJ file");
      for (let g = 0; g < f.length; g++) f[g] -= u;
      return {
        positions: c,
        indices: f
      };
    }
    static readFreeSurfer(e) {
      const n = new Uint8Array(e);
      if (n[0] === 35 && n[1] === 33 && n[2] === 97) return qr.readASC(e);
      const r = new DataView(e), i = r.getUint32(0, false), a = r.getUint32(4, false);
      (i !== 4294966883 || a !== 1919246708) && c1.debug("Unable to recognize file type: does not appear to be FreeSurfer format.");
      let s = 0;
      for (; r.getUint8(s) !== 10; ) s++;
      s += 2;
      let o = r.getUint32(s, false);
      s += 4;
      let l = r.getUint32(s, false);
      s += 4, o *= 3;
      const c = new Float32Array(o);
      for (let g = 0; g < o; g++) c[g] = r.getFloat32(s, false), s += 4;
      l *= 3;
      const f = new Uint32Array(l);
      for (let g = 0; g < l; g++) f[g] = r.getUint32(s, false), s += 4;
      const u = r.getUint32(s, false);
      s += 4;
      let h = u === 20;
      if (!h) {
        const g = r.getUint32(s, false);
        s += 4;
        const v = r.getUint32(s, false);
        s += 4, h = u === 2 && g === 0 && v === 20;
      }
      if (!h) ee.warn("Unknown FreeSurfer Mesh extension code.");
      else {
        const v = new TextDecoder().decode(e.slice(s)).trim().split(`
`);
        for (let m = 0; m < v.length; m++) {
          if (!v[m].startsWith("cras")) continue;
          const w = v[m].split("=")[1].trim().split(" ").map(Number), C = Math.floor(c.length / 3);
          let T = 0;
          for (let S = 0; S < C; S++) c[T] += w[0], T++, c[T] += w[1], T++, c[T] += w[2], T++;
        }
      }
      return {
        positions: c,
        indices: f
      };
    }
    static async readSRF(e) {
      const n = new Uint8Array(e);
      if (n[0] === 35 && n[1] === 33 && n[2] === 97) return qr.readASC(e);
      n[0] === 31 && n[1] === 139 && (e = (await ft.decompress(new Uint8Array(e))).buffer);
      const r = new DataView(e), i = r.getFloat32(0, true), a = r.getUint32(8, true), s = r.getUint32(12, true), o = r.getFloat32(16, true), l = r.getFloat32(20, true), c = r.getFloat32(24, true), f = new Float32Array(a * 3);
      let u = 28, h = 1;
      for (let b = 0; b < a; b++) f[h] = -r.getFloat32(u, true) + o, h += 3, u += 4;
      h = 2;
      for (let b = 0; b < a; b++) f[h] = -r.getFloat32(u, true) + l, h += 3, u += 4;
      h = 0;
      for (let b = 0; b < a; b++) f[h] = -r.getFloat32(u, true) + c, h += 3, u += 4;
      u = 28 + 24 * a;
      const g = r.getFloat32(u, true), v = r.getFloat32(u + 4, true), m = r.getFloat32(u + 8, true), y = r.getFloat32(u + 16, true), w = r.getFloat32(u + 20, true), C = r.getFloat32(u + 24, true);
      u += 32;
      const T = new Float32Array(a * 3), S = new Uint32Array(e, u, a);
      h = 0;
      for (let b = 0; b < a; b++) {
        const D = S[b];
        D > 1056964608 && (T[h + 0] = (D >> 16 & 255) / 255, T[h + 1] = (D >> 8 & 255) / 255, T[h + 2] = (D & 255) / 255), D === 0 && (T[h + 0] = g, T[h + 1] = v, T[h + 2] = m), D === 1 && (T[h + 0] = y, T[h + 1] = w, T[h + 2] = C), h += 3;
      }
      u += a * 4;
      for (let b = 0; b < a; b++) {
        const D = r.getUint32(u, true);
        u += 4 + 4 * D;
      }
      const E = new Uint32Array(s * 3);
      for (let b = 0; b < s * 3; b++) E[b] = r.getInt32(u, true), u += 4;
      return i !== 4 && ee.warn("Not valid SRF"), {
        positions: f,
        indices: E,
        colors: T
      };
    }
    static readTxtSTL(e) {
      const i = new TextDecoder("utf-8").decode(e).split(`
`);
      if (!i[0].startsWith("solid")) throw new Error("Not a valid STL file");
      const a = [];
      for (let c = 1; c < i.length; c++) {
        if (!i[c].includes("vertex")) continue;
        const f = i[c].trim().split(/\s+/);
        for (let u = 1; u < f.length; u++) a.push(parseFloat(f[u]));
      }
      const s = Math.floor(a.length / 3);
      if (s * 3 !== a.length) throw new Error("Unable to parse ASCII STL file.");
      const o = new Float32Array(a), l = new Uint32Array(s);
      for (let c = 0; c < s; c++) l[c] = c;
      return {
        positions: o,
        indices: l
      };
    }
    static readSTL(e) {
      if (e.byteLength < 134) throw new Error("File too small to be STL: bytes = " + e.byteLength);
      const n = new DataView(e);
      if (n.getUint32(0, true) === 1768714099) return qr.readTxtSTL(e);
      const i = n.getUint32(80, true), a = 3 * i;
      if (e.byteLength < 84 + i * 50) throw new Error("STL file too small to store triangles = " + i);
      const s = new Uint32Array(a), o = new Float32Array(a * 3);
      let l = 96, c = 0;
      for (let f = 0; f < i; f++) {
        for (let u = 0; u < 9; u++) o[c] = n.getFloat32(l, true), c += 1, l += 4;
        l += 14;
      }
      for (let f = 0; f < a; f++) s[f] = f;
      return {
        positions: o,
        indices: s
      };
    }
    static decimateLayerVertices(e, n) {
      if (e % n === 0) return e;
      const r = 12, i = Math.round(Math.log((e - 2) / (r - 2)) / Math.log(4)), a = Math.round(Math.log((n - 2) / (r - 2)) / Math.log(4)), s = Math.pow(4, i) * (r - 2) + 2, o = Math.pow(4, a) * (r - 2) + 2;
      return s !== e || o !== n ? e : n;
    }
    static async readNII2(e, n = 0, r = "") {
      let i = new Float32Array();
      const a = e.byteLength;
      let s = true;
      const o = new DataView(e);
      let l = o.getUint16(0, s);
      if (l === 469893120 && (s = false, l = o.getUint16(0, s)), l !== 540) throw new Error("Not a valid NIfTI-2 dataset");
      const c = Number(o.getBigInt64(168, s)), f = o.getFloat64(176, s), u = o.getFloat64(184, s);
      (f !== 1 || u !== 0) && ee.warn("ignoring scale slope and intercept");
      const h = o.getUint32(504, s), g = o.getUint16(12, s);
      if (g !== 2 && g !== 4 && g !== 8 && g !== 16) throw new Error("Unsupported NIfTI datatype " + g);
      let v = 1;
      const m = [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1
      ];
      for (let y = 1; y < 8; y++) m[y] = Math.max(Number(o.getBigInt64(16 + y * 8, s)), 1), v *= m[y];
      if (h >= 3e3 && h <= 3099 && c > 580) {
        let y = function() {
          for (; I < a && R[I] === 10; ) I++;
          const _ = I;
          for (; I < a && R[I] !== 10; ) I++;
          return I++, I - _ < 1 ? "" : new TextDecoder().decode(e.slice(_, I - 1)).trim();
        }, w = function() {
          let _ = y();
          if (!_.startsWith("<") || _.endsWith(">")) return _;
          for (; I < a && !_.endsWith(">"); ) _ += y();
          return _;
        }, C = function(_, K = false) {
          const Z = O.indexOf(_);
          if (Z < 0) return 1;
          const j = O.indexOf('"', Z) + 1, B = O.indexOf('"', j), Y = O.slice(j, B);
          return K ? Y : parseInt(Y);
        }, T = 0, S = 0, E = 0, b = "", D = new Uint32Array();
        const R = new Uint8Array(e);
        let I = 552, O;
        const L = m[5], N = new Float32Array(n * L);
        for (; I < a && (O = w(), !O.includes("</CIFTI>")); ) if (O.includes("<BrainModel")) {
          const _ = C("SurfaceNumberOfVertices="), K = C("BrainStructure=", true).toUpperCase();
          if (_ % n !== 0) continue;
          let Z = false;
          if (r.includes("CORTEX") && K.includes("CORTEX") && (Z = true), !Z || (Z = false, r.includes("LEFT") && K.includes("LEFT") && (Z = true), r.includes("RIGHT") && K.includes("RIGHT") && (Z = true), !Z)) continue;
          if (E = _, T = C("IndexOffset="), S = C("IndexCount="), b = K, O.includes("<VertexIndices>") || (O = w()), !O.startsWith("<VertexIndices>") || !O.endsWith("</VertexIndices>")) return ee.warn("Unable to find CIfTI <VertexIndices>"), N;
          O = O.slice(15, -16);
          const j = O.trim().split(/\s+/);
          j.length < S && ee.error("Error parsing VertexIndices"), D = new Uint32Array(S);
          for (let B = 0; B < S; B++) D[B] = parseInt(j[B]);
        }
        if (E === 0 || D.length === 0) return ee.warn("Unable to find CIfTI structure that matches the mesh."), N;
        if (g !== 16) return ee.warn("Only able to read float32 CIfTI (only known datatype)."), N;
        const F = new Float32Array(S * L), V = c + L * T * 4;
        for (let _ = 0; _ < S * L; _++) F[_] = o.getFloat32(V + _ * 4, s);
        let k = 0;
        for (let _ = 0; _ < S; _++) for (let K = 0; K < L; K++) N[D[_] + K * n] = F[k], k++;
        return ee.debug("CIfTI diagnostics", E, b, T, S, T, r), N;
      }
      if (v = this.decimateLayerVertices(v, n), v % n !== 0) throw new Error("Vertices in layer (" + v + ") is not a multiple of number of vertices (" + n + ")");
      if (s) g === 16 ? i = new Float32Array(e, c, v) : g === 8 ? i = new Int32Array(e, c, v) : g === 4 && (i = new Int16Array(e, c, v));
      else if (g === 16) {
        i = new Float32Array(v);
        for (let y = 0; y < v; y++) i[y] = o.getFloat32(c + y * 4, s);
      } else if (g === 8) {
        i = new Int32Array(v);
        for (let y = 0; y < v; y++) i[y] = o.getInt32(c + y * 4, s);
      } else if (g === 4) {
        i = new Int16Array(v);
        for (let y = 0; y < v; y++) i[y] = o.getInt16(c + y * 2, s);
      }
      return g === 2 && (i = new Uint8Array(e, c, v)), i;
    }
    static async readNII(e, n = 0, r = "") {
      let i = new Float32Array(), a = true, s = new DataView(e), o = s.getUint16(0, a);
      if (o === 540 || o === 469893120) return qr.readNII2(e, n, r);
      if (o === 23553 && (a = false, o = s.getUint16(0, a)), o !== 348) {
        const g = await ft.decompress(new Uint8Array(e));
        if (s = new DataView(g.buffer), e = g.buffer, o = s.getUint16(0, a), o === 540 || o === 469893120) return qr.readNII2(e, n, r);
        o === 23553 && (a = false, o = s.getUint16(0, a));
      }
      o !== 348 && ee.error("Not a valid NIfTI image.");
      const l = s.getFloat32(108, a), c = s.getFloat32(112, a), f = s.getFloat32(116, a);
      (c !== 1 || f !== 0) && ee.warn("ignoring scale slope and intercept");
      const u = s.getUint16(70, a);
      if (u !== 2 && u !== 4 && u !== 8 && u !== 16) throw new Error("Unsupported NIfTI datatype " + u);
      let h = 1;
      for (let g = 1; g < 8; g++) {
        const v = s.getUint16(40 + g * 2, a);
        h *= Math.max(v, 1);
      }
      if (h = this.decimateLayerVertices(h, n), h % n !== 0) throw new Error("Vertices in layer (" + h + ") is not a multiple of number of vertices (" + n + ")");
      if (a) u === 16 ? i = new Float32Array(e, l, h) : u === 8 ? i = new Int32Array(e, l, h) : u === 4 && (i = new Int16Array(e, l, h));
      else if (u === 16) {
        i = new Float32Array(h);
        for (let g = 0; g < h; g++) i[g] = s.getFloat32(l + g * 4, a);
      } else if (u === 8) {
        i = new Int32Array(h);
        for (let g = 0; g < h; g++) i[g] = s.getInt32(l + g * 4, a);
      } else if (u === 4) {
        i = new Int16Array(h);
        for (let g = 0; g < h; g++) i[g] = s.getInt16(l + g * 2, a);
      }
      return u === 2 && (i = new Uint8Array(e, l, h)), i;
    }
    static async readMGH(e, n = 0, r = false) {
      let i = new DataView(e), a = e;
      if (i.getUint8(0) === 31 && i.getUint8(1) === 139) {
        const D = await ft.decompress(new Uint8Array(e));
        a = new ArrayBuffer(D.byteLength), new Uint8Array(a).set(new Uint8Array(D)), i = new DataView(D.buffer);
      }
      const s = i.getInt32(0, false), o = Math.max(1, i.getInt32(4, false)), l = Math.max(1, i.getInt32(8, false)), c = Math.max(1, i.getInt32(12, false)), f = Math.max(1, i.getInt32(16, false)), u = i.getInt32(20, false);
      let h = 284;
      const g = false;
      (s !== 1 || u < 0 || u > 4) && ee.warn("Not a valid MGH file");
      let v = o * l * c * f, m = [];
      if (v = this.decimateLayerVertices(v, n), v % n !== 0) return ee.warn("Vertices in layer (" + v + ") is not a multiple of number of vertices (" + n + ")"), m;
      if (u === 3) {
        m = new Float32Array(v);
        for (let D = 0; D < v; D++) m[D] = i.getFloat32(h + D * 4, g);
      } else if (u === 1) {
        m = new Int32Array(v);
        for (let D = 0; D < v; D++) m[D] = i.getInt32(h + D * 4, g);
      } else if (u === 4) {
        m = new Int16Array(v);
        for (let D = 0; D < v; D++) m[D] = i.getInt16(h + D * 2, g);
      } else u === 0 && (m = new Uint8Array(e, h, v));
      if (!r) return m;
      let y = 4;
      u === 4 && (y = 2), u === 0 && (y = 1), h += y * v, h += 16;
      const w = 1, C = 2, T = 20, S = 30, E = a.byteLength;
      let b;
      for (; h < E - 8; ) {
        const D = i.getInt32(h += 4, g);
        let R = 0;
        switch (D) {
          case S:
            R = i.getInt32(h += 4, g) - 1;
            break;
          case T:
          case C:
            R = 0;
            break;
          case w:
            R = 0;
            {
              let I = i.getInt32(h += 4, g);
              if (I > 0) return ee.warn("unsupported CTABreadFromBinaryV1"), m;
              if (I = -I, I !== 2) return ee.warn("CTABreadFromBinary: unknown version"), m;
              const O = i.getInt32(h += 4, g);
              if (O < 0) return ee.warn("CTABreadFromBinaryV2: nentries was ", O), m;
              const L = i.getInt32(h += 4, g);
              h += L;
              const N = i.getInt32(h += 4, g);
              if (N < 0) return m;
              const F = {
                R: [],
                G: [],
                B: [],
                A: [],
                I: [],
                labels: []
              };
              for (let V = 0; V < N; V++) {
                const k = i.getInt32(h += 4, g), _ = i.getInt32(h += 4, g);
                let K = h + 4, Z = "";
                for (let ie = 0; ie < _; ie++) {
                  const oe = i.getUint8(K++);
                  if (oe === 0) break;
                  Z += String.fromCharCode(oe);
                }
                h += _;
                const j = i.getInt32(h += 4, g), B = i.getInt32(h += 4, g), Y = i.getInt32(h += 4, g), X = 255 - i.getInt32(h += 4, g);
                F.I.push(k), F.R.push(j), F.G.push(B), F.B.push(Y), F.A.push(X), F.labels.push(Z);
              }
              b = Mn.makeLabelLut(F);
            }
            break;
          default:
            R = i.getInt32(h += 8, g);
        }
        h += R;
      }
      return {
        scalars: m,
        colormapLabel: b
      };
    }
    static readX3D(e) {
      const n = e.byteLength;
      if (n < 20) throw new Error("File too small to be X3D: bytes = " + n);
      const r = new Uint8Array(e);
      let i = 0;
      function a() {
        for (; i < n && r[i] !== 60; ) i++;
        const T = i;
        for (; i < n && r[i] !== 62; ) i++;
        const S = i;
        return new TextDecoder().decode(e.slice(T, S + 1)).trim();
      }
      let s = a();
      function o(T) {
        const S = s.indexOf(T + "=");
        if (S < 0) return "";
        const E = s[S + T.length + 1], b = s.indexOf(E, S) + 1, D = s.indexOf(E, b);
        return s.slice(b, D);
      }
      function l(T) {
        const S = s.indexOf(T + "=");
        if (S < 0) return 1;
        const E = s[S + T.length + 1], b = s.indexOf(E, S) + 1, D = s.indexOf(E, b);
        let R = s.slice(b, D).trim();
        R = R.replace(/,\s*$/, "");
        const I = R.trim().split(/\s*,\s*|\s+/);
        if (I.length < 2) return parseFloat(R);
        let O = new Array(I.length), L = 0;
        for (let N = 0; N < I.length; N++) {
          const F = parseFloat(I[N]);
          isFinite(F) && (O[L] = F, L++);
        }
        return O = O.slice(0, L), O;
      }
      s.includes("xml version") || ee.warn("Not a X3D image");
      let c = [], f = [], u = [], h = [], g = [
        0,
        0,
        0,
        0
      ], v = [
        0,
        0,
        0,
        0
      ], m = [
        255,
        255,
        255,
        255
      ], y = [
        255,
        255,
        255,
        255
      ];
      const w = {};
      function C() {
        if (!s.endsWith("/>")) if (s.startsWith("<Appearance>")) for (; i < n && !s.endsWith("</Appearance>"); ) s += a();
        else for (; i < n && !s.endsWith("/>"); ) s += a();
        const T = o("USE");
        if (T.length > 1) {
          T in w ? m = w[T] : ee.warn("Unable to find DEF for " + T);
          return;
        }
        const S = l("diffuseColor");
        if (S.length < 3) return;
        m[0] = Math.round(S[0] * 255), m[1] = Math.round(S[1] * 255), m[2] = Math.round(S[2] * 255);
        const E = o("DEF");
        E.length < 1 || (w[E] = m);
      }
      for (; i < n; ) if (s = a(), m = y.slice(), s.startsWith("<Transform") && (g = l("translation"), v = l("rotation")), s.startsWith("<Appearance") && (C(), y = m.slice()), s.startsWith("<Shape")) {
        let T = 1, S = 1, E = [], b = [];
        for (; i < n && (s = a(), s.startsWith("<Appearance") && C(), !s.startsWith("</Shape")); ) {
          if (s.startsWith("<Sphere") && (T = l("radius"), S = -1), s.startsWith("<Cylinder") && (T = l("radius"), S = l("height")), s.startsWith("<IndexedFaceSet") && (S = -2, E = l("coordIndex")), s.startsWith("<IndexedTriangleSet") && (S = -7, E = l("index")), s.startsWith("<IndexedTriangleStripSet") && (S = -3, E = l("index")), s.startsWith("<Coordinate")) {
            b = l("point");
            const D = b.length % 3;
            D !== 0 && (b = b.slice(0, -D));
          }
          s.startsWith("<Color") && (h = l("color")), s.startsWith("<Box") && (S = -4, ee.warn("Unsupported x3d shape: Box")), s.startsWith("<Cone") && (S = -5, ee.warn("Unsupported x3d shape: Cone")), s.startsWith("<ElevationGrid") && (S = -6, ee.warn("Unsupported x3d shape: ElevationGrid"));
        }
        if (!(S < -3 && S !== -7)) if (S < -1) {
          if (E.length < 1 || b.length < 3 || b.length === void 0) {
            ee.warn("Indexed mesh must specify indices and points");
            break;
          }
          const D = Math.floor(c.length / 3);
          let R = 2;
          if (S === -7) f = [
            ...f,
            ...E
          ];
          else if (S === -2) {
            let L = 0;
            for (; R < E.length; ) E[R] >= 0 ? (f.push(E[L] + D), f.push(E[R - 1] + D), f.push(E[R - 0] + D), R += 1) : (R += 3, L = R - 2);
          } else for (; R < E.length; ) E[R] >= 0 ? (f.push(E[R - 2] + D), f.push(E[R - 1] + D), f.push(E[R - 0] + D), R += 1) : R += 3;
          c = [
            ...c,
            ...b
          ];
          const I = Math.floor(b.length / 3), O = Array(I).fill(m).flat();
          if (h.length === I * 3) {
            let L = 0, N = 0;
            for (let F = 0; F < I; F++) {
              for (let V = 0; V < 3; V++) O[N] = Math.round(h[L] * 255), L++, N++;
              N++;
            }
          }
          u = [
            ...u,
            ...O
          ];
        } else if (S < 0) zc.makeColoredSphere(c, f, u, T, g, m);
        else {
          const D = Yt();
          DE(D, v[3], [
            v[0],
            v[1],
            v[2]
          ]);
          const R = zn(0, -S * 0.5, 0, 1), I = zn(0, +S * 0.5, 0, 1);
          Zr(R, R, D), Zr(I, I, D), Fw(R, R, g), Fw(I, I, g);
          const O = Ue(R[0], R[1], R[2]), L = Ue(I[0], I[1], I[2]);
          zc.makeColoredCylinder(c, f, u, O, L, T, m);
        }
      }
      return {
        positions: Float32Array.from(c),
        indices: Uint32Array.from(f),
        rgba255: Uint8Array.from(u)
      };
    }
    static async readGII(e, n = 0) {
      let r = e.byteLength;
      if (r < 20) throw new Error("File too small to be GII: bytes = " + r);
      let i = new TextDecoder("ascii").decode(e);
      if (i[0].charCodeAt(0) === 31) {
        const N = await ft.decompress(new Uint8Array(e));
        e = N.buffer, i = new TextDecoder("ascii").decode(N.buffer);
      }
      let a = 0;
      function s() {
        let N = true, F = a;
        for (; N; ) {
          for (; a < r && i[a] !== "<"; ) a++;
          for (F = a; a < r && i[a] !== ">"; ) a++;
          if (N = i[a - 1] === "/", F + 1 < r && i[F + 1] === "/" && (a += 1, N = true), a >= r) break;
        }
        const V = new TextDecoder().decode(e.slice(F + 1, a)).trim(), k = V.split(" ")[0].trim(), _ = a;
        let K = a, Z = a;
        if (i[F + 1] !== "?" && i[F + 1] !== "!") {
          const j = "</" + k + ">";
          K = i.indexOf(j, _), Z = K + j.length - 1;
        }
        return {
          name: V,
          startPos: F,
          contentStartPos: _,
          contentEndPos: K,
          endPos: Z
        };
      }
      let o = s();
      if (!o.name.startsWith("?xml")) throw new Error("readGII: Invalid XML file");
      for (; !o.name.startsWith("GIFTI") && o.endPos < r; ) o = s();
      if (!o.name.startsWith("GIFTI") || o.contentStartPos === o.contentEndPos) throw new Error("readGII: XML file does not include GIFTI tag");
      r = o.contentEndPos;
      let l = new Float32Array(), c = new Uint32Array(), f = new Float32Array(), u = "", h = false, g = false, v = false, m = false, y = [
        1,
        1,
        1
      ];
      const w = [
        0,
        0,
        0
      ];
      let C = 0, T = false, S = false, E = 0, b = false;
      o.endPos = o.contentStartPos;
      let D = "";
      function R(N, F = false) {
        const V = D.indexOf(N);
        if (V < 0) return 1;
        const k = D.indexOf('"', V) + 1, _ = D.indexOf('"', k), K = D.slice(k, _);
        return F ? parseFloat(K) : parseInt(K);
      }
      function I(N) {
        const F = D.indexOf(N);
        if (F < 0) return "";
        const V = F + N.length, k = D.indexOf("]", V);
        return D.slice(V, k);
      }
      const O = {
        R: [],
        G: [],
        B: [],
        A: [],
        I: [],
        labels: []
      };
      for (; o.endPos < r && o.name.length > 1; ) {
        if (o = s(), o.name.startsWith("Label Key") && (D = o.name, O.I.push(R("Key=")), O.R.push(Math.round(255 * R("Red=", true))), O.G.push(Math.round(255 * R("Green=", true))), O.B.push(Math.round(255 * R("Blue=", true))), O.A.push(Math.round(255 * R("Alpha", true))), D = new TextDecoder().decode(e.slice(o.contentStartPos + 1, o.contentEndPos)).trim(), O.labels.push(I("<![CDATA["))), o.name.trim() === "Data") {
          if (v) continue;
          D = new TextDecoder().decode(e.slice(o.contentStartPos + 1, o.contentEndPos)).trim();
          let N;
          if (S) {
            const F = y[0] * y[1] * y[2], V = D.split(/\s+/);
            if (F !== V.length) throw new Error("Unable to parse ASCII GIfTI");
            if (C === 2 && (C = 8), C === 32 && (C = 16), C === 8) {
              N = new Int32Array(F);
              for (let k = 0; k < F; k++) N[k] = parseInt(V[k]);
            }
            if (C === 16) {
              N = new Float32Array(F);
              for (let k = 0; k < F; k++) N[k] = parseFloat(V[k]);
            }
          } else if (typeof Buffer > "u") {
            let F = function(V) {
              const k = atob(V), _ = k.length, K = new Uint8Array(_);
              for (let Z = 0; Z < _; Z++) K[Z] = k.charCodeAt(Z);
              return K;
            };
            if (T) {
              const V = F(D.slice());
              N = await ft.decompress(new Uint8Array(V));
            } else N = F(D.slice());
          } else if (T) {
            const F = Buffer.from(D.slice(), "base64");
            N = await ft.decompress(new Uint8Array(F));
          } else N = Buffer.from(D.slice(), "base64");
          if (g) {
            if (C !== 16 && ee.warn("expect positions as FLOAT32"), l = new Float32Array(N.buffer), m) {
              const F = l.slice(), V = F.length / 3;
              let k = 0;
              for (let _ = 0; _ < V; _++) for (let K = 0; K < 3; K++) l[k] = F[K * V + _], k++;
            }
          } else if (h) {
            if (C !== 8 && ee.warn("expect indices as INT32"), c = new Uint32Array(N.buffer), m) {
              const F = c.slice(), V = F.length / 3;
              let k = 0;
              for (let _ = 0; _ < V; _++) for (let K = 0; K < 3; K++) c[k] = F[K * V + _], k++;
            }
          } else {
            let F = function(k, _) {
              const K = k.length, Z = new Float32Array(K + _.length);
              return Z.set(k), Z.set(_, K), Z;
            };
            E = y[0] * y[1] * y[2], n !== 0 && E % n !== 0 && ee.warn("Number of vertices in scalar overlay (" + E + ") does not match mesh (" + n + ")");
            let V;
            if (C === 2) {
              const k = new Uint8Array(N.buffer);
              V = Float32Array.from(k);
            } else if (C === 8) {
              const k = new Int32Array(N.buffer);
              V = Float32Array.from(k);
            } else if (C === 16) V = new Float32Array(N.buffer);
            else if (C === 32) {
              const k = new Float64Array(N.buffer);
              V = Float32Array.from(k);
            } else throw new Error(`Invalid dataType: ${C}`);
            f = F(f, V);
          }
          continue;
        }
        if (o.name.trim() === "DataSpace" && (D = new TextDecoder().decode(e.slice(o.contentStartPos + 1, o.contentEndPos)).trim(), D.includes("NIFTI_XFORM_SCANNER_ANAT") && (b = true)), o.name.trim() === "MD" && (D = new TextDecoder().decode(e.slice(o.contentStartPos + 1, o.contentEndPos)).trim(), D.includes("AnatomicalStructurePrimary") && D.includes("CDATA[") && (u = I("<Value><![CDATA[").toUpperCase()), D.includes("VolGeom") && D.includes("CDATA["))) {
          let N = -1;
          if (D.includes("VolGeomC_R") && (N = 0), D.includes("VolGeomC_A") && (N = 1), D.includes("VolGeomC_S") && (N = 2), N < 0) continue;
          w[N] = parseFloat(I("<Value><![CDATA["));
        }
        o.name.startsWith("DataArray") && (D = o.name, y = [
          1,
          1,
          1
        ], T = D.includes('Encoding="GZipBase64Binary"'), S = D.includes('Encoding="ASCII"'), h = D.includes('Intent="NIFTI_INTENT_TRIANGLE"'), g = D.includes('Intent="NIFTI_INTENT_POINTSET"'), v = D.includes('Intent="NIFTI_INTENT_VECTOR"'), m = D.includes('ArrayIndexingOrder="ColumnMajorOrder"'), D.includes('DataType="NIFTI_TYPE_UINT8"') && (C = 2), D.includes('DataType="NIFTI_TYPE_INT32"') && (C = 8), D.includes('DataType="NIFTI_TYPE_FLOAT32"') && (C = 16), D.includes('DataType="NIFTI_TYPE_FLOAT64"') && (C = 32), y[0] = R("Dim0="), y[1] = R("Dim1="), y[2] = R("Dim2="));
      }
      let L;
      if (O.I.length > 1 && (L = Mn.makeLabelLut(O)), n > 0) return {
        scalars: f,
        colormapLabel: L,
        anatomicalStructurePrimary: u
      };
      if (l.length > 2 && !b && (w[0] !== 0 || w[1] !== 0 || w[2] !== 0)) {
        E = Math.floor(l.length / 3);
        let N = 0;
        for (let F = 0; F < E; F++) l[N] += w[0], N++, l[N] += w[1], N++, l[N] += w[2], N++;
      }
      return {
        positions: l,
        indices: c,
        scalars: f,
        colormapLabel: L,
        anatomicalStructurePrimary: u
      };
    }
  }, u8 = class {
    constructor(t, e, n, r, i) {
      J(this, "text"), J(this, "style"), J(this, "points"), J(this, "anchor"), J(this, "onClick"), this.text = t, this.style = e, this.points = n, this.anchor = r || 0, this.onClick = i;
    }
  }, kv = () => {
    const t = new ArrayBuffer(2);
    return new DataView(t).setInt16(0, 256, true), new Int16Array(t)[0] === 256;
  }, $E = ((t) => (t[t.UNKNOWN = 0] = "UNKNOWN", t[t.NII = 1] = "NII", t[t.DCM = 2] = "DCM", t[t.DCM_MANIFEST = 3] = "DCM_MANIFEST", t[t.MIH = 4] = "MIH", t[t.MIF = 5] = "MIF", t[t.NHDR = 6] = "NHDR", t[t.NRRD = 7] = "NRRD", t[t.MHD = 8] = "MHD", t[t.MHA = 9] = "MHA", t[t.MGH = 10] = "MGH", t[t.MGZ = 11] = "MGZ", t[t.V = 12] = "V", t[t.V16 = 13] = "V16", t[t.VMR = 14] = "VMR", t[t.HEAD = 15] = "HEAD", t[t.DCM_FOLDER = 16] = "DCM_FOLDER", t[t.SRC = 17] = "SRC", t[t.FIB = 18] = "FIB", t[t.BMP = 19] = "BMP", t[t.ZARR = 20] = "ZARR", t[t.NPY = 21] = "NPY", t[t.NPZ = 22] = "NPZ", t))($E || {}), Gt = Object.freeze({
    ...$E,
    parse: (t) => {
      let e = 0;
      switch (t.toUpperCase()) {
        case "":
        case "DCM":
          e = 2;
          break;
        case "TXT":
          e = 3;
          break;
        case "FZ":
        case "GQI":
        case "QSDR":
        case "FIB":
          e = 18;
          break;
        case "NII":
          e = 1;
          break;
        case "MIH":
          e = 4;
          break;
        case "MIF":
          e = 5;
          break;
        case "NHDR":
          e = 6;
          break;
        case "NRRD":
          e = 7;
          break;
        case "MHD":
          e = 8;
          break;
        case "MHA":
          e = 9;
          break;
        case "MGH":
          e = 10;
          break;
        case "MGZ":
          e = 11;
          break;
        case "NPY":
          e = 21;
          break;
        case "NPZ":
          e = 22;
          break;
        case "SRC":
          e = 17;
          break;
        case "V":
          e = 12;
          break;
        case "V16":
          e = 13;
          break;
        case "VMR":
          e = 14;
          break;
        case "HEAD":
          e = 15;
          break;
        case "PNG":
        case "BMP":
        case "GIF":
        case "JPG":
        case "JPEG":
          e = 19;
          break;
        case "ZARR":
          e = 20;
          break;
      }
      return e;
    }
  }), Cg = (t, e = "", n = "", r = "gray", i = 1, a = NaN, s = NaN, o = true, l = 0.02, c = false, f = false, u = "", h = 0, g = Gt.UNKNOWN, v = NaN, m = NaN, y = true, w = false, C = null) => ({
    url: t,
    urlImageData: e,
    name: n,
    colormap: r,
    colorMap: r,
    opacity: i,
    cal_min: a,
    cal_max: s,
    trustCalMinMax: o,
    percentileFrac: l,
    ignoreZeroVoxels: c,
    useQFormNotSForm: f,
    colormapNegative: u,
    imageType: g,
    cal_minNeg: v,
    cal_maxNeg: m,
    colorbarVisible: y,
    frame4D: h,
    alphaThreshold: w,
    colormapLabel: C
  });
  function tC(t, e = 80) {
    t = t.replace(/[`$]/g, "");
    const n = [], r = Math.min(e, t.length);
    for (let i = 0; i < r; i++) {
      const a = t.charCodeAt(i);
      n.push(a & 255);
    }
    return n;
  }
  function rp(t, e = false, n = false) {
    let a = true;
    n && (a = t.littleEndian);
    const s = new Uint8Array(348), o = new DataView(s.buffer);
    o.setInt32(0, 348, a), o.setUint8(38, 114), o.setUint8(39, t.dim_info);
    for (let c = 0; c < 8; c++) o.setUint16(40 + 2 * c, t.dims[c], a);
    o.setFloat32(56, t.intent_p1, a), o.setFloat32(60, t.intent_p2, a), o.setFloat32(64, t.intent_p3, a), o.setInt16(68, t.intent_code, a), e ? (o.setInt16(70, 2, a), o.setInt16(72, 8, a)) : (o.setInt16(70, t.datatypeCode, a), o.setInt16(72, t.numBitsPerVoxel, a)), o.setInt16(74, t.slice_start, a);
    for (let c = 0; c < 8; c++) o.setFloat32(76 + 4 * c, t.pixDims[c], a);
    e ? (o.setFloat32(108, 352, a), o.setFloat32(112, 1, a), o.setFloat32(116, 0, a)) : (o.setFloat32(108, t.vox_offset, a), o.setFloat32(112, t.scl_slope, a), o.setFloat32(116, t.scl_inter, a)), o.setInt16(120, t.slice_end, a), o.setUint8(122, t.slice_code), t.xyzt_units === 0 ? o.setUint8(123, 10) : o.setUint8(123, t.xyzt_units), e ? (o.setFloat32(124, 0, a), o.setFloat32(128, 0, a)) : (o.setFloat32(124, t.cal_max, a), o.setFloat32(128, t.cal_min, a)), o.setFloat32(132, t.slice_duration, a), o.setFloat32(136, t.toffset, a), s.set(tC(t.description), 148), s.set(tC(t.aux_file), 228), o.setInt16(252, t.qform_code, a), t.sform_code < 1 || t.sform_code < 1 ? o.setInt16(254, 1, a) : o.setInt16(254, t.sform_code, a), o.setFloat32(256, t.quatern_b, a), o.setFloat32(260, t.quatern_c, a), o.setFloat32(264, t.quatern_d, a), o.setFloat32(268, t.qoffset_x, a), o.setFloat32(272, t.qoffset_y, a), o.setFloat32(276, t.qoffset_z, a);
    const l = t.affine.flat();
    for (let c = 0; c < 12; c++) o.setFloat32(280 + 4 * c, l[c], a);
    return o.setInt32(344, 3222382, true), s;
  }
  function RG(t, e = true) {
    const n = Math.round(t.length / 3), r = Ue(0, 0, 0), i = He(), a = He();
    let s = 0, o = 1;
    e && (o = 2);
    for (let u = 0; u < o; u++) {
      s = 0;
      for (let g = 0; g < n; g++) {
        const v = Ue(t[g * 3], t[g * 3 + 1], t[g * 3 + 2]);
        g === 0 && (Du(i, v), Du(a, v)), z6(i, i, v), W6(a, a, v), Ft(v, v, r);
        const m = Pc(v);
        s = Math.max(s, m);
      }
      if (u + 1 >= o) break;
      let h = true;
      for (let g = 0; g < 3; ++g) i[g] > r[g] && (h = false), a[g] < r[g] && (h = false);
      if (h) break;
      D_(r, i, a, 0.5), ee.debug("origin moved inside volume: ", r);
    }
    const l = [
      i[0],
      i[1],
      i[2]
    ], c = [
      a[0],
      a[1],
      a[2]
    ];
    return {
      min: l,
      max: c,
      furthestVertexFromOrigin: s,
      origin: r
    };
  }
  function nC(t) {
    const e = [
      false,
      false,
      false,
      false
    ], n = [
      false,
      false,
      false,
      false
    ];
    for (let r = 0; r < 4; r++) for (let i = 0; i < 4; i++) if (isNaN(t[r][i])) return false;
    for (let r = 0; r < 3; r++) for (let i = 0; i < 3; i++) t[r][i] !== 0 && (e[r] = true, n[i] = true);
    for (let r = 0; r < 3; r++) if (!e[r] || !n[r]) return false;
    return true;
  }
  async function e4(t) {
    const e = t.getReader(), { done: n, value: r } = await e.read();
    if (n) return e.releaseLock(), new ReadableStream({
      start(s) {
        s.close();
      }
    });
    if (!r || r.length < 2) return e.releaseLock(), new ReadableStream({
      start(s) {
        r && s.enqueue(r), s.close();
      }
    });
    const i = r[0] === 31 && r[1] === 139, a = new ReadableStream({
      async start(s) {
        try {
          for (s.enqueue(r); ; ) {
            const { done: o, value: l } = await e.read();
            if (o) {
              s.close(), e.releaseLock();
              break;
            }
            s.enqueue(l);
          }
        } catch (o) {
          s.error(o), e.releaseLock();
        }
      }
    });
    return i ? a.pipeThrough(new DecompressionStream("gzip")) : a;
  }
  function eb(t = [
    256,
    256,
    256
  ], e = [
    1,
    1,
    1
  ], n = [
    1,
    0,
    0,
    -128,
    0,
    1,
    0,
    -128,
    0,
    0,
    1,
    -128,
    0,
    0,
    0,
    1
  ], r = 2) {
    const i = new tt();
    i.littleEndian = true, i.dims = [
      3,
      1,
      1,
      1,
      0,
      0,
      0,
      0
    ], i.dims[0] = Math.max(3, t.length);
    for (let s = 0; s < t.length; s++) i.dims[s + 1] = t[s];
    i.pixDims = [
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ];
    for (let s = 0; s < t.length; s++) i.pixDims[s + 1] = e[s];
    if (n.length === 16) {
      let s = 0;
      for (let o = 0; o < 4; o++) for (let l = 0; l < 4; l++) i.affine[o][l] = n[s], s++;
    }
    let a = 8;
    return r === 256 || r === 2 ? a = 8 : r === 512 || r === 4 ? a = 16 : r === 16 || r === 768 || r === 8 || r === 2304 ? a = 32 : r === 64 ? a = 64 : ee.warn("Unsupported NIfTI datatypeCode for header creation: " + r), i.datatypeCode = r, i.numBitsPerVoxel = a, i.scl_inter = 0, i.scl_slope = 1, i.sform_code = 2, i.magic = "n+1", i.vox_offset = 352, i;
  }
  function OG(t = [
    256,
    256,
    256
  ], e = [
    1,
    1,
    1
  ], n = [
    1,
    0,
    0,
    -128,
    0,
    1,
    0,
    -128,
    0,
    0,
    1,
    -128,
    0,
    0,
    0,
    1
  ], r = 2, i = new Uint8Array()) {
    const a = eb(t, e, n, r), s = rp(a, false);
    a.vox_offset = Math.max(352, s.length);
    const o = rp(a, false);
    if (i.length < 1) return o;
    const l = Math.max(0, a.vox_offset - o.length), c = new Uint8Array(l), f = new Uint8Array(i.buffer, i.byteOffset, i.byteLength), u = a.vox_offset + f.length, h = new Uint8Array(u);
    return h.set(o, 0), h.set(c, o.length), h.set(f, a.vox_offset), h;
  }
  function tb(t, e = null) {
    if (!t.hdr) throw new Error("NVImage header is not defined for toUint8Array");
    if (!t.img && e === null) throw new Error("NVImage image data is not defined for toUint8Array");
    const n = e !== null, r = JSON.parse(JSON.stringify(t.hdr)), i = t.extensions && t.extensions.length > 0, a = new Uint8Array(4);
    a[0] = i ? 1 : 0;
    let s = new Uint8Array(0);
    if (i) {
      const y = [];
      let w = 0;
      for (const T of t.extensions) {
        const S = new Uint8Array(T.edata), E = new Uint8Array(8 + S.length), b = new DataView(E.buffer);
        b.setInt32(0, T.esize, true), b.setInt32(4, T.ecode, true), E.set(S, 8), y.push(E), w += E.length;
      }
      s = new Uint8Array(w);
      let C = 0;
      for (const T of y) s.set(T, C), C += T.length;
    }
    const o = 348;
    r.vox_offset = Math.max(352, o + a.length + s.length), n && (r.datatypeCode = 2, r.numBitsPerVoxel = 8, r.scl_slope = 1, r.scl_inter = 0);
    const l = rp(r, n);
    let c;
    if (n) {
      const y = e, w = t.permRAS;
      if (w && (w[0] !== 1 || w[1] !== 2 || w[2] !== 3)) {
        ee.debug("Reorienting drawing bytes back to native space for saving...");
        const C = t.hdr.dims, T = C[1] * C[2] * C[3], S = t.dimsRAS ? t.dimsRAS[1] * t.dimsRAS[2] * t.dimsRAS[3] : T;
        if (y.length !== S) console.warn(`Drawing length (${y.length}) does not match expected RAS voxel count (${S}). Cannot reorient drawing reliably.`), c = y;
        else if (!t.img2RASstep || !t.img2RASstart || !t.dimsRAS) console.warn("Missing RAS transformation info (img2RASstep, img2RASstart, dimsRAS). Cannot reorient drawing reliably."), c = y;
        else {
          const E = t.img2RASstep, b = t.img2RASstart, D = t.dimsRAS, R = new Uint8Array(T);
          R.fill(0);
          const I = y;
          let O = 0;
          for (let L = 0; L < D[3]; L++) {
            const N = b[2] + L * E[2];
            for (let F = 0; F < D[2]; F++) {
              const V = b[1] + F * E[1];
              for (let k = 0; k < D[1]; k++) {
                const K = b[0] + k * E[0] + V + N;
                K >= 0 && K < T ? R[K] = I[O] : O < I.length && console.warn(`Calculated native index ${K} is out of bounds [0..${T - 1}] during drawing reorientation.`), O++;
              }
            }
          }
          c = R;
        }
      } else c = y;
    } else {
      if (!t.img) throw new Error("NVImage image data is null when trying to save non-drawing.");
      c = new Uint8Array(t.img.buffer, t.img.byteOffset, t.img.byteLength);
    }
    const f = l.length + a.length + s.length, u = Math.max(0, r.vox_offset - f), h = new Uint8Array(u), g = r.vox_offset + c.length, v = new Uint8Array(g);
    let m = 0;
    return v.set(l, m), m += l.length, v.set(a, m), m += a.length, v.set(s, m), m += s.length, v.set(h, m), m += h.length, v.set(c, r.vox_offset), v;
  }
  async function nb(t, e, n = null) {
    const r = tb(t, n);
    if (e.toLowerCase().endsWith(".gz")) try {
      const a = await ft.compress(r, "gzip");
      return new Uint8Array(a);
    } catch (a) {
      return ee.error("Compression failed:", a), ee.warn("Returning uncompressed data due to compression error."), r;
    }
    else return r;
  }
  async function IG(t, e = "", n = null) {
    const r = await nb(t, e, n);
    if (!e) return ee.debug("saveToDisk: empty file name, returning data as Uint8Array rather than triggering download"), r;
    try {
      const i = new Blob([
        r.buffer
      ], {
        type: "application/octet-stream"
      }), a = URL.createObjectURL(i), s = document.createElement("a");
      s.setAttribute("href", a), s.setAttribute("download", e), s.style.visibility = "hidden", document.body.appendChild(s), s.click(), document.body.removeChild(s), setTimeout(() => URL.revokeObjectURL(a), 100);
    } catch (i) {
      ee.error("Failed to trigger download:", i);
    }
    return r;
  }
  function rb(t, e, n, r, i = 0, a = false) {
    if (!t.hdr) throw new Error("getValue: NVImage header is not defined.");
    if (!a && !t.img) throw new Error("getValue: NVImage image data is not defined.");
    if (a && !t.imaginary) return ee.warn("getValue: Attempted to read imaginary data, but none exists."), [
      0
    ];
    const s = t.hdr.dims[1], o = t.hdr.dims[2], l = t.hdr.dims[3], c = t.permRAS.slice();
    if (c[0] !== 1 || c[1] !== 2 || c[2] !== 3) {
      const C = zn(e, n, r, 1);
      Zr(C, C, t.toRASvox), e = C[0], n = C[1], r = C[2];
    }
    e = Math.max(0, Math.min(Math.round(e), s - 1)), n = Math.max(0, Math.min(Math.round(n), o - 1)), r = Math.max(0, Math.min(Math.round(r), l - 1)), i = Math.max(0, i);
    let f = e + n * s + r * s * o;
    if (t.hdr.datatypeCode === 2304) return t.img ? (f *= 4, f + 3 >= t.img.length ? (ee.warn(`getValue: Calculated index ${f} out of bounds for RGBA data.`), [
      0
    ]) : [
      t.img[f],
      t.img[f + 1],
      t.img[f + 2],
      t.img[f + 3]
    ]) : [
      0
    ];
    if (t.hdr.datatypeCode === 128) return t.img ? (f *= 3, f + 2 >= t.img.length ? (ee.warn(`getValue: Calculated index ${f} out of bounds for RGB data.`), [
      0
    ]) : [
      t.img[f],
      t.img[f + 1],
      t.img[f + 2]
    ]) : [
      0
    ];
    const u = s * o * l, h = i * u, g = f + h, v = a ? t.imaginary : t.img;
    if (g < 0 || g >= v.length) return [
      0
    ];
    const m = v[g], y = isNaN(t.hdr.scl_slope) || t.hdr.scl_slope === 0 ? 1 : t.hdr.scl_slope, w = isNaN(t.hdr.scl_inter) ? 0 : t.hdr.scl_inter;
    return [
      y * m + w
    ];
  }
  function VG(t, e, n, r, i = 0, a = false) {
    const s = rb(t, e, n, r, i, a);
    return s.length < 3 ? s[0] : s[0] * 0.2126 + s[1] * 0.7152 + s[2] * 0.0722;
  }
  function NG(t, e = [
    -1,
    0,
    0
  ], n = [
    0,
    0,
    0
  ], r = "same") {
    const i = [
      new Uint8Array(),
      [
        0,
        0,
        0
      ]
    ];
    if (!t.hdr || !t.img || !t.dimsRAS || !t.img2RASstep || !t.img2RASstart) return ee.error("getVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start)."), i;
    if (e = e.slice(0, 3), n = n.slice(0, 3), Math.min(...e) < 0 || Math.min(...n) < 0) return ee.warn("getVolumeData: Invalid start or end coordinates provided."), i;
    const a = t.dimsRAS.slice(1, 4);
    for (let y = 0; y < 3; y++) if (e[y] = Math.max(0, Math.min(Math.round(e[y]), a[y] - 1)), n[y] = Math.max(0, Math.min(Math.round(n[y]), a[y] - 1)), n[y] < e[y]) {
      const w = n[y];
      n[y] = e[y], e[y] = w;
    }
    const s = [
      n[0] - e[0] + 1,
      n[1] - e[1] + 1,
      n[2] - e[2] + 1
    ], o = s[0] * s[1] * s[2];
    if (o <= 0) return ee.warn("getVolumeData: Calculated slab size is zero or negative."), i;
    let l = t.img.constructor;
    r === "uint8" ? l = Uint8Array : r === "int16" ? l = Int16Array : r === "uint16" ? l = Uint16Array : r === "float32" || r === "scaled" || r === "normalized" || r === "windowed" ? l = Float32Array : r === "float64" ? l = Float64Array : r !== "same" && ee.warn(`getVolumeData: Unsupported dataType '${r}'. Using 'same'.`);
    let c;
    try {
      c = new l(o);
    } catch (y) {
      return ee.error(`getVolumeData: Failed to create output array for dataType '${r}'.`, y), i;
    }
    const f = t.img2RASstep, u = t.img2RASstart, h = t.img;
    let g = 0;
    for (let y = e[2]; y <= n[2]; y++) {
      const w = u[2] + y * f[2];
      for (let C = e[1]; C <= n[1]; C++) {
        const T = u[1] + C * f[1];
        for (let S = e[0]; S <= n[0]; S++) {
          const b = u[0] + S * f[0] + T + w;
          let D = 0;
          b >= 0 && b < h.length && (D = h[b]), c[g++] = D;
        }
      }
    }
    const v = isNaN(t.hdr.scl_slope) || t.hdr.scl_slope === 0 ? 1 : t.hdr.scl_slope, m = isNaN(t.hdr.scl_inter) ? 0 : t.hdr.scl_inter;
    if (r === "scaled" || r === "normalized" || r === "windowed") {
      c instanceof Float32Array || (ee.warn(`getVolumeData: Converting output to Float32 for scaling type '${r}'.`), c = Float32Array.from(c));
      for (let y = 0; y < c.length; y++) c[y] = c[y] * v + m;
    }
    if (r === "normalized" || r === "windowed") {
      let y = t.cal_min, w = t.cal_max;
      r === "normalized" && (y = t.global_min, w = t.global_max);
      const C = w - y, T = C === 0 ? 0 : 1 / C;
      for (let S = 0; S < c.length; S++) c[S] = (c[S] - y) * T, c[S] = Math.max(0, Math.min(c[S], 1));
    }
    return [
      c,
      s
    ];
  }
  function LG(t, e = [
    -1,
    0,
    0
  ], n = [
    0,
    0,
    0
  ], r = new Uint8Array()) {
    if (!t.hdr || !t.img || !t.dimsRAS || !t.img2RASstep || !t.img2RASstart) {
      ee.error("setVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start).");
      return;
    }
    if (r.length < 1) {
      ee.warn("setVolumeData: Input slabData is empty.");
      return;
    }
    if (e = e.slice(0, 3), n = n.slice(0, 3), Math.min(...e) < 0 || Math.min(...n) < 0) {
      ee.warn("setVolumeData: Invalid start or end coordinates provided.");
      return;
    }
    const i = t.dimsRAS.slice(1, 4);
    for (let u = 0; u < 3; u++) if (e[u] = Math.max(0, Math.min(Math.round(e[u]), i[u] - 1)), n[u] = Math.max(0, Math.min(Math.round(n[u]), i[u] - 1)), n[u] < e[u]) {
      const h = n[u];
      n[u] = e[u], e[u] = h;
    }
    const a = [
      n[0] - e[0] + 1,
      n[1] - e[1] + 1,
      n[2] - e[2] + 1
    ], s = a[0] * a[1] * a[2];
    if (s <= 0) {
      ee.warn("setVolumeData: Calculated slab size is zero or negative.");
      return;
    }
    if (r.length < s) {
      ee.error(`setVolumeData: Input slabData length (${r.length}) is less than the calculated slab size (${s}).`);
      return;
    }
    const o = t.img2RASstep, l = t.img2RASstart, c = t.img;
    let f = 0;
    for (let u = e[2]; u <= n[2]; u++) {
      const h = l[2] + u * o[2];
      for (let g = e[1]; g <= n[1]; g++) {
        const v = l[1] + g * o[1];
        for (let m = e[0]; m <= n[0]; m++) {
          const w = l[0] + m * o[0] + v + h;
          w >= 0 && w < c.length && (c[w] = r[f]), f++;
        }
      }
    }
  }
  var ib = {};
  u5(ib, {
    isFreeSurferLabelImage: () => sb,
    optimizeFreeSurferLabels: () => ab,
    readMgh: () => UG
  });
  function rC(t, e, n, r = 1) {
    const i = e + n;
    let a = e;
    const s = [];
    for (; a + 12 <= i; ) {
      const o = t.getInt32(a, false), l = t.getInt32(a + 8, false);
      if (a += 12, l <= 0 || a + l > i) break;
      if (o !== r) {
        a += l;
        continue;
      }
      let c = l, f = a;
      if (r === 1) {
        if (a + 4 > i) break;
        c = t.getInt32(a, false), f += 4;
      }
      if (c > 1 && f + c <= i) {
        const u = new Uint8Array(t.buffer, f, c), h = new TextDecoder("utf-8").decode(u.slice(0, -1));
        s.push(h);
      }
      a += l;
    }
    return s.join(`

`);
  }
  function ab(t, e) {
    if (t.intent_code = 1002, t.datatypeCode !== 16 && t.datatypeCode !== 8) return e;
    let n = new Float32Array(e);
    if (t.datatypeCode === 8 && (n = new Int32Array(e)), kv()) {
      const s = new Uint32Array(e);
      for (let o = 0; o < s.length; o++) {
        const l = s[o];
        s[o] = (l & 255) << 24 | (l & 65280) << 8 | (l & 16711680) >>> 8 | (l & 4278190080) >>> 24;
      }
    }
    t.littleEndian = kv();
    let r = true, i = 1 / 0, a = -1 / 0;
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      Number.isFinite(o) && (Number.isInteger(o) || (r = false), o < i && (i = o), o > a && (a = o));
    }
    if (!r || i < 0 || a > 2147483647) return ee.warn(`FreeSurfer Labels must be integers in INT32 range. range ${i}..${a}`), e;
    if (a > 32767) {
      t.datatypeCode = 8;
      const s = new Int32Array(n.length);
      for (let o = 0; o < n.length; o++) s[o] = Math.trunc(n[o]);
      return s.buffer;
    } else if (a > 255) {
      t.datatypeCode = 4, t.numBitsPerVoxel = 16;
      const s = new Int16Array(n.length);
      for (let o = 0; o < n.length; o++) s[o] = Math.trunc(n[o]);
      return s.buffer;
    } else {
      t.datatypeCode = 2, t.numBitsPerVoxel = 8;
      const s = new Uint8Array(n.length);
      for (let o = 0; o < n.length; o++) s[o] = Math.trunc(n[o]);
      return s.buffer;
    }
  }
  function sb(t, e, n) {
    const r = t.byteLength - e.vox_offset;
    if (r < n) return ee.error(`MGH image data size mismatch: expected ${n}, found ${r}`), false;
    if (r === n) return false;
    const i = e.vox_offset + n + 20, a = t.byteLength - i;
    return a <= 12 ? false : rC(new DataView(t), i, a).toLowerCase().endsWith("lut.txt") ? true : rC(new DataView(t), i, a, 3).includes("mri_label2vol");
  }
  async function UG(t, e) {
    t.hdr || (ee.debug("readMgh called before nvImage.hdr was initialized. Creating default."), t.hdr = new tt());
    const n = t.hdr;
    n.littleEndian = false;
    let r = e, i = new DataView(r);
    if (r.byteLength >= 2 && i.getUint8(0) === 31 && i.getUint8(1) === 139) try {
      r = await ft.decompressToBuffer(new Uint8Array(e)), i = new DataView(r);
    } catch (Z) {
      return ee.error("Failed to decompress MGZ file.", Z), null;
    }
    if (r.byteLength < 284) return ee.error("File too small to be a valid MGH/MGZ header."), null;
    const a = i.getInt32(0, false), s = i.getInt32(4, false), o = i.getInt32(8, false), l = i.getInt32(12, false), c = i.getInt32(16, false), f = i.getInt32(20, false), u = i.getFloat32(30, false), h = i.getFloat32(34, false), g = i.getFloat32(38, false), v = i.getFloat32(42, false), m = i.getFloat32(46, false), y = i.getFloat32(50, false), w = i.getFloat32(54, false), C = i.getFloat32(58, false), T = i.getFloat32(62, false), S = i.getFloat32(66, false), E = i.getFloat32(70, false), b = i.getFloat32(74, false), D = i.getFloat32(78, false), R = i.getFloat32(82, false), I = i.getFloat32(86, false);
    if (a !== 1 && ee.warn(`Unexpected MGH version: ${a}.`), s <= 0 || o <= 0 || l <= 0) return ee.error(`Invalid MGH dimensions: ${s}x${o}x${l}`), null;
    switch (f) {
      case 0:
        n.numBitsPerVoxel = 8, n.datatypeCode = 2;
        break;
      case 4:
        n.numBitsPerVoxel = 16, n.datatypeCode = 4;
        break;
      case 1:
        n.numBitsPerVoxel = 32, n.datatypeCode = 8;
        break;
      case 3:
        n.numBitsPerVoxel = 32, n.datatypeCode = 16;
        break;
      default:
        return ee.error(`Unsupported MGH data type: ${f}`), null;
    }
    n.dims[1] = s, n.dims[2] = o, n.dims[3] = l, n.dims[4] = Math.max(1, c), n.dims[0] = n.dims[4] > 1 ? 4 : 3, n.pixDims[1] = Math.abs(u), n.pixDims[2] = Math.abs(h), n.pixDims[3] = Math.abs(g), n.pixDims[4] = 0, n.sform_code = 1, n.qform_code = 0;
    const O = Qi(v * n.pixDims[1], w * n.pixDims[2], S * n.pixDims[3], 0, m * n.pixDims[1], C * n.pixDims[2], E * n.pixDims[3], 0, y * n.pixDims[1], T * n.pixDims[2], b * n.pixDims[3], 0, 0, 0, 0, 1), L = zn(n.dims[1] / 2, n.dims[2] / 2, n.dims[3] / 2, 1), N = Rs();
    Zr(N, L, O);
    const F = Ue(D - N[0], R - N[1], I - N[2]);
    n.affine = [
      [
        O[0],
        O[1],
        O[2],
        F[0]
      ],
      [
        O[4],
        O[5],
        O[6],
        F[1]
      ],
      [
        O[8],
        O[9],
        O[10],
        F[2]
      ],
      [
        0,
        0,
        0,
        1
      ]
    ], n.vox_offset = 284, n.magic = "n+1";
    const V = n.numBitsPerVoxel / 8, _ = s * o * l * n.dims[4] * V, K = r.slice(n.vox_offset, n.vox_offset + _);
    return sb(r, n, _) ? ab(n, K) : K;
  }
  var ob = {};
  u5(ob, {
    readNifti: () => FG
  });
  async function FG(t, e) {
    let n = e, r = null;
    try {
      if (Q6(n) && (ee.debug(`Decompressing NIfTI file: ${t.name}`), n = await ck(n), ee.debug(`Decompression complete for: ${t.name}`)), !n || n.byteLength === 0) throw new Error("Buffer became invalid after decompression attempt.");
      if (t.hdr = await F1(n), fk(t.hdr) && (t.extensions = t.hdr.extensions), t.hdr === null) throw new Error(`Failed to read NIfTI header: ${t.name}`);
      if (t.hdr.cal_min === 0 && t.hdr.cal_max === 255 && t.hdr.datatypeCode !== 2 && (ee.debug(`Resetting suspicious cal_min/max (0/255) for non-uint8 NIfTI: ${t.name}`), t.hdr.cal_min = 0, t.hdr.cal_max = 0), r = hk(t.hdr, n), r === null) throw new Error(`nifti-reader-js readImage returned null for ${t.name}`);
      return r;
    } catch (i) {
      return ee.error(`Error processing NIfTI file ${t.name}:`, i), t.hdr = null, null;
    }
  }
  var lb = {};
  u5(lb, {
    readNrrd: () => BG
  });
  async function BG(t, e, n = null) {
    t.hdr || (ee.warn("readNrrd called before nvImage.hdr was initialized. Creating default."), t.hdr = new tt());
    const r = t.hdr;
    r.pixDims = [
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ];
    const i = e.byteLength;
    let a = null;
    const s = new Uint8Array(e);
    for (let b = 1; b < i; b++) if (s[b - 1] === 10 && s[b] === 10) {
      const D = e.slice(0, b - 1);
      a = new TextDecoder().decode(D), r.vox_offset = b + 1;
      break;
    }
    if (a === null) return ee.error("readNrrd: could not extract txt"), null;
    const o = a.split(`
`);
    if (!o[0].startsWith("NRRD")) return ee.error("Invalid NRRD image (magic signature missing)"), null;
    const l = o.length;
    let c = false, f = false, u = false;
    const h = as(NaN, 0, 0, 0, 1, 0, 0, 0, 1), g = Ue(0, 0, 0);
    let v = S_();
    for (let b = 1; b < l; b++) {
      let D = o[b];
      if ((D.length === 0 || D[0] === "#") && (D.startsWith("#") || D.trim().length === 0)) continue;
      D = D.toLowerCase();
      const R = D.split(":");
      if (R.length < 2) continue;
      const I = R[0].trim();
      let O = R[1].trim();
      switch (O = O.replaceAll(")", " "), O = O.replaceAll("(", " "), O = O.trim(), I) {
        case "data file":
          u = true;
          break;
        case "encoding":
          if (O.includes("raw")) c = false;
          else if (O.includes("gz")) c = true;
          else return ee.error("Unsupported NRRD encoding"), null;
          break;
        case "type":
          switch (O) {
            case "uchar":
            case "unsigned char":
            case "uint8":
            case "uint8_t":
              r.numBitsPerVoxel = 8, r.datatypeCode = 2;
              break;
            case "signed char":
            case "int8":
            case "int8_t":
              r.numBitsPerVoxel = 8, r.datatypeCode = 256;
              break;
            case "short":
            case "short int":
            case "signed short":
            case "signed short int":
            case "int16":
            case "int16_t":
              r.numBitsPerVoxel = 16, r.datatypeCode = 4;
              break;
            case "ushort":
            case "unsigned short":
            case "unsigned short int":
            case "uint16":
            case "uint16_t":
              r.numBitsPerVoxel = 16, r.datatypeCode = 512;
              break;
            case "int":
            case "signed int":
            case "int32":
            case "int32_t":
              r.numBitsPerVoxel = 32, r.datatypeCode = 8;
              break;
            case "uint":
            case "unsigned int":
            case "uint32":
            case "uint32_t":
              r.numBitsPerVoxel = 32, r.datatypeCode = 768;
              break;
            case "float":
              r.numBitsPerVoxel = 32, r.datatypeCode = 16;
              break;
            case "double":
              r.numBitsPerVoxel = 64, r.datatypeCode = 64;
              break;
            default:
              return ee.error("Unsupported NRRD data type: " + O), null;
          }
          break;
        case "spacings":
          {
            const L = O.split(/[ ,]+/);
            for (let N = 0; N < L.length; N++) r.pixDims[N + 1] = parseFloat(L[N]);
          }
          break;
        case "sizes":
          {
            const L = O.split(/[ ,]+/);
            r.dims[0] = L.length;
            for (let N = 0; N < L.length; N++) r.dims[N + 1] = parseInt(L[N]);
          }
          break;
        case "endian":
          O.includes("little") ? r.littleEndian = true : O.includes("big") && (r.littleEndian = false);
          break;
        case "space directions":
          {
            const L = O.split(/[ ,]+/);
            if (L.length === 9) for (let N = 0; N < 9; N++) h[N] = parseFloat(L[N]);
          }
          break;
        case "space origin":
          {
            const L = O.split(/[ ,]+/);
            L.length === 3 && (g[0] = parseFloat(L[0]), g[1] = parseFloat(L[1]), g[2] = parseFloat(L[2]));
          }
          break;
        case "space units":
          O.includes("microns") && (f = true);
          break;
        case "space":
          O.includes("right-anterior-superior") || O.includes("ras") ? v = as(1, 0, 0, 0, 1, 0, 0, 0, 1) : O.includes("left-anterior-superior") || O.includes("las") ? v = as(-1, 0, 0, 0, 1, 0, 0, 0, 1) : O.includes("left-posterior-superior") || O.includes("lps") ? v = as(-1, 0, 0, 0, -1, 0, 0, 0, 1) : ee.warn("Unsupported NRRD space value:", O);
          break;
        default:
          ee.warn("Unknown:", I);
          break;
      }
    }
    if (!isNaN(h[0])) {
      r.sform_code = 2, f && (b_(h, h, 1e-3), g[0] *= 1e-3, g[1] *= 1e-3, g[2] *= 1e-3), v[0] < 0 && (g[0] = -g[0]), v[4] < 0 && (g[1] = -g[1]), v[8] < 0 && (g[2] = -g[2]), bE(h, v, h);
      const b = Qi(h[0], h[3], h[6], g[0], h[1], h[4], h[7], g[1], h[2], h[5], h[8], g[2], 0, 0, 0, 1);
      if (!t.vox2mm) return null;
      const D = t.vox2mm([
        0,
        0,
        0
      ], b), R = t.vox2mm([
        1,
        0,
        0
      ], b);
      Ft(R, R, D);
      const I = t.vox2mm([
        0,
        1,
        0
      ], b);
      Ft(I, I, D);
      const O = t.vox2mm([
        0,
        0,
        1
      ], b);
      Ft(O, O, D), r.pixDims[1] = Ms(R), r.pixDims[2] = Ms(I), r.pixDims[3] = Ms(O), r.affine = [
        [
          b[0],
          b[1],
          b[2],
          b[3]
        ],
        [
          b[4],
          b[5],
          b[6],
          b[7]
        ],
        [
          b[8],
          b[9],
          b[10],
          b[11]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ];
    }
    let m = null;
    const y = u ? n : e, w = u ? 0 : r.vox_offset;
    if (u && !y) return ee.warn("Missing data: NRRD header describes detached data file but only one URL provided"), null;
    if (!y || w >= y.byteLength) return ee.error(`NRRD data offset (${w}) invalid for buffer length (${(y == null ? void 0 : y.byteLength) ?? 0})`), null;
    let C = y.slice(w);
    if (c) try {
      ee.debug("Decompressing NRRD data..."), C = await ft.decompressToBuffer(new Uint8Array(C)), ee.debug("Decompression complete.");
    } catch (b) {
      return ee.error("Failed to decompress NRRD data.", b), null;
    }
    const T = r.numBitsPerVoxel / 8, E = r.dims.slice(1, r.dims[0] + 1).reduce((b, D) => b * Math.max(1, D), 1) * T;
    return C.byteLength < E ? (ee.error(`NRRD image data size mismatch: expected ${E}, found ${C.byteLength}`), null) : (C.byteLength > E && (ee.warn(`NRRD has extra ${C.byteLength - E} bytes after expected image data. Truncating.`), C = C.slice(0, E)), m = C, r.datatypeCode ? r.numBitsPerVoxel ? m : (ee.error("NRRD parsing failed to set numBitsPerVoxel."), null) : (ee.error("NRRD parsing failed to set datatypeCode."), null));
  }
  var Ci = class Tg {
    constructor(e = null, n = "", r = "gray", i = 1, a = null, s = NaN, o = NaN, l = true, c = 0.02, f = false, u = false, h = "", g = 0, v = Gt.UNKNOWN, m = NaN, y = NaN, w = true, C = null, T = 0) {
      J(this, "name"), J(this, "id"), J(this, "url"), J(this, "headers"), J(this, "_colormap"), J(this, "_opacity"), J(this, "percentileFrac"), J(this, "ignoreZeroVoxels"), J(this, "trustCalMinMax"), J(this, "colormapNegative"), J(this, "colormapLabel"), J(this, "colormapInvert"), J(this, "nFrame4D"), J(this, "frame4D"), J(this, "nTotalFrame4D"), J(this, "cal_minNeg"), J(this, "cal_maxNeg"), J(this, "colorbarVisible", true), J(this, "modulationImage", null), J(this, "modulateAlpha", 0), J(this, "series", []), J(this, "nVox3D"), J(this, "oblique_angle"), J(this, "maxShearDeg"), J(this, "useQFormNotSForm"), J(this, "colormapType"), J(this, "pixDims"), J(this, "matRAS"), J(this, "pixDimsRAS"), J(this, "obliqueRAS"), J(this, "dimsRAS"), J(this, "permRAS"), J(this, "img2RASstep"), J(this, "img2RASstart"), J(this, "toRAS"), J(this, "toRASvox"), J(this, "frac2mm"), J(this, "frac2mmOrtho"), J(this, "extentsMinOrtho"), J(this, "extentsMaxOrtho"), J(this, "mm2ortho"), J(this, "hdr", null), J(this, "extensions"), J(this, "imageType"), J(this, "img"), J(this, "imaginary"), J(this, "v1"), J(this, "fileObject"), J(this, "dims"), J(this, "onColormapChange", () => {
      }), J(this, "onOpacityChange", () => {
      }), J(this, "mm000"), J(this, "mm100"), J(this, "mm010"), J(this, "mm001"), J(this, "cal_min"), J(this, "cal_max"), J(this, "robust_min"), J(this, "robust_max"), J(this, "global_min"), J(this, "global_max"), J(this, "urlImgData"), J(this, "isManifest"), J(this, "limitFrames4D"), this.init(e, n, r, i, a, s, o, l, c, f, u, h, g, v, m, y, w, C, T);
    }
    init(e = null, n = "", r = "", i = 1, a = null, s = NaN, o = NaN, l = true, c = 0.02, f = false, u = false, h = "", g = 0, v = Gt.UNKNOWN, m = NaN, y = NaN, w = true, C = null, T = 0, S = null) {
      const E = r === "";
      if (E && (r = "gray"), this.name = n, this.imageType = v, this.id = Lv(), this._colormap = r, this._opacity = i > 1 ? 1 : i, this.percentileFrac = c, this.ignoreZeroVoxels = f, this.trustCalMinMax = l, this.colormapNegative = h, this.colormapLabel = C, this.frame4D = g, this.cal_minNeg = m, this.cal_maxNeg = y, this.colorbarVisible = w, this.colormapType = T, this.useQFormNotSForm = u, !e) return;
      if (E && this.hdr && this.hdr.intent_code === 1002 && (r = "random", this._colormap = r), this.hdr && typeof this.hdr.magic == "number" && (this.hdr.magic = "n+1"), this.nFrame4D = 1, this.hdr) for (let I = 4; I < 7; I++) this.hdr.dims[I] > 1 && (this.nFrame4D *= this.hdr.dims[I]);
      if (this.frame4D = Math.min(this.frame4D, this.nFrame4D - 1), this.nTotalFrame4D = this.nFrame4D, !this.hdr || !S) return;
      this.nVox3D = this.hdr.dims[1] * this.hdr.dims[2] * this.hdr.dims[3];
      const b = this.nVox3D * (this.hdr.numBitsPerVoxel / 8), D = S.byteLength / b;
      D !== this.nFrame4D && (D > 0 && D * b === S.byteLength ? ee.debug("Loading the first " + D + " of " + this.nFrame4D + " volumes") : ee.warn("This header does not match voxel data", this.hdr, S.byteLength), this.nFrame4D = D), (this.hdr.intent_code === 1007 || this.hdr.intent_code === 2003) && this.nFrame4D === 3 && this.hdr.datatypeCode === 16 && (S = this.float32V1asRGBA(new Float32Array(S)).buffer), (this.hdr.pixDims[1] === 0 || this.hdr.pixDims[2] === 0 || this.hdr.pixDims[3] === 0) && ee.error("pixDims not plausible", this.hdr), (isNaN(this.hdr.scl_slope) || this.hdr.scl_slope === 0) && (this.hdr.scl_slope = 1), isNaN(this.hdr.scl_inter) && (this.hdr.scl_inter = 0);
      let R = nC(this.hdr.affine);
      if (u || !R || this.hdr.qform_code > this.hdr.sform_code) {
        ee.debug("spatial transform based on QForm");
        const I = this.hdr.quatern_b, O = this.hdr.quatern_c, L = this.hdr.quatern_d, N = Math.sqrt(1 - (Math.pow(I, 2) + Math.pow(O, 2) + Math.pow(L, 2))), F = this.hdr.pixDims[0] === 0 ? 1 : this.hdr.pixDims[0], V = [
          [
            N * N + I * I - O * O - L * L,
            2 * I * O - 2 * N * L,
            2 * I * L + 2 * N * O
          ],
          [
            2 * I * O + 2 * N * L,
            N * N + O * O - I * I - L * L,
            2 * O * L - 2 * N * I
          ],
          [
            2 * I * L - 2 * N * O,
            2 * O * L + 2 * N * I,
            N * N + L * L - O * O - I * I
          ]
        ], k = this.hdr.affine;
        for (let _ = 0; _ < 3; _ += 1) for (let K = 0; K < 3; K += 1) k[_][K] = V[_][K] * this.hdr.pixDims[K + 1], K === 2 && (k[_][K] *= F);
        k[0][3] = this.hdr.qoffset_x, k[1][3] = this.hdr.qoffset_y, k[2][3] = this.hdr.qoffset_z, this.hdr.affine = k;
      }
      if (R = nC(this.hdr.affine), !R) {
        ee.debug("Defective NIfTI: spatial transform does not make sense");
        let I = this.hdr.pixDims[1], O = this.hdr.pixDims[2], L = this.hdr.pixDims[3];
        (isNaN(I) || I === 0) && (I = 1), (isNaN(O) || O === 0) && (O = 1), (isNaN(L) || L === 0) && (L = 1), this.hdr.pixDims[1] = I, this.hdr.pixDims[2] = O, this.hdr.pixDims[3] = L;
        const N = [
          [
            I,
            0,
            0,
            0
          ],
          [
            0,
            O,
            0,
            0
          ],
          [
            0,
            0,
            L,
            0
          ],
          [
            0,
            0,
            0,
            1
          ]
        ];
        this.hdr.affine = N;
      }
      if (this.hdr.datatypeCode !== 128 && this.hdr.datatypeCode !== 2304 && this.hdr.littleEndian !== kv() && this.hdr.numBitsPerVoxel > 8) {
        if (this.hdr.numBitsPerVoxel === 16) {
          const I = new Uint16Array(S);
          for (let O = 0; O < I.length; O++) {
            const L = I[O];
            I[O] = ((L & 255) << 8 | L >> 8 & 255) << 16 >> 16;
          }
        } else if (this.hdr.numBitsPerVoxel === 32) {
          const I = new Uint32Array(S);
          for (let O = 0; O < I.length; O++) {
            const L = I[O];
            I[O] = (L & 255) << 24 | (L & 65280) << 8 | L >> 8 & 65280 | L >> 24 & 255;
          }
        } else if (this.hdr.numBitsPerVoxel === 64) {
          const I = this.hdr.numBitsPerVoxel / 8, O = new Uint8Array(S);
          for (let L = 0; L < O.length; L += I) {
            let N = I - 1;
            for (let F = 0; F < N; F++) {
              const V = O[L + F];
              O[L + F] = O[L + N], O[L + N] = V, N--;
            }
          }
        }
      }
      switch (this.hdr.datatypeCode) {
        case 2:
          this.img = new Uint8Array(S);
          break;
        case 4:
          this.img = new Int16Array(S);
          break;
        case 16:
          this.img = new Float32Array(S);
          break;
        case 64:
          this.img = new Float64Array(S);
          break;
        case 128:
          this.img = new Uint8Array(S);
          break;
        case 512:
          this.img = new Uint16Array(S);
          break;
        case 2304:
          this.img = new Uint8Array(S);
          break;
        case 256: {
          const I = new Int8Array(S), O = I.length;
          this.img = new Int16Array(O);
          for (let L = 0; L < O; L++) this.img[L] = I[L];
          this.hdr.datatypeCode = 4, this.hdr.numBitsPerVoxel = 16;
          break;
        }
        case 1: {
          const I = this.hdr.dims[1] * this.hdr.dims[2] * Math.max(1, this.hdr.dims[3]) * Math.max(1, this.hdr.dims[4]), O = new Uint8Array(S);
          this.img = new Uint8Array(I);
          const L = new Uint8Array(8);
          for (let F = 0; F < 8; F++) L[F] = Math.pow(2, F);
          let N = -1;
          for (let F = 0; F < I; F++) {
            const V = F % 8;
            V === 0 && N++, (O[N] & L[V]) !== 0 && (this.img[F] = 1);
          }
          this.hdr.datatypeCode = 2, this.hdr.numBitsPerVoxel = 8;
          break;
        }
        case 768: {
          const I = new Uint32Array(S), O = I.length;
          this.img = new Float64Array(O);
          for (let L = 0; L < O - 1; L++) this.img[L] = I[L];
          this.hdr.datatypeCode = 64;
          break;
        }
        case 8: {
          const I = new Int32Array(S), O = I.length;
          this.img = new Float64Array(O);
          for (let L = 0; L < O - 1; L++) this.img[L] = I[L];
          this.hdr.datatypeCode = 64;
          break;
        }
        case 1024: {
          const I = new BigInt64Array(S), O = I.length;
          this.img = new Float64Array(O);
          for (let L = 0; L < O - 1; L++) this.img[L] = Number(I[L]);
          this.hdr.datatypeCode = 64;
          break;
        }
        case 32: {
          const I = new Float32Array(S), O = Math.floor(I.length / 2);
          this.imaginary = new Float32Array(O), this.img = new Float32Array(O);
          let L = 0;
          for (let N = 0; N < O - 1; N++) this.img[N] = I[L], this.imaginary[N] = I[L + 1], L += 2;
          this.hdr.datatypeCode = 16;
          break;
        }
        default:
          throw new Error("datatype " + this.hdr.datatypeCode + " not supported");
      }
      this.calculateRAS(), isNaN(s) || (this.hdr.cal_min = s), isNaN(o) || (this.hdr.cal_max = o), this.calMinMax();
    }
    static async new(e = null, n = "", r = "", i = 1, a = null, s = NaN, o = NaN, l = true, c = 0.02, f = false, u = false, h = "", g = 0, v = Gt.UNKNOWN, m = NaN, y = NaN, w = true, C = null, T = 0, S) {
      const E = new Tg(), b = /(?:\.([^.]+))?$/;
      let D = b.exec(n)[1] || "";
      D = D.toUpperCase(), D === "GZ" && (D = b.exec(n.slice(0, -3))[1], D = D.toUpperCase());
      let R = null;
      if (v === Gt.UNKNOWN && (v = Gt.parse(D)), e instanceof ArrayBuffer && e.byteLength >= 2 && v === Gt.DCM) {
        const I = new Uint8Array(e);
        (I[0] === 92 && I[1] === 1 || I[1] === 92 && I[0] === 1) && (v = Gt.NII);
      }
      switch (E.imageType = v, v) {
        case Gt.DCM_FOLDER:
        case Gt.DCM_MANIFEST:
        case Gt.DCM:
          return;
        case Gt.FIB:
          [R, E.v1] = await E.readFIB(e);
          break;
        case Gt.MIH:
        case Gt.MIF:
          R = await E.readMIF(e, a);
          break;
        case Gt.NHDR:
        case Gt.NRRD:
          if (R = await lb.readNrrd(E, e), R === null) throw new Error(`Failed to parse NHDR/NRRD file ${n}`);
          break;
        case Gt.MHD:
        case Gt.MHA:
          R = await E.readMHA(e, a);
          break;
        case Gt.MGH:
        case Gt.MGZ:
          if (R = await ib.readMgh(E, e), R === null) throw new Error(`Failed to parse MGH/MGZ file ${n}`);
          break;
        case Gt.SRC:
          R = await E.readSRC(e);
          break;
        case Gt.V:
          R = E.readECAT(e);
          break;
        case Gt.V16:
          R = E.readV16(e);
          break;
        case Gt.VMR:
          R = E.readVMR(e);
          break;
        case Gt.HEAD:
          R = await E.readHEAD(e, a);
          break;
        case Gt.BMP:
          R = await E.readBMP(e);
          break;
        case Gt.NPY:
          R = await E.readNPY(e);
          break;
        case Gt.NPZ:
          R = await E.readNPZ(e);
          break;
        case Gt.ZARR:
          R = await E.readZARR(e, S);
          break;
        case Gt.NII:
          if (R = await ob.readNifti(E, e), R === null) throw new Error(`Failed to parse NIfTI file ${n}.`);
          break;
        default:
          throw new Error("Image type not supported");
      }
      return E.init(e, n, r, i, a, s, o, l, c, f, u, h, g, v, m, y, w, C, T, R), E;
    }
    computeObliqueAngle(e) {
      const n = Tr(e);
      _i(n, e);
      const r = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]), i = Math.max(Math.max(Math.abs(n[0]), Math.abs(n[1])), Math.abs(n[2])) / r, a = Math.sqrt(n[4] * n[4] + n[5] * n[5] + n[6] * n[6]), s = Math.max(Math.max(Math.abs(n[4]), Math.abs(n[5])), Math.abs(n[6])) / a, o = Math.sqrt(n[8] * n[8] + n[9] * n[9] + n[10] * n[10]), l = Math.max(Math.max(Math.abs(n[8]), Math.abs(n[9])), Math.abs(n[10])) / o, c = Math.min(Math.min(i, s), l);
      let f = Math.abs(Math.acos(c) * 180 / 3.141592653);
      return f > 0.01 ? ee.warn("Warning voxels not aligned with world space: " + f + ` degrees from plumb.
`) : f = 0, f;
    }
    float32V1asRGBA(e) {
      e.length !== this.nVox3D * 3 && ee.warn("float32V1asRGBA() expects " + this.nVox3D * 3 + "voxels, got ", +e.length);
      const n = e.slice();
      this.hdr.datatypeCode = 2304, this.nFrame4D = 1;
      for (let l = 4; l < 7; l++) this.hdr.dims[l] = 1;
      this.hdr.dims[0] = 3;
      const r = new Uint8Array(this.nVox3D * 4);
      let i = 1;
      for (let l = 0; l < this.nVox3D * 3; l++) isNaN(n[l]) || (i = Math.max(i, Math.abs(n[l])));
      const a = 255 / i, s = this.nVox3D * 2;
      let o = 0;
      for (let l = 0; l < this.nVox3D; l++) {
        const c = n[l], f = n[l + this.nVox3D], u = n[l + s];
        r[o] = Math.abs(c * a), r[o + 1] = Math.abs(f * a), r[o + 2] = Math.abs(u * a);
        const h = +(c > 0) * 1, g = +(f > 0) * 2, v = +(u > 0) * 4;
        let m = 248 + h + g + v;
        Math.abs(c) + Math.abs(f) + Math.abs(u) < 0.1 && (m = 0), r[o + 3] = m, o += 4;
      }
      return r;
    }
    loadImgV1(e = false, n = false, r = false) {
      let i = this.v1;
      if (!i && this.nFrame4D === 3 && this.img.constructor === Float32Array && (i = this.img.slice()), !i) return ee.warn("Image does not have V1 data"), false;
      if (e) for (let a = 0; a < this.nVox3D; a++) i[a] = -i[a];
      if (n) for (let a = this.nVox3D; a < 2 * this.nVox3D; a++) i[a] = -i[a];
      if (r) for (let a = 2 * this.nVox3D; a < 3 * this.nVox3D; a++) i[a] = -i[a];
      return this.img = this.float32V1asRGBA(i), true;
    }
    calculateOblique() {
      if (!this.matRAS) throw new Error("matRAS not defined");
      if (this.pixDimsRAS === void 0) throw new Error("pixDimsRAS not defined");
      if (!this.dimsRAS) throw new Error("dimsRAS not defined");
      this.oblique_angle = this.computeObliqueAngle(this.matRAS);
      const e = this.vox2mm([
        0,
        0,
        0
      ], this.matRAS), n = this.vox2mm([
        1 / this.pixDimsRAS[1],
        0,
        0
      ], this.matRAS), r = this.vox2mm([
        0,
        1 / this.pixDimsRAS[2],
        0
      ], this.matRAS), i = this.vox2mm([
        0,
        0,
        1 / this.pixDimsRAS[3]
      ], this.matRAS);
      Ft(n, n, e), Ft(r, r, e), Ft(i, i, e);
      const a = Qi(n[0], n[1], n[2], 0, r[0], r[1], r[2], 0, i[0], i[1], i[2], 0, 0, 0, 0, 1);
      this.obliqueRAS = Tr(a);
      const s = Math.abs(90 - th(n, r) * (180 / Math.PI)), o = Math.abs(90 - th(n, i) * (180 / Math.PI)), l = Math.abs(90 - th(r, i) * (180 / Math.PI));
      this.maxShearDeg = Math.max(Math.max(s, o), l), this.maxShearDeg > 0.1 && ee.warn("Warning: voxels are rhomboidal, maximum shear is %f degrees.", this.maxShearDeg);
      const c = zn(this.dimsRAS[1], this.dimsRAS[2], this.dimsRAS[3], 1), f = Tr(this.matRAS);
      _i(f, f);
      const u = zn(-0.5, -0.5, -0.5, 0);
      au(f, f, Ue(u[0], u[1], u[2])), f[0] *= c[0], f[1] *= c[0], f[2] *= c[0], f[4] *= c[1], f[5] *= c[1], f[6] *= c[1], f[8] *= c[2], f[9] *= c[2], f[10] *= c[2], this.frac2mm = Tr(f);
      const h = this.pixDimsRAS[1], g = this.pixDimsRAS[2], v = this.pixDimsRAS[3], m = Tr(f);
      m[0] = h * c[0], m[1] = 0, m[2] = 0, m[4] = 0, m[5] = g * c[1], m[6] = 0, m[8] = 0, m[9] = 0, m[10] = v * c[2];
      const y = this.mm2vox([
        0,
        0,
        0
      ], true);
      m[12] = (-y[0] - 0.5) * h, m[13] = (-y[1] - 0.5) * g, m[14] = (-y[2] - 0.5) * v, this.frac2mmOrtho = Tr(m), this.extentsMinOrtho = [
        m[12],
        m[13],
        m[14]
      ], this.extentsMaxOrtho = [
        m[0] + m[12],
        m[5] + m[13],
        m[10] + m[14]
      ], this.mm2ortho = Yt(), Ti(this.mm2ortho, a);
    }
    THD_daxes_to_NIFTI(e, n, r) {
      const i = this.hdr;
      if (i === null) throw new Error("HDR is not set");
      i.sform_code = 2;
      const a = "xxyyzzg";
      let s = -1, o = -1, l = -1;
      const c = [
        "x",
        "y",
        "z"
      ];
      c[0] = a[r[0]], c[1] = a[r[1]], c[2] = a[r[2]];
      const f = e.slice(0, 3), u = n.slice(0, 3);
      for (let h = 0; h < 3; h++) c[h] === "x" ? s = h : c[h] === "y" ? o = h : l = h;
      s < 0 || o < 0 || l < 0 || s === o || s === l || o === l || (i.pixDims[1] = Math.abs(f[0]), i.pixDims[2] = Math.abs(f[1]), i.pixDims[3] = Math.abs(f[2]), i.affine = [
        [
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], i.affine[0][s] = -f[s], i.affine[1][o] = -f[o], i.affine[2][l] = f[l], i.affine[0][3] = -u[s], i.affine[1][3] = -u[o], i.affine[2][3] = u[l]);
    }
    SetPixDimFromSForm() {
      if (!this.hdr) throw new Error("hdr not defined");
      const e = this.hdr.affine, n = Qi(e[0][0], e[0][1], e[0][2], e[0][3], e[1][0], e[1][1], e[1][2], e[1][3], e[2][0], e[2][1], e[2][2], e[2][3], e[3][0], e[3][1], e[3][2], e[3][3]), r = this.vox2mm([
        0,
        0,
        0
      ], n), i = this.vox2mm([
        1,
        0,
        0
      ], n);
      Ft(i, i, r);
      const a = this.vox2mm([
        0,
        1,
        0
      ], n);
      Ft(a, a, r);
      const s = this.vox2mm([
        0,
        0,
        1
      ], n);
      Ft(s, s, r), this.hdr.pixDims[1] = Ms(i), this.hdr.pixDims[2] = Ms(a), this.hdr.pixDims[3] = Ms(s);
    }
    readECAT(e) {
      this.hdr = new tt();
      const n = this.hdr;
      n.dims = [
        3,
        1,
        1,
        1,
        0,
        0,
        0,
        0
      ], n.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ];
      const r = new DataView(e), i = r.getInt32(0, false), a = r.getInt16(50, false);
      if (i !== 1296127058 || a < 1 || a > 14) throw new Error("Not a valid ECAT file");
      let s = 512, o = 0;
      const l = [];
      let c = new Float32Array();
      for (; ; ) {
        const f = r.getInt32(s, false), u = r.getInt32(s + 12, false);
        if (f + u !== 31) break;
        let h = s + 20, g = 0, v = 0;
        for (; g < 31 && (v = r.getInt32(h, false), h += 16, v !== 0); ) {
          g++;
          let m = v * 512;
          const y = m - 512, w = r.getUint16(y, false);
          n.dims[1] = r.getUint16(y + 4, false), n.dims[2] = r.getUint16(y + 6, false), n.dims[3] = r.getUint16(y + 8, false);
          const C = r.getFloat32(y + 26, false);
          n.pixDims[1] = r.getFloat32(y + 34, false) * 10, n.pixDims[2] = r.getFloat32(y + 38, false) * 10, n.pixDims[3] = r.getFloat32(y + 42, false) * 10, n.pixDims[4] = r.getUint32(y + 46, false) / 1e3, l.push(n.pixDims[4]);
          const T = n.dims[1] * n.dims[2] * n.dims[3], S = new Float32Array(T);
          if (w === 1) for (let b = 0; b < T; b++) S[b] = r.getUint8(m) * C, m++;
          else if (w === 6) for (let b = 0; b < T; b++) S[b] = r.getUint16(m, false) * C, m += 2;
          else if (w === 7) for (let b = 0; b < T; b++) S[b] = r.getUint32(m, false) * C, m += 4;
          else ee.warn("Unknown ECAT data type " + w);
          const E = c.slice(0);
          c = new Float32Array(E.length + S.length), c.set(E), c.set(S, E.length), o++;
        }
        if (v === 0) break;
        s += 512;
      }
      if (n.dims[4] = o, n.pixDims[4] = l[0], o > 1) {
        n.dims[0] = 4;
        let f = false;
        for (let u = 0; u < o; u++) l[u] !== l[0] && (f = true);
        f && ee.warn("Frame durations vary");
      }
      return n.sform_code = 1, n.affine = [
        [
          -n.pixDims[1],
          0,
          0,
          (n.dims[1] - 2) * 0.5 * n.pixDims[1]
        ],
        [
          0,
          -n.pixDims[2],
          0,
          (n.dims[2] - 2) * 0.5 * n.pixDims[2]
        ],
        [
          0,
          0,
          -n.pixDims[3],
          (n.dims[3] - 2) * 0.5 * n.pixDims[3]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], n.numBitsPerVoxel = 32, n.datatypeCode = 16, c.buffer;
    }
    readV16(e) {
      this.hdr = new tt();
      const n = this.hdr;
      n.dims = [
        3,
        1,
        1,
        1,
        0,
        0,
        0,
        0
      ], n.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ];
      const r = new DataView(e);
      return n.dims[1] = r.getUint16(0, true), n.dims[2] = r.getUint16(2, true), n.dims[3] = r.getUint16(4, true), 2 * n.dims[1] * n.dims[2] * n.dims[3] + 6 !== e.byteLength && ee.warn("This does not look like a valid BrainVoyager V16 file"), n.numBitsPerVoxel = 16, n.datatypeCode = 512, ee.warn("Warning: V16 files have no spatial transforms"), n.affine = [
        [
          0,
          0,
          -n.pixDims[1],
          (n.dims[1] - 2) * 0.5 * n.pixDims[1]
        ],
        [
          -n.pixDims[2],
          0,
          0,
          (n.dims[2] - 2) * 0.5 * n.pixDims[2]
        ],
        [
          0,
          -n.pixDims[3],
          0,
          (n.dims[3] - 2) * 0.5 * n.pixDims[3]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], n.littleEndian = true, e.slice(6);
    }
    async readNPY(e) {
      function n(S) {
        return {
          "|b1": 1,
          "<i1": 1,
          "<u1": 1,
          "<i2": 2,
          "<u2": 2,
          "<i4": 4,
          "<u4": 4,
          "<f4": 4,
          "<f8": 8
        }[S] ?? 1;
      }
      function r(S) {
        return {
          "|b1": 2,
          "<i1": 256,
          "<u1": 2,
          "<i2": 4,
          "<u2": 512,
          "<i4": 8,
          "<u4": 768,
          "<f4": 16,
          "<f8": 64
        }[S] ?? 16;
      }
      const i = new DataView(e), a = [
        i.getUint8(0),
        i.getUint8(1),
        i.getUint8(2),
        i.getUint8(3),
        i.getUint8(4),
        i.getUint8(5)
      ], s = [
        147,
        78,
        85,
        77,
        80,
        89
      ];
      if (!a.every((S, E) => S === s[E])) throw new Error("Not a valid NPY file: Magic number mismatch");
      const o = i.getUint16(8, true), l = new TextDecoder("utf-8").decode(e.slice(10, 10 + o)), c = l.match(/'shape': \((.*?)\)/);
      if (!c) throw new Error("Invalid NPY header: Shape not found");
      const f = c[1].split(",").map((S) => S.trim()).filter((S) => S !== "").map(Number), u = l.match(/'descr': '([^']+)'/);
      if (!u) throw new Error("Invalid NPY header: Data type not found");
      const h = u[1], g = f.reduce((S, E) => S * E, 1), v = 10 + o, m = e.slice(v, v + g * n(h)), y = f.length > 0 ? f[f.length - 1] : 1, w = f.length > 1 ? f[f.length - 2] : 1, C = f.length > 2 ? f[f.length - 3] : 1;
      this.hdr = new tt();
      const T = this.hdr;
      return T.dims = [
        3,
        y,
        w,
        C,
        0,
        0,
        0,
        0
      ], T.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ], T.affine = [
        [
          T.pixDims[1],
          0,
          0,
          -(T.dims[1] - 2) * 0.5 * T.pixDims[1]
        ],
        [
          0,
          -T.pixDims[2],
          0,
          (T.dims[2] - 2) * 0.5 * T.pixDims[2]
        ],
        [
          0,
          0,
          -T.pixDims[3],
          (T.dims[3] - 2) * 0.5 * T.pixDims[3]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], T.numBitsPerVoxel = n(h) * 8, T.datatypeCode = r(h), m;
    }
    async readNPZ(e) {
      const n = new JE(e);
      for (let r = 0; r < n.entries.length; r++) {
        const i = n.entries[r];
        if (i.fileName.toLowerCase().endsWith(".npy")) {
          const a = await i.extract();
          return await this.readNPY(a.buffer);
        }
      }
    }
    async imageDataFromArrayBuffer(e) {
      return new Promise((n, r) => {
        const i = new Blob([
          e
        ]), a = URL.createObjectURL(i), s = new Image();
        s.crossOrigin = "Anonymous", s.src = a, s.onload = () => {
          URL.revokeObjectURL(a);
          const o = document.createElement("canvas");
          o.width = s.width, o.height = s.height;
          const l = o.getContext("2d");
          if (!l) {
            r(new Error("Failed to get 2D context"));
            return;
          }
          l.drawImage(s, 0, 0), n(l.getImageData(0, 0, s.width, s.height));
        }, s.onerror = (o) => {
          URL.revokeObjectURL(a), r(o);
        };
      });
    }
    async readBMP(e) {
      const n = await this.imageDataFromArrayBuffer(e), { width: r, height: i, data: a } = n;
      this.hdr = new tt();
      const s = this.hdr;
      s.dims = [
        3,
        r,
        i,
        1,
        0,
        0,
        0,
        0
      ], s.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ], s.affine = [
        [
          s.pixDims[1],
          0,
          0,
          -(s.dims[1] - 2) * 0.5 * s.pixDims[1]
        ],
        [
          0,
          -s.pixDims[2],
          0,
          (s.dims[2] - 2) * 0.5 * s.pixDims[2]
        ],
        [
          0,
          0,
          -s.pixDims[3],
          (s.dims[3] - 2) * 0.5 * s.pixDims[3]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], s.numBitsPerVoxel = 8, s.datatypeCode = 2304;
      let o = true;
      for (let l = 0; l < a.length; l += 4) if (a[l] !== a[l + 1] || a[l] !== a[l + 2]) {
        o = false;
        break;
      }
      if (o) {
        s.datatypeCode = 2;
        const l = new Uint8Array(r * i);
        for (let c = 0, f = 0; c < a.length; c += 4, f++) l[f] = a[c];
        return l.buffer;
      }
      return a.buffer;
    }
    async readZARR(e, n) {
      let { width: r, height: i, depth: a = 1, data: s } = n ?? {}, o = r * i * a * 3, l = o === s.length;
      if (l || (o = r * i * a, a === 3 && (l = true, a = 1)), o !== s.length) throw new Error(`Expected RGB ${r}\xD7${i}\xD7${a}\xD73 =  ${o}, but ZARR length ${s.length}`);
      this.hdr = new tt();
      const c = this.hdr;
      if (c.dims = [
        3,
        r,
        i,
        a,
        1,
        1,
        1,
        1
      ], c.pixDims = [
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0
      ], c.affine = [
        [
          c.pixDims[1],
          0,
          0,
          -(c.dims[1] - 2) * 0.5 * c.pixDims[1]
        ],
        [
          0,
          -c.pixDims[2],
          0,
          (c.dims[2] - 2) * 0.5 * c.pixDims[2]
        ],
        [
          0,
          0,
          -c.pixDims[3],
          (c.dims[3] - 2) * 0.5 * c.pixDims[3]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], !l) {
        if (c.numBitsPerVoxel = 8, c.datatypeCode = 2, s instanceof Uint8Array) {
          const v = new ArrayBuffer(s.length);
          return new Uint8Array(v).set(s), v;
        }
        return s;
      }
      c.numBitsPerVoxel = 24, c.datatypeCode = 128;
      function f(v, m, y, w) {
        const C = m * y, T = new Uint8Array(C * w * 3), S = new Array(w);
        for (let D = 0; D < w; D++) S[D] = C * 3 * D;
        let E = 0, b = 0;
        for (let D = 0; D < C; D++) {
          for (let R = 0; R < w; R++) T[S[R] + b] = v[E++], T[S[R] + b + 1] = v[E++], T[S[R] + b + 2] = v[E++];
          b += 3;
        }
        return T;
      }
      const u = f(s, c.dims[1], c.dims[2], c.dims[3]), h = new ArrayBuffer(u.length);
      return new Uint8Array(h).set(u), h;
    }
    readVMR(e) {
      this.hdr = new tt();
      const n = this.hdr;
      n.dims = [
        3,
        1,
        1,
        1,
        0,
        0,
        0,
        0
      ], n.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ];
      const r = new DataView(e), i = r.getUint16(0, true);
      i !== 4 && ee.warn("Not a valid version 4 VMR image"), n.dims[1] = r.getUint16(2, true), n.dims[2] = r.getUint16(4, true), n.dims[3] = r.getUint16(6, true);
      const a = n.dims[1] * n.dims[2] * n.dims[3];
      if (i >= 4) {
        let s = 8 + a;
        const o = r.getUint32(s + 88, true);
        if (s = s + 92, o > 0) {
          const l = e.byteLength;
          for (let c = 0; c < o; c++) {
            for (; s < l && r.getUint8(s) !== 0; ) s++;
            for (s++, s += 4; s < l && r.getUint8(s) !== 0; ) s++;
            s++;
            const f = r.getUint32(s, true);
            s += 4;
            for (let u = 0; u < f; u++) s += 4;
          }
        }
        n.pixDims[1] = r.getFloat32(s + 2, true), n.pixDims[2] = r.getFloat32(s + 6, true), n.pixDims[3] = r.getFloat32(s + 10, true);
      }
      return ee.warn("Warning: VMR spatial transform not implemented"), n.affine = [
        [
          0,
          0,
          -n.pixDims[1],
          (n.dims[1] - 2) * 0.5 * n.pixDims[1]
        ],
        [
          -n.pixDims[2],
          0,
          0,
          (n.dims[2] - 2) * 0.5 * n.pixDims[2]
        ],
        [
          0,
          -n.pixDims[3],
          0,
          (n.dims[3] - 2) * 0.5 * n.pixDims[3]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], ee.debug(n), n.numBitsPerVoxel = 8, n.datatypeCode = 2, e.slice(8, 8 + a);
    }
    async readFIB(e) {
      this.hdr = new tt();
      const n = this.hdr;
      n.littleEndian = false, n.dims = [
        3,
        1,
        1,
        1,
        0,
        0,
        0,
        0
      ], n.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ];
      const r = await ft.readMatV4(e, true);
      if (!("dimension" in r) || !("dti_fa" in r)) throw new Error("Not a valid DSIstudio FIB file");
      const i = "index0" in r && "index1" in r && "index2" in r && "odf_vertices" in r;
      n.numBitsPerVoxel = 32, n.datatypeCode = 16, n.dims[1] = r.dimension[0], n.dims[2] = r.dimension[1], n.dims[3] = r.dimension[2], n.dims[4] = 1, n.pixDims[1] = r.voxel_size[0], n.pixDims[2] = r.voxel_size[1], n.pixDims[3] = r.voxel_size[2], n.sform_code = 1;
      const a = (n.dims[1] - 1) * 0.5 * n.pixDims[1], s = (n.dims[2] - 1) * 0.5 * n.pixDims[2], o = (n.dims[3] - 1) * 0.5 * n.pixDims[3];
      n.affine = [
        [
          n.pixDims[1],
          0,
          0,
          -a
        ],
        [
          0,
          -n.pixDims[2],
          0,
          s
        ],
        [
          0,
          0,
          n.pixDims[2],
          -o
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], n.littleEndian = true;
      const l = n.dims[1] * n.dims[2] * n.dims[3], c = l * Math.ceil(n.numBitsPerVoxel / 8), f = c * n.dims[4], u = new Uint8Array(new ArrayBuffer(l * 4 * 3));
      if (i) {
        const m = n.dims[1] * n.dims[2] * n.dims[3], y = new Float32Array(m), w = new Float32Array(m), C = new Float32Array(m), T = r.index0, S = r.odf_vertices;
        for (let E = 0; E < m; E++) {
          const b = T[E] * 3;
          y[E] = S[b + 0], w[E] = S[b + 1], C[E] = -S[b + 2];
        }
        u.set(new Uint8Array(y.buffer, y.byteOffset, y.byteLength), 0 * c), u.set(new Uint8Array(w.buffer, w.byteOffset, w.byteLength), 1 * c), u.set(new Uint8Array(C.buffer, C.byteOffset, C.byteLength), 2 * c);
      }
      "report" in r && (n.description = new TextDecoder().decode(r.report.subarray(0, Math.min(79, r.report.byteLength))));
      const h = new Uint8Array(new ArrayBuffer(f)), g = Float32Array.from(r.dti_fa);
      if ("mask" in r) {
        let m = 1;
        "dti_fa_slope" in r && (m = r.dti_fa_slope[0]);
        let y = 1;
        "dti_fa_inter" in r && (y = r.dti_fa_inter[0]);
        const w = n.dims[1] * n.dims[2] * n.dims[3], C = r.mask, T = new Float32Array(w);
        let S = 0;
        for (let E = 0; E < w; E++) C[E] !== 0 && (T[E] = g[S] * m + y, S++);
        return [
          T.buffer,
          new Float32Array(u.buffer)
        ];
      }
      const v = new Uint8Array(g.buffer, g.byteOffset, g.byteLength);
      return h.set(v, 0), [
        h.buffer,
        new Float32Array(u.buffer)
      ];
    }
    async readSRC(e) {
      this.hdr = new tt();
      const n = this.hdr;
      n.littleEndian = false, n.dims = [
        3,
        1,
        1,
        1,
        0,
        0,
        0,
        0
      ], n.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ];
      const r = await ft.readMatV4(e);
      if (!("dimension" in r) || !("image0" in r)) throw new Error("Not a valid DSIstudio SRC file");
      let i = 0, a = 0;
      for (const [g, v] of Object.entries(r)) if (g.startsWith("image")) {
        if (i === 0 ? a = v.length : a !== v.length && (a = -1), v.constructor !== Uint16Array) throw new Error("DSIstudio SRC files always use Uint16 datatype");
        i++;
      }
      if (a < 1 || i < 1) throw new Error("SRC file not valid DSI Studio data. The image(s) should have the same length");
      n.numBitsPerVoxel = 16, n.datatypeCode = 512, n.dims[1] = r.dimension[0], n.dims[2] = r.dimension[1], n.dims[3] = r.dimension[2], n.dims[4] = i, n.dims[4] > 1 && (n.dims[0] = 4), n.pixDims[1] = r.voxel_size[0], n.pixDims[2] = r.voxel_size[1], n.pixDims[3] = r.voxel_size[2], n.sform_code = 1;
      const s = (n.dims[1] - 1) * 0.5 * n.pixDims[1], o = (n.dims[2] - 1) * 0.5 * n.pixDims[2], l = (n.dims[3] - 1) * 0.5 * n.pixDims[3];
      n.affine = [
        [
          n.pixDims[1],
          0,
          0,
          -s
        ],
        [
          0,
          -n.pixDims[2],
          0,
          o
        ],
        [
          0,
          0,
          n.pixDims[2],
          -l
        ],
        [
          0,
          0,
          0,
          1
        ]
      ], n.littleEndian = true;
      const c = n.dims[1] * n.dims[2] * n.dims[3] * (n.numBitsPerVoxel / 8), f = c * n.dims[4], u = new Uint8Array(new ArrayBuffer(f));
      let h = 0;
      for (let g = 0; g < i; g++) {
        const v = r[`image${g}`], m = new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
        u.set(m, h), h += c;
      }
      return "report" in r && (n.description = new TextDecoder().decode(r.report.subarray(0, Math.min(79, r.report.byteLength)))), u.buffer;
    }
    async readHEAD(e, n) {
      this.hdr = new tt();
      const r = this.hdr;
      r.dims[0] = 3, r.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ];
      let i = [
        0,
        0,
        0
      ], a = [
        0,
        0,
        0
      ], s = [
        1,
        1,
        1
      ];
      const l = new TextDecoder().decode(e).split(/\r?\n/), c = (e.byteLength + 8) % 16, f = e.byteLength + (16 - c);
      ee.debug(e.byteLength, "len", f);
      const u = new ArrayBuffer(f);
      new Uint8Array(u).set(new Uint8Array(e));
      const h = new PE(f + 8, 42, u, true);
      r.addExtension(h), r.extensionCode = 42, r.extensionFlag[0] = 1, r.extensionSize = f + 8;
      const g = l.length;
      let v = 0, m = false;
      for (; v < g; ) {
        let w = l[v];
        if (v++, !w.startsWith("type")) continue;
        const C = w.includes("integer-attribute"), T = w.includes("float-attribute");
        if (w = l[v], v++, !w.startsWith("name")) continue;
        let S = w.split("= ");
        const E = S[1];
        w = l[v], v++, S = w.split("= ");
        let b = parseInt(S[1]);
        if (!(b < 1)) {
          if (w = l[v], v++, S = w.trim().split(/\s+/), T || C) {
            for (; S.length < b; ) {
              w = l[v], v++;
              const D = w.trim().split(/\s+/);
              S.push(...D);
            }
            for (let D = 0; D < b; D++) S[D] = parseFloat(S[D]);
          }
          switch (E) {
            case "BYTEORDER_STRING":
              S[0].includes("LSB_FIRST") ? r.littleEndian = true : S[0].includes("MSB_FIRST") && (r.littleEndian = false);
              break;
            case "BRICK_TYPES":
              {
                r.dims[4] = b;
                const D = parseInt(S[0]);
                D === 0 ? (r.numBitsPerVoxel = 8, r.datatypeCode = 2) : D === 1 ? (r.numBitsPerVoxel = 16, r.datatypeCode = 4) : D === 3 ? (r.numBitsPerVoxel = 32, r.datatypeCode = 16) : ee.warn("Unknown BRICK_TYPES ", D);
              }
              break;
            case "IJK_TO_DICOM_REAL":
              if (b < 12) break;
              m = true, r.sform_code = 2, r.affine = [
                [
                  -S[0],
                  -S[1],
                  -S[2],
                  -S[3]
                ],
                [
                  -S[4],
                  -S[5],
                  -S[6],
                  -S[7]
                ],
                [
                  S[8],
                  S[9],
                  S[10],
                  S[11]
                ],
                [
                  0,
                  0,
                  0,
                  1
                ]
              ];
              break;
            case "DATASET_DIMENSIONS":
              b = Math.max(b, 3);
              for (let D = 0; D < b; D++) r.dims[D + 1] = S[D];
              break;
            case "ORIENT_SPECIFIC":
              i = S;
              break;
            case "ORIGIN":
              a = S;
              break;
            case "DELTA":
              s = S;
              break;
            case "TAXIS_FLOATS":
              r.pixDims[4] = S[0];
              break;
            default:
              ee.warn("Unknown:", E);
          }
        }
      }
      m ? this.SetPixDimFromSForm() : this.THD_daxes_to_NIFTI(s, a, i);
      const y = r.numBitsPerVoxel / 8 * r.dims[1] * r.dims[2] * r.dims[3] * r.dims[4];
      if (!n) throw new Error("pairedImgData not set");
      return n.byteLength < y ? await ft.decompressToBuffer(new Uint8Array(n)) : n.slice(0);
    }
    async readMHA(e, n) {
      const r = e.byteLength;
      if (r < 20) throw new Error("File too small to be VTK: bytes = " + e.byteLength);
      const i = new Uint8Array(e);
      let a = 0;
      function s(m) {
        return m === 10 || m === 13;
      }
      function o() {
        for (; a < r && s(i[a]); ) a++;
        const m = a;
        for (; a < r && !s(i[a]); ) a++;
        return a - m < 2 ? "" : new TextDecoder().decode(e.slice(m, a));
      }
      let l = o();
      this.hdr = new tt();
      const c = this.hdr;
      c.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ], c.dims = [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1
      ], c.littleEndian = true;
      let f = false, u = false;
      const h = as(NaN, 0, 0, 0, 1, 0, 0, 0, 1), g = Ue(0, 0, 0);
      for (; l !== ""; ) {
        let m = l.split(" ");
        if (m.length > 2 && (m = m.slice(2)), l.startsWith("BinaryDataByteOrderMSB") && m[0].includes("False") && (c.littleEndian = true), l.startsWith("BinaryDataByteOrderMSB") && m[0].includes("True") && (c.littleEndian = false), l.startsWith("CompressedData") && m[0].includes("True") && (f = true), l.startsWith("TransformMatrix")) for (let y = 0; y < 9; y++) h[y] = parseFloat(m[y]);
        if (l.startsWith("Offset")) for (let y = 0; y < Math.min(m.length, 3); y++) g[y] = parseFloat(m[y]);
        if (l.startsWith("ElementSpacing")) for (let y = 0; y < m.length; y++) c.pixDims[y + 1] = parseFloat(m[y]);
        if (l.startsWith("DimSize")) {
          c.dims[0] = m.length;
          for (let y = 0; y < m.length; y++) c.dims[y + 1] = parseInt(m[y]);
        }
        if (l.startsWith("ElementType")) switch (m[0]) {
          case "MET_UCHAR":
            c.numBitsPerVoxel = 8, c.datatypeCode = 2;
            break;
          case "MET_CHAR":
            c.numBitsPerVoxel = 8, c.datatypeCode = 256;
            break;
          case "MET_SHORT":
            c.numBitsPerVoxel = 16, c.datatypeCode = 4;
            break;
          case "MET_USHORT":
            c.numBitsPerVoxel = 16, c.datatypeCode = 512;
            break;
          case "MET_INT":
            c.numBitsPerVoxel = 32, c.datatypeCode = 8;
            break;
          case "MET_UINT":
            c.numBitsPerVoxel = 32, c.datatypeCode = 768;
            break;
          case "MET_FLOAT":
            c.numBitsPerVoxel = 32, c.datatypeCode = 16;
            break;
          case "MET_DOUBLE":
            c.numBitsPerVoxel = 64, c.datatypeCode = 64;
            break;
          default:
            throw new Error("Unsupported MHA data type: " + m[0]);
        }
        if (l.startsWith("ObjectType") && !m[0].includes("Image") && ee.warn("Only able to read ObjectType = Image, not " + l), l.startsWith("ElementDataFile")) {
          m[0] !== "LOCAL" && (u = true);
          break;
        }
        l = o();
      }
      const v = as(c.pixDims[1], 0, 0, 0, c.pixDims[2], 0, 0, 0, c.pixDims[3]);
      for (bE(h, h, v), c.affine = [
        [
          -h[0],
          -h[3],
          -h[6],
          -g[0]
        ],
        [
          -h[1],
          -h[4],
          -h[7],
          -g[1]
        ],
        [
          h[2],
          h[5],
          h[8],
          g[2]
        ],
        [
          0,
          0,
          0,
          1
        ]
      ]; i[a] === 10; ) a++;
      return c.vox_offset = a, u && n ? f ? await ft.decompressToBuffer(new Uint8Array(n.slice(0))) : n.slice(0) : f ? await ft.decompressToBuffer(new Uint8Array(e.slice(c.vox_offset))) : e.slice(c.vox_offset);
    }
    async readMIF(e, n) {
      this.hdr = new tt();
      const r = this.hdr;
      r.pixDims = [
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ], r.dims = [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1
      ];
      let i = e.byteLength;
      if (i < 20) throw new Error("File too small to be MIF: bytes = " + i);
      let a = new Uint8Array(e);
      a[0] === 31 && a[1] === 139 && (ee.debug("MIF with GZ decompression"), e = await ft.decompressToBuffer(new Uint8Array(e)), i = e.byteLength, a = new Uint8Array(e));
      let s = 0;
      function o() {
        for (; s < i && a[s] === 10; ) s++;
        const N = s;
        for (; s < i && a[s] !== 10; ) s++;
        return s++, s - N < 1 ? "" : new TextDecoder().decode(e.slice(N, s - 1));
      }
      let l = o();
      if (!l.startsWith("mrtrix image")) throw new Error("Not a valid MIF file");
      const c = [];
      let f = false, u = 0, h = 0, g = false;
      for (l = o(); s < i && !l.startsWith("END"); ) {
        let N = l.split(":");
        if (l = o(), N.length < 2) break;
        const F = N[0];
        N = N[1].split(",");
        for (let V = 0; V < N.length; V++) N[V] = N[V].trim();
        switch (F) {
          case "dim":
            r.dims[0] = N.length;
            for (let V = 0; V < N.length; V++) r.dims[V + 1] = parseInt(N[V]);
            break;
          case "vox":
            for (let V = 0; V < N.length; V++) r.pixDims[V + 1] = parseFloat(N[V]), isNaN(r.pixDims[V + 1]) && (r.pixDims[V + 1] = 0);
            break;
          case "layout":
            for (let V = 0; V < N.length; V++) c.push(parseInt(N[V]));
            break;
          case "datatype":
            {
              const V = N[0];
              V.startsWith("Bit") ? (f = true, r.datatypeCode = 2) : V.startsWith("Int8") ? r.datatypeCode = 256 : V.startsWith("UInt8") ? r.datatypeCode = 2 : V.startsWith("Int16") ? r.datatypeCode = 4 : V.startsWith("UInt16") ? r.datatypeCode = 512 : V.startsWith("Int32") ? r.datatypeCode = 8 : V.startsWith("UInt32") ? r.datatypeCode = 768 : V.startsWith("Float32") ? r.datatypeCode = 16 : V.startsWith("Float64") ? r.datatypeCode = 64 : ee.warn("Unsupported datatype " + V), V.includes("8") ? r.numBitsPerVoxel = 8 : V.includes("16") ? r.numBitsPerVoxel = 16 : V.includes("32") ? r.numBitsPerVoxel = 32 : V.includes("64") && (r.numBitsPerVoxel = 64), r.littleEndian = true, V.endsWith("LE") && (r.littleEndian = true), V.endsWith("BE") && (r.littleEndian = false);
            }
            break;
          case "transform":
            if (u > 2 || N.length !== 4) break;
            r.affine[u][0] = parseFloat(N[0]), r.affine[u][1] = parseFloat(N[1]), r.affine[u][2] = parseFloat(N[2]), r.affine[u][3] = parseFloat(N[3]), u++;
            break;
          case "comments":
            r.description = N[0].substring(0, Math.min(79, N[0].length));
            break;
          case "RepetitionTime":
            h = parseFloat(N[0]);
            break;
          case "file":
            g = !N[0].startsWith(". "), g || (N = N[0].split(" "), r.vox_offset = parseInt(N[1]));
            break;
        }
      }
      const v = r.dims[0];
      v > 5 && ee.warn("reader only designed for a maximum of 5 dimensions (XYZTD)");
      let m = 1;
      for (let N = 0; N < v; N++) m *= Math.max(r.dims[N + 1], 1);
      for (let N = 0; N < 3; N++) for (let F = 0; F < 3; F++) r.affine[N][F] *= r.pixDims[F + 1];
      ee.debug("mif affine:" + r.affine[0]), h > 0 && (r.pixDims[4] = h), g && !n && ee.warn("MIH header provided without paired image data");
      let y;
      if (n && g) y = n.slice(0);
      else if (f) {
        r.numBitsPerVoxel = 8;
        const N = new Uint8Array(m), F = e.slice(r.vox_offset, r.vox_offset + Math.ceil(m / 8)), V = new Uint8Array(F);
        let k = 0;
        for (let _ = 0; _ < m; _++) {
          const K = _ % 8;
          N[_] = V[k] >> 7 - K & 1, K === 7 && k++;
        }
        y = N.buffer;
      } else y = e.slice(r.vox_offset, r.vox_offset + m * (r.numBitsPerVoxel / 8));
      c.length !== r.dims[0] && ee.warn("dims does not match layout");
      let w = 1;
      const C = [
        1,
        1,
        1,
        1,
        1
      ], T = [
        false,
        false,
        false,
        false,
        false
      ];
      for (let N = 0; N < c.length; N++) for (let F = 0; F < c.length; F++) Math.abs(c[F]) === N && (C[F] = w, (c[F] < 0 || Object.is(c[F], -0)) && (T[F] = true), w *= r.dims[F + 1]);
      let S = ft.range(0, r.dims[1] - 1, 1);
      T[0] && (S = ft.range(r.dims[1] - 1, 0, -1));
      for (let N = 0; N < r.dims[1]; N++) S[N] *= C[0];
      let E = ft.range(0, r.dims[2] - 1, 1);
      T[1] && (E = ft.range(r.dims[2] - 1, 0, -1));
      for (let N = 0; N < r.dims[2]; N++) E[N] *= C[1];
      let b = ft.range(0, r.dims[3] - 1, 1);
      T[2] && (b = ft.range(r.dims[3] - 1, 0, -1));
      for (let N = 0; N < r.dims[3]; N++) b[N] *= C[2];
      let D = ft.range(0, r.dims[4] - 1, 1);
      T[3] && (D = ft.range(r.dims[4] - 1, 0, -1));
      for (let N = 0; N < r.dims[4]; N++) D[N] *= C[3];
      let R = ft.range(0, r.dims[5] - 1, 1);
      T[4] && (R = ft.range(r.dims[5] - 1, 0, -1));
      for (let N = 0; N < r.dims[5]; N++) R[N] *= C[4];
      let I = 0, O, L;
      switch (r.datatypeCode) {
        case 256:
          O = new Int8Array(y), L = new Int8Array(m);
          break;
        case 2:
          O = new Uint8Array(y), L = new Uint8Array(m);
          break;
        case 4:
          O = new Int16Array(y), L = new Int16Array(m);
          break;
        case 512:
          O = new Uint16Array(y), L = new Uint16Array(m);
          break;
        case 8:
          O = new Int32Array(y), L = new Int32Array(m);
          break;
        case 768:
          O = new Uint32Array(y), L = new Uint32Array(m);
          break;
        case 16:
          O = new Float32Array(y), L = new Float32Array(m);
          break;
        case 64:
          O = new Float64Array(y), L = new Float64Array(m);
          break;
        default:
          throw new Error("unknown datatypeCode");
      }
      for (let N = 0; N < r.dims[5]; N++) for (let F = 0; F < r.dims[4]; F++) for (let V = 0; V < r.dims[3]; V++) for (let k = 0; k < r.dims[2]; k++) for (let _ = 0; _ < r.dims[1]; _++) L[I] = O[S[_] + E[k] + b[V] + D[F] + R[N]], I++;
      return L.buffer;
    }
    calculateRAS() {
      if (!this.hdr) throw new Error("hdr not set");
      const e = this.hdr.affine, n = this.hdr, r = as(Math.abs(e[0][0]), Math.abs(e[0][1]), Math.abs(e[0][2]), Math.abs(e[1][0]), Math.abs(e[1][1]), Math.abs(e[1][2]), Math.abs(e[2][0]), Math.abs(e[2][1]), Math.abs(e[2][2])), i = [
        1,
        1,
        1
      ];
      r[3] > r[0] && (i[0] = 2), r[6] > r[0] && r[6] > r[3] && (i[0] = 3), i[1] = 1, i[0] === 1 ? r[4] > r[7] ? i[1] = 2 : i[1] = 3 : i[0] === 2 ? r[1] > r[7] ? i[1] = 1 : i[1] = 3 : r[1] > r[4] ? i[1] = 1 : i[1] = 2, i[2] = 6 - i[1] - i[0];
      let a = [
        1,
        2,
        3
      ];
      a[i[0] - 1] = 1, a[i[1] - 1] = 2, a[i[2] - 1] = 3;
      let s = Qi(e[0][0], e[0][1], e[0][2], e[0][3], e[1][0], e[1][1], e[1][2], e[1][3], e[2][0], e[2][1], e[2][2], e[2][3], 0, 0, 0, 1);
      this.mm000 = this.vox2mm([
        -0.5,
        -0.5,
        -0.5
      ], s), this.mm100 = this.vox2mm([
        n.dims[1] - 0.5,
        -0.5,
        -0.5
      ], s), this.mm010 = this.vox2mm([
        -0.5,
        n.dims[2] - 0.5,
        -0.5
      ], s), this.mm001 = this.vox2mm([
        -0.5,
        -0.5,
        n.dims[3] - 0.5
      ], s);
      const o = Yt();
      Iv(o, s);
      for (let y = 0; y < 3; y++) for (let w = 0; w < 3; w++) o[y * 4 + w] = s[y * 4 + a[w] - 1];
      const l = [
        0,
        0,
        0
      ];
      o[0] < 0 && (l[0] = 1), o[5] < 0 && (l[1] = 1), o[10] < 0 && (l[2] = 1), this.dimsRAS = [
        n.dims[0],
        n.dims[a[0]],
        n.dims[a[1]],
        n.dims[a[2]]
      ], this.pixDimsRAS = [
        n.pixDims[0],
        n.pixDims[a[0]],
        n.pixDims[a[1]],
        n.pixDims[a[2]]
      ], this.permRAS = a.slice();
      for (let y = 0; y < 3; y++) l[y] === 1 && (this.permRAS[y] = -this.permRAS[y]);
      if (this.arrayEquals(a, [
        1,
        2,
        3
      ]) && this.arrayEquals(l, [
        0,
        0,
        0
      ])) {
        this.toRAS = Yt(), this.matRAS = Tr(s), this.calculateOblique(), this.img2RASstep = [
          1,
          this.dimsRAS[1],
          this.dimsRAS[1] * this.dimsRAS[2]
        ], this.img2RASstart = [
          0,
          0,
          0
        ];
        return;
      }
      Jg(s), s[0] = 1 - l[0] * 2, s[5] = 1 - l[1] * 2, s[10] = 1 - l[2] * 2, s[3] = (n.dims[a[0]] - 1) * l[0], s[7] = (n.dims[a[1]] - 1) * l[1], s[11] = (n.dims[a[2]] - 1) * l[2];
      const c = Yt();
      Ti(c, s), ml(c, c, o), this.matRAS = Tr(c), s = Qi(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1), s[a[0] - 1 + 0] = -l[0] * 2 + 1, s[a[1] - 1 + 4] = -l[1] * 2 + 1, s[a[2] - 1 + 8] = -l[2] * 2 + 1, s[3] = l[0], s[7] = l[1], s[11] = l[2], this.toRAS = Tr(s), s[3] = 0, s[7] = 0, s[11] = 0, s[12] = 0, (this.permRAS[0] === -1 || this.permRAS[1] === -1 || this.permRAS[2] === -1) && (s[12] = n.dims[1] - 1), s[13] = 0, (this.permRAS[0] === -2 || this.permRAS[1] === -2 || this.permRAS[2] === -2) && (s[13] = n.dims[2] - 1), s[14] = 0, (this.permRAS[0] === -3 || this.permRAS[1] === -3 || this.permRAS[2] === -3) && (s[14] = n.dims[3] - 1), this.toRASvox = Tr(s), ee.debug(this.hdr.dims), ee.debug(this.dimsRAS);
      const f = this.hdr;
      a = this.permRAS;
      const u = [
        Math.abs(a[0]),
        Math.abs(a[1]),
        Math.abs(a[2])
      ], h = [
        f.dims[u[0]],
        f.dims[u[1]],
        f.dims[u[2]]
      ], g = [
        1,
        f.dims[1],
        f.dims[1] * f.dims[2]
      ], v = [
        g[u[0] - 1],
        g[u[1] - 1],
        g[u[2] - 1]
      ], m = [
        0,
        0,
        0
      ];
      for (let y = 0; y < 3; y++) a[y] < 0 && (m[y] = v[y] * (h[y] - 1), v[y] = -v[y]);
      this.img2RASstep = v, this.img2RASstart = m, this.calculateOblique();
    }
    async hdr2RAS(e = 1) {
      if (!this.permRAS) throw new Error("permRAS undefined");
      if (!this.hdr) throw new Error("hdr undefined");
      const n = rp({
        ...this.hdr,
        vox_offset: 352
      }, false), r = await F1(n.buffer, true);
      e === 1 ? (r.dims[0] = 3, r.dims[4] = 1) : e > 1 && (r.dims[0] = 4, r.dims[4] = e);
      const i = this.permRAS.slice();
      if (i[0] === 1 && i[1] === 2 && i[2] === 3) return r;
      r.qform_code = 0;
      for (let s = 1; s < 4; s++) r.dims[s] = this.dimsRAS[s];
      for (let s = 0; s < this.pixDimsRAS.length; s++) r.pixDims[s] = this.pixDimsRAS[s];
      let a = 0;
      for (let s = 0; s < 4; s++) for (let o = 0; o < 4; o++) r.affine[s][o] = this.matRAS[a], a++;
      return r;
    }
    img2RAS(e = 0) {
      if (!this.permRAS) throw new Error("permRAS undefined");
      if (!this.img) throw new Error("img undefined");
      if (!this.hdr) throw new Error("hdr undefined");
      const n = this.permRAS.slice();
      if (n[0] === 1 && n[1] === 2 && n[2] === 3) return this.img;
      const r = this.hdr, i = r.dims[1] * r.dims[2] * r.dims[3];
      let a = e * i;
      (a + i > this.img.length || a < 0) && (a = 0, ee.warn(`img2RAS nVolume (${e}) out of bounds (${e}+1)\xD7${i} > ${this.img.length}`));
      const s = this.img.slice(0, i), o = [
        Math.abs(n[0]),
        Math.abs(n[1]),
        Math.abs(n[2])
      ], l = [
        r.dims[o[0]],
        r.dims[o[1]],
        r.dims[o[2]]
      ], c = [
        1,
        r.dims[1],
        r.dims[1] * r.dims[2]
      ], f = [
        c[o[0] - 1],
        c[o[1] - 1],
        c[o[2] - 1]
      ], u = [
        0,
        0,
        0
      ];
      for (let g = 0; g < 3; g++) n[g] < 0 && (u[g] = f[g] * (l[g] - 1), f[g] = -f[g]);
      let h = 0;
      for (let g = 0; g < l[2]; g++) {
        const v = u[2] + g * f[2];
        for (let m = 0; m < l[1]; m++) {
          const y = u[1] + m * f[1];
          for (let w = 0; w < l[0]; w++) {
            const C = u[0] + w * f[0];
            s[h] = this.img[C + y + v + a], h++;
          }
        }
      }
      return s;
    }
    vox2mm(e, n) {
      const r = Tr(n);
      _i(r, r);
      const i = zn(e[0], e[1], e[2], 1);
      return Zr(i, i, r), Ue(i[0], i[1], i[2]);
    }
    mm2vox(e, n = false) {
      if (!this.matRAS) throw new Error("matRAS undefined");
      const r = Tr(this.matRAS), i = Tr(r);
      _i(i, r), Ti(i, i);
      const a = zn(e[0], e[1], e[2], 1);
      Zr(a, a, i);
      const s = Ue(a[0], a[1], a[2]);
      return n ? s : [
        Math.round(s[0]),
        Math.round(s[1]),
        Math.round(s[2])
      ];
    }
    arrayEquals(e, n) {
      return Array.isArray(e) && Array.isArray(n) && e.length === n.length && e.every((r, i) => r === n[i]);
    }
    setColormap(e) {
      this._colormap = e, this.calMinMax(), this.onColormapChange && this.onColormapChange(this);
    }
    setColormapLabel(e) {
      this.colormapLabel = Mn.makeLabelLut(e);
    }
    async setColormapLabelFromUrl(e) {
      this.colormapLabel = await Mn.makeLabelLutFromUrl(e);
    }
    get colormap() {
      return this._colormap;
    }
    get colorMap() {
      return this._colormap;
    }
    set colormap(e) {
      this.setColormap(e);
    }
    set colorMap(e) {
      this.setColormap(e);
    }
    get opacity() {
      return this._opacity;
    }
    set opacity(e) {
      this._opacity = e, this.onOpacityChange && this.onOpacityChange(this);
    }
    calMinMax(e = Number.POSITIVE_INFINITY, n = true) {
      if (!this.hdr) throw new Error("hdr undefined");
      if (!this.img) throw new Error("img undefined");
      let r = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, a = 0, s = 0, o = this.hdr.dims[1] * this.hdr.dims[2] * this.hdr.dims[3];
      const l = Math.floor(this.img.length / o);
      e >= l && (e = this.frame4D), e = Math.min(e, l - 1);
      const c = e * o;
      let f = [];
      if (n) {
        const F = [
          Math.floor(0.25 * this.hdr.dims[1]),
          Math.floor(0.25 * this.hdr.dims[2]),
          Math.floor(0.25 * this.hdr.dims[3])
        ], V = [
          this.hdr.dims[1] - 2 * F[0],
          this.hdr.dims[2] - 2 * F[1],
          this.hdr.dims[3] - 2 * F[2]
        ], k = [
          V[0] + F[0],
          V[1] + F[1],
          V[2] + F[2]
        ];
        o = V[0] * V[1] * V[2], f = new this.img.constructor(o);
        let _ = -1, K = 0;
        for (let Z = 0; Z < this.hdr.dims[3]; Z++) for (let j = 0; j < this.hdr.dims[2]; j++) for (let B = 0; B < this.hdr.dims[1]; B++) _++, !(B < F[0] || j < F[1] || Z < F[2]) && (B >= k[0] || j >= k[1] || Z >= k[2] || (f[K] = this.img[_ + c], K++));
      } else {
        f = new this.img.constructor(o);
        for (let N = 0; N < o; N++) f[N] = this.img[N + c];
      }
      const u = f.constructor !== Float64Array && f.constructor !== Float32Array && this.ignoreZeroVoxels;
      if (u) for (let N = 0; N < o; N++) r = Math.min(f[N], r), i = Math.max(f[N], i), f[N] === 0 && a++;
      else for (let N = 0; N < o; N++) {
        if (isNaN(f[N])) {
          s++;
          continue;
        }
        f[N] === 0 && (a++, this.ignoreZeroVoxels) || (r = Math.min(f[N], r), i = Math.max(f[N], i));
      }
      this.ignoreZeroVoxels && r === i && a > 0 && (r = 0);
      const h = this.intensityRaw2Scaled(r), g = this.intensityRaw2Scaled(i), v = Mn.colormapFromKey(this._colormap);
      let m = 0, y = 0;
      if (v.min !== void 0 && (m = v.min), v.max !== void 0 && (y = v.max), m === y && this.trustCalMinMax && isFinite(this.hdr.cal_min) && isFinite(this.hdr.cal_max) && this.hdr.cal_max > this.hdr.cal_min) return this.cal_min = this.hdr.cal_min, this.cal_max = this.hdr.cal_max, this.robust_min = this.cal_min, this.robust_max = this.cal_max, this.global_min = h, this.global_max = g, [
        this.hdr.cal_min,
        this.hdr.cal_max,
        this.hdr.cal_min,
        this.hdr.cal_max
      ];
      if (m !== y) return this.cal_min = m, this.cal_max = y, this.robust_min = this.cal_min, this.robust_max = this.cal_max, [
        m,
        y,
        m,
        y
      ];
      const w = 100 * a / (o - 0);
      let C = false;
      w > 60 && !this.ignoreZeroVoxels && (ee.warn(`${Math.round(w)}% of voxels are zero: ignoring zeros for cal_max`), C = true, this.ignoreZeroVoxels = true), this.ignoreZeroVoxels || (a = 0), a += s;
      const T = Math.round((o - 0 - a) * this.percentileFrac);
      if (T < 1 || r === i) return n ? this.calMinMax(e, false) : (ee.debug("no variability in image intensity?"), this.cal_min = h, this.cal_max = g, this.robust_min = this.cal_min, this.robust_max = this.cal_max, this.global_min = h, this.global_max = g, [
        h,
        g,
        h,
        g
      ]);
      const S = 1001, E = (S - 1) / (i - r), b = new Array(S);
      for (let N = 0; N < S; N++) b[N] = 0;
      if (u) for (let N = 0; N < o; N++) b[Math.round((f[N] - r) * E)]++;
      else if (this.ignoreZeroVoxels) for (let N = 0; N < o; N++) f[N] !== 0 && (isNaN(f[N]) || b[Math.round((f[N] - r) * E)]++);
      else for (let N = 0; N < o; N++) isNaN(f[N]) || b[Math.round((f[N] - r) * E)]++;
      let D = 0, R = 0;
      for (; D < T; ) D += b[R], R++;
      R--, D = 0;
      let I = S;
      for (; D < T; ) I--, D += b[I];
      if (R === I) {
        let N = -1;
        for (; N !== 0; ) R > 0 && (R--, b[R] > 0 && (N = 0)), N !== 0 && I < S - 1 && (I++, b[I] > 0 && (N = 0)), R === 0 && I === S - 1 && (N = 0);
      }
      let O = this.intensityRaw2Scaled(R / E + r), L = this.intensityRaw2Scaled(I / E + r);
      return this.hdr.cal_min < this.hdr.cal_max && this.hdr.cal_min >= h && this.hdr.cal_max <= g && (O = this.hdr.cal_min, L = this.hdr.cal_max), C && (O = Math.min(O, 0)), this.cal_min = O, this.cal_max = L, this.hdr.intent_code === 1002 && (this.cal_min = h, this.cal_max = g), this.robust_min = this.cal_min, this.robust_max = this.cal_max, this.global_min = h, this.global_max = g, [
        O,
        L,
        h,
        g
      ];
    }
    intensityRaw2Scaled(e) {
      if (!this.hdr) throw new Error("hdr undefined");
      return this.hdr.scl_slope === 0 && (this.hdr.scl_slope = 1), e * this.hdr.scl_slope + this.hdr.scl_inter;
    }
    intensityScaled2Raw(e) {
      if (!this.hdr) throw new Error("hdr undefined");
      return this.hdr.scl_slope === 0 && (this.hdr.scl_slope = 1), (e - this.hdr.scl_inter) / this.hdr.scl_slope;
    }
    async saveToUint8Array(e, n = null) {
      return nb(this, e, n);
    }
    async saveToDisk(e = "", n = null) {
      return IG(this, e, n);
    }
    static async fetchDicomData(e, n = {}) {
      if (e === "") throw Error("url must not be empty");
      let i = /^(?:[a-z+]+:)?\/\//i.test(e) ? e : new URL(e, window.location.href);
      /(?:.([^.]+))?$/.exec(i.pathname) || (i = new URL("niivue-manifest.txt", e));
      let o = await fetch(i, {
        headers: n
      });
      if (!o.ok) throw Error(o.statusText);
      const c = (await o.text()).split(`
`), u = /(.*\/).*/.exec(i)[0], h = [];
      for (const g of c) {
        const v = new URL(g, u);
        if (o = await fetch(v, {
          headers: n
        }), !o.ok) throw Error(o.statusText);
        const m = await o.arrayBuffer();
        h.push({
          name: g,
          data: m
        });
      }
      return h;
    }
    static async readFirstDecompressedBytes(e, n) {
      const r = e.getReader(), i = new ek(), a = [];
      let s = 0, o = false, l, c;
      const f = new Promise((h, g) => {
        l = h, c = g;
      });
      function u() {
        const h = new Uint8Array(s);
        let g = 0;
        for (const v of a) h.set(v, g), g += v.length;
        l(h);
      }
      return i.ondata = (h) => {
        a.push(h), s += h.length, s >= n && (o = true, r.cancel().catch(() => {
        }), u());
      }, (async () => {
        try {
          for (; !o; ) {
            const { done: h, value: g } = await r.read();
            if (h) {
              o = true, i.push(new Uint8Array(), true);
              return;
            }
            i.push(g, false);
          }
        } catch (h) {
          c(h);
        }
      })().catch(() => {
      }), f;
    }
    static extractFilenameFromUrl(e) {
      const r = new URL(e).searchParams.get("response-content-disposition");
      if (r) {
        const i = r.match(/filename\*?=(?:UTF-8'')?"?([^";]+)"?/);
        if (i) return decodeURIComponent(i[1]);
      }
      return e.split("/").pop().split("?")[0];
    }
    static async loadInitialVolumesGz(e = "", n = {}, r = NaN) {
      if (isNaN(r)) return null;
      const i = await fetch(e, {
        headers: n,
        cache: "force-cache"
      });
      let a = 352, s = await this.readFirstDecompressedBytes(i.body, a);
      const o = new DataView(s.buffer, s.byteOffset, s.byteLength), l = o.getUint16(0, true), c = l === 348;
      if (!c && !(l === 23553) || (s.length > 111 && (a = o.getFloat32(108, c)), a > s.length && (s = await this.readFirstDecompressedBytes(i.body, a)), !(s[0] === 92 && s[1] === 1 || s[1] === 92 && s[0] === 1))) return null;
      const h = await F1(s.buffer);
      if (!h) throw new Error("Could not read NIfTI header");
      const g = h.numBitsPerVoxel / 8, v = [
        1,
        2,
        3
      ].reduce((S, E) => S * (h.dims[E] > 1 ? h.dims[E] : 1), 1), m = [
        4,
        5,
        6
      ].reduce((S, E) => S * (h.dims[E] > 1 ? h.dims[E] : 1), 1), y = Math.max(Math.min(r, m), 1), w = h.vox_offset + y * v * g;
      if (y === m) return null;
      const C = await fetch(e, {
        headers: n,
        cache: "force-cache"
      });
      return (await this.readFirstDecompressedBytes(C.body, w)).buffer.slice(0, w);
    }
    static async loadInitialVolumes(e = "", n = {}, r = NaN) {
      if (isNaN(r)) return null;
      const a = (await fetch(e, {
        headers: n,
        cache: "force-cache"
      })).body.getReader(), { value: s, done: o } = await a.read();
      let l = s;
      if (o || !l || l.length < 2) throw new Error("Not enough data to determine compression");
      const c = new DataView(l.buffer, l.byteOffset, l.byteLength), f = c.getUint16(0, true);
      if (f === 35615) return await a.cancel(), this.loadInitialVolumesGz(e, n, r);
      const h = f === 348;
      if (!h && !(f === 23553)) return await a.cancel(), null;
      let v = 352;
      for (l.length > 111 && (v = c.getFloat32(108, h)); l.length < v; ) {
        let R = function(L, N) {
          const F = new Uint8Array(L.length + N.length);
          return F.set(L, 0), F.set(N, L.length), F;
        };
        const { value: I, done: O } = await a.read();
        if (O || !I) break;
        l = R(l, I);
      }
      const m = await F1(l.buffer);
      if (!m) throw new Error("Could not read NIfTI header");
      const y = m.numBitsPerVoxel / 8, w = [
        1,
        2,
        3
      ].reduce((R, I) => R * (m.dims[I] > 1 ? m.dims[I] : 1), 1), C = [
        4,
        5,
        6
      ].reduce((R, I) => R * (m.dims[I] > 1 ? m.dims[I] : 1), 1), T = Math.max(Math.min(r, C), 1), S = m.vox_offset + T * w * y, E = new Uint8Array(S), b = Math.min(l.length, S);
      E.set(l.subarray(0, b), 0);
      let D = b;
      for (; D < S; ) {
        const { value: R, done: I } = await a.read();
        if (I || !R) return await a.cancel(), null;
        const O = Math.min(R.length, S - D);
        E.set(R.subarray(0, O), D), D += O;
      }
      return await a.cancel(), E.buffer;
    }
    static async loadFromUrl({ url: e = "", urlImgData: n = "", headers: r = {}, name: i = "", colormap: a = "", opacity: s = 1, cal_min: o = NaN, cal_max: l = NaN, trustCalMinMax: c = true, percentileFrac: f = 0.02, ignoreZeroVoxels: u = false, useQFormNotSForm: h = false, colormapNegative: g = "", frame4D: v = 0, isManifest: m = false, limitFrames4D: y = NaN, imageType: w = Gt.UNKNOWN, colorbarVisible: C = true, buffer: T = new ArrayBuffer(0) } = {}) {
      if (e === "") throw Error("url must not be empty");
      let S = null, E = null, b = null;
      if (e instanceof Uint8Array && (e = e.slice().buffer), T.byteLength > 0 && (e = T), e instanceof ArrayBuffer) if (E = e, i !== "") e = i;
      else {
        const L = new Uint8Array(E);
        e = L[0] === 31 && L[1] === 139 ? "array.nii.gz" : "array.nii";
      }
      function D(L) {
        const N = L.match(/\.([^.]+)(?:\.gz|\.bz2|\.xz)?$/);
        return N ? N[1] : "";
      }
      let R = "";
      if (i === "" ? R = D(e) : R = D(i), w === Gt.UNKNOWN && (w = Gt.parse(R)), w === Gt.UNKNOWN && typeof e == "string") {
        const L = await fetch(e, {});
        if (L.redirected) {
          const N = this.extractFilenameFromUrl(L.url);
          N && N.length > 0 && i === "" && (i = N, R = D(i), w = Gt.parse(R));
        }
      }
      if (w === Gt.ZARR) {
        const L = new URL(e).searchParams, N = L.get("z"), F = L.get("y"), V = L.get("x"), k = N ? ih(parseInt(N), parseInt(N) + 1) : null, _ = F ? ih(parseInt(F), parseInt(F) + 1) : null, K = V ? ih(parseInt(V), parseInt(V) + 1) : null, Z = e.split("?")[0], j = new pk(Z), B = Uk(j);
        let Y;
        try {
          Y = await Sl(B.resolve(e), {
            kind: "array"
          });
        } catch {
          Y = await Sl(B, {
            kind: "array"
          });
        }
        let X;
        if (Y.shape.length === 4) {
          const Pe = Y.shape[2], ot = Y.shape[1], vt = Y.shape[0];
          k && k[0] >= Pe && (k[0] = Pe - 1), _ && _[0] >= ot && (_[0] = ot - 1), K && K[0] >= vt && (K[0] = vt - 1), X = await Jw(Y, [
            K,
            _,
            k,
            null
          ]);
        } else X = await Jw(Y, [
          K,
          _,
          k
        ]);
        E = X.data;
        const [ie, oe, he, Le] = X.shape;
        b = {
          data: E,
          width: oe,
          height: ie,
          depth: he,
          channels: Le
        };
      }
      const I = w === Gt.DCM || Gt.NII;
      if (!E && I && (E = await this.loadInitialVolumes(e, r, y)), !E) if (m) E = await Tg.fetchDicomData(e, r), w = Gt.DCM_MANIFEST;
      else {
        const L = await fetch(e, {
          headers: r
        });
        if (!L.ok) throw Error(L.statusText);
        if (!L.body) throw new Error("No readable stream available");
        const N = await e4(L.body), F = [], V = N.getReader();
        for (; ; ) {
          const { done: Z, value: j } = await V.read();
          if (Z) break;
          F.push(j);
        }
        const k = F.reduce((Z, j) => Z + j.length, 0);
        E = new ArrayBuffer(k);
        const _ = new Uint8Array(E);
        let K = 0;
        for (const Z of F) _.set(Z, K), K += Z.length;
      }
      R.toUpperCase() === "HEAD" && n === "" && (n = e.substring(0, e.lastIndexOf("HEAD")) + "BRIK");
      let O = null;
      if (n) try {
        let L = await fetch(n, {
          headers: r
        });
        if (L.status === 404 && n.includes("BRIK") && (L = await fetch(`${n}.gz`, {
          headers: r
        })), L.ok && L.body) {
          const N = await e4(L.body), F = [], V = N.getReader();
          for (; ; ) {
            const { done: Z, value: j } = await V.read();
            if (Z) break;
            F.push(j);
          }
          const k = F.reduce((Z, j) => Z + j.length, 0);
          O = new ArrayBuffer(k);
          const _ = new Uint8Array(O);
          let K = 0;
          for (const Z of F) _.set(Z, K), K += Z.length;
        }
      } catch (L) {
        console.error("Error loading paired image data:", L);
      }
      if (!E) throw new Error("Unable to load buffer properly from volume");
      if (!i) {
        let L;
        try {
          L = new URL(e).pathname.split("/");
        } catch {
          L = e.split("/");
        }
        i = L.slice(-1)[0], i.indexOf("?") > -1 && (i = i.slice(0, i.indexOf("?")));
      }
      return S = await this.new(E, i, a, s, O, o, l, c, f, u, h, g, v, w, NaN, NaN, true, null, 0, b), S.url = e, S.colorbarVisible = C, S;
    }
    static async readFileAsync(e, n = NaN) {
      let r = e.stream();
      if (!isNaN(n)) {
        let u = 0;
        const h = new TransformStream({
          transform(g, v) {
            if (u >= n) {
              v.terminate();
              return;
            }
            const m = n - u;
            g.length > m ? (v.enqueue(g.slice(0, m)), v.terminate()) : v.enqueue(g), u += g.length;
          }
        });
        r = r.pipeThrough(h);
      }
      const i = await e4(r), a = [], s = i.getReader();
      for (; ; ) {
        const { done: u, value: h } = await s.read();
        if (u) break;
        a.push(h);
      }
      const o = a.reduce((u, h) => u + h.length, 0), l = new ArrayBuffer(o), c = new Uint8Array(l);
      let f = 0;
      for (const u of a) c.set(u, f), f += u.length;
      return l;
    }
    static async loadFromFile({ file: e, name: n = "", colormap: r = "", opacity: i = 1, urlImgData: a = null, cal_min: s = NaN, cal_max: o = NaN, trustCalMinMax: l = true, percentileFrac: c = 0.02, ignoreZeroVoxels: f = false, useQFormNotSForm: u = false, colormapNegative: h = "", frame4D: g = 0, limitFrames4D: v = NaN, imageType: m = Gt.UNKNOWN }) {
      let y = null, w = [];
      try {
        if (Array.isArray(e)) w = await Promise.all(e.map((T) => this.readFileAsync(T)));
        else {
          if (isNaN(v)) w = await this.readFileAsync(e);
          else {
            const T = await this.readFileAsync(e, 512), S = new Uint8Array(T);
            if (!(S[0] === 92 && S[1] === 1 || S[1] === 92 && S[0] === 1)) w = await this.readFileAsync(e);
            else {
              const b = await F1(T);
              if (!b) throw new Error("could not read nifti header");
              const D = b.numBitsPerVoxel / 8, R = [
                1,
                2,
                3
              ].reduce((N, F) => N * (b.dims[F] > 1 ? b.dims[F] : 1), 1), I = [
                4,
                5,
                6
              ].reduce((N, F) => N * (b.dims[F] > 1 ? b.dims[F] : 1), 1), O = Math.max(Math.min(v, I), 1), L = b.vox_offset + O * R * D;
              w = await this.readFileAsync(e, L);
            }
          }
          n = e.name;
        }
        let C = null;
        a && (C = await this.readFileAsync(a)), y = await this.new(w, n, r, i, C, s, o, l, c, f, u, h, g, m, NaN, NaN, true, null, 0, null), y.fileObject = e;
      } catch (C) {
        throw ee.error(C), new Error("could not build NVImage");
      }
      if (y === null) throw new Error("could not build NVImage");
      return y;
    }
    static createNiftiArray(e = [
      256,
      256,
      256
    ], n = [
      1,
      1,
      1
    ], r = [
      1,
      0,
      0,
      -128,
      0,
      1,
      0,
      -128,
      0,
      0,
      1,
      -128,
      0,
      0,
      0,
      1
    ], i = 2, a = new Uint8Array()) {
      return OG(e, n, r, i, a);
    }
    static createNiftiHeader(e = [
      256,
      256,
      256
    ], n = [
      1,
      1,
      1
    ], r = [
      1,
      0,
      0,
      -128,
      0,
      1,
      0,
      -128,
      0,
      0,
      1,
      -128,
      0,
      0,
      0,
      1
    ], i = 2) {
      return eb(e, n, r, i);
    }
    getVolumeData(e = [
      -1,
      0,
      0
    ], n = [
      0,
      0,
      0
    ], r = "same") {
      return NG(this, e, n, r);
    }
    setVolumeData(e = [
      -1,
      0,
      0
    ], n = [
      0,
      0,
      0
    ], r = new Uint8Array()) {
      LG(this, e, n, r);
    }
    static async loadFromBase64({ base64: e, name: n = "", colormap: r = "", opacity: i = 1, cal_min: a = NaN, cal_max: s = NaN, trustCalMinMax: o = true, percentileFrac: l = 0.02, ignoreZeroVoxels: c = false, useQFormNotSForm: f = false, colormapNegative: u = "", frame4D: h = 0, imageType: g = Gt.UNKNOWN, cal_minNeg: v = NaN, cal_maxNeg: m = NaN, colorbarVisible: y = true, colormapLabel: w = null }) {
      function C(S) {
        const E = window.atob(S), b = E.length, D = new Uint8Array(b);
        for (let R = 0; R < b; R++) D[R] = E.charCodeAt(R);
        return D.buffer;
      }
      let T = null;
      try {
        const S = C(e);
        T = await this.new(S, n, r, i, null, a, s, o, l, c, f, u, h, g, v, m, y, w, 0, null);
      } catch (S) {
        ee.debug(S);
      }
      if (T === null) throw new Error("could not load NVImage");
      return T;
    }
    clone() {
      const e = new Tg();
      return e.id = Lv(), e.hdr = Object.assign({}, this.hdr), e.img = this.img.slice(), e.calculateRAS(), e.calMinMax(), e;
    }
    zeroImage() {
      this.img.fill(0);
    }
    getImageMetadata() {
      if (!this.hdr) throw new Error("hdr undefined");
      const e = this.id, n = this.hdr.datatypeCode, r = this.hdr.dims, i = r[1], a = r[2], s = r[3], o = Math.max(1, r[4]), l = this.hdr.pixDims, c = l[1], f = l[2], u = l[3], h = l[4], g = Math.floor(this.hdr.numBitsPerVoxel / 8);
      return {
        id: e,
        datatypeCode: n,
        nx: i,
        ny: a,
        nz: s,
        nt: o,
        dx: c,
        dy: f,
        dz: u,
        dt: h,
        bpv: g
      };
    }
    static zerosLike(e, n = "same") {
      const r = e.clone();
      return r.zeroImage(), n === "uint8" && (r.img = Uint8Array.from(r.img), r.hdr.datatypeCode = 2, r.hdr.numBitsPerVoxel = 8), n === "float32" && (r.img = Float32Array.from(r.img), r.hdr.datatypeCode = 16, r.hdr.numBitsPerVoxel = 32), r;
    }
    getValue(e, n, r, i = 0, a = false) {
      return VG(this, e, n, r, i, a);
    }
    getValues(e, n, r, i = 0, a = false) {
      return rb(this, e, n, r, i, a);
    }
    applyOptionsUpdate(e) {
      this.hdr.cal_min = e.cal_min, this.hdr.cal_max = e.cal_max, Object.assign(this, e);
    }
    getImageOptions() {
      return Cg("", "", this.name, this._colormap, this.opacity, this.hdr.cal_min, this.hdr.cal_max, this.trustCalMinMax, this.percentileFrac, this.ignoreZeroVoxels, this.useQFormNotSForm, this.colormapNegative, this.frame4D, this.imageType, this.colormapType);
    }
    toUint8Array(e = null) {
      return tb(this, e);
    }
    convertVox2Frac(e) {
      return Ue((e[0] + 0.5) / this.dimsRAS[1], (e[1] + 0.5) / this.dimsRAS[2], (e[2] + 0.5) / this.dimsRAS[3]);
    }
    convertFrac2Vox(e) {
      return Ue(Math.round(e[0] * this.dims[1] - 0.5), Math.round(e[1] * this.dims[2] - 0.5), Math.round(e[2] * this.dims[3] - 0.5));
    }
    convertFrac2MM(e, n = false) {
      const r = zn(e[0], e[1], e[2], 1);
      return n ? Zr(r, r, this.frac2mm) : Zr(r, r, this.frac2mmOrtho), r;
    }
    convertMM2Frac(e, n = false) {
      const r = zn(e[0], e[1], e[2], 1), i = this.dimsRAS, a = Ue(0, 0, 0);
      if (typeof i > "u") return a;
      if (!n) {
        const o = Tr(this.frac2mmOrtho);
        return Ti(o, o), Zr(r, r, o), a[0] = r[0], a[1] = r[1], a[2] = r[2], a;
      }
      if (i[1] < 1 || i[2] < 1 || i[3] < 1) return a;
      const s = Tr(this.matRAS);
      return Ti(s, s), _i(s, s), Zr(r, r, s), a[0] = (r[0] + 0.5) / i[1], a[1] = (r[1] + 0.5) / i[2], a[2] = (r[2] + 0.5) / i[3], a;
    }
  }, cb = ((t) => (t[t.AXIAL = 0] = "AXIAL", t[t.CORONAL = 1] = "CORONAL", t[t.SAGITTAL = 2] = "SAGITTAL", t[t.MULTIPLANAR = 3] = "MULTIPLANAR", t[t.RENDER = 4] = "RENDER", t))(cb || {}), ub = ((t) => (t[t.none = 0] = "none", t[t.contrast = 1] = "contrast", t[t.measurement = 2] = "measurement", t[t.pan = 3] = "pan", t[t.slicer3D = 4] = "slicer3D", t[t.callbackOnly = 5] = "callbackOnly", t[t.roiSelection = 6] = "roiSelection", t[t.angle = 7] = "angle", t[t.crosshair = 8] = "crosshair", t[t.windowing = 9] = "windowing", t))(ub || {}), ns = {
    textHeight: -1,
    fontSizeScaling: 0.4,
    fontMinPx: 13,
    colorbarHeight: 0.05,
    colorbarWidth: -1,
    showColorbarBorder: true,
    crosshairWidth: 1,
    crosshairWidthUnit: "voxels",
    crosshairGap: 0,
    rulerWidth: 4,
    show3Dcrosshair: false,
    backColor: [
      0,
      0,
      0,
      1
    ],
    crosshairColor: [
      1,
      0,
      0,
      1
    ],
    fontColor: [
      0.5,
      0.5,
      0.5,
      1
    ],
    selectionBoxColor: [
      1,
      1,
      1,
      0.5
    ],
    clipPlaneColor: [
      0.7,
      0,
      0.7,
      0.5
    ],
    paqdUniforms: [
      0.3,
      0.5,
      0.5,
      1
    ],
    clipThick: 2,
    clipVolumeLow: [
      0,
      0,
      0
    ],
    clipVolumeHigh: [
      1,
      1,
      1
    ],
    rulerColor: [
      1,
      0,
      0,
      0.8
    ],
    colorbarMargin: 0.05,
    trustCalMinMax: true,
    clipPlaneHotKey: "KeyC",
    viewModeHotKey: "KeyV",
    doubleTouchTimeout: 500,
    longTouchTimeout: 1e3,
    keyDebounceTime: 50,
    isNearestInterpolation: false,
    isResizeCanvas: true,
    atlasOutline: 0,
    atlasActiveIndex: 0,
    isRuler: false,
    isColorbar: false,
    isOrientCube: false,
    tileMargin: 0,
    multiplanarPadPixels: 0,
    multiplanarForceRender: false,
    multiplanarEqualSize: false,
    multiplanarShowRender: 2,
    isRadiologicalConvention: false,
    meshThicknessOn2D: 1 / 0,
    dragMode: 1,
    dragModePrimary: 8,
    mouseEventConfig: void 0,
    touchEventConfig: void 0,
    yoke3Dto2DZoom: false,
    isDepthPickMesh: false,
    isCornerOrientationText: false,
    isOrientationTextVisible: true,
    showAllOrientationMarkers: false,
    heroImageFraction: 0,
    heroSliceType: 4,
    sagittalNoseLeft: false,
    isSliceMM: false,
    isV1SliceShader: false,
    forceDevicePixelRatio: 0,
    logLevel: "info",
    loadingText: "loading ...",
    isForceMouseClickToVoxelCenters: false,
    dragAndDropEnabled: true,
    drawingEnabled: false,
    penValue: 1,
    penType: 0,
    floodFillNeighbors: 6,
    isFilledPen: false,
    thumbnail: "",
    maxDrawUndoBitmaps: 8,
    sliceType: 3,
    meshXRay: 0,
    isAntiAlias: null,
    limitFrames4D: NaN,
    isAdditiveBlend: false,
    showLegend: true,
    legendBackgroundColor: [
      0.3,
      0.3,
      0.3,
      0.5
    ],
    legendTextColor: [
      1,
      1,
      1,
      1
    ],
    multiplanarLayout: 0,
    renderOverlayBlend: 1,
    sliceMosaicString: "",
    centerMosaic: false,
    penSize: 1,
    interactive: true,
    clickToSegment: false,
    clickToSegmentRadius: 3,
    clickToSegmentBright: true,
    clickToSegmentAutoIntensity: false,
    clickToSegmentIntensityMax: NaN,
    clickToSegmentIntensityMin: NaN,
    clickToSegmentPercent: 0,
    clickToSegmentMaxDistanceMM: Number.POSITIVE_INFINITY,
    clickToSegmentIs2D: false,
    selectionBoxLineThickness: 4,
    selectionBoxIsOutline: false,
    scrollRequiresFocus: false,
    showMeasureUnits: true,
    measureTextJustify: "center",
    measureTextColor: [
      1,
      0,
      0,
      1
    ],
    measureLineColor: [
      1,
      0,
      0,
      1
    ],
    measureTextHeight: 0.06,
    isAlphaClipDark: false,
    gradientOrder: 1,
    gradientOpacity: 0,
    renderSilhouette: 0,
    gradientAmount: 0,
    invertScrollDirection: false,
    is2DSliceShader: false
  }, k1 = {
    gamma: 1,
    azimuth: 110,
    elevation: 10,
    crosshairPos: Ue(0.5, 0.5, 0.5),
    clipPlane: [
      0,
      0,
      0,
      0
    ],
    clipPlaneDepthAziElev: [
      2,
      0,
      0
    ],
    volScaleMultiplier: 1,
    pan2Dxyzmm: zn(0, 0, 0, 1),
    clipThick: 2,
    clipVolumeLow: [
      0,
      0,
      0
    ],
    clipVolumeHigh: [
      1,
      1,
      1
    ]
  };
  function _G(t, e) {
    const n = {};
    for (const r in t) {
      const i = t[r], a = e[r], s = Array.isArray(i) && Array.isArray(a);
      (s && i.some((o, l) => o !== a[l]) || !s && i !== a) && (n[r] = i);
    }
    return n;
  }
  var t4 = class hl {
    constructor() {
      J(this, "data", {
        title: "Untitled document",
        imageOptionsArray: [],
        meshOptionsArray: [],
        opts: {
          ...ns
        },
        previewImageDataURL: "",
        labels: [],
        encodedImageBlobs: [],
        encodedDrawingBlob: ""
      }), J(this, "scene"), J(this, "volumes", []), J(this, "meshDataObjects"), J(this, "meshes", []), J(this, "drawBitmap", null), J(this, "imageOptionsMap", /* @__PURE__ */ new Map()), J(this, "meshOptionsMap", /* @__PURE__ */ new Map()), J(this, "completedMeasurements", []), J(this, "completedAngles", []), J(this, "_optsProxy", null), J(this, "_optsChangeCallback", null), this.scene = {
        onAzimuthElevationChange: () => {
        },
        onZoom3DChange: () => {
        },
        sceneData: {
          ...k1,
          pan2Dxyzmm: zn(0, 0, 0, 1),
          crosshairPos: Ue(0.5, 0.5, 0.5)
        },
        get renderAzimuth() {
          return this.sceneData.azimuth;
        },
        set renderAzimuth(e) {
          this.sceneData.azimuth = e, this.onAzimuthElevationChange && this.onAzimuthElevationChange(this.sceneData.azimuth, this.sceneData.elevation);
        },
        get renderElevation() {
          return this.sceneData.elevation;
        },
        set renderElevation(e) {
          this.sceneData.elevation = e, this.onAzimuthElevationChange && this.onAzimuthElevationChange(this.sceneData.azimuth, this.sceneData.elevation);
        },
        get volScaleMultiplier() {
          return this.sceneData.volScaleMultiplier;
        },
        set volScaleMultiplier(e) {
          this.sceneData.volScaleMultiplier = e, this.onZoom3DChange(e);
        },
        get crosshairPos() {
          return this.sceneData.crosshairPos;
        },
        set crosshairPos(e) {
          this.sceneData.crosshairPos = e;
        },
        get clipPlane() {
          return this.sceneData.clipPlane;
        },
        set clipPlane(e) {
          this.sceneData.clipPlane = e;
        },
        get clipPlaneDepthAziElev() {
          return this.sceneData.clipPlaneDepthAziElev;
        },
        set clipPlaneDepthAziElev(e) {
          this.sceneData.clipPlaneDepthAziElev = e;
        },
        get pan2Dxyzmm() {
          return this.sceneData.pan2Dxyzmm;
        },
        set pan2Dxyzmm(e) {
          this.sceneData.pan2Dxyzmm = e;
        },
        get gamma() {
          return this.sceneData.gamma;
        },
        set gamma(e) {
          this.sceneData.gamma = e;
        }
      };
    }
    get title() {
      return this.data.title;
    }
    get previewImageDataURL() {
      return this.data.previewImageDataURL;
    }
    set previewImageDataURL(e) {
      this.data.previewImageDataURL = e;
    }
    set title(e) {
      this.data.title = e;
    }
    get imageOptionsArray() {
      return this.data.imageOptionsArray;
    }
    get encodedImageBlobs() {
      return this.data.encodedImageBlobs;
    }
    get encodedDrawingBlob() {
      return this.data.encodedDrawingBlob;
    }
    get opts() {
      return this._optsProxy || this._createOptsProxy(), this._optsProxy;
    }
    set opts(e) {
      this.data.opts = {
        ...e
      }, this._optsProxy = null;
    }
    get labels() {
      return this.data.labels;
    }
    set labels(e) {
      this.data.labels = e;
    }
    get customData() {
      return this.data.customData;
    }
    set customData(e) {
      this.data.customData = e;
    }
    hasImage(e) {
      return this.volumes.find((n) => n.id === e.id) !== void 0;
    }
    hasImageFromUrl(e) {
      return this.data.imageOptionsArray.find((n) => n.url === e) !== void 0;
    }
    addImageOptions(e, n) {
      if (!this.hasImage(e) && !n.name) if (n.url) {
        const i = /^(?:[a-z+]+:)?\/\//i.test(n.url) ? new URL(n.url) : new URL(n.url, window.location.href);
        n.name = i.pathname.split("/").pop(), n.name.toLowerCase().endsWith(".gz") && (n.name = n.name.slice(0, -3)), n.name.toLowerCase().endsWith(".nii") || (n.name += ".nii");
      } else n.name = "untitled.nii";
      n.imageType = Gt.NII, this.data.imageOptionsArray.push(n), this.imageOptionsMap.set(e.id, this.data.imageOptionsArray.length - 1);
    }
    removeImage(e) {
      if (this.imageOptionsMap.has(e.id)) {
        const n = this.imageOptionsMap.get(e.id);
        this.data.imageOptionsArray.length > n && this.data.imageOptionsArray.splice(n, 1), this.imageOptionsMap.delete(e.id);
      }
      this.volumes = this.volumes.filter((n) => n.id !== e.id);
    }
    async fetchLinkedData() {
      var _a3;
      if (this.data.encodedImageBlobs = [], !!((_a3 = this.imageOptionsArray) == null ? void 0 : _a3.length)) {
        for (const e of this.imageOptionsArray) if (e.url) try {
          const n = await fetch(e.url);
          if (!n.ok) {
            console.warn("Failed to fetch image:", e.url);
            continue;
          }
          const r = await n.arrayBuffer(), i = new Uint8Array(r), a = ft.uint8tob64(i);
          this.data.encodedImageBlobs.push(a), console.info("fetch linked data fetched from ", e.url);
        } catch (n) {
          console.warn(`Failed to fetch/encode image from ${e.url}:`, n);
        }
      }
    }
    getImageOptions(e) {
      return this.imageOptionsMap.has(e.id) ? this.data.imageOptionsArray[this.imageOptionsMap.get(e.id)] : null;
    }
    json(e = true, n = true) {
      const r = {
        encodedImageBlobs: [],
        previewImageDataURL: this.data.previewImageDataURL,
        imageOptionsMap: /* @__PURE__ */ new Map()
      }, i = [];
      r.sceneData = {
        ...this.scene.sceneData
      }, r.opts = _G(this.opts, ns), this.opts.meshThicknessOn2D === 1 / 0 && (r.opts.meshThicknessOn2D = "infinity"), this.opts.meshThicknessOn2D === 1 / 0 && (r.opts.meshThicknessOn2D = "infinity"), r.labels = [
        ...this.data.labels
      ];
      for (const s of r.labels) delete s.onClick;
      if (r.customData = this.customData, r.completedMeasurements = [
        ...this.completedMeasurements
      ], r.completedAngles = [
        ...this.completedAngles
      ], this.volumes.length) for (let s = 0; s < this.volumes.length; s++) {
        const o = this.volumes[s];
        let l = this.getImageOptions(o);
        if (l === null ? (ee.warn("no options found for image, using options from the volume directly"), l = {
          name: (o == null ? void 0 : o.name) ?? "",
          colormap: (o == null ? void 0 : o._colormap) ?? "gray",
          opacity: (o == null ? void 0 : o._opacity) ?? 1,
          pairedImgData: null,
          cal_min: (o == null ? void 0 : o.cal_min) ?? NaN,
          cal_max: (o == null ? void 0 : o.cal_max) ?? NaN,
          trustCalMinMax: (o == null ? void 0 : o.trustCalMinMax) ?? true,
          percentileFrac: (o == null ? void 0 : o.percentileFrac) ?? 0.02,
          ignoreZeroVoxels: (o == null ? void 0 : o.ignoreZeroVoxels) ?? false,
          useQFormNotSForm: (o == null ? void 0 : o.useQFormNotSForm) ?? false,
          colormapNegative: (o == null ? void 0 : o.colormapNegative) ?? "",
          colormapLabel: (o == null ? void 0 : o.colormapLabel) ?? null,
          imageType: (o == null ? void 0 : o.imageType) ?? Gt.NII,
          frame4D: (o == null ? void 0 : o.frame4D) ?? 0,
          limitFrames4D: (o == null ? void 0 : o.limitFrames4D) ?? NaN,
          url: (o == null ? void 0 : o.url) ?? "",
          urlImageData: (o == null ? void 0 : o.urlImgData) ?? "",
          alphaThreshold: false,
          cal_minNeg: (o == null ? void 0 : o.cal_minNeg) ?? NaN,
          cal_maxNeg: (o == null ? void 0 : o.cal_maxNeg) ?? NaN,
          colorbarVisible: (o == null ? void 0 : o.colorbarVisible) ?? true
        }) : "imageType" in l || (l.imageType = Gt.NII), l.colormap = o.colormap, l.colormapLabel = o.colormapLabel, l.opacity = o.opacity, l.cal_max = o.cal_max ?? NaN, l.cal_min = o.cal_min ?? NaN, i.push(l), e) {
          const c = ft.uint8tob64(o.toUint8Array());
          r.encodedImageBlobs.push(c);
        }
        r.imageOptionsMap.set(o.id, s);
      }
      r.imageOptionsArray = [
        ...i
      ];
      const a = [];
      r.connectomes = [];
      for (const s of this.meshes) {
        if (s.type === "connectome") {
          r.connectomes.push(JSON.stringify(s.json()));
          continue;
        }
        const o = {
          pts: s.pts,
          tris: s.tris,
          name: s.name,
          rgba255: Uint8Array.from(s.rgba255),
          opacity: s.opacity,
          connectome: s.connectome,
          dpg: s.dpg,
          dps: s.dps,
          dpv: s.dpv,
          meshShaderIndex: s.meshShaderIndex,
          layers: s.layers.map((l) => ({
            values: l.values,
            nFrame4D: l.nFrame4D,
            frame4D: 0,
            outlineBorder: l.outlineBorder,
            global_min: l.global_min,
            global_max: l.global_max,
            cal_min: l.cal_min,
            cal_max: l.cal_max,
            opacity: l.opacity,
            colormap: l.colormap,
            colormapNegative: l.colormapNegative,
            colormapLabel: l.colormapLabel,
            useNegativeCmap: l.useNegativeCmap
          })),
          hasConnectome: s.hasConnectome,
          edgeColormap: s.edgeColormap,
          edgeColormapNegative: s.edgeColormapNegative,
          edgeMax: s.edgeMax,
          edgeMin: s.edgeMin,
          edges: s.edges && Array.isArray(s.edges) ? [
            ...s.edges
          ] : [],
          extentsMax: s.extentsMax,
          extentsMin: s.extentsMin,
          furthestVertexFromOrigin: s.furthestVertexFromOrigin,
          nodeColormap: s.nodeColormap,
          nodeColormapNegative: s.nodeColormapNegative,
          nodeMaxColor: s.nodeMaxColor,
          nodeMinColor: s.nodeMinColor,
          nodeScale: s.nodeScale,
          legendLineThickness: s.legendLineThickness,
          offsetPt0: s.offsetPt0,
          nodes: s.nodes
        };
        s.offsetPt0 && s.offsetPt0.length > 0 && (o.offsetPt0 = s.offsetPt0, o.fiberGroupColormap = s.fiberGroupColormap, o.fiberColor = s.fiberColor, o.fiberDither = s.fiberDither, o.fiberRadius = s.fiberRadius, o.colormap = s.colormap), a.push(o);
      }
      return r.meshesString = JSON.stringify(G_(a)), n && this.drawBitmap && (r.encodedDrawingBlob = ft.uint8tob64(this.drawBitmap)), r;
    }
    async download(e, n, r = {
      embedImages: true
    }) {
      const i = this.json(r.embedImages), a = JSON.stringify(i), s = n ? "application/gzip" : "application/json", o = n ? await ft.compressStringToArrayBuffer(a) : a;
      ft.download(o, e, s);
    }
    static deserializeMeshDataObjects(e) {
      if (!e.data.meshesString || e.data.meshesString === "[]") {
        e.meshDataObjects = [];
        return;
      }
      if (e.data.meshesString) {
        e.meshDataObjects = B_(JSON.parse(e.data.meshesString));
        for (const n of e.meshDataObjects) for (const r of n.layers) "colorMap" in r && (r.colormap = r.colorMap, delete r.colorMap), "colorMapNegative" in r && (r.colormapNegative = r.colorMapNegative, delete r.colorMapNegative);
      }
    }
    static async loadFromUrl(e) {
      const r = await (await fetch(e)).arrayBuffer();
      let i;
      if (ft.isArrayBufferCompressed(r)) {
        const a = await ft.decompressArrayBuffer(r);
        i = JSON.parse(a);
      } else {
        const a = new TextDecoder();
        i = JSON.parse(a.decode(r));
      }
      return hl.loadFromJSON(i);
    }
    static async loadFromFile(e) {
      const n = await ft.readFileAsync(e);
      let r;
      const i = new hl();
      return ft.isArrayBufferCompressed(n) ? r = await ft.decompressArrayBuffer(n) : r = new TextDecoder().decode(n), i.data = JSON.parse(r), i.data.opts.meshThicknessOn2D === "infinity" && (i.data.opts.meshThicknessOn2D = 1 / 0), i.scene.sceneData = {
        ...k1,
        ...i.data.sceneData
      }, hl.deserializeMeshDataObjects(i), i;
    }
    static loadFromJSON(e) {
      const n = new hl();
      return Object.assign(n.data, {
        ...e,
        imageOptionsArray: e.imageOptionsArray ?? [],
        encodedImageBlobs: e.encodedImageBlobs ?? [],
        labels: e.labels ?? [],
        meshOptionsArray: e.meshOptionsArray ?? [],
        connectomes: e.connectomes ?? [],
        encodedDrawingBlob: e.encodedDrawingBlob ?? "",
        previewImageDataURL: e.previewImageDataURL ?? "",
        customData: e.customData ?? "",
        title: e.title ?? "untitled"
      }), n.data.opts = {
        ...ns,
        ...e.opts || {}
      }, n.data.opts.meshThicknessOn2D === "infinity" && (n.data.opts.meshThicknessOn2D = 1 / 0), n.scene.sceneData = {
        ...k1,
        ...e.sceneData || {}
      }, e.completedMeasurements && (n.completedMeasurements = e.completedMeasurements.map((r) => ({
        ...r,
        startMM: ki(r.startMM),
        endMM: ki(r.endMM)
      }))), e.completedAngles && (n.completedAngles = e.completedAngles.map((r) => ({
        ...r,
        firstLineMM: {
          start: ki(r.firstLineMM.start),
          end: ki(r.firstLineMM.end)
        },
        secondLineMM: {
          start: ki(r.secondLineMM.start),
          end: ki(r.secondLineMM.end)
        }
      }))), n.data.meshesString && hl.deserializeMeshDataObjects(n), n;
    }
    static oldloadFromJSON(e) {
      const n = new hl();
      return n.data = e, n.data.opts.meshThicknessOn2D === "infinity" && (n.data.opts.meshThicknessOn2D = 1 / 0), n.scene.sceneData = {
        ...k1,
        ...e.sceneData
      }, hl.deserializeMeshDataObjects(n), n;
    }
    setOptsChangeCallback(e) {
      this._optsChangeCallback = e, this._optsProxy = null;
    }
    removeOptsChangeCallback() {
      this._optsChangeCallback = null, this._optsProxy = null;
    }
    _createOptsProxy() {
      const e = this.data.opts;
      this._optsProxy = new Proxy(e, {
        set: (n, r, i) => {
          const a = n[r];
          return a !== i && (n[r] = i, this._optsChangeCallback && typeof r == "string" && r in ns && this._optsChangeCallback(r, i, a)), true;
        },
        get: (n, r) => n[r]
      });
    }
  }, kG = {
    colormap: "gray",
    opacity: 0,
    nFrame4D: 0,
    frame4D: 0,
    outlineBorder: 0,
    cal_min: 0,
    cal_max: 0,
    cal_minNeg: 0,
    cal_maxNeg: 0,
    colormapType: 0,
    values: new Array(),
    useNegativeCmap: false,
    showLegend: true
  }, ou = class Ss {
    constructor(e, n, r = "", i = new Uint8Array([
      255,
      255,
      255,
      255
    ]), a = 1, s = true, o, l = null, c = null, f = null, u = null, h = true, g = "") {
      J(this, "id"), J(this, "name"), J(this, "anatomicalStructurePrimary"), J(this, "colorbarVisible"), J(this, "furthestVertexFromOrigin"), J(this, "extentsMin"), J(this, "extentsMax"), J(this, "opacity"), J(this, "visible"), J(this, "meshShaderIndex", 0), J(this, "offsetPt0", null), J(this, "colormapInvert", false), J(this, "fiberGroupColormap", null), J(this, "indexBuffer"), J(this, "vertexBuffer"), J(this, "vao"), J(this, "vaoFiber"), J(this, "pts"), J(this, "tris"), J(this, "layers"), J(this, "type", "mesh"), J(this, "data_type"), J(this, "rgba255"), J(this, "fiberLength"), J(this, "fiberLengths"), J(this, "fiberDensity"), J(this, "fiberDither", 0.1), J(this, "fiberColor", "Global"), J(this, "fiberDecimationStride", 1), J(this, "fiberSides", 5), J(this, "fiberRadius", 0), J(this, "fiberOcclusion", 0), J(this, "f32PerVertex", 5), J(this, "fiberMask"), J(this, "colormap"), J(this, "dpg"), J(this, "dps"), J(this, "dpv"), J(this, "hasConnectome", false), J(this, "connectome"), J(this, "indexCount"), J(this, "vertexCount", 1), J(this, "nodeScale", 4), J(this, "edgeScale", 1), J(this, "legendLineThickness", 0), J(this, "showLegend", true), J(this, "nodeColormap", "warm"), J(this, "edgeColormap", "warm"), J(this, "nodeColormapNegative"), J(this, "edgeColormapNegative"), J(this, "nodeMinColor"), J(this, "nodeMaxColor"), J(this, "edgeMin"), J(this, "edgeMax"), J(this, "nodes"), J(this, "edges"), J(this, "points"), this.anatomicalStructurePrimary = g, this.name = r, this.colorbarVisible = h, this.id = Lv();
      const v = Ec.getExtents(e);
      if (this.furthestVertexFromOrigin = v.mxDx, this.extentsMin = v.extentsMin, this.extentsMax = v.extentsMax, this.opacity = a > 1 ? 1 : a, this.visible = s, this.meshShaderIndex = 0, this.indexBuffer = o.createBuffer(), this.vertexBuffer = o.createBuffer(), this.vao = o.createVertexArray(), o.bindVertexArray(this.vao), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this.indexBuffer), o.bindBuffer(o.ARRAY_BUFFER, this.vertexBuffer), o.enableVertexAttribArray(0), o.enableVertexAttribArray(1), this.f32PerVertex !== 7 ? (o.vertexAttribPointer(0, 3, o.FLOAT, false, 20, 0), o.vertexAttribPointer(1, 4, o.BYTE, true, 20, 12), o.enableVertexAttribArray(2), o.vertexAttribPointer(2, 4, o.UNSIGNED_BYTE, true, 20, 16)) : (o.vertexAttribPointer(0, 3, o.FLOAT, false, 28, 0), o.vertexAttribPointer(1, 3, o.FLOAT, false, 28, 12), o.enableVertexAttribArray(2), o.vertexAttribPointer(2, 4, o.UNSIGNED_BYTE, true, 28, 24)), o.bindVertexArray(null), this.vaoFiber = o.createVertexArray(), this.offsetPt0 = null, this.hasConnectome = false, this.colormapInvert = false, this.fiberGroupColormap = null, this.pts = e, this.layers = [], this.type = "mesh", this.tris = n, i[3] < 1) {
        this.rgba255 = i, this.fiberLength = 2, this.fiberDither = 0.1, this.fiberColor = "Global", this.fiberDecimationStride = 1, this.fiberMask = [], this.colormap = l, this.dpg = c, this.dps = f, this.dpv = u, c && this.initValuesArray(c), f && this.initValuesArray(f), u && this.initValuesArray(u), this.offsetPt0 = new Uint32Array(n), this.tris = new Uint32Array(0), this.updateFibers(o), o.bindVertexArray(this.vaoFiber), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this.indexBuffer), o.bindBuffer(o.ARRAY_BUFFER, this.vertexBuffer), o.enableVertexAttribArray(0), o.vertexAttribPointer(0, 3, o.FLOAT, false, 16, 0), o.enableVertexAttribArray(1), o.vertexAttribPointer(1, 4, o.UNSIGNED_BYTE, true, 16, 12), o.bindVertexArray(null);
        return;
      }
      if (l) {
        this.connectome = l, this.hasConnectome = true;
        const y = Object.keys(l);
        for (let w = 0, C = y.length; w < C; w++) this[y[w]] = l[y[w]];
      }
      this.rgba255 = i, this.updateMesh(o);
    }
    initValuesArray(e) {
      for (let n = 0; n < e.length; n++) {
        const r = e[n].vals.reduce((a, s) => Math.min(a, s)), i = e[n].vals.reduce((a, s) => Math.max(a, s));
        e[n].global_min = r, e[n].global_max = i, e[n].cal_min = r, e[n].cal_max = i;
      }
      return e;
    }
    linesToCylinders(e, n, r) {
      function i(I) {
        return Ue(I[0], I[1], I[2]);
      }
      const a = Math.pow(2, 32) - 1, s = r.length;
      let o = 0, l = 0;
      for (let I = 0; I < s; I++) {
        if (r[I] === a) {
          l++;
          continue;
        }
        o++;
      }
      const c = this.fiberSides, f = c * o, u = this.f32PerVertex;
      if (u !== 5) throw Error("fiberSides > 1 requires f32PerVertex == 5");
      const h = new Float32Array(f * u), g = new Uint8Array(h.buffer);
      let v = 0, m = Rs(), y = Rs(), w = Rs();
      const C = He();
      let T = He(), S = 0;
      const E = this.fiberRadius;
      for (let I = 0; I < s; I++) {
        const O = r[I] === a;
        if (O && S < 1) continue;
        let L = r[I] * 4;
        if (S++, S <= 1) {
          m = zn(n[L + 0], n[L + 1], n[L + 2], n[L + 3]), y = Tl(m), I + 1 < s && r[I + 1] !== a && (L = r[I + 1] * 4, w = zn(n[L + 0], n[L + 1], n[L + 2], n[L + 3]), Ft(C, i(m), i(w)), Pr(C, C), T = zc.getFirstPerpVector(C));
          continue;
        }
        O ? w = Tl(y) : w = zn(n[L + 0], n[L + 1], n[L + 2], n[L + 3]), Ft(C, i(m), i(w)), Pr(C, C);
        const N = He();
        Vr(N, T, C);
        const F = He();
        Vr(F, C, N), T = ki(T);
        const V = He();
        Vr(V, C, F), Pr(V, V);
        const k = He();
        for (let _ = 0; _ < c; _++) {
          const K = Math.cos(_ / c * 2 * Math.PI), Z = Math.sin(_ / c * 2 * Math.PI);
          k[0] = E * (K * F[0] + Z * V[0]), k[1] = E * (K * F[1] + Z * V[1]), k[2] = E * (K * F[2] + Z * V[2]), Ai(k, i(y), k);
          const j = v * u;
          h[j + 0] = k[0], h[j + 1] = k[1], h[j + 2] = k[2];
          const B = He();
          Ft(B, k, i(y)), Pr(B, B);
          const Y = (j + 3) * 4;
          g[Y + 0] = B[0] * 127, g[Y + 1] = B[1] * 127, g[Y + 2] = B[2] * 127, h[j + 4] = y[3], v++;
        }
        m = Tl(y), y = Tl(w), O && (S = 0);
      }
      const b = (o - l) * c * 2 * 3, D = new Uint32Array(b);
      let R = 0;
      v = 0;
      for (let I = 1; I < s; I++) {
        if (r[I] === a) {
          v += c;
          continue;
        }
        if (r[I - 1] === a) continue;
        let O = v, L = v + c;
        const N = L, F = L + c;
        for (let V = 0; V < c; V++) D[R++] = O, D[R++] = L++, L === F && (L = F - c), D[R++] = L, D[R++] = O++, O === N && (O = N - c), D[R++] = L, D[R++] = O;
        v += c;
      }
      e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, Uint32Array.from(D), e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, g, e.STATIC_DRAW), this.indexCount = b;
    }
    createFiberDensityMap() {
      if (this.fiberDensity) return;
      const e = this.pts, n = e.length / 3;
      let r = 0;
      for (let C = 0; C < 3; C++) {
        const T = this.extentsMax[C] - this.extentsMin[C];
        r = Math.max(r, T);
      }
      if (this.fiberDensity = new Float32Array(n), r === 0) return;
      const i = 64, s = r / (i - 1) / 2, o = (i - 1) / r;
      let l = new Float32Array(i * i * i);
      const c = [
        this.extentsMin[0] - s,
        this.extentsMin[1] - s,
        this.extentsMin[2] - s
      ], f = [
        0,
        0,
        0
      ], u = -1, h = i * i;
      let g = 0;
      for (let C = 0; C < n; C++) {
        f[0] = Math.round((e[g++] - c[0]) * o), f[1] = Math.round((e[g++] - c[1]) * o), f[2] = Math.round((e[g++] - c[2]) * o);
        const T = f[0] + f[1] * i + f[2] * h;
        T !== u && l[T]++;
      }
      function v(C, T) {
        let S = C.slice(), E = -1;
        const b = T - 1;
        for (let R = 0; R < T; R++) for (let I = 0; I < T; I++) for (let O = 0; O < T; O++) E++, !(O < 1 || O >= b) && (C[E] = S[E - 1] + S[E] + S[E] + S[E + 1]);
        E = -1, S = C.slice();
        for (let R = 0; R < T; R++) for (let I = 0; I < T; I++) for (let O = 0; O < T; O++) E++, !(I < 1 || I >= b) && (C[E] = S[E - T] + S[E] + S[E] + S[E + T]);
        const D = T * T;
        E = -1, S = C.slice();
        for (let R = 0; R < T; R++) for (let I = 0; I < T; I++) for (let O = 0; O < T; O++) E++, !(R < 1 || R >= b) && (C[E] = S[E - D] + S[E] + S[E] + S[D]);
        return C;
      }
      l = v(l, i), l = v(l, i);
      let m = 0, y = 1 / 0;
      const w = i * i * i;
      for (let C = 0; C < w; C++) l[C] <= 0 || (m = Math.max(m, l[C]), y = Math.min(y, l[C]));
      if (!(m <= 1 || m <= y)) {
        g = 0;
        for (let C = 0; C < w; C++) l[C] = Math.max(0, l[C] - y);
        m -= y;
        for (let C = 0; C < n; C++) {
          f[0] = Math.round((e[g++] - c[0]) * o), f[1] = Math.round((e[g++] - c[1]) * o), f[2] = Math.round((e[g++] - c[2]) * o);
          const T = f[0] + f[1] * i + f[2] * h;
          this.fiberDensity[C] = l[T] / m;
        }
      }
    }
    updateFibers(e) {
      if (!this.offsetPt0 || !this.fiberLength) return;
      const n = this.pts, r = this.offsetPt0, i = r.length - 1, a = n.length / 3;
      if (!this.fiberLengths) {
        this.fiberLengths = new Uint32Array(i);
        for (let b = 0; b < i; b++) {
          const D = r[b] * 3, R = (r[b + 1] - 1) * 3;
          let I = 0;
          for (let O = D; O < R; O += 3) {
            const L = Ue(n[O + 0] - n[O + 3], n[O + 1] - n[O + 4], n[O + 2] - n[O + 5]);
            I += Pc(L);
          }
          this.fiberLengths[b] = I;
        }
      }
      const s = new Float32Array(a * 4), o = new Uint32Array(s.buffer);
      let l = 0, c = 0;
      for (let b = 0; b < a; b++) s[c + 0] = n[l + 0], s[c + 1] = n[l + 1], s[c + 2] = n[l + 2], l += 3, c += 4;
      const f = this.fiberDither, u = f * 0.5;
      function h(b, D, R) {
        const O = 255 * (f * Math.random() - u);
        return b = Math.max(Math.min(b + O, 255), 0), D = Math.max(Math.min(D + O, 255), 0), R = Math.max(Math.min(R + O, 255), 0), b + (D << 8) + (R << 16);
      }
      function g(b, D, R, I, O, L, N) {
        const F = Ue(Math.abs(b - I), Math.abs(D - O), Math.abs(R - L));
        Pr(F, F);
        const V = N - u;
        for (let k = 0; k < 3; k++) F[k] = 255 * Math.max(Math.min(Math.abs(F[k]) + V, 1), 0);
        return F[0] + (F[1] << 8) + (F[2] << 16);
      }
      const v = this.fiberColor.toLowerCase();
      let m = null, y = null;
      if (v.startsWith("dps") && this.dps && this.dps.length > 0) {
        const b = parseInt(v.substring(3));
        b < this.dps.length && this.dps[b].vals.length === i && (m = this.dps[b].vals);
      }
      if (v.startsWith("dpv") && this.dpv && this.dpv.length > 0) {
        const b = parseInt(v.substring(3));
        b < this.dpv.length && this.dpv[b].vals.length === a && (y = this.dpv[b]);
      }
      const w = new Int16Array(i);
      if (this.dpg && this.fiberGroupColormap !== null) {
        const b = new Uint8ClampedArray(this.dpg.length * 4), D = new Array(this.dpg.length).fill(false), R = this.fiberGroupColormap;
        R.A === void 0 && (R.A = Array.from(new Uint8ClampedArray(R.I.length).fill(255)));
        for (let I = 0; I < R.I.length; I++) {
          let O = R.I[I];
          O < 0 || O >= this.dpg.length || R.A[I] < 1 || (D[O] = true, O *= 4, b[O] = R.R[I], b[O + 1] = R.G[I], b[O + 2] = R.B[I], b[O + 3] = 255);
        }
        w.fill(-1);
        for (let I = 0; I < this.dpg.length; I++) if (D[I]) for (let O = 0; O < this.dpg[I].vals.length; O++) w[this.dpg[I].vals[O]] = I;
        for (let I = 0; I < i; I++) {
          if (w[I] < 0) continue;
          const O = w[I] % 256 * 4, L = h(b[O], b[O + 1], b[O + 2]), N = r[I], F = r[I + 1] - 1, V = N * 4 + 3, k = F * 4 + 3;
          for (let _ = V; _ <= k; _ += 4) o[_] = L;
        }
      } else if (y) {
        const b = Mn.colormap(this.colormap, this.colormapInvert), D = y.cal_min, R = y.cal_max;
        let I = 3;
        for (let O = 0; O < a; O++) {
          let L = Math.min(Math.max((y.vals[O] - D) / (R - D), 0), 1);
          L = Math.round(Math.max(Math.min(255, L * 255))) * 4;
          const N = b[L] + (b[L + 1] << 8) + (b[L + 2] << 16);
          o[I] = N, I += 4;
        }
      } else if (m) {
        const b = Mn.colormap(this.colormap, this.colormapInvert);
        let D = m[0], R = m[0];
        for (let I = 0; I < i; I++) D = Math.min(D, m[I]), R = Math.max(R, m[I]);
        R === D && (D -= 1);
        for (let I = 0; I < i; I++) {
          let O = (m[I] - D) / (R - D);
          O = Math.round(Math.max(Math.min(255, O * 255))) * 4;
          const L = b[O] + (b[O + 1] << 8) + (b[O + 2] << 16), N = r[I], F = r[I + 1] - 1, V = N * 4 + 3, k = F * 4 + 3;
          for (let _ = V; _ <= k; _ += 4) o[_] = L;
        }
      } else if (v.includes("fixed")) if (f === 0) {
        const b = this.rgba255[0] + (this.rgba255[1] << 8) + (this.rgba255[2] << 16);
        let D = 3;
        for (let R = 0; R < a; R++) o[D] = b, D += 4;
      } else for (let b = 0; b < i; b++) {
        const D = h(this.rgba255[0], this.rgba255[1], this.rgba255[2]), R = r[b], I = r[b + 1] - 1, O = R * 4 + 3, L = I * 4 + 3;
        for (let N = O; N <= L; N += 4) o[N] = D;
      }
      else if (v.includes("local")) for (let b = 0; b < i; b++) {
        const D = r[b], R = r[b + 1] - 1;
        let I = D * 3;
        const O = R * 3, L = f * Math.random();
        let N = g(n[I], n[I + 1], n[I + 2], n[I + 4], n[I + 5], n[I + 6], L), F = D * 4 + 3;
        for (; I < O; ) o[F] = N, F += 4, I += 3, N = g(n[I - 3], n[I - 2], n[I - 1], n[I + 3], n[I + 4], n[I + 5], L);
        o[F] = o[F - 4];
      }
      else for (let b = 0; b < i; b++) {
        const D = r[b], R = r[b + 1] - 1, I = D * 3, O = R * 3, L = g(n[I], n[I + 1], n[I + 2], n[O], n[O + 1], n[O + 2], f * Math.random()), N = D * 4 + 3, F = R * 4 + 3;
        for (let V = N; V <= F; V += 4) o[V] = L;
      }
      if (this.fiberOcclusion > 0) {
        let b = function(D, R) {
          const I = R * (D & 255), O = R * (D >> 8 & 255), L = R * (D >> 16 & 255);
          return I + (O << 8) + (L << 16);
        };
        this.createFiberDensityMap();
        for (let D = 0; D < i; D++) {
          const R = r[D], I = r[D + 1] - 1, O = R * 4 + 3, L = I * 4 + 3;
          let N = R;
          const F = Math.min(this.fiberOcclusion, 0.99);
          for (let V = O; V <= L; V += 4) {
            let k = this.fiberDensity[N++];
            if (k <= 0) continue;
            k = k / ((1 / F - 2) * (1 - k) + 1);
            const _ = 1 - Math.min(k, 0.9);
            let K = o[V];
            K = b(K, _), o[V] = K;
          }
        }
      }
      const C = this.fiberLength, T = Math.pow(2, 32) - 1, S = [];
      let E = -1;
      for (let b = 0; b < i; b++) if (!(w[b] < 0) && !(this.fiberLengths[b] < C) && (E++, E % this.fiberDecimationStride === 0)) {
        for (let D = r[b]; D < r[b + 1]; D++) S.push(D);
        S.push(T);
      }
      this.fiberSides > 2 && this.fiberRadius > 0 ? this.linesToCylinders(e, s, S) : (this.indexCount = S.length, e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, Uint32Array.from(o), e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, Uint32Array.from(S), e.STATIC_DRAW));
    }
    indexNearestXYZmm(e, n, r) {
      const i = this.pts, a = this.pts.length / 3;
      let s = 0, o = 1 / 0, l = 0;
      for (let c = 0; c < a; c++) {
        const f = Math.pow(i[s] - e, 2) + Math.pow(i[s + 1] - n, 2) + Math.pow(i[s + 2] - r, 2);
        f < o && (o = f, l = c), s += 3;
      }
      return o = Math.sqrt(o), [
        l,
        o
      ];
    }
    unloadMesh(e) {
      if (e.bindBuffer(e.ARRAY_BUFFER, null), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null), e.bindVertexArray(null), e.deleteBuffer(this.vertexBuffer), e.deleteBuffer(this.indexBuffer), e.deleteVertexArray(this.vao), e.deleteVertexArray(this.vaoFiber), this.offsetPt0 = null, this.tris = null, this.pts = null, this.layers && this.layers.length > 0) for (let n = 0; n < this.layers.length; n++) this.layers[n].values = null;
      if (this.dpg && this.dpg.length > 0) for (let n = 0; n < this.dpg.length; n++) this.dpg[n].vals = null;
      if (this.dps && this.dps.length > 0) for (let n = 0; n < this.dps.length; n++) this.dps[n].vals = null;
    }
    scalars2RGBA(e, n, r, i = false) {
      const a = r.length;
      if (4 * a < e.length) return ee.error(`colormap2RGBA incorrectly specified ${a}*4 != ${e.length}`), e;
      const s = Math.round(n.opacity * 255);
      let o = n.cal_min, l = n.cal_max, c = Mn.colormap(n.colormap, this.colormapInvert), f = 1;
      if (i) {
        if (!n.useNegativeCmap) return e;
        f = -1, c = Mn.colormap(n.colormapNegative, n.colormapInvert), o = n.cal_min, l = n.cal_max, isFinite(n.cal_minNeg) && isFinite(n.cal_minNeg) && (o = -n.cal_minNeg, l = -n.cal_maxNeg);
      }
      let u = o;
      n.isTransparentBelowCalMin || (u = Number.NEGATIVE_INFINITY);
      const h = n.colormapType === 2;
      n.colormapType !== 0 && (o = Math.min(o, 0));
      const g = 255 / (l - o);
      for (let v = 0; v < a; v++) {
        let m = r[v] * f;
        if (isNaN(m)) continue;
        let y = s;
        if (m < u) if (m > 0 && h) y = Math.round(n.opacity * 255 * Math.pow(m / u, 2));
        else continue;
        if (m = (m - o) * g, m < 0 && n.isTransparentBelowCalMin) continue;
        m = Math.min(255, Math.max(0, Math.round(m))) * 4;
        const w = v * 4;
        e[w + 0] = c[m + 0], e[w + 1] = c[m + 1], e[w + 2] = c[m + 2], e[w + 3] = y;
      }
      return e;
    }
    blendColormap(e, n, r, i, a, s, o = false) {
      const l = this.pts.length / 3, c = Math.min(r.opacity, 1);
      function f(T, S, E) {
        return T * (1 - E) + S * E;
      }
      function u(T, S) {
        return Math.min(T + S, 255);
      }
      const h = o ? -1 : 1, g = Math.min(Math.max(r.frame4D, 0), r.nFrame4D - 1), v = l * g;
      let m = i;
      r.isTransparentBelowCalMin || (m = Number.NEGATIVE_INFINITY), r.colormapType !== 0 && (i = Math.min(i, 0));
      const y = 255 / (a - i);
      let w = new Array(l).fill(false);
      if (r.outlineBorder !== 0) {
        const T = new Uint8Array(l).fill(0);
        for (let S = 0; S < l; S++) h * r.values[S + v] >= m && (T[S] = 1);
        w = Ec.getClusterBoundaryU8(T, this.tris);
        for (let S = 0; S < l; S++) h * r.values[S + v] < m && (w[S] = false);
      }
      const C = new Float32Array(256).fill(c);
      if (m > i && r.colormapType === 2) {
        let T = Math.round((m - i) * y);
        T = Math.max(T, 1);
        for (let S = 1; S < T; S++) C[S] = c * Math.pow(S / T, 2);
        C[0] = 0, m = i + Number.EPSILON;
      }
      for (let T = 0; T < l; T++) {
        const S = h * r.values[T + v];
        if (S < m) continue;
        let E = Math.round((S - i) * y);
        if (E < 0 && r.isTransparentBelowCalMin) continue;
        E = Math.max(0, E), E = Math.min(255, E);
        let b = C[E];
        E *= 4;
        let D = T * 28 + 24;
        if (this.f32PerVertex !== 7 && (D = T * 20 + 16), r.isAdditiveBlend) {
          const R = T * 4;
          n[R + 0] = u(n[R + 0], s[E + 0]), n[R + 1] = u(n[R + 1], s[E + 1]), n[R + 2] = u(n[R + 2], s[E + 2]), n[R + 3] = u(n[R + 3], 255);
        } else {
          if (w[T] && (b = r.outlineBorder, r.outlineBorder < 0)) {
            e[D + 0] = 0, e[D + 1] = 0, e[D + 2] = 0;
            continue;
          }
          e[D + 0] = f(e[D + 0], s[E + 0], b), e[D + 1] = f(e[D + 1], s[E + 1], b), e[D + 2] = f(e[D + 2], s[E + 2], b);
        }
      }
    }
    updateMesh(e) {
      if (this.offsetPt0) {
        this.updateFibers(e);
        return;
      }
      if (this.hasConnectome) return;
      if (!this.pts || !this.tris || !this.rgba255) {
        ee.warn("underspecified mesh");
        return;
      }
      function n(c, f, u) {
        return c * (1 - u) + f * u;
      }
      const r = this.generatePosNormClr(this.pts, this.tris, this.rgba255), i = this.pts.length / 3, a = new Uint8Array(r.buffer);
      let s = 0;
      const o = new Uint8Array(i * 4);
      let l = this.tris;
      if (this.layers && this.layers.length > 0) for (let c = 0; c < this.layers.length; c++) {
        const f = this.layers[c], u = f.opacity;
        if (u <= 0 || f.cal_min > f.cal_max) continue;
        if (f.outlineBorder === void 0 && (f.outlineBorder = 0), f.isAdditiveBlend === void 0 && (f.isAdditiveBlend = false), f.colormapLabel && f.colormapLabel.R && !f.colormapLabel.lut && (f.colormapLabel = Mn.makeLabelLut(f.colormapLabel)), f.colormapLabel && f.colormapLabel.lut) {
          const g = f.colormapLabel;
          let v = 0;
          f.colormapLabel.min && (v = f.colormapLabel.min);
          let m = g.lut;
          const y = Math.round(f.opacity * 255);
          m[3] > 0 && (m[3] = y);
          for (let D = 7; D < m.length; D += 4) m[D] = y;
          const w = Math.floor(m.length / 4);
          if (f.atlasValues && w > 0 && w === f.atlasValues.length && f.colormap) {
            const D = f.atlasValues;
            let R = false, I = true;
            for (let O = 0; O < w; O++) isNaN(D[O]) ? R = true : I = false;
            if (I) {
              ee.debug("invisible mesh: all atlasValues are NaN.");
              return;
            }
            if (R) {
              ee.debug("some vertices have NaN atlasValues (mesh will be decimated).");
              const O = new Array(i).fill(false);
              for (let k = 0; k < i; k++) {
                const _ = Math.round(f.values[k]) - v;
                isNaN(D[_]) && (O[k] = true);
              }
              const L = new Array(l.length).fill(false);
              for (let k = 0; k < l.length; k++) O[l[k]] && (L[k] = true);
              const N = this.tris;
              let F = 0;
              for (let k = 0; k < N.length; k += 3) !L[k] && !L[k + 1] && !L[k + 2] && F++;
              F === 0 && ee.debug("invisible mesh: all triangles of a vertex with a NaN atlasValue."), l = new Uint32Array(F * 3);
              let V = 0;
              for (let k = 0; k < N.length; k += 3) !L[k] && !L[k + 1] && !L[k + 2] && (l[V++] = N[k], l[V++] = N[k + 1], l[V++] = N[k + 2]);
            }
            m.fill(0), m = this.scalars2RGBA(m, f, D), f.useNegativeCmap && (m = this.scalars2RGBA(m, f, D, true));
          } else f.atlasValues && ee.warn(`Expected ${w} atlasValues but got ${f.atlasValues.length} for mesh layer`);
          if (f.showLegend && w === f.colormapLabel.labels.length) {
            f.labels = [];
            for (let D = 0; D < w; D++) {
              const R = Array.from(m.slice(D * 4, D * 4 + 4)).map((F) => F / 255), I = f.colormapLabel.labels[D], O = [
                0,
                0,
                0
              ];
              let L = 0;
              for (let F = 0; F < i; F++) if (f.values[F] === D) {
                const V = F * 3;
                O[0] += this.pts[V], O[1] += this.pts[V + 1], O[2] += this.pts[V + 2], L++;
              }
              if (L > 0 && (O[0] /= L, O[1] /= L, O[2] /= L), R[3] === 0 || !I || I.startsWith("_")) continue;
              R[3] = 1;
              const N = new u8(I, {
                textColor: R,
                bulletScale: 1,
                bulletColor: R,
                lineWidth: 0,
                lineColor: R,
                textScale: 1,
                textAlignment: "left",
                lineTerminator: "none"
              }, O);
              f.labels.push(N), ee.debug("label for mesh layer:", N);
            }
          } else delete f.labels;
          const C = Math.min(Math.max(f.frame4D, 0), f.nFrame4D - 1), T = i * C, S = new Uint8Array(i * 4);
          let E = 0;
          for (let D = 0; D < i; D++) {
            const R = f.values[D + T] - v, I = 4 * Math.min(Math.max(R, 0), w - 1);
            S[E + 0] = m[I + 0], S[E + 1] = m[I + 1], S[E + 2] = m[I + 2], S[E + 3] = m[I + 3], E += 4;
          }
          let b = new Array(i).fill(false);
          f.outlineBorder !== 0 && (b = Ec.getClusterBoundary(S, this.tris)), E = 0;
          for (let D = 0; D < i; D++) {
            let R = D * 28 + 24;
            this.f32PerVertex !== 7 && (R = D * 20 + 16);
            let I = S[E + 3] / 255;
            if (b[D] && (I = f.outlineBorder, f.outlineBorder < 0)) {
              a[R + 0] = 0, a[R + 1] = 0, a[R + 2] = 0, E += 4;
              continue;
            }
            a[R + 0] = n(a[R + 0], S[E + 0], I), a[R + 1] = n(a[R + 1], S[E + 1], I), a[R + 2] = n(a[R + 2], S[E + 2], I), E += 4;
          }
          continue;
        }
        if (f.values instanceof Uint8Array) {
          const g = new Uint8Array(f.values.buffer);
          let v = new Array(i).fill(true);
          f.outlineBorder !== 0 && (v = Ec.getClusterBoundary(g, this.tris));
          let m = 0;
          for (let y = 0; y < f.values.length; y++) {
            let w = y * 28 + 24;
            this.f32PerVertex !== 7 && (w = y * 20 + 16);
            let C = u;
            if (v[y] && (C = f.outlineBorder, f.outlineBorder < 0)) {
              a[w + 0] = 0, a[w + 1] = 0, a[w + 2] = 0, m += 4;
              continue;
            }
            a[w + 0] = n(a[w + 0], g[m + 0], C), a[w + 1] = n(a[w + 1], g[m + 1], C), a[w + 2] = n(a[w + 2], g[m + 2], C), m += 4;
          }
          continue;
        }
        f.useNegativeCmap && (f.cal_min = Math.max(Number.EPSILON, f.cal_min), f.cal_max = Math.max(f.cal_min + 1e-6, f.cal_max)), f.isTransparentBelowCalMin === void 0 && (f.isTransparentBelowCalMin = true);
        const h = Mn.colormap(f.colormap, f.colormapInvert);
        if (f.isAdditiveBlend && s++, this.blendColormap(a, o, f, f.cal_min, f.cal_max, h), f.useNegativeCmap) {
          const g = Mn.colormap(f.colormapNegative, f.colormapInvert);
          let v = f.cal_min, m = f.cal_max;
          isFinite(f.cal_minNeg) && isFinite(f.cal_minNeg) && (v = -f.cal_minNeg, m = -f.cal_maxNeg), this.blendColormap(a, o, f, v, m, g, true);
        }
      }
      if (s > 0) for (let c = 0; c < i; c++) {
        let f = function(v, m) {
          return Math.min(v * m * 0.00392156862745098, 255);
        }, u = c * 28 + 24;
        this.f32PerVertex !== 7 && (u = c * 20 + 16);
        const h = c * 4, g = Math.min(s, o[h + 3] / 255);
        g <= 0 || (a[u + 0] = f(a[u + 0], o[h + 0]), a[u + 1] = f(a[u + 1], o[h + 1]), a[u + 2] = f(a[u + 2], o[h + 2]), a[u + 0] = n(a[u + 0], o[h + 0], g), a[u + 1] = n(a[u + 1], o[h + 1], g), a[u + 2] = n(a[u + 2], o[h + 2], g));
      }
      e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, Uint32Array.from(l), e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, a, e.STATIC_DRAW), this.indexCount = l.length, this.vertexCount = this.pts.length;
    }
    reverseFaces(e) {
      if (this.offsetPt0 || this.hasConnectome) return;
      const n = this.tris || [];
      for (let r = 0; r < n.length; r += 3) {
        const i = n[r];
        n[r] = n[r + 1], n[r + 1] = i;
      }
      this.updateMesh(e);
    }
    hierarchicalOrder() {
      const r = this.tris.length / 3, i = Math.log(r / 20) / Math.log(4);
      if (r !== Math.pow(4, i) * 20) return NaN;
      if (this.pts.length / 3 !== Math.pow(4, i) * 10 + 2) return NaN;
      for (let s = 0; s < 15; s += 3) if (this.tris[s] !== 0) return NaN;
      for (let s = 15; s < 24; s += 3) if (this.tris[s] !== 3) return NaN;
      for (let s = 24; s < 30; s += 3) if (this.tris[s] !== 4) return NaN;
      return i;
    }
    decimateFaces(e, n) {
      let r = this.tris;
      const i = 12, a = 20;
      for (let s = e - 1; s >= n; s--) {
        const o = Math.pow(4, s + 1) * (i - 2) + 2, l = Math.pow(4, s) * (i - 2) + 2, c = r.length / 3, f = Math.pow(4, s) * a;
        console.log(`order ${s + 1} -> ${s} vertices ${o} -> ${l} faces ${c} -> ${f}`);
        const u = Array.from({
          length: o
        }, (g, v) => v + 1);
        for (let g = 0; g < c; g++) {
          const v = r[3 * g], m = r[3 * g + 1], y = r[3 * g + 2];
          u[v - 1] = Math.min(u[v - 1], m, y);
        }
        const h = new Uint32Array(f * 3);
        for (let g = 0; g < f; g++) h[3 * g] = u[r[3 * g] - 1], h[3 * g + 1] = u[r[3 * g + 1] - 1], h[3 * g + 2] = u[r[3 * g + 2] - 1];
        r = h;
      }
      this.tris = new Uint32Array(r);
    }
    decimateHierarchicalMesh(e, n = 4) {
      const r = this.hierarchicalOrder();
      if (isNaN(r)) return ee.warn("Unable to decimate mesh: it does not have a hierarchical structure"), false;
      if (n >= r) return ee.warn(`Unable to decimate mesh: input order (${r}) must be larger than downsampled order (${n})`), false;
      const i = this.pts.length / 3, s = Math.pow(4, n) * (12 - 2) + 2;
      if (this.pts = new Float32Array(this.pts.slice(0, s * 3)), this.decimateFaces(r, n), this.layers && this.layers.length > 0) for (let o = 0; o < this.layers.length; o++) {
        const l = this.layers[o];
        l.values instanceof Float32Array || l.values.length !== i ? l.values = new Float32Array(l.values.slice(0, s)) : ee.warn("decimation logic needs to be updated");
      }
      return this.updateMesh(e), true;
    }
    async setLayerProperty(e, n, r, i) {
      const a = this.layers[e];
      if (!a || !(n in a)) {
        ee.warn("mesh does not have property ", n, " for layer ", a);
        return;
      }
      if (n === "colormapLabel") if (typeof r == "object") a[n] = Mn.makeLabelLut(r);
      else if (typeof r == "string") {
        const s = await Mn.makeLabelLutFromUrl(r);
        a[n] = s, this.updateMesh(i);
        return;
      } else ee.error("colormapLabel requires a string or object");
      else a[n] = r;
      this.updateMesh(i);
    }
    setProperty(e, n, r) {
      if (!(e in this)) {
        console.warn("Mesh does not have property:", e, this);
        return;
      }
      this[e] = n, this.updateMesh(r);
    }
    generatePosNormClr(e, n, r) {
      (e.length < 3 || r.length < 4) && (ee.error("Catastrophic failure generatePosNormClr()"), ee.debug("this", this), ee.debug("pts", e), ee.debug("rgba", r));
      const i = Ec.generateNormals(e, n), a = e.length / 3, s = a === r.length / 4, o = this.f32PerVertex, l = new Float32Array(a * o), c = new Uint8Array(l.buffer);
      let f = 0, u = 0, h = 0, g = (o - 1) * 4;
      for (let v = 0; v < a; v++) l[h + 0] = e[f + 0], l[h + 1] = e[f + 1], l[h + 2] = e[f + 2], o !== 7 ? (c[g - 4] = i[f + 0] * 127, c[g - 3] = i[f + 1] * 127, c[g - 2] = i[f + 2] * 127) : (l[h + 3] = i[f + 0], l[h + 4] = i[f + 1], l[h + 5] = i[f + 2]), c[g] = r[u + 0], c[g + 1] = r[u + 1], c[g + 2] = r[u + 2], c[g + 3] = r[u + 3], s && (u += 4), f += 3, h += o, g += o * 4;
      return l;
    }
    static async readMesh(e, n, r, i = 1, a = new Uint8Array([
      255,
      255,
      255,
      255
    ]), s = true) {
      let o = new Uint32Array([]), l = new Float32Array([]), c = "", f;
      const u = /(?:\.([^.]+))?$/;
      let h = u.exec(n)[1];
      if (h = h.toUpperCase(), h === "GZ" && (h = u.exec(n.slice(0, -3))[1], h = h.toUpperCase()), h === "JCON" && ee.error("you should never see this message: load using nvconnectome not nvmesh"), h === "JSON" && ee.error("you should never see this message: load using nvconnectome not nvmesh"), a[3] = Math.max(1, a[3]), h === "TCK" || h === "TRK" || h === "TT" || h === "TRX" || h === "TRACT") {
        if (h === "TCK" ? f = Qn.readTCK(e) : h === "TRACT" ? f = Qn.readTRACT(e) : h === "TT" ? f = await Qn.readTT(e) : h === "TRX" ? f = await Qn.readTRX(e) : f = await Qn.readTRK(e), typeof f > "u") {
          const y = new Float32Array([
            0,
            0,
            0,
            0,
            0,
            0
          ]), w = new Uint32Array([
            0
          ]);
          f = {
            pts: y,
            offsetPt0: w
          }, ee.error("Creating empty tracts");
        }
        return a[3] = 0, new Ss(f.pts, f.offsetPt0, n, a, i, s, r, "inferno", f.dpg || null, f.dps || null, f.dpv || null);
      }
      if (h === "GII") f = await Qn.readGII(e);
      else if (h === "MZ3") f = await Qn.readMZ3(e), "positions" in f || ee.warn("MZ3 does not have positions (statistical overlay?)");
      else if (h === "ASC") f = Qn.readASC(e);
      else if (h === "DFS") f = Qn.readDFS(e);
      else if (h === "BYU" || h === "G") f = Qn.readGEO(e);
      else if (h === "GEO") f = Qn.readGEO(e, true);
      else if (h === "ICO" || h === "TRI") f = Qn.readICO(e);
      else if (h === "OFF") f = Qn.readOFF(e);
      else if (h === "NV") f = Qn.readNV(e);
      else if (h === "OBJ") f = await Qn.readOBJ(e);
      else if (h === "PLY") f = Qn.readPLY(e);
      else if (h === "WRL") f = Qn.readWRL(e);
      else if (h === "X3D") f = Qn.readX3D(e);
      else if (h === "FIB" || h === "VTK") {
        if (f = Qn.readVTK(e), "offsetPt0" in f) return a[3] = 0, new Ss(f.pts, f.offsetPt0, n, a, i, s, r, "inferno");
      } else h === "SRF" ? f = await Qn.readSRF(e) : h === "STL" ? f = Qn.readSTL(e) : f = Qn.readFreeSurfer(e);
      if (f.anatomicalStructurePrimary && (c = f.anatomicalStructurePrimary), f instanceof Float32Array) throw new Error("fatal: unknown mesh type loaded");
      if (!("positions" in f)) throw new Error("positions not loaded");
      if (!f.indices) throw new Error("indices not loaded");
      if (l = f.positions, o = f.indices, "rgba255" in f && f.rgba255.length > 0 && (a = f.rgba255), "colors" in f && f.colors && f.colors.length === l.length) {
        const y = l.length / 3;
        a = new Uint8Array(y * 4);
        let w = 0, C = 0;
        for (let T = 0; T < y; T++) a[C++] = f.colors[w] * 255, a[C++] = f.colors[w + 1] * 255, a[C++] = f.colors[w + 2] * 255, a[C++] = 255, w += 3;
      }
      const g = l.length / 3;
      if (o.length / 3 < 1 || g < 3) throw new Error("Mesh should have at least one triangle and three vertices");
      a[3] = Math.max(1, a[3]);
      const m = new Ss(l, o, n, a, i, s, r, null, null, null, null, true, c);
      if ("scalars" in f && f.scalars.length > 0) {
        const y = await Qn.readLayer(n, e, m, i, "gray");
        typeof y > "u" ? ee.warn("readLayer() failed to convert scalars") : (m.layers.push(y), m.updateMesh(r));
      }
      return m;
    }
    static async loadLayer(e, n) {
      let r = new Uint8Array().buffer;
      function i(v) {
        const m = window.atob(v), y = m.length, w = new Uint8Array(y);
        for (let C = 0; C < y; C++) w[C] = m.charCodeAt(C);
        return w.buffer;
      }
      if (e.base64 !== void 0) r = i(e.base64);
      else {
        if (!e.url) throw new Error("layer: missing url");
        const v = await fetch(e.url, {
          headers: e.headers
        });
        if (!v.ok) throw Error(v.statusText);
        r = await v.arrayBuffer();
      }
      let a, s = [];
      if (e.name && e.name !== "") a = e.name;
      else {
        if (!e.url) throw new Error("layer: missing url");
        try {
          s = new URL(e.url).pathname.split("/");
        } catch {
          s = e.url.split("/");
        } finally {
          a = s.slice(-1)[0];
        }
      }
      a.indexOf("?") > -1 && (a = a.slice(0, a.indexOf("?")));
      let o = 0.5;
      "opacity" in e && (o = e.opacity);
      let l = "warm";
      "colormap" in e && (l = e.colormap);
      let c = "winter";
      "colormapNegative" in e && (c = e.colormapNegative);
      let f = false;
      "useNegativeCmap" in e && (f = e.useNegativeCmap);
      let u = null;
      "cal_min" in e && (u = e.cal_min);
      let h = null;
      "cal_max" in e && (h = e.cal_max);
      const g = await Qn.readLayer(a, r, n, o, l, c, f, u, h);
      g && n.layers.push(g);
    }
    static async loadFromUrl({ url: e = "", headers: n = {}, gl: r, name: i = "", opacity: a = 1, rgba255: s = [
      255,
      255,
      255,
      255
    ], visible: o = true, layers: l = [], buffer: c = new ArrayBuffer(0) } = {}) {
      let f = e.split("/");
      if (i === "") {
        try {
          f = new URL(e).pathname.split("/");
        } catch {
          f = e.split("/");
        }
        i = f.slice(-1)[0], i.indexOf("?") > -1 && (i = i.slice(0, i.indexOf("?")));
      }
      if (e === "") throw Error("url must not be empty");
      if (!r) throw Error("gl context is null");
      let u;
      if (c.byteLength > 0) u = c;
      else {
        const g = await fetch(e, {
          headers: n
        });
        if (!g.ok) throw Error(g.statusText);
        u = await g.arrayBuffer();
      }
      const h = await this.readMesh(u, i, r, a, new Uint8Array(s), o);
      if (!l || l.length < 1) return h;
      for (let g = 0; g < l.length; g++) await Ss.loadLayer(l[g], h);
      return h.updateMesh(r), h;
    }
    static async readFileAsync(e) {
      return new Promise((n, r) => {
        const i = new FileReader();
        i.onload = () => {
          n(i.result);
        }, i.onerror = r, i.readAsArrayBuffer(e);
      });
    }
    static async loadFromFile({ file: e, gl: n, name: r = "", opacity: i = 1, rgba255: a = [
      255,
      255,
      255,
      255
    ], visible: s = true, layers: o = [] } = {}) {
      if (!e) throw new Error("file must be set");
      if (!n) throw new Error("rendering context must be set");
      const l = await Ss.readFileAsync(e), c = await Ss.readMesh(l, r, n, i, new Uint8Array(a), s);
      if (!o || o.length < 1) return c;
      for (let f = 0; f < o.length; f++) await Ss.loadLayer(o[f], c);
      return c.updateMesh(n), c;
    }
    async loadFromBase64({ base64: e, gl: n, name: r = "", opacity: i = 1, rgba255: a = [
      255,
      255,
      255,
      255
    ], visible: s = true, layers: o = [] } = {}) {
      if (!e) throw new Error("base64 must bet set");
      if (!n) throw new Error("rendering context must be set");
      function l(u) {
        const h = window.atob(u), g = h.length, v = new Uint8Array(g);
        for (let m = 0; m < g; m++) v[m] = h.charCodeAt(m);
        return v.buffer;
      }
      const c = l(e), f = await Ss.readMesh(c, r, n, i, new Uint8Array(a), s);
      if (!o || o.length < 1) return f;
      for (let u = 0; u < o.length; u++) await Ss.loadLayer(o[u], f);
      return f.updateMesh(n), f;
    }
  }, PG = "data:image/jpeg;base64,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ZwAAAAAAAAALY3JvcFJlY3RUb3Bsb25nAAAAAAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQABOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAABOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EAAAAAAAAAgAAOEJJTQQCAAAAAAACAAA4QklNBDAAAAAAAAEBADhCSU0ELQAAAAAABgABAAAAMjhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM9AAAABgAAAAAAAAAAAAACAAAAAgAAAAAEAG0AYwA2ADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAIAAAAAAFJnaHRsb25nAAACAAAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAA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bnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTgtMDctMTJUMjA6MDc6NDcrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo0OGNjMGI3YS1iYTJkLWZmNDAtYmNkNC1jNGQzMzIyZjBiNzQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphYzFjM2NhNS1hYTg4LWI5NGMtOGE4MS05YmU4MjA3ZGZiODciPiA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPiA8cmRmOkJhZz4gPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6YThjMGNhZTYtODNjYy1hYzQ4LWI2YzAtN2FiODNlOWJkMGM3PC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWMxYzNjYTUtYWE4OC1iOTRjLThhODEtOWJlODIwN2RmYjg3IiBzdEV2dDp3aGVuPSIyMDE4LTA3LTEyVDIwOjA3OjQ3KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYmI3MzZlZC0zOTRhLTM2NDgtYThiOC02Mzk1MmY0NDcxMjIiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTY6MTM6NTgrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RFdnQ6d2hlbj0iMjAxOC0wNy0xM1QxNzo1NDoyNyswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvanBlZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9qcGVnIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTc6NTQ6MjcrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjg3NjM1NDk5LWZiMTItYWU0MC04NWEzLThkMWFiN2NkZGVhOSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmFjMWMzY2E1LWFhODgtYjk0Yy04YTgxLTliZTgyMDdkZmI4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAEAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1Q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", iC = "data:image/png;base64,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", aC = {
    atlas: {
      type: "msdf",
      distanceRange: 2,
      size: 59.65625,
      width: 512,
      height: 256,
      yOrigin: "bottom"
    },
    metrics: {
      emSize: 1,
      lineHeight: 1.171875,
      ascender: 0.927734375,
      descender: -0.244140625,
      underlineY: -0.09765625,
      underlineThickness: 0.048828125
    },
    glyphs: [
      {
        unicode: 32,
        advance: 0.24755859375
      },
      {
        unicode: 33,
        advance: 0.25732421875,
        planeBounds: {
          left: 0.056159633438645884,
          bottom: -0.02437761405677056,
          right: 0.20702396031135412,
          top: 0.7299440203067705
        },
        atlasBounds: {
          left: 488.5,
          bottom: 145.5,
          right: 497.5,
          top: 190.5
        }
      },
      {
        unicode: 34,
        advance: 0.31982421875,
        planeBounds: {
          left: 0.049409125974004715,
          bottom: 0.48691155587022,
          right: 0.2840869677759953,
          top: 0.77187750662978
        },
        atlasBounds: {
          left: 486.5,
          bottom: 213.5,
          right: 500.5,
          top: 230.5
        }
      },
      {
        unicode: 35,
        advance: 0.61572265625,
        planeBounds: {
          left: 0.037219103997511785,
          bottom: -0.02169206718177056,
          right: 0.6239137085024882,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 66.5,
          bottom: 51.5,
          right: 101.5,
          top: 96.5
        }
      },
      {
        unicode: 36,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.02956531458715296,
          bottom: -0.12381369908983761,
          right: 0.5324464041628472,
          top: 0.8484230740898377
        },
        atlasBounds: {
          left: 109.5,
          bottom: 197.5,
          right: 139.5,
          top: 255.5
        }
      },
      {
        unicode: 37,
        advance: 0.732421875,
        planeBounds: {
          left: 0.026481776289942378,
          bottom: -0.030073418674698794,
          right: 0.7137525987100576,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 88.5,
          bottom: 144.5,
          right: 129.5,
          top: 190.5
        }
      },
      {
        unicode: 38,
        advance: 0.62158203125,
        planeBounds: {
          left: 0.03225572125458355,
          bottom: -0.030073418674698794,
          right: 0.6357130287454166,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 130.5,
          bottom: 144.5,
          right: 166.5,
          top: 190.5
        }
      },
      {
        unicode: 39,
        advance: 0.17431640625,
        planeBounds: {
          left: 0.028244602049502358,
          bottom: 0.49895501673814824,
          right: 0.14558352295049765,
          top: 0.7671582645118518
        },
        atlasBounds: {
          left: 498.5,
          bottom: 62.5,
          right: 505.5,
          top: 78.5
        }
      },
      {
        unicode: 40,
        advance: 0.341796875,
        planeBounds: {
          left: 0.042983329377291775,
          bottom: -0.250029542422407,
          right: 0.34471198312270823,
          top: 0.8227834486724072
        },
        atlasBounds: {
          left: 0.5,
          bottom: 191.5,
          right: 18.5,
          top: 255.5
        }
      },
      {
        unicode: 41,
        advance: 0.34765625,
        planeBounds: {
          left: -0.003159248747708225,
          bottom: -0.250029542422407,
          right: 0.29856940499770823,
          top: 0.8227834486724072
        },
        atlasBounds: {
          left: 19.5,
          bottom: 191.5,
          right: 37.5,
          top: 255.5
        }
      },
      {
        unicode: 42,
        advance: 0.4306640625,
        planeBounds: {
          left: -0.011208599684062338,
          bottom: 0.27785390031593765,
          right: 0.44138438093406235,
          top: 0.7304468809340623
        },
        atlasBounds: {
          left: 449.5,
          bottom: 23.5,
          right: 476.5,
          top: 50.5
        }
      },
      {
        unicode: 43,
        advance: 0.56689453125,
        planeBounds: {
          left: 0.01353503347629649,
          bottom: 0.053493525733368255,
          right: 0.5499415290237036,
          top: 0.6066627242666317
        },
        atlasBounds: {
          left: 361.5,
          bottom: 17.5,
          right: 393.5,
          top: 50.5
        }
      },
      {
        unicode: 44,
        advance: 0.1962890625,
        planeBounds: {
          left: -0.009919475797210583,
          bottom: -0.15981695975478,
          right: 0.1744702570472106,
          top: 0.12514899100478
        },
        atlasBounds: {
          left: 498.5,
          bottom: 79.5,
          right: 509.5,
          top: 96.5
        }
      },
      {
        unicode: 45,
        advance: 0.27587890625,
        planeBounds: {
          left: -0.00527594412977999,
          bottom: 0.24333249267450235,
          right: 0.27969000662978,
          top: 0.36067141357549765
        },
        atlasBounds: {
          left: 52.5,
          bottom: 7.5,
          right: 69.5,
          top: 14.5
        }
      },
      {
        unicode: 46,
        advance: 0.26318359375,
        planeBounds: {
          left: 0.051032680313645884,
          bottom: -0.027092319686354116,
          right: 0.20189700718635412,
          top: 0.12377200718635412
        },
        atlasBounds: {
          left: 501.5,
          bottom: 221.5,
          right: 510.5,
          top: 230.5
        }
      },
      {
        unicode: 47,
        advance: 0.412109375,
        planeBounds: {
          left: -0.013733006073205867,
          bottom: -0.08573505127848349,
          right: 0.4053345685732059,
          top: 0.7356373950284835
        },
        atlasBounds: {
          left: 252.5,
          bottom: 206.5,
          right: 277.5,
          top: 255.5
        }
      },
      {
        unicode: 48,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.037458384830081196,
          bottom: -0.030073418674698794,
          right: 0.5235767714199189,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 167.5,
          bottom: 144.5,
          right: 196.5,
          top: 190.5
        }
      },
      {
        unicode: 49,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.06023674350936354,
          bottom: -0.01998308280677056,
          right: 0.37872810024063647,
          top: 0.7343385515567705
        },
        atlasBounds: {
          left: 488.5,
          bottom: 97.5,
          right: 507.5,
          top: 142.5
        }
      },
      {
        unicode: 50,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.025334353719224725,
          bottom: -0.01680925468177056,
          right: 0.5449781462807752,
          top: 0.7375123796817705
        },
        atlasBounds: {
          left: 278.5,
          bottom: 51.5,
          right: 309.5,
          top: 96.5
        }
      },
      {
        unicode: 51,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.028181041080081196,
          bottom: -0.030073418674698794,
          right: 0.5142994276699189,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 197.5,
          bottom: 144.5,
          right: 226.5,
          top: 190.5
        }
      },
      {
        unicode: 52,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.005886103858368255,
          bottom: -0.02169206718177056,
          right: 0.5590553023916317,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 310.5,
          bottom: 51.5,
          right: 343.5,
          top: 96.5
        }
      },
      {
        unicode: 53,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.055524791080081196,
          bottom: -0.02657487968177056,
          right: 0.5416431776699189,
          top: 0.7277467546817705
        },
        atlasBounds: {
          left: 344.5,
          bottom: 51.5,
          right: 373.5,
          top: 96.5
        }
      },
      {
        unicode: 54,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.046003306705081196,
          bottom: -0.034712090549698794,
          right: 0.5321216932949189,
          top: 0.7363722467996989
        },
        atlasBounds: {
          left: 227.5,
          bottom: 144.5,
          right: 256.5,
          top: 190.5
        }
      },
      {
        unicode: 55,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.018010134969224725,
          bottom: -0.02169206718177056,
          right: 0.5376539275307752,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 374.5,
          bottom: 51.5,
          right: 405.5,
          top: 96.5
        }
      },
      {
        unicode: 56,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.037702525455081196,
          bottom: -0.030073418674698794,
          right: 0.5238209120449189,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 257.5,
          bottom: 144.5,
          right: 286.5,
          top: 190.5
        }
      },
      {
        unicode: 57,
        advance: 0.5615234375,
        planeBounds: {
          left: 0.029401744205081196,
          bottom: -0.025434746799698794,
          right: 0.5155201307949189,
          top: 0.7456495905496989
        },
        atlasBounds: {
          left: 287.5,
          bottom: 144.5,
          right: 316.5,
          top: 190.5
        }
      },
      {
        unicode: 58,
        advance: 0.2421875,
        planeBounds: {
          left: 0.046394008438645884,
          bottom: -0.029431286627488215,
          right: 0.19725833531135412,
          top: 0.5572633178774882
        },
        atlasBounds: {
          left: 439.5,
          bottom: 61.5,
          right: 448.5,
          top: 96.5
        }
      },
      {
        unicode: 59,
        advance: 0.21142578125,
        planeBounds: {
          left: 0.001066852327789419,
          bottom: -0.16459733294591408,
          right: 0.1854565851722106,
          top: 0.556198895445914
        },
        atlasBounds: {
          left: 406.5,
          bottom: 53.5,
          right: 417.5,
          top: 96.5
        }
      },
      {
        unicode: 60,
        advance: 0.50830078125,
        planeBounds: {
          left: 0.016948142433865897,
          bottom: 0.0726146348300812,
          right: 0.4527784200661341,
          top: 0.5587330214199189
        },
        atlasBounds: {
          left: 394.5,
          bottom: 21.5,
          right: 420.5,
          top: 50.5
        }
      },
      {
        unicode: 61,
        advance: 0.548828125,
        planeBounds: {
          left: 0.051535540940937666,
          bottom: 0.17620354038436353,
          right: 0.5041285215590624,
          top: 0.49469489711563647
        },
        atlasBounds: {
          left: 477.5,
          bottom: 31.5,
          right: 504.5,
          top: 50.5
        }
      },
      {
        unicode: 62,
        advance: 0.5224609375,
        planeBounds: {
          left: 0.047629290940937666,
          bottom: 0.0731029160800812,
          right: 0.5002222715590624,
          top: 0.5592213026699189
        },
        atlasBounds: {
          left: 421.5,
          bottom: 21.5,
          right: 448.5,
          top: 50.5
        }
      },
      {
        unicode: 63,
        advance: 0.47216796875,
        planeBounds: {
          left: 0.016704001808865897,
          bottom: -0.027876153049698794,
          right: 0.4525342794411341,
          top: 0.7432081842996989
        },
        atlasBounds: {
          left: 317.5,
          bottom: 144.5,
          right: 343.5,
          top: 190.5
        }
      },
      {
        unicode: 64,
        advance: 0.89794921875,
        planeBounds: {
          left: 0.034064457306783605,
          bottom: -0.23896750384690937,
          right: 0.8721996065996072,
          top: 0.7165065663469093
        },
        atlasBounds: {
          left: 155.5,
          bottom: 198.5,
          right: 205.5,
          top: 255.5
        }
      },
      {
        unicode: 65,
        advance: 0.65234375,
        planeBounds: {
          left: -0.008838044092129387,
          bottom: -0.02169206718177056,
          right: 0.6616700753421295,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 237.5,
          bottom: 51.5,
          right: 277.5,
          top: 96.5
        }
      },
      {
        unicode: 66,
        advance: 0.62255859375,
        planeBounds: {
          left: 0.06464099434422473,
          bottom: -0.02169206718177056,
          right: 0.5842847869057752,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 205.5,
          bottom: 51.5,
          right: 236.5,
          top: 96.5
        }
      },
      {
        unicode: 67,
        advance: 0.65087890625,
        planeBounds: {
          left: 0.038439807122511785,
          bottom: -0.030073418674698794,
          right: 0.6251344116274882,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 344.5,
          bottom: 144.5,
          right: 379.5,
          top: 190.5
        }
      },
      {
        unicode: 68,
        advance: 0.65576171875,
        planeBounds: {
          left: 0.06301501010836826,
          bottom: -0.02169206718177056,
          right: 0.6161842086416317,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 162.5,
          bottom: 51.5,
          right: 195.5,
          top: 96.5
        }
      },
      {
        unicode: 69,
        advance: 0.568359375,
        planeBounds: {
          left: 0.0652904160800812,
          bottom: -0.02169206718177056,
          right: 0.5514088026699189,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 132.5,
          bottom: 51.5,
          right: 161.5,
          top: 96.5
        }
      },
      {
        unicode: 70,
        advance: 0.552734375,
        planeBounds: {
          left: 0.059675181705081196,
          bottom: -0.02169206718177056,
          right: 0.5457935682949189,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 102.5,
          bottom: 51.5,
          right: 131.5,
          top: 96.5
        }
      },
      {
        unicode: 71,
        advance: 0.68115234375,
        planeBounds: {
          left: 0.040148791497511785,
          bottom: -0.030073418674698794,
          right: 0.6268433960024882,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 380.5,
          bottom: 144.5,
          right: 415.5,
          top: 190.5
        }
      },
      {
        unicode: 72,
        advance: 0.712890625,
        planeBounds: {
          left: 0.062365588372511785,
          bottom: -0.02169206718177056,
          right: 0.6490601928774882,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 30.5,
          bottom: 51.5,
          right: 65.5,
          top: 96.5
        }
      },
      {
        unicode: 73,
        advance: 0.27197265625,
        planeBounds: {
          left: 0.06917965680657412,
          bottom: -0.02169206718177056,
          right: 0.20328128069342588,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 196.5,
          bottom: 51.5,
          right: 204.5,
          top: 96.5
        }
      },
      {
        unicode: 74,
        advance: 0.5517578125,
        planeBounds: {
          left: 0.007184947330081194,
          bottom: -0.02657487968177056,
          right: 0.4933033339199188,
          top: 0.7277467546817705
        },
        atlasBounds: {
          left: 0.5,
          bottom: 51.5,
          right: 29.5,
          top: 96.5
        }
      },
      {
        unicode: 75,
        advance: 0.626953125,
        planeBounds: {
          left: 0.061633166497511785,
          bottom: -0.02169206718177056,
          right: 0.6483277710024882,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 452.5,
          bottom: 97.5,
          right: 487.5,
          top: 142.5
        }
      },
      {
        unicode: 76,
        advance: 0.5380859375,
        planeBounds: {
          left: 0.06341786132300943,
          bottom: -0.02169206718177056,
          right: 0.5327735449269906,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 423.5,
          bottom: 97.5,
          right: 451.5,
          top: 142.5
        }
      },
      {
        unicode: 77,
        advance: 0.873046875,
        planeBounds: {
          left: 0.05911847969322944,
          bottom: -0.02169206718177056,
          right: 0.8134401140567705,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 377.5,
          bottom: 97.5,
          right: 422.5,
          top: 142.5
        }
      },
      {
        unicode: 78,
        advance: 0.712890625,
        planeBounds: {
          left: 0.062365588372511785,
          bottom: -0.02169206718177056,
          right: 0.6490601928774882,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 341.5,
          bottom: 97.5,
          right: 376.5,
          top: 142.5
        }
      },
      {
        unicode: 79,
        advance: 0.6875,
        planeBounds: {
          left: 0.033395854136655315,
          bottom: -0.030073418674698794,
          right: 0.6536158646133446,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 416.5,
          bottom: 144.5,
          right: 453.5,
          top: 190.5
        }
      },
      {
        unicode: 80,
        advance: 0.630859375,
        planeBounds: {
          left: 0.061550166358368255,
          bottom: -0.02169206718177056,
          right: 0.6147193648916317,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 273.5,
          bottom: 97.5,
          right: 306.5,
          top: 142.5
        }
      },
      {
        unicode: 81,
        advance: 0.6875,
        planeBounds: {
          left: 0.030466166636655315,
          bottom: -0.14391866037519643,
          right: 0.6506861771133446,
          top: 0.7445045978751964
        },
        atlasBounds: {
          left: 214.5,
          bottom: 202.5,
          right: 251.5,
          top: 255.5
        }
      },
      {
        unicode: 82,
        advance: 0.61572265625,
        planeBounds: {
          left: 0.06350329135836826,
          bottom: -0.02169206718177056,
          right: 0.6166724898916317,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 186.5,
          bottom: 97.5,
          right: 219.5,
          top: 142.5
        }
      },
      {
        unicode: 83,
        advance: 0.59326171875,
        planeBounds: {
          left: 0.020778681983368255,
          bottom: -0.030073418674698794,
          right: 0.5739478805166317,
          top: 0.7410109186746989
        },
        atlasBounds: {
          left: 454.5,
          bottom: 144.5,
          right: 487.5,
          top: 190.5
        }
      },
      {
        unicode: 84,
        advance: 0.5966796875,
        planeBounds: {
          left: 0.005480822747511787,
          bottom: -0.02169206718177056,
          right: 0.5921754272524882,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 112.5,
          bottom: 97.5,
          right: 147.5,
          top: 142.5
        }
      },
      {
        unicode: 85,
        advance: 0.6484375,
        planeBounds: {
          left: 0.049098994483368255,
          bottom: -0.02657487968177056,
          right: 0.6022681930166317,
          top: 0.7277467546817705
        },
        atlasBounds: {
          left: 78.5,
          bottom: 97.5,
          right: 111.5,
          top: 142.5
        }
      },
      {
        unicode: 86,
        advance: 0.63623046875,
        planeBounds: {
          left: -0.008269192599201152,
          bottom: -0.02169206718177056,
          right: 0.6454762238492011,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 38.5,
          bottom: 97.5,
          right: 77.5,
          top: 142.5
        }
      },
      {
        unicode: 87,
        advance: 0.88720703125,
        planeBounds: {
          left: 0.011923628617731797,
          bottom: -0.02169206718177056,
          right: 0.8835841838822683,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 220.5,
          bottom: 97.5,
          right: 272.5,
          top: 142.5
        }
      },
      {
        unicode: 88,
        advance: 0.626953125,
        planeBounds: {
          left: 0.004098979136655316,
          bottom: -0.02169206718177056,
          right: 0.6243189896133446,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 0.5,
          bottom: 97.5,
          right: 37.5,
          top: 142.5
        }
      },
      {
        unicode: 89,
        advance: 0.6005859375,
        planeBounds: {
          left: -0.010793598988344685,
          bottom: -0.02169206718177056,
          right: 0.6094264114883446,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 148.5,
          bottom: 97.5,
          right: 185.5,
          top: 142.5
        }
      },
      {
        unicode: 90,
        advance: 0.5986328125,
        planeBounds: {
          left: 0.024196650733368255,
          bottom: -0.02169206718177056,
          right: 0.5773658492666317,
          top: 0.7326295671817705
        },
        atlasBounds: {
          left: 307.5,
          bottom: 97.5,
          right: 340.5,
          top: 142.5
        }
      },
      {
        unicode: 91,
        advance: 0.26513671875,
        planeBounds: {
          left: 0.05437250871693295,
          bottom: -0.17280296457569408,
          right: 0.27228764753306706,
          top: 0.8329592145756942
        },
        atlasBounds: {
          left: 59.5,
          bottom: 195.5,
          right: 72.5,
          top: 255.5
        }
      },
      {
        unicode: 92,
        advance: 0.41015625,
        planeBounds: {
          left: 0.0014037126767941326,
          bottom: -0.08573505127848349,
          right: 0.4204712873232059,
          top: 0.7356373950284835
        },
        atlasBounds: {
          left: 278.5,
          bottom: 206.5,
          right: 303.5,
          top: 255.5
        }
      },
      {
        unicode: 93,
        advance: 0.26513671875,
        planeBounds: {
          left: -0.020659233400995285,
          bottom: -0.17280296457569408,
          right: 0.2140186084009953,
          top: 0.8329592145756942
        },
        atlasBounds: {
          left: 94.5,
          bottom: 195.5,
          right: 108.5,
          top: 255.5
        }
      },
      {
        unicode: 94,
        advance: 0.41796875,
        planeBounds: {
          left: 0.006855376669722368,
          bottom: 0.33229482979472236,
          right: 0.40916024833027764,
          top: 0.7345997014552776
        },
        atlasBounds: {
          left: 486.5,
          bottom: 231.5,
          right: 510.5,
          top: 255.5
        }
      },
      {
        unicode: 95,
        advance: 0.451171875,
        planeBounds: {
          left: -0.017473255794918804,
          bottom: -0.09553469482549765,
          right: 0.4686451307949188,
          top: 0.021804226075497646
        },
        atlasBounds: {
          left: 70.5,
          bottom: 7.5,
          right: 99.5,
          top: 14.5
        }
      },
      {
        unicode: 96,
        advance: 0.30908203125,
        planeBounds: {
          left: 0.00391839948107648,
          bottom: 0.5860277898277895,
          right: 0.2553589442689235,
          top: 0.7704175226722105
        },
        atlasBounds: {
          left: 36.5,
          bottom: 3.5,
          right: 51.5,
          top: 14.5
        }
      },
      {
        unicode: 97,
        advance: 0.5439453125,
        planeBounds: {
          left: 0.028181041080081196,
          bottom: -0.029187146002488215,
          right: 0.5142994276699189,
          top: 0.5575074585024882
        },
        atlasBounds: {
          left: 30.5,
          bottom: 15.5,
          right: 59.5,
          top: 50.5
        }
      },
      {
        unicode: 98,
        advance: 0.56103515625,
        planeBounds: {
          left: 0.048932994205081196,
          bottom: -0.032187684160555265,
          right: 0.5350513807949189,
          top: 0.7724220591605554
        },
        atlasBounds: {
          left: 304.5,
          bottom: 207.5,
          right: 333.5,
          top: 255.5
        }
      },
      {
        unicode: 99,
        advance: 0.5234375,
        planeBounds: {
          left: 0.024518931705081196,
          bottom: -0.029187146002488215,
          right: 0.5106373182949189,
          top: 0.5575074585024882
        },
        atlasBounds: {
          left: 0.5,
          bottom: 15.5,
          right: 29.5,
          top: 50.5
        }
      },
      {
        unicode: 100,
        advance: 0.56396484375,
        planeBounds: {
          left: 0.026227916080081196,
          bottom: -0.032187684160555265,
          right: 0.5123463026699189,
          top: 0.7724220591605554
        },
        atlasBounds: {
          left: 334.5,
          bottom: 207.5,
          right: 363.5,
          top: 255.5
        }
      },
      {
        unicode: 101,
        advance: 0.52978515625,
        planeBounds: {
          left: 0.026472056705081196,
          bottom: -0.029187146002488215,
          right: 0.5125904432949189,
          top: 0.5575074585024882
        },
        atlasBounds: {
          left: 468.5,
          bottom: 61.5,
          right: 497.5,
          top: 96.5
        }
      },
      {
        unicode: 102,
        advance: 0.34716796875,
        planeBounds: {
          left: 0.004575110905578838,
          bottom: -0.022177918535555265,
          right: 0.3733545765944212,
          top: 0.7824318247855554
        },
        atlasBounds: {
          left: 364.5,
          bottom: 207.5,
          right: 386.5,
          top: 255.5
        }
      },
      {
        unicode: 103,
        advance: 0.56103515625,
        planeBounds: {
          left: 0.026960337955081196,
          bottom: -0.22888445766762702,
          right: 0.5130787245449189,
          top: 0.558962582667627
        },
        atlasBounds: {
          left: 28.5,
          bottom: 143.5,
          right: 57.5,
          top: 190.5
        }
      },
      {
        unicode: 104,
        advance: 0.55078125,
        planeBounds: {
          left: 0.049826556565937666,
          bottom: -0.01892352016762703,
          right: 0.5024195371840624,
          top: 0.768923520167627
        },
        atlasBounds: {
          left: 0.5,
          bottom: 143.5,
          right: 27.5,
          top: 190.5
        }
      },
      {
        unicode: 105,
        advance: 0.24267578125,
        planeBounds: {
          left: 0.046882289688645884,
          bottom: -0.01680925468177056,
          right: 0.19774661656135412,
          top: 0.7375123796817705
        },
        atlasBounds: {
          left: 498.5,
          bottom: 145.5,
          right: 507.5,
          top: 190.5
        }
      },
      {
        unicode: 106,
        advance: 0.23876953125,
        planeBounds: {
          left: -0.048979545900995285,
          bottom: -0.2324562772148376,
          right: 0.1856982959009953,
          top: 0.7397804959648377
        },
        atlasBounds: {
          left: 140.5,
          bottom: 197.5,
          right: 154.5,
          top: 255.5
        }
      },
      {
        unicode: 107,
        advance: 0.5068359375,
        planeBounds: {
          left: 0.044294322330081196,
          bottom: -0.01892352016762703,
          right: 0.5304127089199189,
          top: 0.768923520167627
        },
        atlasBounds: {
          left: 58.5,
          bottom: 143.5,
          right: 87.5,
          top: 190.5
        }
      },
      {
        unicode: 108,
        advance: 0.24267578125,
        planeBounds: {
          left: 0.05428707868157412,
          bottom: -0.01892352016762703,
          right: 0.18838870256842588,
          top: 0.768923520167627
        },
        atlasBounds: {
          left: 477.5,
          bottom: 208.5,
          right: 485.5,
          top: 255.5
        }
      },
      {
        unicode: 109,
        advance: 0.87646484375,
        planeBounds: {
          left: 0.04430890170737297,
          bottom: -0.024304333502488215,
          right: 0.832155942042627,
          top: 0.5623902710024882
        },
        atlasBounds: {
          left: 116.5,
          bottom: 15.5,
          right: 163.5,
          top: 50.5
        }
      },
      {
        unicode: 110,
        advance: 0.5517578125,
        planeBounds: {
          left: 0.049826556565937666,
          bottom: -0.024304333502488215,
          right: 0.5024195371840624,
          top: 0.5623902710024882
        },
        atlasBounds: {
          left: 60.5,
          bottom: 15.5,
          right: 87.5,
          top: 50.5
        }
      },
      {
        unicode: 111,
        advance: 0.5703125,
        planeBounds: {
          left: 0.025090213094224725,
          bottom: -0.029187146002488215,
          right: 0.5447340056557752,
          top: 0.5575074585024882
        },
        atlasBounds: {
          left: 193.5,
          bottom: 15.5,
          right: 224.5,
          top: 50.5
        }
      },
      {
        unicode: 112,
        advance: 0.56103515625,
        planeBounds: {
          left: 0.048444712955081196,
          bottom: -0.22644305141762702,
          right: 0.5345630995449189,
          top: 0.561403988917627
        },
        atlasBounds: {
          left: 447.5,
          bottom: 208.5,
          right: 476.5,
          top: 255.5
        }
      },
      {
        unicode: 113,
        advance: 0.568359375,
        planeBounds: {
          left: 0.025983775455081196,
          bottom: -0.22644305141762702,
          right: 0.5121021620449189,
          top: 0.561403988917627
        },
        atlasBounds: {
          left: 417.5,
          bottom: 208.5,
          right: 446.5,
          top: 255.5
        }
      },
      {
        unicode: 114,
        advance: 0.33837890625,
        planeBounds: {
          left: 0.045180595002291775,
          bottom: -0.024304333502488215,
          right: 0.34690924874770823,
          top: 0.5623902710024882
        },
        atlasBounds: {
          left: 449.5,
          bottom: 61.5,
          right: 467.5,
          top: 96.5
        }
      },
      {
        unicode: 115,
        advance: 0.515625,
        planeBounds: {
          left: 0.021669814448009427,
          bottom: -0.029187146002488215,
          right: 0.4910254980519906,
          top: 0.5575074585024882
        },
        atlasBounds: {
          left: 164.5,
          bottom: 15.5,
          right: 192.5,
          top: 50.5
        }
      },
      {
        unicode: 116,
        advance: 0.32666015625,
        planeBounds: {
          left: -0.019433670483564695,
          bottom: -0.02877457520298586,
          right: 0.3158203892335647,
          top: 0.675258950202986
        },
        atlasBounds: {
          left: 418.5,
          bottom: 54.5,
          right: 438.5,
          top: 96.5
        }
      },
      {
        unicode: 117,
        advance: 0.55126953125,
        planeBounds: {
          left: 0.048117572190937666,
          bottom: -0.034069958502488215,
          right: 0.5007105528090624,
          top: 0.5526246460024882
        },
        atlasBounds: {
          left: 88.5,
          bottom: 15.5,
          right: 115.5,
          top: 50.5
        }
      },
      {
        unicode: 118,
        advance: 0.484375,
        planeBounds: {
          left: -0.002092396419918806,
          bottom: -0.02080579450955998,
          right: 0.4840259901699188,
          top: 0.5491261070095601
        },
        atlasBounds: {
          left: 331.5,
          bottom: 16.5,
          right: 360.5,
          top: 50.5
        }
      },
      {
        unicode: 119,
        advance: 0.75146484375,
        planeBounds: {
          left: -0.002649098431770561,
          bottom: -0.02080579450955998,
          right: 0.7516725359317705,
          top: 0.5491261070095601
        },
        atlasBounds: {
          left: 225.5,
          bottom: 16.5,
          right: 270.5,
          top: 50.5
        }
      },
      {
        unicode: 120,
        advance: 0.49560546875,
        planeBounds: {
          left: -0.0046143729128470395,
          bottom: -0.02080579450955998,
          right: 0.4982667166628471,
          top: 0.5491261070095601
        },
        atlasBounds: {
          left: 300.5,
          bottom: 16.5,
          right: 330.5,
          top: 50.5
        }
      },
      {
        unicode: 121,
        advance: 0.47314453125,
        planeBounds: {
          left: -0.007219349544918806,
          bottom: -0.23645281704262702,
          right: 0.4788990370449188,
          top: 0.551394223292627
        },
        atlasBounds: {
          left: 387.5,
          bottom: 208.5,
          right: 416.5,
          top: 255.5
        }
      },
      {
        unicode: 122,
        advance: 0.49560546875,
        planeBounds: {
          left: 0.018007705073009427,
          bottom: -0.02080579450955998,
          right: 0.4873633886769906,
          top: 0.5491261070095601
        },
        atlasBounds: {
          left: 271.5,
          bottom: 16.5,
          right: 299.5,
          top: 50.5
        }
      },
      {
        unicode: 123,
        advance: 0.33837890625,
        planeBounds: {
          left: 0.011572188891435306,
          bottom: -0.20234398020069408,
          right: 0.3468262486085647,
          top: 0.8034181989506942
        },
        atlasBounds: {
          left: 73.5,
          bottom: 195.5,
          right: 93.5,
          top: 255.5
        }
      },
      {
        unicode: 124,
        advance: 0.24365234375,
        planeBounds: {
          left: 0.06315671142450235,
          bottom: -0.15466084787519643,
          right: 0.18049563232549765,
          top: 0.7337624103751964
        },
        atlasBounds: {
          left: 206.5,
          bottom: 202.5,
          right: 213.5,
          top: 255.5
        }
      },
      {
        unicode: 125,
        advance: 0.33837890625,
        planeBounds: {
          left: -0.010156326733564695,
          bottom: -0.20234398020069408,
          right: 0.3250977329835647,
          top: 0.8034181989506942
        },
        atlasBounds: {
          left: 38.5,
          bottom: 195.5,
          right: 58.5,
          top: 255.5
        }
      },
      {
        unicode: 126,
        advance: 0.68017578125,
        planeBounds: {
          left: 0.046984728997511785,
          bottom: 0.1766063915990047,
          right: 0.6336793335024882,
          top: 0.4112842334009953
        },
        atlasBounds: {
          left: 0.5,
          bottom: 0.5,
          right: 35.5,
          top: 14.5
        }
      }
    ],
    kerning: []
  }, w2 = {
    name: "untitled connectome",
    nodeColormap: "warm",
    nodeColormapNegative: "winter",
    nodeMinColor: 0,
    nodeMaxColor: 4,
    nodeScale: 3,
    edgeColormap: "warm",
    edgeColormapNegative: "winter",
    edgeMin: 2,
    edgeMax: 6,
    edgeScale: 1,
    legendLineThickness: 0,
    showLegend: true
  }, C2 = class fb extends ou {
    constructor(e, n) {
      super(new Float32Array([]), new Uint32Array([]), n.name, new Uint8Array([]), 1, true, e, n), J(this, "gl"), J(this, "nodesChanged"), this.gl = e, this.type = "connectome", this.nodes && this.updateLabels(), this.nodesChanged = new EventTarget();
    }
    static convertLegacyConnectome(e) {
      const n = {
        nodes: [],
        edges: [],
        ...w2
      };
      for (const i in e) if (i in w2) {
        const a = i;
        n[a] = e[a];
      }
      const r = e.nodes;
      for (let i = 0; i < r.names.length; i++) n.nodes.push({
        name: r.names[i],
        x: r.X[i],
        y: r.Y[i],
        z: r.Z[i],
        colorValue: r.Color[i],
        sizeValue: r.Size[i]
      });
      for (let i = 0; i < r.names.length - 1; i++) for (let a = i + 1; a < r.names.length; a++) {
        const s = e.edges[i * r.names.length + a];
        n.edges.push({
          first: i,
          second: a,
          colorValue: s
        });
      }
      return n;
    }
    static convertFreeSurferConnectome(e, n = "warm") {
      let r = true;
      if ("data_type" in e ? e.data_type !== "fs_pointset" && (r = false) : r = false, "points" in e || (r = false), !r) throw Error("not a valid FreeSurfer json pointset");
      const i = e.points.map((s) => ({
        name: Array.isArray(s.comments) && s.comments.length > 0 && "text" in s.comments[0] ? s.comments[0].text : "",
        x: s.coordinates.x,
        y: s.coordinates.y,
        z: s.coordinates.z,
        colorValue: 1,
        sizeValue: 1,
        metadata: s.comments
      }));
      return {
        ...w2,
        nodeColormap: n,
        edgeColormap: n,
        nodes: i,
        edges: []
      };
    }
    updateLabels() {
      const e = this.nodes;
      if (e && e.length > 0) {
        const n = e.reduce((c, f) => c.sizeValue > f.sizeValue ? c : f).sizeValue;
        let r, i;
        if (typeof this.nodeMinColor < "u" && isFinite(this.nodeMinColor)) r = this.nodeMinColor;
        else {
          r = e[0].colorValue;
          for (let c = 1; c < e.length; c++) e[c].colorValue < r && (r = e[c].colorValue);
        }
        if (typeof this.nodeMaxColor < "u" && isFinite(this.nodeMaxColor)) i = this.nodeMaxColor;
        else {
          i = e[0].colorValue;
          for (let c = 1; c < e.length; c++) e[c].colorValue > i && (i = e[c].colorValue);
        }
        const a = Mn.colormap(this.nodeColormap, this.colormapInvert), s = Mn.colormap(this.nodeColormapNegative, this.colormapInvert), o = "nodeColormapNegative" in this;
        let l = this.legendLineThickness ? this.legendLineThickness : 0;
        this.showLegend === false && (l = 0);
        for (let c = 0; c < e.length; c++) {
          let f = e[c].colorValue, u = false;
          if (o && f < 0 && (u = true, f = -f), r < i) {
            if (f < r) {
              ee.warn("color value lower than min");
              continue;
            }
            f = (f - r) / (i - r);
          } else f = 1;
          f = Math.round(Math.max(Math.min(255, f * 255))) * 4;
          let h = [
            a[f],
            a[f + 1],
            a[f + 2],
            255
          ];
          u && (h = [
            s[f],
            s[f + 1],
            s[f + 2],
            255
          ]), h = h.map((g) => g / 255), ee.debug("adding label for ", e[c]), e[c].label = new u8(e[c].name, {
            textColor: h,
            bulletScale: e[c].sizeValue / n,
            bulletColor: h,
            lineWidth: l,
            lineColor: h,
            textScale: 1,
            textAlignment: "left",
            lineTerminator: "none"
          }, [
            e[c].x,
            e[c].y,
            e[c].z
          ]), ee.debug("label for node:", e[c].label);
        }
      }
    }
    addConnectomeNode(e) {
      if (ee.debug("adding node", e), !this.nodes) throw new Error("nodes not defined");
      this.nodes.push(e), this.updateLabels(), this.nodesChanged.dispatchEvent(new CustomEvent("nodeAdded", {
        detail: {
          node: e
        }
      }));
    }
    deleteConnectomeNode(e) {
      const n = this.nodes.indexOf(e), r = this.edges;
      r && (this.edges = r.filter((i) => i.first !== n && i.second !== n)), this.nodes = this.nodes.filter((i) => i !== e), this.updateLabels(), this.updateConnectome(this.gl), this.nodesChanged.dispatchEvent(new CustomEvent("nodeDeleted", {
        detail: {
          node: e
        }
      }));
    }
    updateConnectomeNodeByIndex(e, n) {
      this.nodes[e] = n, this.updateLabels(), this.updateConnectome(this.gl), this.nodesChanged.dispatchEvent(new CustomEvent("nodeChanged", {
        detail: {
          node: n
        }
      }));
    }
    updateConnectomeNodeByPoint(e, n) {
      const r = this.nodes;
      if (!r) throw new Error("Node to update does not exist");
      const i = r.find((s) => ft.arraysAreEqual([
        s.x,
        s.y,
        s.z
      ], e));
      if (!i) throw new Error(`Node with point ${e} to update does not exist`);
      const a = r.findIndex((s) => s === i);
      this.updateConnectomeNodeByIndex(a, n);
    }
    addConnectomeEdge(e, n, r) {
      const i = this.edges;
      let a = i.find((s) => (s.first === e || s.second === e) && s.first + s.second === e + n);
      return a || (a = {
        first: e,
        second: n,
        colorValue: r
      }, i.push(a), this.updateConnectome(this.gl), a);
    }
    deleteConnectomeEdge(e, n) {
      const r = this.edges, i = r.find((a) => (a.first === e || a.first === n) && a.first + a.second === e + n);
      if (i) this.edges = r.filter((a) => a !== i);
      else throw new Error(`edge between ${e} and ${n} not found`);
      return this.updateConnectome(this.gl), i;
    }
    findClosestConnectomeNode(e, n) {
      const r = this.nodes;
      if (!r || r.length === 0) return null;
      const i = r.map((a, s) => ({
        node: a,
        distance: Math.sqrt(Math.pow(a.x - e[0], 2) + Math.pow(a.y - e[1], 2) + Math.pow(a.z - e[2], 2)),
        index: s
      })).filter((a) => a.distance < n).sort((a, s) => a.distance - s.distance);
      return i.length > 0 ? i[0].node : null;
    }
    updateConnectome(e) {
      const n = [], r = [], i = [];
      let a = Mn.colormap(this.nodeColormap, this.colormapInvert), s = Mn.colormap(this.nodeColormapNegative, this.colormapInvert), o = "nodeColormapNegative" in this;
      this.nodeMinColor === void 0 && (this.nodeMinColor = NaN), this.nodeMaxColor === void 0 && (this.nodeMaxColor = NaN), this.edgeMin === void 0 && (this.edgeMin = NaN), this.edgeMax === void 0 && (this.edgeMax = NaN);
      let l = this.nodeMinColor, c = this.nodeMaxColor;
      if (!isFinite(l) || !isFinite(l)) {
        const w = this.nodes;
        l = w[0].colorValue, c = w[0].colorValue;
        for (let C = 0; C < w.length; C++) l = Math.min(l, w[C].colorValue), c = Math.max(c, w[C].colorValue);
      }
      const f = this.nodes, u = f.length;
      for (let w = 0; w < u; w++) {
        const C = f[w].sizeValue * this.nodeScale;
        if (C <= 0) continue;
        let T = f[w].colorValue, S = false;
        if (o && T < 0 && (S = true, T = -T), l < c) {
          if (T < l) continue;
          T = (T - l) / (c - l);
        } else T = 1;
        T = Math.round(Math.max(Math.min(255, T * 255))) * 4;
        let E = [
          a[T],
          a[T + 1],
          a[T + 2],
          255
        ];
        S && (E = [
          s[T],
          s[T + 1],
          s[T + 2],
          255
        ]);
        const b = Ue(f[w].x, f[w].y, f[w].z);
        zc.makeColoredSphere(r, n, i, C, b, E);
      }
      a = Mn.colormap(this.edgeColormap, this.colormapInvert), s = Mn.colormap(this.edgeColormapNegative, this.colormapInvert), o = "edgeColormapNegative" in this;
      const h = this.edges;
      if (h !== void 0 && h.length > 0) {
        if (l = this.edgeMin, c = this.edgeMax, !isFinite(l) || !isFinite(l)) {
          l = h[0].colorValue, c = h[0].colorValue;
          for (let w = 0; w < h.length; w++) l = Math.min(l, h[w].colorValue), c = Math.max(c, h[w].colorValue);
        }
        for (const w of h) {
          let C = w.colorValue;
          const T = o && C < 0;
          T && (C = -C);
          const S = C * this.edgeScale;
          if (S <= 0) continue;
          if (l < c) {
            if (C < l) continue;
            C = (C - l) / (c - l);
          } else C = 1;
          C = Math.round(Math.max(Math.min(255, C * 255))) * 4;
          let E = [
            a[C],
            a[C + 1],
            a[C + 2],
            255
          ];
          T && (E = [
            s[C],
            s[C + 1],
            s[C + 2],
            255
          ]);
          const b = Ue(f[w.first].x, f[w.first].y, f[w.first].z), D = Ue(f[w.second].x, f[w.second].y, f[w.second].z);
          zc.makeColoredCylinder(r, n, i, b, D, S, E);
        }
      }
      const g = new Float32Array(r), v = new Uint32Array(n), m = Ec.getExtents(g);
      this.furthestVertexFromOrigin = m.mxDx, this.extentsMin = m.extentsMin, this.extentsMax = m.extentsMax;
      const y = this.generatePosNormClr(g, v, new Uint8Array(i));
      e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, Uint32Array.from(v), e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, Float32Array.from(y), e.STATIC_DRAW), this.indexCount = n.length;
    }
    updateMesh(e) {
      this.updateConnectome(e), this.updateLabels();
    }
    json() {
      const e = {};
      for (const n in this) (n in w2 || n === "nodes" || n === "edges") && (e[n] = this[n]);
      return e;
    }
    static async loadConnectomeFromUrl(e, n) {
      const i = await (await fetch(n)).json();
      return new fb(e, i);
    }
  };
  function GG(t, e, n) {
    if (!t.dimsRAS || !t.matRAS || !t.pixDimsRAS || !t.vox2mm) throw new Error("Cannot create NiivueObject3D: Missing required RAS properties or vox2mm access on NVImage.");
    const r = t.dimsRAS, i = t.matRAS, a = t.pixDimsRAS, s = -0.5, o = -0.5, l = -0.5, c = r[1] - 1 + 0.5, f = r[2] - 1 + 0.5, u = r[3] - 1 + 0.5, h = t.vox2mm, g = h.call(t, [
      s,
      o,
      l
    ], i), v = h.call(t, [
      s,
      f,
      l
    ], i), m = h.call(t, [
      s,
      o,
      u
    ], i), y = h.call(t, [
      s,
      f,
      u
    ], i), w = h.call(t, [
      c,
      o,
      l
    ], i), C = h.call(t, [
      c,
      f,
      l
    ], i), T = h.call(t, [
      c,
      o,
      u
    ], i), S = h.call(t, [
      c,
      f,
      u
    ], i), E = [
      ...m,
      0,
      0,
      1,
      ...T,
      1,
      0,
      1,
      ...S,
      1,
      1,
      1,
      ...y,
      0,
      1,
      1,
      ...g,
      0,
      0,
      0,
      ...v,
      0,
      1,
      0,
      ...C,
      1,
      1,
      0,
      ...w,
      1,
      0,
      0
    ], b = n.createBuffer();
    if (!b) throw new Error("Failed to create GL index buffer");
    n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, b);
    const D = [
      0,
      3,
      2,
      2,
      1,
      0,
      4,
      7,
      6,
      6,
      5,
      4,
      5,
      6,
      2,
      2,
      3,
      5,
      4,
      0,
      1,
      1,
      7,
      4,
      7,
      1,
      2,
      2,
      6,
      7,
      4,
      5,
      3,
      3,
      0,
      4
    ];
    n.bufferData(n.ELEMENT_ARRAY_BUFFER, new Uint16Array(D), n.STATIC_DRAW);
    const R = n.createBuffer();
    if (!R) throw new Error("Failed to create GL vertex buffer");
    n.bindBuffer(n.ARRAY_BUFFER, R), n.bufferData(n.ARRAY_BUFFER, new Float32Array(E), n.STATIC_DRAW);
    const I = n.createVertexArray();
    if (!I) throw new Error("Failed to create GL VAO");
    n.bindVertexArray(I), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, b), n.bindBuffer(n.ARRAY_BUFFER, R);
    const O = 24;
    n.enableVertexAttribArray(0), n.vertexAttribPointer(0, 3, n.FLOAT, false, O, 0), n.enableVertexAttribArray(1), n.vertexAttribPointer(1, 3, n.FLOAT, false, O, 12), n.bindVertexArray(null);
    const L = new zc(e, R, n.TRIANGLES, D.length, b, I), N = [
      ...m,
      ...T,
      ...S,
      ...y,
      ...g,
      ...v,
      ...C,
      ...w
    ], F = RG(N);
    return L.extentsMin = F.min.slice(), L.extentsMax = F.max.slice(), L.furthestVertexFromOrigin = F.furthestVertexFromOrigin, L.originNegate = ki(F.origin), Rl(L.originNegate, L.originNegate), L.fieldOfViewDeObliqueMM = [
      r[1] * a[1],
      r[2] * a[2],
      r[3] * a[3]
    ], L;
  }
  function zG(t) {
    const e = t.length;
    let n = 0;
    const r = new Uint8Array(e + Math.ceil(0.01 * e)), i = new Int8Array(r.buffer);
    let a = 0;
    for (; n < e; ) {
      let s = t[n];
      n++;
      let o = 1;
      for (; o < 129 && n < e && t[n] === s; ) n++, o++;
      if (o > 1) {
        i[a] = -o + 1, a++, r[a] = s, a++;
        continue;
      }
      for (; n < e && !(o > 127 || n + 2 < e && s !== t[n] && t[n + 2] === t[n] && t[n + 1] === t[n]); ) s = t[n], n++, o++;
      r[a] = o - 1, a++;
      for (let l = 0; l < o; l++) r[a] = t[n - o + l], a++;
    }
    return ee.debug("PackBits " + e + " -> " + a + " bytes (x" + e / a + ")"), r.slice(0, a);
  }
  function Pv(t, e) {
    const n = new Uint8Array(t.buffer), r = new Int8Array(n.buffer);
    let i = 0;
    const a = new Uint8Array(e);
    let s = 0;
    for (; i < n.length; ) {
      const o = r[i];
      if (i++, o < 0) {
        const l = r[i];
        i++;
        for (let c = 0; c < 1 - o; c++) a[s] = l, s++;
      } else for (let l = 0; l < o + 1; l++) a[s] = r[i], i++, s++;
    }
    return a;
  }
  var WG = ({ drawUndoBitmaps: t, currentDrawUndoBitmap: e, drawBitmap: n }) => {
    const r = t.length;
    if (r < 1) {
      ee.debug("undo bitmaps not loaded");
      return;
    }
    if (e--, e < 0 && (e = r - 1), e >= r && (e = 0), t[e].length < 2) {
      ee.debug("drawUndo is misbehaving");
      return;
    }
    return n = Pv(t[e], n.length), {
      drawBitmap: n,
      currentDrawUndoBitmap: e
    };
  };
  function HG(t, e, n) {
    const { dimX: r, dimY: i, dimZ: a } = n;
    let s;
    if (t === 0) s = a;
    else if (t === 1) s = i;
    else if (t === 2) s = r;
    else return null;
    let o = -1, l = -1;
    for (let c = 0; c < s; c++) {
      let f = false;
      if (t === 0) {
        const u = c * r * i;
        for (let h = 0; h < r * i; h++) if (e[u + h] > 0) {
          f = true;
          break;
        }
      } else if (t === 1) for (let u = 0; u < a; u++) {
        for (let h = 0; h < r; h++) {
          const g = h + c * r + u * r * i;
          if (e[g] > 0) {
            f = true;
            break;
          }
        }
        if (f) break;
      }
      else if (t === 2) for (let u = 0; u < a; u++) {
        for (let h = 0; h < i; h++) {
          const g = c + h * r + u * r * i;
          if (e[g] > 0) {
            f = true;
            break;
          }
        }
        if (f) break;
      }
      f && (o === -1 && (o = c), l = c);
    }
    return o === -1 || l === -1 ? null : {
      first: o,
      last: l
    };
  }
  function n4(t, e, n, r) {
    const { dimX: i, dimY: a, dimZ: s } = r;
    let o;
    if (e === 0) {
      o = new Float32Array(i * a);
      const l = t * i * a;
      for (let c = 0; c < i * a; c++) o[c] = n[l + c];
    } else if (e === 1) {
      o = new Float32Array(i * s);
      for (let l = 0; l < s; l++) for (let c = 0; c < i; c++) {
        const f = c + t * i + l * i * a, u = c + l * i;
        o[u] = n[f];
      }
    } else if (e === 2) {
      o = new Float32Array(a * s);
      for (let l = 0; l < s; l++) for (let c = 0; c < a; c++) {
        const f = t + c * i + l * i * a, u = c + l * a;
        o[u] = n[f];
      }
    } else throw new Error("Invalid slice type");
    return o;
  }
  function r4(t, e, n, r, i) {
    const { dimX: a, dimY: s, dimZ: o } = r;
    let l;
    if (e === 0) {
      l = new Float32Array(a * s);
      const c = t * a * s;
      for (let f = 0; f < a * s; f++) l[f] = n[c + f] / i;
    } else if (e === 1) {
      l = new Float32Array(a * o);
      for (let c = 0; c < o; c++) for (let f = 0; f < a; f++) {
        const u = f + t * a + c * a * s, h = f + c * a;
        l[h] = n[u] / i;
      }
    } else if (e === 2) {
      l = new Float32Array(s * o);
      for (let c = 0; c < o; c++) for (let f = 0; f < s; f++) {
        const u = t + f * a + c * a * s, h = f + c * s;
        l[h] = n[u] / i;
      }
    } else throw new Error("Invalid slice type");
    return l;
  }
  function jG(t, e, n, r, i, a, s) {
    const { dimX: o, dimY: l, dimZ: c } = i;
    if (n === 0) {
      const f = e * o * l;
      for (let u = 0; u < t.length; u++) t[u] >= a && (r[f + u] = s);
    } else if (n === 1) for (let f = 0; f < c; f++) for (let u = 0; u < o; u++) {
      const h = u + f * o, g = u + e * o + f * o * l;
      t[h] >= a && (r[g] = s);
    }
    else if (n === 2) for (let f = 0; f < c; f++) for (let u = 0; u < l; u++) {
      const h = u + f * l, g = e + u * o + f * o * l;
      t[h] >= a && (r[g] = s);
    }
    else throw new Error("Invalid slice type");
  }
  function sC(t, e, n) {
    if (e < 3 || n < 3) return;
    const r = new Float32Array(t.length);
    for (let i = 0; i < n; i++) for (let a = 0; a < e; a++) {
      const s = a + i * e;
      a === 0 || a === e - 1 ? r[s] = t[s] : r[s] = (t[s - 1] + 2 * t[s] + t[s + 1]) * 0.25;
    }
    for (let i = 0; i < n; i++) for (let a = 0; a < e; a++) {
      const s = a + i * e;
      i === 0 || i === n - 1 ? t[s] = r[s] : t[s] = (r[s - e] + 2 * r[s] + r[s + e]) * 0.25;
    }
  }
  function KG(t, e, n, r) {
    const i = Math.abs(n - t), a = Math.abs(n - e), s = Math.exp(-i * i / (2 * r * r)), o = Math.exp(-a * a / (2 * r * r)), l = s + o;
    return l < 1e-6 ? 0.5 : s / l;
  }
  function YG(t, e, n, r, i, a) {
    const s = (n - r) / (i - r), o = 1 - s;
    for (let l = 0; l < t.length; l++) a[l] = t[l] * o + e[l] * s;
  }
  function qG(t, e, n, r, i, a, s, o, l, c) {
    const f = (n - r) / (i - r), u = 1 - f;
    for (let h = 0; h < t.length; h++) if (t[h] > 0 || e[h] > 0) {
      const g = KG(o[h], l[h], c[h], s.intensitySigma), v = s.intensityWeight, m = v * g + (1 - v) * u, y = 1 - m;
      a[h] = t[h] * m + e[h] * y;
    } else a[h] = t[h] * u + e[h] * f;
  }
  function XG(t, e, n, r, i, a, s, o) {
    const { dimX: l, dimY: c, dimZ: f } = e, u = s.sliceType ?? 0;
    let h, g, v;
    if (u === 0) h = l, g = c, v = f - 1;
    else if (u === 1) h = l, g = f, v = c - 1;
    else if (u === 2) h = c, g = f, v = l - 1;
    else throw new Error("Invalid slice type. Must be AXIAL, CORONAL, or SAGITTAL");
    const m = {
      intensityWeight: s.intensityWeight ?? 0.7,
      binaryThreshold: s.binaryThreshold ?? 0.375,
      intensitySigma: s.intensitySigma ?? 0.1,
      applySmoothingToSlices: s.applySmoothingToSlices ?? true,
      useIntensityGuided: s.useIntensityGuided ?? true
    };
    if (i !== void 0 && a !== void 0) {
      if (i >= a) throw new Error("Low slice index must be less than high slice index");
      if (i < 0 || a > v) throw new Error(`Slice indices out of bounds [0, ${v}]`);
    }
    const y = /* @__PURE__ */ new Map();
    for (let w = 0; w <= v; w++) {
      const C = n4(w, u, t, e);
      for (let T = 0; T < C.length; T++) {
        const S = C[T];
        if (S > 0) if (!y.has(S)) y.set(S, {
          min: w,
          max: w
        });
        else {
          const E = y.get(S);
          E.min = Math.min(E.min, w), E.max = Math.max(E.max, w);
        }
      }
    }
    for (const [w, C] of y) {
      const T = i !== void 0 ? Math.max(i, C.min) : C.min, S = a !== void 0 ? Math.min(a, C.max) : C.max;
      if (T >= S || S - T < 2) continue;
      const E = n4(T, u, t, e), b = n4(S, u, t, e), D = new Float32Array(E.length), R = new Float32Array(b.length);
      for (let I = 0; I < E.length; I++) D[I] = E[I] === w ? 1 : 0, R[I] = b[I] === w ? 1 : 0;
      m.applySmoothingToSlices && (sC(D, h, g), sC(R, h, g));
      for (let I = T + 1; I < S; I++) {
        const O = new Float32Array(h * g);
        if (m.useIntensityGuided && n) {
          const L = r4(T, u, n, e, r), N = r4(S, u, n, e, r), F = r4(I, u, n, e, r);
          qG(D, R, I, T, S, O, m, L, N, F);
        } else YG(D, R, I, T, S, O);
        jG(O, I, u, t, e, m.binaryThreshold, w);
      }
    }
    o();
  }
  var u1 = `#version 300 es
#line 4
layout(location=0) in vec3 pos;
layout(location=1) in vec3 texCoords;
uniform mat4 mvpMtx;
out vec3 vColor;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vColor = texCoords;
}`, f8 = `
	vec4 drawColor(float scalar, float drawOpacity) {
		float nlayer = float(textureSize(colormap, 0).y);
		float layer = (nlayer - 0.5) / nlayer;
		vec4 dcolor = texture(colormap, vec2((scalar * 255.0)/256.0 + 0.5/256.0, layer)).rgba;
		dcolor.a *= drawOpacity;
		return dcolor;
}`, Xh = `vec3 GetBackPosition(vec3 startPositionTex) {
	vec3 startPosition = startPositionTex * volScale;
	vec3 invR = 1.0 / rayDir;
	vec3 tbot = invR * (vec3(0.0)-startPosition);
	vec3 ttop = invR * (volScale-startPosition);
	vec3 tmax = max(ttop, tbot);
	vec2 t = min(tmax.xx, tmax.yz);
	vec3 endPosition = startPosition + (rayDir * min(t.x, t.y));
	//convert world position back to texture position:
	endPosition = endPosition / volScale;
	return endPosition;
}

vec4 applyClip (vec3 dir, inout vec4 samplePos, inout float len, inout bool isClip) {
	float cdot = dot(dir,clipPlane.xyz);
	isClip = false;
	if  ((clipPlane.a > 1.0) || (cdot == 0.0)) return samplePos;
	bool frontface = (cdot > 0.0);
	float dis = (-clipPlane.a - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;
	float thick = clipThick;
	if (thick <= 0.0) thick = 2.0;
	float  disBackFace = (-(clipPlane.a-thick) - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;
	if (((frontface) && (dis >= len)) || ((!frontface) && (dis <= 0.0))) {
		samplePos.a = len + 1.0;
		return samplePos;
	}
	if (frontface) {
		dis = max(0.0, dis);
		samplePos = vec4(samplePos.xyz+dir * dis, dis);
		if (dis > 0.0) isClip = true;
		len = min(disBackFace, len);
	}
	if (!frontface) {
		len = min(dis, len);
		disBackFace = max(0.0, disBackFace);
		if (len == dis) isClip = true;
		samplePos = vec4(samplePos.xyz+dir * disBackFace, disBackFace);
	}
	return samplePos;
}

void clipVolume(inout vec3 startPos, inout vec3 backPos, int dim, float frac, bool isLo) {
	vec3 dir = backPos - startPos;
	float len = length(dir);
	dir = normalize(dir);
	// Discard if both startPos and backPos are outside the clipping plane
	if (isLo && startPos[dim] < frac && backPos[dim] < frac) {
		discard;
	}
	if (!isLo && startPos[dim] > frac && backPos[dim] > frac) {
		discard;
	}
	vec4 plane = vec4(0.0, 0.0, 0.0, 0.5 - frac);
	plane[dim] = 1.0;
	float cdot = dot(dir, plane.xyz);
	float dis = (-plane.w - dot(plane.xyz, startPos - vec3(0.5))) / cdot;
	// Adjust startPos or backPos based on the intersection with the plane
	bool isFrontFace = (cdot > 0.0);
	if (!isLo)
		isFrontFace = !isFrontFace;
	if (dis > 0.0) {
		if (isFrontFace) {
				if (dis <= len) {
					startPos = startPos + dir * dis;
				}
		} else {
			if (dis < len) {
				backPos = startPos + dir * dis;
			}
		}
	}
}

void clipVolumeStart (inout vec3 startPos, inout vec3 backPos) {
	// vec3 clipLo = vec3(0.1, 0.2, 0.4);
	// vec3 clipHi = vec3(0.8, 0.7, 0.7);
	for (int i = 0; i < 3; i++) {
		if (clipLo[i] > 0.0)
			clipVolume(startPos, backPos, i, clipLo[i], true);
	}
	for (int i = 0; i < 3; i++) {
		if (clipHi[i] < 1.0)
			clipVolume(startPos, backPos, i, clipHi[i], false);
	}
}

float frac2ndc(vec3 frac) {
//https://stackoverflow.com/questions/7777913/how-to-render-depth-linearly-in-modern-opengl-with-gl-fragcoord-z-in-fragment-sh
	vec4 pos = vec4(frac.xyz, 1.0); //fraction
	vec4 dim = vec4(vec3(textureSize(volume, 0)), 1.0);
	pos = pos * dim;
	vec4 shim = vec4(-0.5, -0.5, -0.5, 0.0);
	pos += shim;
	vec4 mm = transpose(matRAS) * pos;
	float z_ndc = (mvpMtx * vec4(mm.xyz, 1.0)).z;
	return (z_ndc + 1.0) / 2.0;
}` + f8, h8 = `void main() {
	if (fColor.x > 2.0) {
		fColor = vec4(1.0, 0.0, 0.0, 0.5);
		return;
	}
	fColor = vec4(0.0,0.0,0.0,0.0);
	vec4 clipPlaneColorX = clipPlaneColor;
	//if (clipPlaneColor.a < 0.0)
	//	clipPlaneColorX.a = - 1.0;
	bool isColorPlaneInVolume = false;
	if (clipPlaneColorX.a < 0.0) {
		isColorPlaneInVolume = true;
		clipPlaneColorX.a = 0.0;
	}
	//fColor = vec4(vColor.rgb, 1.0); return;
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	vec3 backPosition = GetBackPosition(start);
	// fColor = vec4(backPosition, 1.0); return;
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	dir = normalize(dir);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	//if ((clipPos.a != samplePos.a) && (len < 3.0)) {
	//start: OPTIONAL fast pass: rapid traversal until first hit
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	float drawOpacityA = renderDrawAmbientOcclusionXY.y;
	if ((samplePos.a >= len) && (((overlays < 1.0) && (drawOpacityA <= 0.0) ) || (backgroundMasksOverlays > 0)))  {
		if (isClip)
			fColor += clipPlaneColorX;
		return;
	}
	fColor = vec4(1.0, 1.0, 1.0, 1.0);
	//gl_FragDepth = frac2ndc(samplePos.xyz); //crude due to fast pass resolution
	samplePos -= deltaDirFast;
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	//end: fast pass
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * lenNoClip);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	samplePos += deltaDir * ran; //jitter ray
`, f5 = `
	if (firstHit.a < len) {
		gl_FragDepth = frac2ndc(firstHit.xyz);
		vec4 paqdSample = texture(paqd, samplePos.xyz);
		if (paqdSample.a > 0.0) {
			//colAcc.rgb = paqdSample.rgb;
			float a = max(abs(paqdUniforms[2]), abs(paqdUniforms[3]));
			colAcc.rgb = mix(colAcc.rgb, paqdSample.rgb, 0.5 * paqdSample.a * a);
		}
		
	}
	colAcc.a = (colAcc.a / earlyTermination) * backOpacity;
	fColor = colAcc;
	//if (isClip) //CR
	if ((isColorPlaneInVolume) && (clipPos.a != samplePos.a) && (abs(firstHit.a - clipPos.a) < deltaDir.a))
		fColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, abs(clipPlaneColor.a));
		//fColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, clipPlaneColorX.a * 0.65);
	float renderDrawAmbientOcclusionX = renderDrawAmbientOcclusionXY.x;
	float drawOpacity = renderDrawAmbientOcclusionXY.y;
	if ((overlays < 1.0) && (drawOpacity <= 0.0))
		return;
	//overlay pass
	len = lenNoClip;
	samplePos = vec4(start.xyz, 0.0); //ray position
	//start: OPTIONAL fast pass: rapid traversal until first hit
	stepSizeFast = sliceSize * 1.0;
	deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (drawOpacity > 0.0)
			val = max(val, texture(drawing, samplePos.xyz).r);
		if (val > 0.001)
			break;
		samplePos += deltaDirFast; //advance ray position
	}
	if (samplePos.a >= len) {
		if (isClip && (fColor.a == 0.0))
				fColor += clipPlaneColorX;
			return;
	}
	samplePos -= deltaDirFast;
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	//end: fast pass
	float overFarthest = len;
	colAcc = vec4(0.0, 0.0, 0.0, 0.0);

	samplePos += deltaDir * ran; //jitter ray
	vec4 overFirstHit = vec4(0.0,0.0,0.0,2.0 * len);
	if (backgroundMasksOverlays > 0)
		samplePos = firstHit;
	bool firstDraw = true;
	while (samplePos.a <= len) {
		vec4 colorSample = texture(overlay, samplePos.xyz);
		if ((colorSample.a < 0.01) && (drawOpacity > 0.0)) {
			float val = texture(drawing, samplePos.xyz).r;
			vec4 draw = drawColor(val, drawOpacity);
			if ((draw.a > 0.0) && (firstDraw)) {
				firstDraw = false;
				float sum = 0.0;
				const float mn = 1.0 / 256.0;
				const float sampleRadius = 1.1;
				float dx = sliceSize * sampleRadius;
				vec3 center = samplePos.xyz;
				//six neighbors that share a face
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,0.0), dir)).r, mn);
				//float proportion = (sum / mn) / 6.0;
				
				//12 neighbors that share an edge
				dx = sliceSize * sampleRadius * sqrt(2.0) * 0.5;
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,+dx,0.0), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,-dx,0.0), dir)).r, mn);

				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,-dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(+dx,-dx,0.0), dir)).r, mn);
				
				sum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,+dx), dir)).r, mn);
				sum += min(texture(drawing, center.xyz + cross(vec3(-dx,+dx,0.0), dir)).r, mn);
				float proportion = (sum / mn) / 18.0; //proportion of six neighbors is non-zero
				
				//a high proportion of hits means crevice
				//since the AO term adds shadows that darken most voxels, it will result in dark surfaces
				//the term brighten adds a little illumination to balance this
				// without brighten, only the most extreme ridges will not be darker
				const float brighten = 1.2;
				vec3 ao = draw.rgb * (1.0 - proportion) * brighten;
				draw.rgb = mix (draw.rgb, ao , renderDrawAmbientOcclusionX);
			}
			colorSample = draw;
		}
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (overFirstHit.a > len)
				overFirstHit = samplePos;
			colorSample.a *= renderOverlayBlend;
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			overFarthest = samplePos.a;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
	//if (samplePos.a >= len) {
	if (colAcc.a <= 0.0) {
		if (isClip && (fColor.a == 0.0))
			fColor += clipPlaneColorX;
		return;
	}
	if (overFirstHit.a < firstHit.a)
		gl_FragDepth = frac2ndc(overFirstHit.xyz);
	float overMix = colAcc.a;
	float overlayDepth = 0.3;
	if (fColor.a <= 0.0)
		overMix = 1.0;
	else if (((overFarthest) > backNearest)) {
		float dx = (overFarthest - backNearest)/1.73;
		dx = fColor.a * pow(dx, overlayDepth);
		overMix *= 1.0 - dx;
	}
	fColor.rgb = mix(fColor.rgb, colAcc.rgb, overMix);
	fColor.a = max(fColor.a, colAcc.a);
}`, ZG = `#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
` + Xh + `
	void main() {
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays
		fColor = vec4(0.0,0.0,0.0,0.0);
		return;
	}
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	vec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	vec4 colAcc = vec4(0.0,0.0,0.0,0.0);
	vec4 firstHit = vec4(0.0,0.0,0.0,2.0 * len);
	const float earlyTermination = 0.95;
	float backNearest = len; //assume no hit
	float dis = len;
	//check if axial plane is closest
	vec4 aClip = vec4(0.0, 0.0, 1.0, (1.0- clipPlane.z) - 0.5);
	float adis = (-aClip.a - dot(aClip.xyz, samplePos.xyz-0.5)) / dot(dir,aClip.xyz);
	if (adis > 0.0)
		dis = min(adis, dis);
	//check of coronal plane is closest
	vec4 cClip = vec4(0.0, 1.0, 0.0, (1.0- clipPlane.y) - 0.5);
	float cdis = (-cClip.a - dot(cClip.xyz, samplePos.xyz-0.5)) / dot(dir,cClip.xyz);
	if (cdis > 0.0)
		dis = min(cdis, dis);
	//check if coronal slice is closest
	vec4 sClip = vec4(1.0, 0.0, 0.0, (1.0- clipPlane.x) - 0.5);
	float sdis = (-sClip.a - dot(sClip.xyz, samplePos.xyz-0.5)) / dot(dir,sClip.xyz);
	if (sdis > 0.0)
		dis = min(sdis, dis);
	if ((dis > 0.0) && (dis < len)) {
		samplePos = vec4(samplePos.xyz+dir * dis, dis);
		colAcc = texture(volume, samplePos.xyz);
		colAcc.a = earlyTermination;
		firstHit = samplePos;
		backNearest = min(backNearest, samplePos.a);
	}
	//the following are only used by overlays
	vec4 clipPlaneColorX = clipPlaneColor;
	bool isColorPlaneInVolume = false;
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	if (samplePos.a < 0.0)
		vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);
	samplePos += deltaDir * ran; //jitter ray
` + f5, QG = `#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform vec2 renderDrawAmbientOcclusionXY;
in vec3 vColor;
out vec4 fColor;
` + Xh + h8 + `while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		samplePos += deltaDir; //advance ray position
		if (colorSample.a >= 0.01) {
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
	}
` + f5, ah = 192, hb = `#version 300 es
#line 215
precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 texVox;
uniform int backgroundMasksOverlays;
uniform vec3 volScale;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform float backOpacity;
uniform mat4 mvpMtx;
uniform mat4 normMtx;
uniform mat4 matRAS;
uniform vec4 clipPlaneColor;
uniform float renderOverlayBlend;
uniform highp sampler3D drawing, gradient;
uniform highp sampler2D colormap;
uniform highp sampler2D matCap;
uniform vec2 renderDrawAmbientOcclusionXY;
uniform float gradientAmount;
uniform float silhouettePower;
uniform float gradientOpacity[${ah}];
in vec3 vColor;
out vec4 fColor;
`, JG = hb + Xh + h8 + `
	float startPos = samplePos.a;
	float clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	float silhouetteThreshold = 1.0 - silhouettePower;
	while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			grad.rgb = normalize(grad.rgb*2.0 - 1.0);
			//if (grad.a < prevGrad.a)
			//	grad.rgb = prevGrad.rgb;
			//prevGrad = grad;
			vec3 n = mat3(normMtx) * grad.rgb;
			n.y = - n.y;
			vec4 mc = vec4(texture(matCap, n.xy * 0.5 + 0.5).rgb, 1.0) * brighten;
			mc = mix(vec4(1.0), mc, gradientAmount);
			if (samplePos.a > clipClose)
				colorSample.rgb *= mc.rgb;
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			int gradIdx = int(grad.a * ${ah}.0);
			colorSample.a *= gradientOpacity[gradIdx];
			float lightNormDot = dot(grad.rgb, rayDir);
			// n.b. "lightNormDor" is cosTheta, "silhouettePower" is Fresnel effect exponent
 			colorSample.a *= pow(1.0 - abs(lightNormDot), silhouettePower);
 			float viewAlign = abs(lightNormDot); // 0 = perpendicular, 1 = aligned
 			// linearly map silhouettePower (0..1) to a threshold range, e.g., [1.0, 0.0]
 			// Cull voxels that are too aligned with the view direction
 			if (viewAlign > silhouetteThreshold)
 				colorSample.a = 0.0;
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
` + f5, $G = hb + Xh + h8 + `
	float startPos = samplePos.a;
	float clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane
	float brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25
	//vec4 prevGrad = vec4(0.0);
	while (samplePos.a <= len) {
		vec4 colorSample = texture(volume, samplePos.xyz);
		if (colorSample.a >= 0.0) {
			vec4 grad = texture(gradient, samplePos.xyz);
			colorSample.rgb = abs(normalize(grad.rgb*2.0 - 1.0));
			if (firstHit.a > lenNoClip)
				firstHit = samplePos;
			backNearest = min(backNearest, samplePos.a);
			colorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);
			colorSample.rgb *= colorSample.a;
			colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
			if ( colAcc.a > earlyTermination )
				break;
		}
		samplePos += deltaDir; //advance ray position
	}
` + f5, T2 = `#version 300 es
#line 392
layout(location=0) in vec3 pos;
uniform int axCorSag;
uniform mat4 mvpMtx;
uniform mat4 frac2mm;
uniform float slice;
out vec3 texPos;
void main(void) {
	texPos = vec3(pos.x, pos.y, slice);
	if (axCorSag > 1)
		texPos = vec3(slice, pos.x, pos.y);
	else if (axCorSag > 0)
		texPos = vec3(pos.x, slice, pos.y);
	vec4 mm = frac2mm * vec4(texPos, 1.0);
	gl_Position = mvpMtx * mm;
}`, db = `#version 300 es
#line 411
precision highp int;
precision highp float;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform int backgroundMasksOverlays;
uniform float overlayOutlineWidth;
uniform float overlayAlphaShader;
uniform int axCorSag;
uniform float overlays;
uniform float opacity;
uniform float drawOpacity;
uniform float drawRimOpacity;
uniform bool isAlphaClipDark;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
in vec3 texPos;
out vec4 color;
` + f8 + `
vec4 blendRGBA(vec4 foreground, vec4 background) {
  float alphaOut = foreground.a + background.a * (1.0 - foreground.a);
  vec3 colorOut = (foreground.rgb * foreground.a + background.rgb * background.a * (1.0 - foreground.a)) / alphaOut;
  return vec4(colorOut, alphaOut);
}
float paqdEaseAlpha(float alpha) {
  // t are alpha transitions
  // <t0 -> y0
  // t0..t1  -> mix between y0..y1
  // t1..t2 -> mix between y1..y2
  // >t2 -> y2
  float t0 = paqdUniforms[0]; // 0.3;
  float t1 = 0.5 * (paqdUniforms[0] + paqdUniforms[1]); // 0.4;
  float t2 = paqdUniforms[1]; // 0.9;
  float y0 = 0.0;
  float y1 = abs(paqdUniforms[2]); // 1.0;
  float y2 = abs(paqdUniforms[3]); //0.25;
  if (alpha <= t0) {
    return y0;
  } else if (alpha <= t1) {
    return mix(y0, y1, (alpha - t0) / (t1 - t0)); // LERP 0.0 \u2192 1.0
  } else if (alpha <= t2) {
    return mix(y1, y2, (alpha - t1) / (t2 - t1)); // LERP 1.0 \u2192 0.2
  } else {
    return y2;
  }
}

void main() {
	//color = vec4(1.0, 0.0, 1.0, 1.0);return;
	vec4 background = texture(volume, texPos);
	color = vec4(background.rgb, opacity);
	if ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range
	vec4 ocolor = vec4(0.0);
	float overlayAlpha = overlayAlphaShader;
	if (overlays > 0.0) {
		ocolor = texture(overlay, texPos);
		//dFdx for "boxing" issue 435 has aliasing on some implementations (coarse vs fine)
		//however, this only identifies 50% of the edges due to aliasing effects
		// http://www.aclockworkberry.com/shader-derivative-functions/
		// https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b
		//if ((ocolor.a >= 1.0) && ((dFdx(ocolor.a) != 0.0) || (dFdy(ocolor.a) != 0.0)  ))
		//	ocolor.rbg = vec3(0.0, 0.0, 0.0);
		bool isOutlineBelowNotAboveThreshold = true;
		if (isOutlineBelowNotAboveThreshold) {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a < 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				//6 voxel neighbors that share a face
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 0.0;
				if (axCorSag != 2) {
					a = max(a, texture(overlay, vxR).a);
					a = max(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = max(a, texture(overlay, vxA).a);
					a = max(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = max(a, texture(overlay, vxS).a);
					a = max(a, texture(overlay, vxI).a);
				}
				bool isCheckCorners = true;
				if (isCheckCorners) {
					//12 voxel neighbors that share an edge
					vec3 vxRA = vec3(texPos.x+vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxLA = vec3(texPos.x-vx.x, texPos.y+vx.y, texPos.z);
					vec3 vxRP = vec3(texPos.x+vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxLP = vec3(texPos.x-vx.x, texPos.y-vx.y, texPos.z);
					vec3 vxRS = vec3(texPos.x+vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxLS = vec3(texPos.x-vx.x, texPos.y, texPos.z+vx.z);
					vec3 vxRI = vec3(texPos.x+vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxLI = vec3(texPos.x-vx.x, texPos.y, texPos.z-vx.z);
					vec3 vxAS = vec3(texPos.x, texPos.y+vx.y, texPos.z+vx.z);
					vec3 vxPS = vec3(texPos.x, texPos.y-vx.y, texPos.z+vx.z);
					vec3 vxAI = vec3(texPos.x, texPos.y+vx.y, texPos.z-vx.z);
					vec3 vxPI = vec3(texPos.x, texPos.y-vx.y, texPos.z-vx.z);

					if (axCorSag == 0) { //axial corners
						a = max(a, texture(overlay, vxRA).a);
						a = max(a, texture(overlay, vxLA).a);
						a = max(a, texture(overlay, vxRP).a);
						a = max(a, texture(overlay, vxLP).a);
					}
					if (axCorSag == 1) { //coronal corners
						a = max(a, texture(overlay, vxRS).a);
						a = max(a, texture(overlay, vxLS).a);
						a = max(a, texture(overlay, vxRI).a);
						a = max(a, texture(overlay, vxLI).a);
					}
					if (axCorSag == 2) { //sagittal corners
						a = max(a, texture(overlay, vxAS).a);
						a = max(a, texture(overlay, vxPS).a);
						a = max(a, texture(overlay, vxAI).a);
						a = max(a, texture(overlay, vxPI).a);
					}
				}
				if (a >= 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}

		} else {
			if ((overlayOutlineWidth > 0.0) && (ocolor.a >= 1.0)) { //check voxel neighbors for edge
				vec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));
				vec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);
				vec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);
				vec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);
				vec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);
				vec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);
				vec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);
				float a = 1.0;
				if (axCorSag != 2) {
					a = min(a, texture(overlay, vxR).a);
					a = min(a, texture(overlay, vxL).a);
				}
				if (axCorSag != 1) {
					a = min(a, texture(overlay, vxA).a);
					a = min(a, texture(overlay, vxP).a);
				}
				if (axCorSag != 0) {
					a = min(a, texture(overlay, vxS).a);
					a = min(a, texture(overlay, vxI).a);
				}
				if (a < 1.0) {
					ocolor = vec4(0.0, 0.0, 0.0, 1.0);
					overlayAlpha = 1.0;
				}
			}
		} //outline above threshold
	}

`, ez = `#version 300 es
#line 411
precision highp int;
precision highp float;
uniform highp sampler2D volume, overlay;
uniform int backgroundMasksOverlays;
uniform float overlayOutlineWidth;
uniform float overlayAlphaShader;
uniform int axCorSag;
uniform float overlays;
uniform float opacity;
uniform float drawOpacity;
uniform bool isAlphaClipDark;
uniform highp sampler2D drawing;
uniform highp sampler2D colormap;
in vec3 texPos;
out vec4 color;` + f8 + `void main() {
	//color = vec4(1.0, 0.0, 1.0, 1.0);return;
	vec4 background = texture(volume, texPos.xy);
	color = vec4(background.rgb, opacity);
	if ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range
	vec4 dcolor = drawColor(texture(drawing, texPos.xy).r, drawOpacity);
	if (dcolor.a > 0.0) {
		color.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);
		color.a = max(drawOpacity, color.a);
	}
}`, gb = `	ocolor.a *= overlayAlpha;
	float drawV = texture(drawing, texPos).r;
	vec4 dcolor = drawColor(drawV, drawOpacity);
	if (dcolor.a > 0.0) {
		if (drawRimOpacity >= 0.0) {
			vec3 vx = 1.0 / vec3(textureSize(drawing, 0));
			//6 voxel neighbors that share a face
			vec3 offsetX = dFdx(texPos); // left-right spacing
			vec3 offsetY = dFdy(texPos); // up-down spacing
			float L = texture(drawing, texPos - offsetX).r;
			float R = texture(drawing, texPos + offsetX).r;
			float T = texture(drawing, texPos - offsetY).r;
			float B = texture(drawing, texPos + offsetY).r;
			if (L != drawV || R != drawV || T != drawV || B != drawV)
				dcolor.a = drawRimOpacity;
		}
		color.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);
		color.a = max(drawOpacity, color.a);
	}
	vec4 pcolor = texture(paqd, texPos);
	if (pcolor.a > 0.0) {
		pcolor.a = paqdEaseAlpha(pcolor.a);
		if (pcolor.a > 0.0) {
			if (paqdUniforms[3] < 0.0)
				ocolor = blendRGBA(pcolor, ocolor);
			else
				ocolor = blendRGBA(ocolor, pcolor);
		}
	}
	if ((backgroundMasksOverlays > 0) && (background.a == 0.0))
		return;
	float a = color.a + ocolor.a * (1.0 - color.a); // premultiplied alpha
	if (a == 0.0) return;
	color.rgb = mix(color.rgb, ocolor.rgb, ocolor.a / a);
	color.a = a;
}`, tz = db + gb, nz = db + `	if (ocolor.a > 0.0) {
		//https://gamedev.stackexchange.com/questions/102889/is-it-possible-to-convert-vec4-to-int-in-glsl-using-opengl-es
		uint alpha = uint(ocolor.a * 255.0);
		vec3 xyzFlip = vec3(float((uint(1) & alpha) > uint(0)), float((uint(2) & alpha) > uint(0)), float((uint(4) & alpha) > uint(0)));
		//convert from 0 and 1 to -1 and 1
		xyzFlip = (xyzFlip * 2.0) - 1.0;
		//https://math.stackexchange.com/questions/1905533/find-perpendicular-distance-from-point-to-line-in-3d
		//v1 principle direction of tensor for this voxel
		vec3 v1 = ocolor.rgb;
		//flips encode polarity to convert from 0..1 to -1..1 (27 bits vs 24 bit precision)
		v1 = normalize( v1 * xyzFlip);
		vec3 vxl = fract(texPos * vec3(textureSize(volume, 0))) - 0.5;
		//vxl coordinates now -0.5..+0.5 so 0,0,0 is origin
		vxl.x = -vxl.x;
		float t = dot(vxl,v1);
		vec3 P = t * v1;
		float dx = length(P-vxl);
		ocolor.a = 1.0 - smoothstep(0.2,0.25, dx);
		//if modulation was applied, use that to scale alpha not color:
		ocolor.a *= length(ocolor.rgb);
		ocolor.rgb = normalize(ocolor.rgb);
		//compute distance one half voxel closer to viewer:
		float pan = 0.5;
		if (axCorSag == 0)
			vxl.z -= pan;
		if (axCorSag == 1)
			vxl.y -= pan;
		if (axCorSag == 2)
			vxl.x += pan;
		t = dot(vxl,v1);
		P = t * v1;
		float dx2 = length(P-vxl);
		ocolor.rgb += (dx2-dx-(0.5 * pan)) * 1.0;
	}
` + gb, i4 = `#version 300 es
#line 480
precision highp int;
precision highp float;
uniform vec4 lineColor;
out vec4 color;
void main() {
	color = lineColor;
}`, rz = `#version 300 es
#line 723
precision highp int;
precision highp float;

uniform vec4 lineColor;
uniform vec4 leftTopWidthHeight;
uniform float thickness; // line thickness in pixels
uniform vec2 canvasWidthHeight;

out vec4 color;

void main() {
    // fragment position in screen coordinates
    vec2 fragCoord = gl_FragCoord.xy;

    // canvas height
    float canvasHeight = canvasWidthHeight.y;

    // 'top' and 'bottom' to match gl_FragCoord.y coordinate system
    float top = canvasHeight - leftTopWidthHeight.y;
    float bottom = top - leftTopWidthHeight.w;

    // left and right edges
    float left = leftTopWidthHeight.x;
    float right = left + leftTopWidthHeight.z;

    bool withinLeft = fragCoord.x >= left && fragCoord.x <= left + thickness;
    bool withinRight = fragCoord.x <= right && fragCoord.x >= right - thickness;
    bool withinTop = fragCoord.y <= top && fragCoord.y >= top - thickness;
    bool withinBottom = fragCoord.y >= bottom && fragCoord.y <= bottom + thickness;

    bool isOutline = withinLeft || withinRight || withinTop || withinBottom;

    if (isOutline) {
        color = lineColor;
    } else {
        discard; 
    }
}`, iz = `#version 300 es
#line 490
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vColor;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vColor = pos.xy;
}`, az = `#version 300 es
#line 506
precision highp int;
precision highp float;
uniform highp sampler2D colormap;
uniform float layer;
in vec2 vColor;
out vec4 color;
void main() {
	float nlayer = float(textureSize(colormap, 0).y);
	float fmap = (0.5 + layer) / nlayer;
	color = vec4(texture(colormap, vec2(vColor.x, fmap)).rgb, 1.0);
}`, oC = `#version 300 es
#line 520
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
}`, sz = `#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec4 startXYendXY;
void main(void) {
	vec2 posXY = mix(startXYendXY.xy, startXYendXY.zw, pos.x);
	vec2 dir = normalize(startXYendXY.xy - startXYendXY.zw);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0
	gl_Position = vec4((posXY * 2.0) - 1.0, 0.0, 1.0);
}`, oz = `#version 300 es
#line 534
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform float thickness;
uniform vec2 startXY;
uniform vec3 endXYZ; // transformed XYZ point
void main(void) {	
	vec2 posXY = mix(startXY.xy, endXYZ.xy, pos.x);
	vec2 startDiff = endXYZ.xy - startXY.xy;
	float startDistance = length(startDiff);
	vec2 diff = endXYZ.xy - posXY;
	float currentDistance = length(diff);
	vec2 dir = normalize(startXY.xy - endXYZ.xy);
	posXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);
	posXY.x = (posXY.x) / canvasWidthHeight.x; //0..1
	posXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0	
	float z = endXYZ.z * ( 1.0 - abs(currentDistance/startDistance)); 
	gl_Position = vec4((posXY * 2.0) - 1.0, z, 1.0);
}`, lz = `#version 300 es
#line 549
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(pos.x, 1.0 - pos.y);
}`, cz = `#version 300 es
#line 565
precision highp int;
precision highp float;
uniform highp sampler2D bmpTexture;
in vec2 vUV;
out vec4 color;
void main() {
	color = texture(bmpTexture, vUV);
}`, uz = `#version 300 es
#line 576
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = vec2(uvLeftTopWidthHeight.x + (pos.x * uvLeftTopWidthHeight.z), uvLeftTopWidthHeight.y  + ((1.0 - pos.y) * uvLeftTopWidthHeight.w) );
}`, fz = `#version 300 es
#line 593
precision highp int;
precision highp float;
uniform highp sampler2D fontTexture;
uniform vec4 fontColor;
uniform float screenPxRange;
in vec2 vUV;
out vec4 color;
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
void main() {
	vec3 msd = texture(fontTexture, vUV).rgb;
	float sd = median(msd.r, msd.g, msd.b);
	float screenPxDistance = screenPxRange*(sd - 0.5);
	float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	color = vec4(fontColor.rgb , fontColor.a * opacity);
}`, hz = `#version 300 es
layout(location=0) in vec3 pos;
uniform vec2 canvasWidthHeight;
uniform vec4 leftTopWidthHeight;
uniform vec4 uvLeftTopWidthHeight;
out vec2 vUV;
void main(void) {
	//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1
	vec2 frac;
	frac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1
	frac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0
	frac = (frac * 2.0) - 1.0;
	gl_Position = vec4(frac, 0.0, 1.0);
	vUV = pos.xy;
}`, dz = `#version 300 es
precision highp int;
precision highp float;
uniform vec4 circleColor;
uniform float fillPercent;
in vec2 vUV;
out vec4 color;
void main() {
	/* Check if the pixel is inside the circle
		 and color it with a gradient. Otherwise, color it 
		 transparent   */
	float distance = length(vUV-vec2(0.5,0.5));
	if ( distance < 0.5 && distance >= (1.0 - fillPercent) / 2.0){
			color = vec4(circleColor.r,circleColor.g,circleColor.b,circleColor.a) ;			
	}else{
			color = vec4(0.0,0.0,0.0,0.0);
	}
}
`, fc = `#version 300 es
#line 613
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4( (vPos.xy-vec2(0.5,0.5)) * 2.0, 0.0, 1.0);
}`, S2 = `#version 300 es
uniform highp usampler3D intensityVol;
`, lC = `#version 300 es
uniform highp isampler3D intensityVol;
`, gz = `#version 300 es
uniform highp sampler3D intensityVol;
`, cC = `#line 1042
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform bool isAdditiveBlend;
uniform float coordZ;
uniform float layer;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform uint activeIndex;
uniform vec4 xyzaFrac;
uniform mat4 mtx;
float textureWidth;
float nlayer;
float layerY;

vec4 scalar2color(uint idx) {
	float fx = (float(idx) + 0.5) / textureWidth;
	vec4 clr = texture(colormap, vec2(fx, layerY)).rgba;
	if (clr.a > 0.0)
		clr.a = 1.0;
	clr.a *= opacity;
	return clr;
}
void main(void) {
	vec4 vx = vec4(TexCoord.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint idx = uint(texture(intensityVol, vx.xyz).r);
	if (idx == uint(0)) {
		if (layer < 1.0) {
			FragColor = vec4(0.0, 0.0, 0.0, 0.0);
			return;
		}
		FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		return;
	}
	textureWidth = float(textureSize(colormap, 0).x);
	nlayer = float(textureSize(colormap, 0).y);
	layerY = ((2.0 * layer) + 1.5) / nlayer;
	//idx = ((idx - uint(1)) % uint(100))+uint(1);
	FragColor = scalar2color(idx);
	bool isBorder = false;
	vx = vec4(TexCoord.x+xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint R = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x-xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;
	uint L = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y+xyzaFrac.y, coordZ, 1.0) * mtx;
	uint A = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y-xyzaFrac.y, coordZ, 1.0) * mtx;
	uint P = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y, coordZ+xyzaFrac.z, 1.0) * mtx;
	uint S = uint(texture(intensityVol, vx.xyz).r);
	vx = vec4(TexCoord.x, TexCoord.y, coordZ-xyzaFrac.z, 1.0) * mtx;
	uint I = uint(texture(intensityVol, vx.xyz).r);
	vec4 centerColor = FragColor;
	FragColor.a += scalar2color(R).a;
	FragColor.a += scalar2color(L).a;
	FragColor.a += scalar2color(A).a;
	FragColor.a += scalar2color(P).a;
	FragColor.a += scalar2color(S).a;
	FragColor.a += scalar2color(I).a;
	FragColor.a /= 7.0;
	if ((!isBorder) &&(idx == activeIndex)) {
		if (centerColor.a > 0.5)
			FragColor.a *= 0.4;
		else
			FragColor.a =0.8;
	}
	if (xyzaFrac.a != 0.0) { //outline
		if ((idx != R) || (idx != L) || (idx != A) || (idx != P) || (idx != S) || (idx != I)) {
			isBorder = true;
			if (xyzaFrac.a > 0.0)
				FragColor.a = xyzaFrac.a;
			else
				FragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}
	if (layer < 1.0) return;
		vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		// https://en.wikipedia.org/wiki/Alpha_compositing
		float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
		if (aout <= 0.0) return;
		if (isAdditiveBlend)
			FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;
		else
			FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
		FragColor.a = aout;
}`, a4 = `#line 691
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform float cal_maxNeg;
uniform float cal_minNeg;
uniform bool isAlphaThreshold;
uniform bool isColorbarFromZero;
uniform bool isAdditiveBlend;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform int modulation;
uniform highp sampler3D modulationVol;
uniform float opacity;
uniform mat4 mtx;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	if ((vx.x < 0.0) || (vx.x > 1.0) || (vx.y < 0.0) || (vx.y > 1.0) || (vx.z < 0.0) || (vx.z > 1.0)) {
		//set transparent if out of range
		//https://webglfundamentals.org/webgl/webgl-3d-textures-repeat-clamp.html
		FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
		return;
	}
	float f = (scl_slope * float(texture(intensityVol, vx.xyz).r)) + scl_inter;
	float mn = cal_min;
	float mx = cal_max;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mn = 0.0;
	float r = max(0.00001, abs(mx - mn));
	mn = min(mn, mx);
	float txl = mix(0.0, 1.0, (f - mn) / r);
	if (f > mn) { //issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
	}
	//https://stackoverflow.com/questions/5879403/opengl-texture-coordinates-in-pixel-space
	float nlayer = float(textureSize(colormap, 0).y);
	//each volume has two color maps:
	// (layer*2) = negative and (layer * 2) + 1 = positive
	float y = ((2.0 * layer) + 1.5)/nlayer;
	FragColor = texture(colormap, vec2(txl, y)).rgba;
	//negative colors
	mn = cal_minNeg;
	mx = cal_maxNeg;
	if ((isAlphaThreshold) || (isColorbarFromZero))
		mx = 0.0;
	//if ((!isnan(cal_minNeg)) && ( f < mx)) {
	if ((cal_minNeg < cal_maxNeg) && ( f < mx)) {
		r = max(0.00001, abs(mx - mn));
		mn = min(mn, mx);
		txl = 1.0 - mix(0.0, 1.0, (f - mn) / r);
		//issue1139: survives threshold, so round up to opaque voxel
		txl = max(txl, 2.0/256.0);
		y = ((2.0 * layer) + 0.5)/nlayer;
		FragColor = texture(colormap, vec2(txl, y));
	}
	if (layer > 0.7)
		FragColor.a = step(0.00001, FragColor.a);
	//if (modulation > 10)
	//	FragColor.a *= texture(modulationVol, vx.xyz).r;
	//	FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (isAlphaThreshold) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = pow(-f / -cal_maxNeg, 2.0);
		else if ((f > 0.0) && (cal_min > 0.0))
			FragColor.a *= pow(f / cal_min, 2.0); //issue435:  A = (V/X)**2
		//FragColor.g = 0.0;
	} else if (isColorbarFromZero) {
		if ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))
			FragColor.a = 0.0;
		else if ((f > 0.0) && (cal_min > 0.0) && (f < cal_min))
			FragColor.a *= 0.0;

	}
	if (modulation == 1) {
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	} else if (modulation == 2) {
		FragColor.a = texture(modulationVol, vx.xyz).r;
	}
	FragColor.a *= opacity;
	if (layer < 1.0) return;
	vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
	// https://en.wikipedia.org/wiki/Alpha_compositing
	float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
	if (aout <= 0.0) return;
	if (isAdditiveBlend)
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;
	else
		FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
	FragColor.a = aout;
}`, pz = `#line 773
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform mat4 mtx;
uniform bool hasAlpha;
uniform int modulation;
uniform highp sampler3D modulationVol;
float textureWidth;
float nlayer;
float layerY;

vec4 scalar2color(uint idx) {
	float fx = (float(idx) + 0.5) / textureWidth;
	vec4 clr = texture(colormap, vec2(fx, layerY)).rgba;
	if (clr.a > 0.0)
		clr.a = 1.0;
	clr.a *= opacity;
	return clr;
}

vec4 paqd2color(uvec4 rgba) {
  // paqd r: max prob index, g: 2nd index, b: max prob a: 2nd prob
  float prob1 = float(rgba.b)/255.0;
  float prob2 = float(rgba.a)/255.0;
  vec4 clr1 = scalar2color(rgba.r);
  vec4 clr2 = scalar2color(rgba.g);
  float total = prob1 + prob2;
  vec4 clr = vec4(clr1.rgb, total);
  // vec4 clr = vec4(clr1.rgb, prob1);
  if (total > 0.0) {
    clr.rgb = mix(clr2.rgb, clr1.rgb, prob1 / total);
  }
  return clr;
}
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	ivec3 voxelCoord = ivec3(vx.xyz * vec3(textureSize(intensityVol, 0)));
	uvec4 rgba = texelFetch(intensityVol, voxelCoord, 0);
	FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	if (rgba.r > uint(0)) {
		textureWidth = float(textureSize(colormap, 0).x);
		nlayer = float(textureSize(colormap, 0).y);
		layerY = ((2.0 * layer) + 1.5) / nlayer;
		FragColor = paqd2color(rgba);
		return;
	}
	// if (layer > 2.0) return;
	// FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
}`, mz = `#line 773
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float layer;
uniform float scl_slope;
uniform float scl_inter;
uniform float cal_max;
uniform float cal_min;
uniform highp sampler2D colormap;
uniform lowp sampler3D blend3D;
uniform float opacity;
uniform mat4 mtx;
uniform bool hasAlpha;
uniform int modulation;
uniform highp sampler3D modulationVol;
void main(void) {
	vec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;
	uvec4 aColor = texture(intensityVol, vx.xyz);
	FragColor = vec4(float(aColor.r) / 255.0, float(aColor.g) / 255.0, float(aColor.b) / 255.0, float(aColor.a) / 255.0);
	if (modulation == 1)
		FragColor.rgb *= texture(modulationVol, vx.xyz).r;
	if (!hasAlpha) {
		FragColor.a = (FragColor.r * 0.21 + FragColor.g * 0.72 + FragColor.b * 0.07);
		//next line: we could binarize alpha, but see rendering of visible human
		//FragColor.a = step(0.01, FragColor.a);
	}
	if (modulation == 2)
		FragColor.a = texture(modulationVol, vx.xyz).r;
	FragColor.a *= opacity;
	if (layer < 1.0) return;
	vec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));
	// https://en.wikipedia.org/wiki/Alpha_compositing
	float aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;
	if (aout <= 0.0) return;
	FragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;
	FragColor.a = aout;
}`, vz = `#version 300 es
#line 808
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	gl_Position = vec4((vPos.x - 0.5) * 2.0, (vPos.y - 0.5) * 2.0, 0.0, 1.0);
}`, yz = `#version 300 es
#line 829
	precision highp float;
	precision highp int;
	precision highp isampler3D;
	layout(location = 0) out int label;
	layout(location = 1) out int strength;
	in vec2 TexCoord;
	uniform int finalPass;
	uniform float coordZ;
	uniform lowp sampler3D in3D;
	uniform highp isampler3D backTex; // background
	uniform highp isampler3D labelTex; // label
	uniform highp isampler3D strengthTex; // strength
void main(void) {
	vec3 interpolatedTextureCoordinate = vec3(TexCoord.xy, coordZ);
	ivec3 size = textureSize(backTex, 0);
	ivec3 texelIndex = ivec3(floor(interpolatedTextureCoordinate * vec3(size)));
	int background = texelFetch(backTex, texelIndex, 0).r;
	label = texelFetch(labelTex, texelIndex, 0).r;
	strength = texelFetch(strengthTex, texelIndex, 0).r;
	for (int k = -1; k <= 1; k++) {
		for (int j = -1; j <= 1; j++) {
			for (int i = -1; i <= 1; i++) {
				if (i != 0 && j != 0 && k != 0) {
					ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
					int neighborBackground = texelFetch(backTex, neighborIndex, 0).r;
					int neighborStrength = texelFetch(strengthTex, neighborIndex, 0).r;
					int strengthCost = abs(neighborBackground - background);
					int takeoverStrength = neighborStrength - strengthCost;
					if (takeoverStrength > strength) {
						strength = takeoverStrength;
						label = texelFetch(labelTex, neighborIndex, 0).r;
					}
				}
			}
		}
	}
	if (finalPass < 1)
		return;
	int ok = 1;
	ivec4 labelCount = ivec4(0,0,0,0);
	for (int k = -1; k <= 1; k++)
		for (int j = -1; j <= 1; j++)
			for (int i = -1; i <= 1; i++) {
				ivec3 neighborIndex = texelIndex + ivec3(i,j,k);
				int ilabel = texelFetch(labelTex, neighborIndex, 0).r;
				if ((ilabel < 0) || (ilabel > 3))
					ok = 0;
				else
					labelCount[ilabel]++;
			}
	if (ok != 1) {
		return;
	}
	int maxIdx = 0;
	for (int i = 1; i < 4; i++) {
		if (labelCount[i] > labelCount[maxIdx])
			maxIdx = i;
	}
	label = maxIdx;
}`, xz = `#version 300 es
layout(location=0) in vec3 pos;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
}`, wz = `#version 300 es
precision highp int;
precision highp float;
uniform vec4 surfaceColor;
out vec4 color;
void main() {
	color = surfaceColor;
}`, Cz = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 clr;
out vec4 vClr;
uniform mat4 mvpMtx;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vClr = clr;
}`, Tz = `#version 300 es
precision highp int;
precision highp float;
in vec4 vClr;
out vec4 color;
uniform float opacity;
void main() {
	color = vec4(vClr.rgb, opacity);
}`, s4 = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
out vec3 vN;
out vec4 vP;
out vec4 vPc;
void main(void) {
	vec3 lightPosition = vec3(0.0, 0.0, -10.0);
	vP = vec4(pos, 1.0);
	vPc = mvpMtx * vec4(pos, 1.0);
	gl_Position = vPc;
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`, Sz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
out vec4 color;
vec4 packFloatToVec4i(const float value) {
	const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
	const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
	vec4 res = fract(value * bitSh);
	res -= res.xxyz * bitMsk;
	return res;
}
void main() {
	color = packFloatToVec4i(gl_FragCoord.z);
}`, Az = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
float stepmix(float edge0, float edge1, float E, float x){
	float T = clamp(0.5 * (x - edge0 + E) / E, 0.0, 1.0);
	return mix(edge0, edge1, T);
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0);
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.5;
	float shininess = 50.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float df = max(0.0, dot(n, l));
	float sf = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	const float A = 0.1;
	const float B = 0.3;
	const float C = 0.6;
	const float D = 1.0;
	float E = fwidth(df);
	if (df > A - E && df < A + E) df = stepmix(A, B, E, df);
	else if (df > B - E && df < B + E) df = stepmix(B, C, E, df);
	else if (df > C - E && df < C + E) df = stepmix(C, D, E, df);
	else if (df < A) df = 0.0;
	else if (df < B) df = B;
	else if (df < C) df = C;
	else df = D;
	E = fwidth(sf);
	if (sf > 0.5 - E && sf < 0.5 + E)
		sf = smoothstep(0.5 - E, 0.5 + E, sf);
	else
		sf = step(0.5, sf);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(df, 0.0) * vClr.rgb * diffuse;
	color.rgb = a + d + (specular * sf);
	color.a = opacity;
}`, Ez = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.25;
	float shininess = 10.0;
	float PenWidth = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	float view = abs(dot(n,r)); //with respect to viewer
	if (PenWidth < view) discard;
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color.rgb = a + d + s;
	color.a = opacity;
}`, bz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	const float thresh = 0.4;
	const vec3 viewDir = vec3(0.0, 0.0, -1.0);
	vec3 n = normalize(vN);
	// use abs() for two-sided lighting, max() for one sided
	float cosTheta = abs(dot(n, viewDir));
	// float cosTheta = max(dot(n, viewDir), 0.0);
	// optional fresnel equation - adjust exponent
	// cosTheta = 1.0 - pow(1.0 - cosTheta, 2.0);
	// use step for binary edges, smoothstep for feathered edges
	// vec3 d = step(thresh, cosTheta) * vClr.rgb;
	vec3 d = smoothstep(thresh - 0.05, thresh + 0.05, cosTheta) * vClr.rgb;
	color = vec4(d, opacity);
}`, Dz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
  const float edge0 = 0.1;
  const float edge1 = 0.25;
  const vec3 viewDir = vec3(0.0, 0.0, -1.0);
  vec3 n = normalize(vN);
  float cosTheta = abs(dot(n, viewDir));
  float alpha = 1.0 - smoothstep(edge0, edge1, cosTheta);
  if (alpha <= 0.0) {
    discard;
  }
  color = vec4(0.0, 0.0, 0.0, opacity * alpha);
}`, Mz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float diffuse = 1.0;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 0.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d = lightNormDot * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(d + s, opacity);
}`, Rz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float diffuse = 1.4;
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(normalize(vN), l), 0.0);
	color = vec4(lightNormDot * vClr.rgb * diffuse, opacity);
}`, Oz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float specularRGB = 0.7;
	float specularWhite = 0.3;
	float shininess = 10.0;
	float diffuse = 1.0;
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	vec3 n = normalize(vN);
	vec3 l = vec3(0.0, 0.0, -1.0);
	float lightNormDot = max(dot(n, l), 0.0);
	vec3 d3 = lightNormDot * vClr.rgb * diffuse;
	float s = pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 s3 = specularRGB * s * vClr.rgb;
	s *= specularWhite;
	color = vec4(d3 + s3 + s, opacity);
}`, Iz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
in vec4 vPc;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	// Compute curvature
	vec3 dx = dFdx(n);
	vec3 dy = dFdy(n);
	vec3 xneg = n - dx;
	vec3 xpos = n + dx;
	vec3 yneg = n - dy;
	vec3 ypos = n + dy;
	float depth = length(vPc.xyz);
	float curv = (cross(xneg, xpos).y - cross(yneg, ypos).x) / depth;
	//at this stage 0.5 for flat, with valleys dark and ridges bright
	curv = 1.0 - (curv + 0.5);
	//clamp
	curv =  min(max(curv, 0.0), 1.0);
	// easing function
	curv = pow(curv, 0.5);
	//modulate ambient and diffuse with curvature
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.6;
	float diffuse = 0.6;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 lightPosition = vec3(0.0, 10.0, -2.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient * curv;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, Vz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, Nz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
uniform sampler2D matCap;
out vec4 color;
void main() {
	vec3 n = normalize(vN);
	vec2 uv = n.xy * 0.5 + 0.5;
	uv.y = 1.0 - uv.y;
	vec3 clr = texture(matCap,uv.xy).rgb * vClr.rgb;
	color = vec4(clr, opacity);
}`, Lz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	float ambient = 0.35;
	float diffuse = 0.6;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	color = vec4(a + d, opacity);
}`, Uz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 up = vec3(0.0, 1.0, 0.0);
	float ax = dot(n, up) * 0.5 + 0.5;  //Shreiner et al. (2013) OpenGL Programming Guide, 8th Ed., p 388. ISBN-10: 0321773039
	vec3 upClr = vec3(1.0, 1.0, 0.95);
	vec3 downClr = vec3(0.4, 0.4, 0.6);
	vec3 a = vClr.rgb * ambient;
	a *= mix(downClr, upClr, ax);
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, Fz = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
in vec3 vN;
out vec4 color;
//Spherical harmonics constants
const float C1 = 0.429043;
const float C2 = 0.511664;
const float C3 = 0.743125;
const float C4 = 0.886227;
const float C5 = 0.247708;
//Spherical harmonics coefficients
// Ramamoorthi, R., and P. Hanrahan. 2001b. "An Efficient Representation for Irradiance Environment Maps." In Proceedings of SIGGRAPH 2001, pp. 497\u2013500.
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl
// Constants for Eucalyptus Grove lighting
const vec3 L00  = vec3( 0.3783264,  0.4260425,  0.4504587);
const vec3 L1m1 = vec3( 0.2887813,  0.3586803,  0.4147053);
const vec3 L10  = vec3( 0.0379030,  0.0295216,  0.0098567);
const vec3 L11  = vec3(-0.1033028, -0.1031690, -0.0884924);
const vec3 L2m2 = vec3(-0.0621750, -0.0554432, -0.0396779);
const vec3 L2m1 = vec3( 0.0077820, -0.0148312, -0.0471301);
const vec3 L20  = vec3(-0.0935561, -0.1254260, -0.1525629);
const vec3 L21  = vec3(-0.0572703, -0.0502192, -0.0363410);
const vec3 L22  = vec3( 0.0203348, -0.0044201, -0.0452180);
vec3 SH(vec3 vNormal) {
	vNormal = vec3(vNormal.x,vNormal.z,vNormal.y);
	vec3 diffuseColor = C1 * L22 * (vNormal.x * vNormal.x - vNormal.y * vNormal.y) +
	C3 * L20 * vNormal.z * vNormal.z +
	C4 * L00 -
	C5 * L20 +
	2.0 * C1 * L2m2 * vNormal.x * vNormal.y +
	2.0 * C1 * L21  * vNormal.x * vNormal.z +
	2.0 * C1 * L2m1 * vNormal.y * vNormal.z +
	2.0 * C2 * L11  * vNormal.x +
	2.0 * C2 * L1m1 * vNormal.y +
	2.0 * C2 * L10  * vNormal.z;
	return diffuseColor;
}
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.3;
	float diffuse = 0.6;
	float specular = 0.1;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	vec3 a = vClr.rgb * ambient;
	vec3 d = vClr.rgb * diffuse * SH(-reflect(n, vec3(l.x, l.y, -l.z)) );
	color = vec4(a + d + s, opacity);
}`, Bz = `#version 300 es
layout(location=0) in vec3 pos;
layout(location=1) in vec4 norm;
layout(location=2) in vec4 clr;
uniform mat4 mvpMtx;
//uniform mat4 modelMtx;
uniform mat4 normMtx;
out vec4 vClr;
flat out vec3 vN;
void main(void) {
	gl_Position = mvpMtx * vec4(pos, 1.0);
	vN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);
	//vV = -vec3(modelMtx*vec4(pos,1.0));
	vClr = clr;
}`, uC = `#version 300 es
precision highp int;
precision highp float;
uniform float opacity;
in vec4 vClr;
flat in vec3 vN;
out vec4 color;
void main() {
	vec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)
	float ambient = 0.35;
	float diffuse = 0.5;
	float specular = 0.2;
	float shininess = 10.0;
	vec3 n = normalize(vN);
	vec3 lightPosition = vec3(0.0, 10.0, -5.0);
	vec3 l = normalize(lightPosition);
	float lightNormDot = dot(n, l);
	vec3 a = vClr.rgb * ambient;
	vec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;
	float s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);
	color = vec4(a + d + s, opacity);
}`, _z = `#version 300 es
#line 1260
//precision highp int;
precision highp float;
uniform vec3 rayDir;
uniform vec3 volScale;
uniform vec3 texVox;
uniform vec4 clipPlane;
uniform highp sampler3D volume, overlay;
uniform highp sampler3D paqd;
uniform vec4 paqdUniforms;
uniform float overlays;
uniform float clipThick;
uniform vec3 clipLo;
uniform vec3 clipHi;
uniform mat4 matRAS;
uniform mat4 mvpMtx;
uniform float drawOpacity, renderOverlayBlend;
uniform highp sampler3D drawing;
uniform highp sampler2D colormap;
uniform int backgroundMasksOverlays;
in vec3 vColor;
out vec4 fColor;
` + Xh + `
void main() {
	int id = 254;
	vec3 start = vColor;
	gl_FragDepth = 0.0;
	fColor = vec4(0.0, 0.0, 0.0, 0.0); //assume no hit: ID = 0
	float fid = float(id & 255)/ 255.0;
	vec3 backPosition = GetBackPosition(start);
	vec3 dir = normalize(backPosition - start);
	clipVolumeStart(start, backPosition);
	float len = length(backPosition - start);
	float lenVox = length((texVox * start) - (texVox * backPosition));
	if ((lenVox < 0.5) || (len > 3.0)) return;//discard; //length limit for parallel rays
	float sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube
	float stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples
	float opacityCorrection = stepSize/sliceSize;
	dir = normalize(dir);
	vec4 samplePos = vec4(start.xyz, 0.0); //ray position
	float lenNoClip = len;
	bool isClip = false;
	vec4 clipPos = applyClip(dir, samplePos, len, isClip);
	if (isClip) fColor = vec4(samplePos.xyz, 253.0 / 255.0); //assume no hit: ID = 0
	//start: OPTIONAL fast pass: rapid traversal until first hit
	float stepSizeFast = sliceSize * 1.9;
	vec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);
	while (samplePos.a <= len) {
		float val = texture(volume, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			break;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//end: fast pass
	if ((overlays < 1.0) || (backgroundMasksOverlays > 0)) {
		return; //background hit, no overlays
	}
	//overlay pass
	len = min(lenNoClip, samplePos.a); //only find overlay closer than background
	samplePos = vec4(start.xyz, 0.0); //ray position
	while (samplePos.a <= len) {
		float val = texture(overlay, samplePos.xyz).a;
		if (val > 0.01) {
			fColor = vec4(samplePos.rgb, fid);
			gl_FragDepth = frac2ndc(samplePos.xyz);
			return;
		}
		samplePos += deltaDirFast; //advance ray position
	}
	//if (fColor.a == 0.0) discard; //no hit in either background or overlays
	//you only get here if there is a hit with the background that is closer than any overlay
}`, kz = `#version 300 es
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
layout(location=0)  in vec3 a_position;
layout(location=1)  in vec3 a_color;
// A matrix to transform the positions by
uniform mat4 u_matrix;
out vec3 vColor;
// all shaders have a main function
void main() {
	// Multiply the position by the matrix.
	vec4 pos = vec4(a_position, 1.0);
	gl_Position = u_matrix * vec4(pos);
	vColor = a_color;
}
`, Pz = `#version 300 es
precision highp float;
uniform vec4 u_color;
in vec3 vColor;
out vec4 outColor;
void main() {
	outColor = vec4(vColor, 1.0);
}`, Gz = `#version 300 es
#line 1359
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
	TexCoord = vPos.xy;
	vec2 viewCoord = (vPos.xy - 0.5) * 2.0;
	gl_Position = vec4((vPos.xy - 0.5) * 2.0, 0.0, 1.0);
}`, zz = `#version 300 es
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform lowp sampler3D in3D;
void main(void) {
 FragColor = texture(in3D, vec3(TexCoord.xy, coordZ));
}`, A2 = `#version 300 es
#line 286
precision highp int;
precision highp float;
in vec3 vPos;
out vec2 TexCoord;
void main() {
    TexCoord = vPos.xy;
    gl_Position = vec4( (vPos.xy-vec2(0.5,0.5))* 2.0, 0.0, 1.0);
}`, Wz = `#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 samp = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
 samp += texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
 FragColor = samp*0.125;
}`, Hz = `#version 300 es
#line 298
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
 vec3 vx = vec3(TexCoord.xy, coordZ);
 vec4 XYZ = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
 vec4 OYZ = texture(intensityVol,vx+vec3(0.0,+dY,+dZ));
 vec4 xYZ = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
 vec4 XOZ = texture(intensityVol,vx+vec3(+dX,0.0,+dZ));
 vec4 OOZ = texture(intensityVol,vx+vec3(0.0,0.0,+dZ));
 vec4 xOZ = texture(intensityVol,vx+vec3(-dX,0.0,+dZ));
 vec4 XyZ = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
 vec4 OyZ = texture(intensityVol,vx+vec3(0.0,-dY,+dZ));
 vec4 xyZ = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));

 vec4 XYO = texture(intensityVol,vx+vec3(+dX,+dY,0.0));
 vec4 OYO = texture(intensityVol,vx+vec3(0.0,+dY,0.0));
 vec4 xYO = texture(intensityVol,vx+vec3(-dX,+dY,0.0));
 vec4 XOO = texture(intensityVol,vx+vec3(+dX,0.0,0.0));
 vec4 OOO = texture(intensityVol,vx+vec3(0.0,0.0,0.0));
 vec4 xOO = texture(intensityVol,vx+vec3(-dX,0.0,0.0));
 vec4 XyO = texture(intensityVol,vx+vec3(+dX,-dY,0.0));
 vec4 OyO = texture(intensityVol,vx+vec3(0.0,-dY,0.0));
 vec4 xyO = texture(intensityVol,vx+vec3(-dX,-dY,0.0));

 vec4 XYz = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
 vec4 OYz = texture(intensityVol,vx+vec3(0.0,+dY,-dZ));
 vec4 xYz = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
 vec4 XOz = texture(intensityVol,vx+vec3(+dX,0.0,-dZ));
 vec4 OOz = texture(intensityVol,vx+vec3(0.0,0.0,-dZ));
 vec4 xOz = texture(intensityVol,vx+vec3(-dX,0.0,-dZ));
 vec4 Xyz = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
 vec4 Oyz = texture(intensityVol,vx+vec3(0.0,-dY,-dZ));
 vec4 xyz = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));

 vec4 blurred = vec4 (0.0, 0.0, 0.0, 0.0);
 blurred.r = 2.0*(xOz.r +xOZ.r +xyO.r +xYO.r +xOO.r +XOz.r +XOZ.r +XyO.r +XYO.r +XOO.r) +xyz.r +xyZ.r +xYz.r +xYZ.r +Xyz.r +XyZ.r +XYz.r +XYZ.r;
 blurred.g = 2.0*(Oyz.r +OyZ.r +xyO.r +XyO.r +OyO.r +OYz.r +OYZ.r +xYO.r +XYO.r +OYO.r) +xyz.r +Xyz.r +xyZ.r +XyZ.r +xYz.r +XYz.r +xYZ.r +XYZ.r;
 blurred.b = 2.0*(Oyz.r +OYz.r +xOz.r +XOz.r +OOz.r +OyZ.r +OYZ.r +xOZ.r +XOZ.r +OOZ.r) +xyz.r +Xyz.r +xYz.r +XYz.r +xyZ.r +XyZ.r +XyZ.r +XYZ.r;
 blurred.a = 0.32*(abs(blurred.r)+abs(blurred.g)+abs(blurred.b));
 // 0.0357 = 1/28 to account for weights, rescale to 2**16,
 FragColor = 0.0357*blurred;
}`, pb = `
  gradientSample.a = log2(gradientSample.r*gradientSample.r + gradientSample.g*gradientSample.g + gradientSample.b*gradientSample.b + 1.922337562475971e-06) + 18.988706873717717;
`, jz = `#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  float TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ)).r;
  float TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ)).r;
  float TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ)).r;
  float TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ)).r;
  float BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ)).r;
  float BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ)).r;
  float BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ)).r;
  float BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ)).r;
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = BAR+BAL+BPR+BPL -TAR-TAL-TPR-TPL;
  gradientSample.g = TPR+TPL+BPR+BPL -TAR-TAL-BAR-BAL;
  gradientSample.b = TAL+TPL+BAL+BPL -TAR-TPR-BAR-BPR;
${pb}
	// 0.04242020977371934 = 1/(log2(3*8) - log2(1/(255**2*8))) // 3*8 -> max for 1st order gradient
	gradientSample.a *= 0.04242020977371934;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb = (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`, Kz = `#version 300 es
#line 323
precision highp int;
precision highp float;
in vec2 TexCoord;
out vec4 FragColor;
uniform float coordZ;
uniform float dX;
uniform float dY;
uniform float dZ;
uniform float dX2;
uniform float dY2;
uniform float dZ2;
uniform highp sampler3D intensityVol;
void main(void) {
  vec3 vx = vec3(TexCoord.xy, coordZ);
  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft
  vec4 TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));
  vec4 TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));
  vec4 TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));
  vec4 TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));
  vec4 BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));
  vec4 BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));
  vec4 BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));
  vec4 BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));
  vec4 T = texture(intensityVol,vx+vec3(+dX2,0.0,0.0));
  vec4 A = texture(intensityVol,vx+vec3(0.0,+dY2,0.0));
  vec4 R = texture(intensityVol,vx+vec3(0.0,0.0,+dZ2));
  vec4 B = texture(intensityVol,vx+vec3(-dX2,0.0,0.0));
  vec4 P = texture(intensityVol,vx+vec3(0.0,-dY2,0.0));
  vec4 L = texture(intensityVol,vx+vec3(0.0,0.0,-dZ2));
  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);
  gradientSample.r = -4.0*B.r +8.0*(BAR.r+BAL.r+BPR.r+BPL.r) -8.0*(TAR.r+TAL.r+TPR.r+TPL.r) +4.0*T.r;
  gradientSample.g = -4.0*P.g +8.0*(TPR.g+TPL.g+BPR.g+BPL.g) -8.0*(TAR.g+TAL.g+BAR.g+BAL.g) +4.0*A.g;
  gradientSample.b = -4.0*L.b +8.0*(TAL.b+TPL.b+BAL.b+BPL.b) -8.0*(TAR.b+TPR.b+BAR.b+BPR.b) +4.0*R.b;
${pb}
	gradientSample.a *= 0.0325;
  gradientSample.rgb = normalize(gradientSample.rgb);
  gradientSample.rgb =  (gradientSample.rgb * 0.5)+0.5;
  FragColor = gradientSample;
}`, Yz = function(t, e, n) {
    const r = t.createShader(t.VERTEX_SHADER);
    t.shaderSource(r, e), t.compileShader(r);
    const i = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(i, n), t.compileShader(i);
    const a = t.createProgram();
    if (t.attachShader(a, r), t.attachShader(a, i), t.linkProgram(a), !t.getProgramParameter(a, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(a)), t.getShaderParameter(r, t.COMPILE_STATUS) || console.log("Vertex shader compilation error:", t.getShaderInfoLog(r)), t.getShaderParameter(i, t.COMPILE_STATUS) || console.log("Fragment shader compilation error:", t.getShaderInfoLog(i)), ee.error(t.getProgramInfoLog(a)), new Error("Shader failed to link, see console for log");
    return a;
  }, un = class {
    constructor(t, e, n) {
      J(this, "program"), J(this, "uniforms", {}), J(this, "isMatcap"), this.program = Yz(t, e, n);
      const r = /uniform[^;]+[ ](\w+);/g, i = /uniform[^;]+[ ](\w+);/, a = e.match(r), s = n.match(r);
      a && a.forEach((o) => {
        const l = o.match(i);
        this.uniforms[l[1]] = -1;
      }), s && s.forEach((o) => {
        const l = o.match(i);
        this.uniforms[l[1]] = -1;
      });
      for (const o in this.uniforms) this.uniforms[o] = t.getUniformLocation(this.program, o);
    }
    use(t) {
      t.useProgram(this.program);
    }
  }, fC = (t, e) => {
    const n = Math.floor(Math.log(t) / Math.log(10)), r = t / Math.pow(10, n);
    let i;
    return e ? r < 1.5 ? i = 1 : r < 3 ? i = 2 : r < 7 ? i = 5 : i = 10 : r <= 1 ? i = 1 : r <= 2 ? i = 2 : r <= 5 ? i = 5 : i = 10, i * Math.pow(10, n);
  };
  function qz(t) {
    return new Promise((e, n) => {
      let r;
      t instanceof File ? r = Promise.resolve(t) : r = new Promise((i, a) => {
        t.file(i, a);
      }), r.then((i) => {
        const a = new FileReader();
        a.onload = () => {
          typeof a.result == "string" ? e(a.result) : n(new Error("Expected a string from FileReader.result"));
        }, a.onerror = () => {
          n(a.error ?? new Error("Unknown FileReader error"));
        }, a.readAsDataURL(i);
      }).catch((i) => n(i));
    });
  }
  function Xz(t) {
    const e = t.hdr.dims, n = t.permRAS, r = e[1] * e[2] * e[3], i = new Int16Array(r), a = [
      0,
      0,
      0
    ];
    for (let g = 0; g < 3; g++) for (let v = 0; v < 3; v++) Math.abs(n[g]) - 1 === v && (a[v] = g * Math.sign(n[g]));
    let s = 1;
    const o = [
      1,
      1,
      1
    ], l = [
      false,
      false,
      false
    ];
    for (let g = 0; g < a.length; g++) for (let v = 0; v < a.length; v++) Math.abs(a[v]) === g && (o[v] = s, (a[v] < 0 || Object.is(a[v], -0)) && (l[v] = true), s *= e[v + 1]);
    let c = ft.range(0, e[1] - 1, 1);
    l[0] && (c = ft.range(e[1] - 1, 0, -1));
    for (let g = 0; g < e[1]; g++) c[g] *= o[0];
    let f = ft.range(0, e[2] - 1, 1);
    l[1] && (f = ft.range(e[2] - 1, 0, -1));
    for (let g = 0; g < e[2]; g++) f[g] *= o[1];
    let u = ft.range(0, e[3] - 1, 1);
    l[2] && (u = ft.range(e[3] - 1, 0, -1));
    for (let g = 0; g < e[3]; g++) u[g] *= o[2];
    let h = 0;
    for (let g = 0; g < e[3]; g++) for (let v = 0; v < e[2]; v++) for (let m = 0; m < e[1]; m++) i[c[m] + f[v] + u[g]] = t.img[h], h++;
    return i;
  }
  function Zz(t) {
    const e = [
      5960464477539063e-23,
      152587890625e-16,
      390625e-8,
      1
    ];
    return (t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]) / 255;
  }
  function hC(t, e) {
    return t.scl_slope === 0 && (t.scl_slope = 1), e * t.scl_slope + t.scl_inter;
  }
  function f1(t, e, n = 4) {
    const r = fC(e - t, false), i = fC(r / (n - 1), true), a = Math.floor(t / i) * i, s = Math.ceil(e / i) * i;
    return [
      i,
      a,
      s,
      a === t && s === e
    ];
  }
  function dC(t, e) {
    let n = f1(t, e, 3);
    return n[3] || (n = f1(t, e, 5)), n[3] || (n = f1(t, e, 4)), n[3] || (n = f1(t, e, 3)), n[3] || (n = f1(t, e, 5)), [
      n[0],
      n[1],
      n[2]
    ];
  }
  function al(t) {
    return t * (Math.PI / 180);
  }
  function o4(t, e, n, r) {
    let i = -t, a = -e;
    return isFinite(n) && isFinite(r) && (i = n, a = r), i > a && ([i, a] = [
      a,
      i
    ]), [
      i,
      a
    ];
  }
  function l4(t, e, n) {
    return Math.min(Math.max(t, e), n);
  }
  function hr(t, e = [
    0,
    1,
    2
  ]) {
    const n = He();
    return n[0] = t[e[0]], n[1] = t[e[1]], n[2] = t[e[2]], n;
  }
  function gC(t) {
    const e = zn(1, 0, 0, 0), n = Rs();
    return Zr(n, e, t), n[0];
  }
  function Qz(t, e, n, r) {
    const i = zn(t, e, n, 1), a = Tr(r);
    Ti(a, a), i[0] = i[0] * 2 - 1, i[1] = i[1] * 2 - 1, i[2] = i[2] * 2 - 1;
    const s = Rs();
    return Zr(s, i, a), s[3] === 0 || (s[0] /= s[3], s[1] /= s[3], s[2] /= s[3]), s;
  }
  var { version: pC } = oP, hc = [
    "ASC",
    "BYU",
    "DFS",
    "FSM",
    "PIAL",
    "ORIG",
    "INFLATED",
    "SMOOTHWM",
    "SPHERE",
    "WHITE",
    "G",
    "GEO",
    "GII",
    "ICO",
    "MZ3",
    "NV",
    "OBJ",
    "OFF",
    "PLY",
    "SRF",
    "STL",
    "TCK",
    "TRACT",
    "TRI",
    "TRK",
    "TT",
    "TRX",
    "VTK",
    "WRL",
    "X3D",
    "JCON",
    "JSON"
  ], h1 = 0, c4 = 1, u4 = 2, Y0 = 33984, E2 = 33985, f4 = 33986, Jz = 33987, $z = 33988, mC = 33989, h4 = 33990, sl = 33991, d1 = 33992, vC = 33992, yC = 33993, xC = 33994, eW = 33995, tW = 33996, nW = 33997, rW = 33998, iW = 33999, wC = {
    filename: "",
    isSaveDrawing: false,
    volumeByIndex: 0
  }, aW = class {
    constructor(t = ns) {
      J(this, "loaders", {}), J(this, "dicomLoader", null), J(this, "canvas", null), J(this, "_gl", null), J(this, "isBusy", false), J(this, "needsRefresh", false), J(this, "colormapTexture", null), J(this, "colormapLists", []), J(this, "volumeTexture", null), J(this, "gradientTexture", null), J(this, "gradientTextureAmount", 0), J(this, "useCustomGradientTexture", false), J(this, "renderGradientValues", false), J(this, "drawTexture", null), J(this, "paqdTexture", null), J(this, "drawUndoBitmaps", []), J(this, "drawLut", Mn.makeDrawLut("$itksnap")), J(this, "drawOpacity", 0.8), J(this, "drawRimOpacity", -1), J(this, "clickToSegmentIsGrowing", false), J(this, "clickToSegmentGrowingBitmap", null), J(this, "clickToSegmentXY", [
        0,
        0
      ]), J(this, "renderDrawAmbientOcclusion", 0.4), J(this, "colorbarHeight", 0), J(this, "drawPenLocation", [
        NaN,
        NaN,
        NaN
      ]), J(this, "drawPenAxCorSag", -1), J(this, "drawFillOverwrites", true), J(this, "drawPenFillPts", []), J(this, "drawShapeStartLocation", [
        NaN,
        NaN,
        NaN
      ]), J(this, "drawShapePreviewBitmap", null), J(this, "overlayTexture", null), J(this, "overlayTextureID", null), J(this, "sliceMMShader"), J(this, "slice2DShader"), J(this, "sliceV1Shader"), J(this, "orientCubeShader"), J(this, "orientCubeShaderVAO", null), J(this, "rectShader"), J(this, "rectOutlineShader"), J(this, "renderShader"), J(this, "lineShader"), J(this, "line3DShader"), J(this, "passThroughShader"), J(this, "renderGradientShader"), J(this, "renderGradientValuesShader"), J(this, "renderSliceShader"), J(this, "renderVolumeShader"), J(this, "pickingMeshShader"), J(this, "pickingImageShader"), J(this, "colorbarShader"), J(this, "customSliceShader", null), J(this, "fontShader", null), J(this, "fiberShader"), J(this, "fontTexture", null), J(this, "circleShader"), J(this, "matCapTexture", null), J(this, "bmpShader", null), J(this, "bmpTexture", null), J(this, "thumbnailVisible", false), J(this, "bmpTextureWH", 1), J(this, "growCutShader"), J(this, "orientShaderAtlasU", null), J(this, "orientShaderAtlasI", null), J(this, "orientShaderU", null), J(this, "orientShaderI", null), J(this, "orientShaderF", null), J(this, "orientShaderRGBU", null), J(this, "orientShaderPAQD", null), J(this, "surfaceShader", null), J(this, "blurShader", null), J(this, "sobelBlurShader", null), J(this, "sobelFirstOrderShader", null), J(this, "sobelSecondOrderShader", null), J(this, "genericVAO", null), J(this, "unusedVAO", null), J(this, "crosshairs3D", null), J(this, "DEFAULT_FONT_GLYPH_SHEET", iC), J(this, "DEFAULT_FONT_METRICS", aC), J(this, "fontMetrics"), J(this, "fontMets", null), J(this, "fontPx", 12), J(this, "legendFontScaling", 1), J(this, "backgroundMasksOverlays", 0), J(this, "overlayOutlineWidth", 0), J(this, "overlayAlphaShader", 1), J(this, "position"), J(this, "extentsMin"), J(this, "extentsMax"), J(this, "resizeObserver", null), J(this, "resizeEventListener", null), J(this, "canvasObserver", null), J(this, "syncOpts", {
        "3d": false,
        "2d": false,
        zoomPan: false,
        cal_min: false,
        cal_max: false,
        clipPlane: false,
        gamma: false,
        sliceType: false,
        crosshair: false
      }), J(this, "readyForSync", false), J(this, "uiData", {
        mousedown: false,
        touchdown: false,
        mouseButtonLeftDown: false,
        mouseButtonCenterDown: false,
        mouseButtonRightDown: false,
        mouseDepthPicker: false,
        clickedTile: -1,
        pan2DxyzmmAtMouseDown: [
          0,
          0,
          0,
          1
        ],
        prevX: 0,
        prevY: 0,
        currX: 0,
        currY: 0,
        currentTouchTime: 0,
        lastTouchTime: 0,
        touchTimer: null,
        doubleTouch: false,
        isDragging: false,
        dragStart: [
          0,
          0
        ],
        dragEnd: [
          0,
          0
        ],
        dragClipPlaneStartDepthAziElev: [
          0,
          0,
          0
        ],
        lastTwoTouchDistance: 0,
        multiTouchGesture: false,
        windowX: 0,
        windowY: 0,
        activeDragMode: null,
        activeDragButton: null,
        angleFirstLine: [
          0,
          0,
          0,
          0
        ],
        angleState: "none"
      }), J(this, "back", null), J(this, "overlays", []), J(this, "deferredVolumes", []), J(this, "deferredMeshes", []), J(this, "furthestVertexFromOrigin", 100), J(this, "volScale", []), J(this, "vox", []), J(this, "mousePos", [
        0,
        0
      ]), J(this, "screenSlices", []), J(this, "cuboidVertexBuffer"), J(this, "otherNV", null), J(this, "volumeObject3D", null), J(this, "pivot3D", [
        0,
        0,
        0
      ]), J(this, "furthestFromPivot", 10), J(this, "currentClipPlaneIndex", 0), J(this, "lastCalled", (/* @__PURE__ */ new Date()).getTime()), J(this, "selectedObjectId", -1), J(this, "CLIP_PLANE_ID", 1), J(this, "VOLUME_ID", 254), J(this, "DISTANCE_FROM_CAMERA", -0.54), J(this, "graph", {
        LTWH: [
          0,
          0,
          640,
          480
        ],
        opacity: 0,
        vols: [
          0
        ],
        autoSizeMultiplanar: false,
        normalizeValues: false,
        isRangeCalMinMax: false
      }), J(this, "customLayout", []), J(this, "meshShaders", [
        {
          Name: "Phong",
          Frag: Vz
        },
        {
          Name: "Matte",
          Frag: Lz
        },
        {
          Name: "Harmonic",
          Frag: Fz
        },
        {
          Name: "Hemispheric",
          Frag: Uz
        },
        {
          Name: "Crevice",
          Frag: Iz
        },
        {
          Name: "Edge",
          Frag: Mz
        },
        {
          Name: "Diffuse",
          Frag: Rz
        },
        {
          Name: "Outline",
          Frag: Ez
        },
        {
          Name: "Specular",
          Frag: Oz
        },
        {
          Name: "Toon",
          Frag: Az
        },
        {
          Name: "Flat",
          Frag: uC
        },
        {
          Name: "Matcap",
          Frag: Nz
        },
        {
          Name: "Rim",
          Frag: bz
        },
        {
          Name: "Silhouette",
          Frag: Dz
        }
      ]), J(this, "dragModes", {
        contrast: 1,
        measurement: 2,
        angle: 7,
        none: 0,
        pan: 3,
        slicer3D: 4,
        callbackOnly: 5
      }), J(this, "sliceTypeAxial", 0), J(this, "sliceTypeCoronal", 1), J(this, "sliceTypeSagittal", 2), J(this, "sliceTypeMultiplanar", 3), J(this, "sliceTypeRender", 4), J(this, "onDragRelease", () => {
      }), J(this, "onMouseUp", () => {
      }), J(this, "onLocationChange", () => {
      }), J(this, "onIntensityChange", () => {
      }), J(this, "onClickToSegment", () => {
      }), J(this, "onImageLoaded", () => {
      }), J(this, "onMeshLoaded", () => {
      }), J(this, "onFrameChange", () => {
      }), J(this, "onError", () => {
      }), J(this, "onColormapChange", () => {
      }), J(this, "onInfo", () => {
      }), J(this, "onWarn", () => {
      }), J(this, "onDebug", () => {
      }), J(this, "onVolumeAddedFromUrl", () => {
      }), J(this, "onVolumeWithUrlRemoved", () => {
      }), J(this, "onVolumeUpdated", () => {
      }), J(this, "onMeshAddedFromUrl", () => {
      }), J(this, "onMeshAdded", () => {
      }), J(this, "onMeshWithUrlRemoved", () => {
      }), J(this, "onZoom3DChange", () => {
      }), J(this, "onAzimuthElevationChange", () => {
      }), J(this, "onClipPlaneChange", () => {
      }), J(this, "onCustomMeshShaderAdded", () => {
      }), J(this, "onMeshShaderChanged", () => {
      }), J(this, "onMeshPropertyChanged", () => {
      }), J(this, "onDicomLoaderFinishedWithImages", () => {
      }), J(this, "onDocumentLoaded", () => {
      }), J(this, "onOptsChange", () => {
      }), J(this, "document", new t4()), J(this, "mediaUrlMap", /* @__PURE__ */ new Map()), J(this, "initialized", false), J(this, "currentDrawUndoBitmap");
      for (const e in t) typeof t[e] == "function" ? this[e] = t[e] : this.opts[e] = ns[e] === void 0 ? ns[e] : t[e];
      this.opts.forceDevicePixelRatio === 0 ? this.uiData.dpr = window.devicePixelRatio || 1 : this.opts.forceDevicePixelRatio < 0 ? this.uiData.dpr = 1 : this.uiData.dpr = this.opts.forceDevicePixelRatio, this.currentDrawUndoBitmap = this.opts.maxDrawUndoBitmaps, this.opts.drawingEnabled && this.createEmptyDrawing(), this.opts.thumbnail.length > 0 && (this.thumbnailVisible = true), ee.setLogLevel(this.opts.logLevel), this.document.setOptsChangeCallback((e, n, r) => {
        this.onOptsChange(e, n, r);
      });
    }
    get scene() {
      return this.document.scene;
    }
    get opts() {
      return this.document.opts;
    }
    get sliceMosaicString() {
      return this.document.opts.sliceMosaicString || "";
    }
    set sliceMosaicString(t) {
      this.document.opts.sliceMosaicString = t;
    }
    get isAlphaClipDark() {
      return this.document.opts.isAlphaClipDark;
    }
    set isAlphaClipDark(t) {
      this.document.opts.isAlphaClipDark = t;
    }
    cleanup() {
      this.resizeEventListener && (window.removeEventListener("resize", this.resizeEventListener), this.resizeEventListener = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.canvasObserver && (this.canvasObserver.disconnect(), this.canvasObserver = null), this.canvas && this.opts.interactive && (this.canvas.removeEventListener("mousedown", this.mouseDownListener.bind(this)), this.canvas.removeEventListener("mouseup", this.mouseUpListener.bind(this)), this.canvas.removeEventListener("mousemove", this.mouseMoveListener.bind(this)), this.canvas.removeEventListener("touchstart", this.touchStartListener.bind(this)), this.canvas.removeEventListener("touchend", this.touchEndListener.bind(this)), this.canvas.removeEventListener("touchmove", this.touchMoveListener.bind(this)), this.canvas.removeEventListener("wheel", this.wheelListener.bind(this)), this.canvas.removeEventListener("contextmenu", this.mouseContextMenuListener.bind(this)), this.canvas.removeEventListener("dblclick", this.resetBriCon.bind(this)), this.canvas.removeEventListener("dragenter", this.dragEnterListener.bind(this)), this.canvas.removeEventListener("dragover", this.dragOverListener.bind(this)), this.canvas.removeEventListener("drop", this.dropListener.bind(this)), this.canvas.removeEventListener("keyup", this.keyUpListener.bind(this)), this.canvas.removeEventListener("keydown", this.keyDownListener.bind(this))), this.document.removeOptsChangeCallback();
    }
    get volumes() {
      return this.document.volumes;
    }
    set volumes(t) {
      this.document.volumes = t;
    }
    get meshes() {
      return this.document.meshes;
    }
    set meshes(t) {
      this.document.meshes = t;
    }
    get drawBitmap() {
      return this.document.drawBitmap;
    }
    set drawBitmap(t) {
      this.document.drawBitmap = t;
    }
    get volScaleMultiplier() {
      return this.scene.volScaleMultiplier;
    }
    set volScaleMultiplier(t) {
      this.setScale(t);
    }
    async saveScene(t = "niivue.png") {
      function e(r, i) {
        const a = document.createElement("a");
        document.body.appendChild(a), a.style.display = "none";
        const s = window.URL.createObjectURL(r);
        a.href = s, a.download = i, a.click(), a.remove();
      }
      const n = this.canvas;
      if (!n) throw new Error("canvas not defined");
      this.drawScene(), n.toBlob((r) => {
        r && (t === "" && (t = `niivue-screenshot-${(/* @__PURE__ */ new Date()).toString()}.png`, t = t.replace(/\s/g, "_")), e(r, t));
      });
    }
    async attachTo(t, e = null) {
      return await this.attachToCanvas(document.getElementById(t), e), ee.debug("attached to element with id: ", t), this;
    }
    async attachToCanvas(t, e = null) {
      return this.canvas = t, e === null && (e = navigator.hardwareConcurrency > 6, ee.debug("AntiAlias ", e, " Threads ", navigator.hardwareConcurrency)), this.gl = this.canvas.getContext("webgl2", {
        alpha: true,
        antialias: e
      }), this.uiData.max2D = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE), this.uiData.max3D = this.gl.getParameter(this.gl.MAX_3D_TEXTURE_SIZE), ee.info("NIIVUE VERSION ", pC), ee.debug(`Max texture size 2D: ${this.uiData.max2D} 3D: ${this.uiData.max3D}`), this.canvas.parentElement.style.backgroundColor = "black", this.opts.isResizeCanvas && (this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.display = "block", this.canvas.width = this.canvas.offsetWidth, this.canvas.height = this.canvas.offsetHeight, this.resizeEventListener = () => {
        requestAnimationFrame(() => {
          this.resizeListener();
        });
      }, window.addEventListener("resize", this.resizeEventListener), this.resizeObserver = new ResizeObserver(() => {
        requestAnimationFrame(() => {
          this.resizeListener();
        });
      }), this.resizeObserver.observe(this.canvas.parentElement), this.canvasObserver = new MutationObserver((n) => {
        for (const r of n) if (r.type === "childList" && r.removedNodes.length > 0 && Array.from(r.removedNodes).includes(this.canvas)) {
          this.cleanup();
          break;
        }
      }), this.canvasObserver.observe(this.canvas.parentElement, {
        childList: true
      })), this.opts.interactive && this.registerInteractions(), await this.init(), this.drawScene(), this;
    }
    syncWith(t, e = {
      "2d": true,
      "3d": true
    }) {
      t instanceof Array || (t = [
        t
      ]), this.otherNV = t, this.syncOpts = {
        ...e
      };
    }
    broadcastTo(t, e = {
      "2d": true,
      "3d": true
    }) {
      t instanceof Array || (t = [
        t
      ]), this.otherNV = t, this.syncOpts = e;
    }
    doSync3d(t) {
      t.scene.renderAzimuth = this.scene.renderAzimuth, t.scene.renderElevation = this.scene.renderElevation, t.scene.volScaleMultiplier = this.scene.volScaleMultiplier;
    }
    doSync2d(t) {
      const e = this.frac2mm(this.scene.crosshairPos);
      t.scene.crosshairPos = t.mm2frac(e), t.scene.pan2Dxyzmm = Tl(this.scene.pan2Dxyzmm);
    }
    doSyncGamma(t) {
      const e = this.scene.gamma, n = t.scene.gamma;
      e !== n && t.setGamma(e);
    }
    doSyncZoomPan(t) {
      t.scene.pan2Dxyzmm = Tl(this.scene.pan2Dxyzmm);
    }
    doSyncCrosshair(t) {
      const e = this.frac2mm(this.scene.crosshairPos);
      t.scene.crosshairPos = t.mm2frac(e);
    }
    doSyncCalMin(t) {
      this.volumes[0].cal_min !== t.volumes[0].cal_min && (t.volumes[0].cal_min = this.volumes[0].cal_min, t.updateGLVolume());
    }
    doSyncCalMax(t) {
      this.volumes[0].cal_max !== t.volumes[0].cal_max && (t.volumes[0].cal_max = this.volumes[0].cal_max, t.updateGLVolume());
    }
    doSyncSliceType(t) {
      t.setSliceType(this.opts.sliceType);
    }
    doSyncClipPlane(t) {
      t.setClipPlane(this.scene.clipPlaneDepthAziElev);
    }
    sync() {
      if (!(!this.gl || !this.otherNV || typeof this.otherNV > "u") && this.gl.canvas.matches(":focus")) for (let t = 0; t < this.otherNV.length; t++) this.otherNV[t] !== this && (this.syncOpts.gamma && this.doSyncGamma(this.otherNV[t]), this.syncOpts.crosshair && this.doSyncCrosshair(this.otherNV[t]), this.syncOpts.zoomPan && this.doSyncZoomPan(this.otherNV[t]), this.syncOpts.sliceType && this.doSyncSliceType(this.otherNV[t]), this.syncOpts.cal_min && this.doSyncCalMin(this.otherNV[t]), this.syncOpts.cal_max && this.doSyncCalMax(this.otherNV[t]), this.syncOpts.clipPlane && this.doSyncClipPlane(this.otherNV[t]), this.syncOpts["2d"] && this.doSync2d(this.otherNV[t]), this.syncOpts["3d"] && this.doSync3d(this.otherNV[t]), this.otherNV[t].drawScene(), this.otherNV[t].createOnLocationChange());
    }
    arrayEquals(t, e) {
      return Array.isArray(t) && Array.isArray(e) && t.length === e.length && t.every((n, r) => n === e[r]);
    }
    textSizePoints() {
      this.opts.textHeight >= 0 && (ee.warn("textHeight is deprecated (use fontMinPx and fontSizeScaling)"), this.opts.fontMinPx = this.opts.textHeight * 217, this.opts.fontSizeScaling = 0.4, this.opts.textHeight = -1);
      const t = this.uiData.dpr || 1, e = this.opts.fontMinPx, n = this.gl.canvas.width / t, r = this.gl.canvas.height / t, i = n * r, a = 800 * 600, s = Math.max(i / a, 1), o = Math.pow(s, this.opts.fontSizeScaling), l = e * o * t;
      this.fontPx = l, ee.debug(`${n.toFixed(0)}x${r.toFixed(0)} pts (dpi=${t}) => areaScale=${s.toFixed(2)}, scale=${o.toFixed(2)}, minPx=${this.opts.fontMinPx} fontScale=${this.opts.fontSizeScaling} fontPx=${l.toFixed(2)}`);
    }
    resizeListener() {
      if (!(!this.canvas || !this.gl)) {
        if (!this.opts.isResizeCanvas) {
          this.opts.forceDevicePixelRatio >= 0 && ee.warn("this.opts.forceDevicePixelRatio requires isResizeCanvas"), this.drawScene();
          return;
        }
        this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.display = "block", this.opts.forceDevicePixelRatio === 0 ? this.uiData.dpr = window.devicePixelRatio || 1 : this.opts.forceDevicePixelRatio < 0 ? this.uiData.dpr = 1 : this.uiData.dpr = this.opts.forceDevicePixelRatio, ee.debug("devicePixelRatio: " + this.uiData.dpr), "width" in this.canvas.parentElement ? (this.canvas.width = this.canvas.parentElement.width * this.uiData.dpr, this.canvas.height = this.canvas.parentElement.height * this.uiData.dpr) : (this.canvas.width = this.canvas.offsetWidth * this.uiData.dpr, this.canvas.height = this.canvas.offsetHeight * this.uiData.dpr), this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.textSizePoints(), this.drawScene();
      }
    }
    getRelativeMousePosition(t, e) {
      if (e = e || t.target, !e) return;
      const n = e.getBoundingClientRect();
      return {
        x: t.clientX - n.left,
        y: t.clientY - n.top
      };
    }
    getNoPaddingNoBorderCanvasRelativeMousePosition(t, e) {
      return e = e || t.target, this.getRelativeMousePosition(t, e);
    }
    mouseContextMenuListener(t) {
      t.preventDefault();
    }
    mouseDownListener(t) {
      t.preventDefault(), this.drawPenLocation = [
        NaN,
        NaN,
        NaN
      ], this.drawPenAxCorSag = -1, this.drawShapeStartLocation = [
        NaN,
        NaN,
        NaN
      ], this.uiData.mousedown = true, this.opts.dragMode === 7 && this.uiData.angleState === "drawing_second_line" || (this.setDragStart(0, 0), this.setDragEnd(0, 0)), ee.debug("mouse down"), ee.debug(t);
      const e = this.getNoPaddingNoBorderCanvasRelativeMousePosition(t, this.gl.canvas);
      if (!e) return;
      const [n, r] = [
        e.x * this.uiData.dpr,
        e.y * this.uiData.dpr
      ];
      this.opts.clickToSegment && (this.clickToSegmentXY = [
        n,
        r
      ]);
      const i = this.getLabelAtPoint([
        n,
        r
      ]);
      if (i) {
        if (i.onClick) {
          i.onClick(i, t);
          return;
        }
        for (const a of this.meshes) {
          if (a.type !== "connectome") {
            if (Array.isArray(i.points) && i.points.length === 3 && i.points.every(Number.isFinite)) {
              const [s, o, l] = i.points;
              this.scene.crosshairPos = this.mm2frac([
                s,
                o,
                l
              ]), this.updateGLVolume(), this.drawScene();
            }
            continue;
          }
          for (const s of a.nodes) s.label === i && (this.scene.crosshairPos = this.mm2frac([
            s.x,
            s.y,
            s.z
          ]), this.updateGLVolume(), this.drawScene());
        }
      }
      this.uiData.clickedTile = this.tileIndex(n, r), t.button === h1 && t.shiftKey ? (this.uiData.mouseButtonCenterDown = true, this.setActiveDragMode(h1, true, t.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, t, e)) : t.button === h1 ? (this.uiData.mouseButtonLeftDown = true, this.setActiveDragMode(h1, false, t.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, t, e)) : t.button === u4 ? (this.uiData.mouseButtonRightDown = true, this.setActiveDragMode(u4, t.shiftKey, t.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, t, e)) : t.button === c4 && (this.uiData.mouseButtonCenterDown = true, this.setActiveDragMode(c4, t.shiftKey, t.ctrlKey), this.handleMouseAction(this.uiData.activeDragMode, t, e));
    }
    getMouseButtonDragMode(t, e, n) {
      const r = this.opts.mouseEventConfig;
      return t === h1 ? (r == null ? void 0 : r.leftButton) ? e && r.leftButton.withShift !== void 0 ? r.leftButton.withShift : n && r.leftButton.withCtrl !== void 0 ? r.leftButton.withCtrl : r.leftButton.primary : n ? 8 : this.opts.dragModePrimary : t === u4 ? (r == null ? void 0 : r.rightButton) !== void 0 ? r.rightButton : this.opts.dragMode : t === c4 ? (r == null ? void 0 : r.centerButton) !== void 0 ? r.centerButton : this.opts.dragMode : this.opts.dragMode;
    }
    getTouchDragMode(t) {
      const e = this.opts.touchEventConfig;
      return t ? (e == null ? void 0 : e.doubleTouch) ?? this.opts.dragMode : (e == null ? void 0 : e.singleTouch) ?? this.opts.dragModePrimary;
    }
    setActiveDragMode(t, e, n) {
      this.uiData.activeDragMode = this.getMouseButtonDragMode(t, e, n), this.uiData.activeDragButton = t;
    }
    getCurrentDragMode() {
      return this.uiData.activeDragMode !== null ? this.uiData.activeDragMode : this.opts.dragMode;
    }
    clearActiveDragMode() {
      this.uiData.activeDragMode = null, this.uiData.activeDragButton = null;
    }
    handleMouseAction(t, e, n) {
      if (t === 8) this.mouseDown(n.x, n.y), this.mouseClick(n.x, n.y);
      else if (t === 9) this.uiData.windowX = e.x, this.uiData.windowY = e.y;
      else {
        if (this.mousePos = [
          n.x * this.uiData.dpr,
          n.y * this.uiData.dpr
        ], t === 0) return;
        if (t === 7) if (this.uiData.angleState === "none") this.uiData.angleState = "drawing_first_line";
        else if (this.uiData.angleState === "drawing_second_line") {
          const r = [
            n.x * this.uiData.dpr,
            n.y * this.uiData.dpr
          ], i = this.tileIndex(r[0], r[1]);
          let a = {
            sliceIndex: -1,
            sliceType: 0,
            slicePosition: 0
          };
          if (i >= 0 && i < this.screenSlices.length) {
            const u = this.screenSlices[i].axCorSag;
            let h = 0;
            u === 0 ? h = this.scene.crosshairPos[2] : u === 1 ? h = this.scene.crosshairPos[1] : u === 2 && (h = this.scene.crosshairPos[0]), a = {
              sliceIndex: i,
              sliceType: u,
              slicePosition: h
            };
          }
          const s = [
            this.uiData.angleFirstLine[2],
            this.uiData.angleFirstLine[3],
            r[0],
            r[1]
          ], o = this.canvasPos2frac([
            this.uiData.angleFirstLine[0],
            this.uiData.angleFirstLine[1]
          ]), l = this.canvasPos2frac([
            this.uiData.angleFirstLine[2],
            this.uiData.angleFirstLine[3]
          ]), c = this.canvasPos2frac([
            s[0],
            s[1]
          ]), f = this.canvasPos2frac([
            s[2],
            s[3]
          ]);
          if (o[0] >= 0 && l[0] >= 0 && c[0] >= 0 && f[0] >= 0) {
            const u = this.frac2mm(o), h = this.frac2mm(l), g = this.frac2mm(c), v = this.frac2mm(f), m = {
              firstLineMM: {
                start: Ue(u[0], u[1], u[2]),
                end: Ue(h[0], h[1], h[2])
              },
              secondLineMM: {
                start: Ue(g[0], g[1], g[2]),
                end: Ue(v[0], v[1], v[2])
              },
              sliceIndex: a.sliceIndex,
              sliceType: a.sliceType,
              slicePosition: a.slicePosition,
              angle: this.calculateAngleBetweenLines(this.uiData.angleFirstLine, s)
            };
            this.document.completedAngles.push(m);
          }
          this.resetAngleMeasurement(), this.uiData.angleState = "complete", this.drawScene();
          return;
        } else this.uiData.angleState === "complete" && (this.resetAngleMeasurement(), this.uiData.angleState = "drawing_first_line");
        this.setDragStart(n.x, n.y), this.uiData.isDragging || (this.uiData.pan2DxyzmmAtMouseDown = Tl(this.scene.pan2Dxyzmm)), this.uiData.isDragging = true, this.uiData.dragClipPlaneStartDepthAziElev = this.scene.clipPlaneDepthAziElev;
      }
    }
    calculateMinMaxVoxIdx(t) {
      if (t.length > 2) throw new Error("array must not contain more than two values");
      return [
        Math.floor(Math.min(t[0], t[1])),
        Math.floor(Math.max(t[0], t[1]))
      ];
    }
    calculateNewRange({ volIdx: t = 0 } = {}) {
      if (this.opts.sliceType === 4 && this.sliceMosaicString.length < 1 || this.uiData.dragStart[0] === this.uiData.dragEnd[0] && this.uiData.dragStart[1] === this.uiData.dragEnd[1]) return;
      let e = this.canvasPos2frac([
        this.uiData.dragStart[0],
        this.uiData.dragStart[1]
      ]);
      if (e[0] < 0) return;
      const n = this.frac2vox(e, t);
      if (e = this.canvasPos2frac([
        this.uiData.dragEnd[0],
        this.uiData.dragEnd[1]
      ]), e[0] < 0) return;
      const r = this.frac2vox(e, t);
      let i = -Number.MAX_VALUE, a = Number.MAX_VALUE;
      const s = this.calculateMinMaxVoxIdx([
        n[0],
        r[0]
      ]), o = this.calculateMinMaxVoxIdx([
        n[1],
        r[1]
      ]), l = this.calculateMinMaxVoxIdx([
        n[2],
        r[2]
      ]);
      n[0] - r[0] === 0 ? s[1] = n[0] + 1 : n[1] - r[1] === 0 ? o[1] = n[1] + 1 : n[2] - r[2] === 0 && (l[1] = n[2] + 1);
      const c = this.volumes[t].hdr, f = this.volumes[t].img;
      if (!c || !f) return;
      const u = c.dims[1], h = c.dims[2];
      for (let m = l[0]; m < l[1]; m++) {
        const y = m * u * h;
        for (let w = o[0]; w < o[1]; w++) {
          const C = w * u;
          for (let T = s[0]; T < s[1]; T++) {
            const S = y + C + T;
            a > f[S] && (a = f[S]), i < f[S] && (i = f[S]);
          }
        }
      }
      if (a >= i) return;
      const g = hC(c, a), v = hC(c, i);
      this.volumes[t].cal_min = g, this.volumes[t].cal_max = v, this.onIntensityChange(this.volumes[t]);
    }
    generateMouseUpCallback(t, e) {
      const n = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]), r = this.tileIndex(this.uiData.dragEnd[0], this.uiData.dragEnd[1]);
      let i = -1;
      n === r && (i = r);
      let a = -1;
      i >= 0 && (a = this.screenSlices[i].axCorSag);
      const s = this.frac2mm(t), o = this.frac2mm(e), l = He();
      hi(l, Ue(s[0], s[1], s[2]), Ue(o[0], o[1], o[2]));
      const c = Pc(l), f = this.frac2vox(t), u = this.frac2vox(e);
      this.onDragRelease({
        fracStart: t,
        fracEnd: e,
        voxStart: f,
        voxEnd: u,
        mmStart: s,
        mmEnd: o,
        mmLength: c,
        tileIdx: i,
        axCorSag: a
      });
    }
    mouseUpListener() {
      function t(i) {
        return Object.prototype.toString.call(i).indexOf("Function") > -1;
      }
      const e = {
        mouseButtonRightDown: this.uiData.mouseButtonRightDown,
        mouseButtonCenterDown: this.uiData.mouseButtonCenterDown,
        isDragging: this.uiData.isDragging,
        mousePos: this.mousePos,
        fracPos: this.canvasPos2frac(this.mousePos)
      };
      this.uiData.mousedown = false, this.uiData.mouseButtonRightDown = false;
      const n = this.uiData.mouseButtonCenterDown;
      this.uiData.mouseButtonCenterDown = false, this.uiData.mouseButtonLeftDown = false;
      const r = this.getCurrentDragMode();
      if (this.drawPenFillPts.length > 0 ? this.drawPenFilled() : this.opts.drawingEnabled && !isNaN(this.drawPenLocation[0]) ? this.drawAddUndoBitmap() : this.opts.drawingEnabled && !isNaN(this.drawShapeStartLocation[0]) && (this.opts.penType === 1 || this.opts.penType === 2) && (this.opts.penValue === 0 ? this.drawAddUndoBitmap() : this.drawAddUndoBitmap(this.drawFillOverwrites), this.drawShapePreviewBitmap = null), this.drawPenLocation = [
        NaN,
        NaN,
        NaN
      ], this.drawPenAxCorSag = -1, this.drawShapeStartLocation = [
        NaN,
        NaN,
        NaN
      ], this.drawShapePreviewBitmap && (this.drawBitmap = this.drawShapePreviewBitmap, this.drawShapePreviewBitmap = null, this.refreshDrawing(true, false)), t(this.onMouseUp) && this.onMouseUp(e), this.uiData.isDragging) {
        if (this.uiData.isDragging = false, r === 7) {
          if (this.uiData.angleState === "drawing_first_line") {
            this.uiData.angleFirstLine = [
              this.uiData.dragStart[0],
              this.uiData.dragStart[1],
              this.uiData.dragEnd[0],
              this.uiData.dragEnd[1]
            ], this.uiData.angleState = "drawing_second_line", this.uiData.isDragging = true, this.drawScene();
            return;
          } else if (this.uiData.angleState === "drawing_second_line") {
            this.uiData.angleState = "complete", this.clearActiveDragMode(), this.drawScene();
            return;
          }
        }
        r === 5 && this.drawScene();
        const i = this.canvasPos2frac([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1]
        ]), a = this.canvasPos2frac([
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        if (this.generateMouseUpCallback(i, a), r === 6) {
          this.clearActiveDragMode();
          return;
        }
        if (r === 1) {
          if (n) {
            this.clearActiveDragMode();
            return;
          }
          if (this.uiData.dragStart[0] === this.uiData.dragEnd[0] && this.uiData.dragStart[1] === this.uiData.dragEnd[1]) {
            this.clearActiveDragMode();
            return;
          }
          this.calculateNewRange({
            volIdx: 0
          }), this.refreshLayers(this.volumes[0], 0);
        }
        if (r === 2) {
          const s = this.getCurrentSliceInfo(), o = this.canvasPos2frac([
            this.uiData.dragStart[0],
            this.uiData.dragStart[1]
          ]), l = this.canvasPos2frac([
            this.uiData.dragEnd[0],
            this.uiData.dragEnd[1]
          ]);
          if (o[0] >= 0 && l[0] >= 0) {
            const c = this.frac2mm(o), f = this.frac2mm(l);
            this.document.completedMeasurements.push({
              startMM: Ue(c[0], c[1], c[2]),
              endMM: Ue(f[0], f[1], f[2]),
              sliceIndex: s.sliceIndex,
              sliceType: s.sliceType,
              slicePosition: s.slicePosition,
              distance: Mu(Ue(c[0], c[1], c[2]), Ue(f[0], f[1], f[2]))
            });
          }
          this.clearActiveDragMode(), this.drawScene();
          return;
        }
      }
      this.clearActiveDragMode(), this.drawScene();
    }
    checkMultitouch(t) {
      if (this.uiData.touchdown && !this.uiData.multiTouchGesture) {
        const e = this.canvas.getBoundingClientRect();
        this.mouseDown(t.touches[0].clientX - e.left, t.touches[0].clientY - e.top), this.mouseClick(t.touches[0].clientX - e.left, t.touches[0].clientY - e.top);
      }
    }
    touchStartListener(t) {
      t.preventDefault(), this.uiData.touchTimer || (this.uiData.touchTimer = setTimeout(() => {
        this.resetBriCon(t);
      }, this.opts.longTouchTimeout)), this.uiData.touchdown = true, this.uiData.currentTouchTime = (/* @__PURE__ */ new Date()).getTime();
      const e = this.uiData.currentTouchTime - this.uiData.lastTouchTime;
      if (e < this.opts.doubleTouchTimeout && e > 0) {
        this.uiData.doubleTouch = true, this.setDragStart(t.targetTouches[0].clientX - t.target.getBoundingClientRect().left, t.targetTouches[0].clientY - t.target.getBoundingClientRect().top), this.resetBriCon(t), this.uiData.lastTouchTime = this.uiData.currentTouchTime;
        return;
      } else this.uiData.doubleTouch = false, this.setDragStart(0, 0), this.setDragEnd(0, 0), this.uiData.lastTouchTime = this.uiData.currentTouchTime;
      this.uiData.touchdown && t.touches.length < 2 ? this.uiData.multiTouchGesture = false : this.uiData.multiTouchGesture = true, setTimeout(this.checkMultitouch.bind(this), 1, t);
    }
    touchEndListener(t) {
      if (t.preventDefault(), this.uiData.touchdown = false, this.uiData.lastTwoTouchDistance = 0, this.uiData.multiTouchGesture = false, this.uiData.touchTimer && (clearTimeout(this.uiData.touchTimer), this.uiData.touchTimer = null), this.uiData.isDragging) {
        this.uiData.isDragging = false, this.getCurrentDragMode() === 1 && (this.calculateNewRange(), this.refreshLayers(this.volumes[0], 0));
        const e = this.canvasPos2frac([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1]
        ]), n = this.canvasPos2frac([
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]);
        this.generateMouseUpCallback(e, n);
      }
      this.mouseUpListener();
    }
    windowingHandler(t, e, n = 0) {
      const r = this.uiData.windowX, i = this.uiData.windowY;
      let a = this.volumes[0].cal_min, s = this.volumes[0].cal_max;
      const o = this.volumes[0].global_min, l = this.volumes[0].global_max;
      e < i ? (a += 1, s += 1) : e > i && (a -= 1, s -= 1), t > r ? (a -= 1, s += 1) : t < r && (a += 1, s -= 1), s - a < 1 && (s = a + 1), a < o && (a = o), s > l && (s = l), a > s && (a = s - 1), this.volumes[n].cal_min = a, this.volumes[n].cal_max = s, this.refreshLayers(this.volumes[n], 0), this.uiData.windowX = t, this.uiData.windowY = e;
    }
    mouseLeaveListener() {
      this.clickToSegmentIsGrowing && (ee.debug("Mouse left canvas, stopping clickToSegment preview."), this.clickToSegmentIsGrowing = false, this.refreshDrawing(true, false)), this.opts.drawingEnabled && !isNaN(this.drawPenLocation[0]) && (ee.debug("Mouse left canvas during drawing, resetting pen state."), this.drawPenLocation = [
        NaN,
        NaN,
        NaN
      ], this.drawPenAxCorSag = -1, this.drawPenFillPts = []), this.opts.drawingEnabled && !isNaN(this.drawShapeStartLocation[0]) && (ee.debug("Mouse left canvas during shape drawing, resetting shape state."), this.drawShapeStartLocation = [
        NaN,
        NaN,
        NaN
      ], this.drawShapePreviewBitmap && (this.drawBitmap = this.drawShapePreviewBitmap, this.drawShapePreviewBitmap = null, this.refreshDrawing(true, false))), this.uiData.isDragging && (ee.debug("Mouse left canvas during drag, resetting drag state."), this.uiData.isDragging = false, this.uiData.mouseButtonLeftDown = false, this.uiData.mouseButtonCenterDown = false, this.uiData.mouseButtonRightDown = false, this.uiData.mousedown = false, this.drawScene());
    }
    mouseMoveListener(t) {
      if (this.uiData.mousedown) {
        const e = this.getNoPaddingNoBorderCanvasRelativeMousePosition(t, this.gl.canvas);
        if (!e) return;
        const n = e.x * this.uiData.dpr, r = e.y * this.uiData.dpr;
        if (this.tileIndex(n, r) !== this.uiData.clickedTile) return;
        const a = this.getCurrentDragMode();
        if (a === 8) {
          this.mouseMove(e.x, e.y), this.mouseClick(e.x, e.y), this.drawScene(), this.uiData.prevX = this.uiData.currX, this.uiData.prevY = this.uiData.currY;
          return;
        } else if (a === 9) {
          this.windowingHandler(e.x, e.y), this.drawScene(), this.uiData.prevX = this.uiData.currX, this.uiData.prevY = this.uiData.currY;
          return;
        } else this.setDragEnd(e.x, e.y);
        this.drawScene(), this.uiData.prevX = this.uiData.currX, this.uiData.prevY = this.uiData.currY;
      } else if (this.getCurrentDragMode() === 7 && this.uiData.angleState === "drawing_second_line") {
        const e = this.getNoPaddingNoBorderCanvasRelativeMousePosition(t, this.gl.canvas);
        if (!e) return;
        this.setDragEnd(e.x, e.y), this.drawScene();
      } else if (!this.uiData.mousedown && this.opts.clickToSegment) {
        const e = this.getNoPaddingNoBorderCanvasRelativeMousePosition(t, this.gl.canvas);
        if (!e) return;
        const n = e.x * this.uiData.dpr, r = e.y * this.uiData.dpr;
        this.mousePos = [
          n,
          r
        ];
        const i = this.tileIndex(n, r);
        i >= 0 && this.opts.drawingEnabled && this.screenSlices[i].axCorSag <= 2 && (this.clickToSegmentXY = [
          n,
          r
        ], this.clickToSegmentIsGrowing = true, this.doClickToSegment({
          x: n,
          y: r,
          tileIndex: i
        }));
      }
    }
    resetBriCon(t = null) {
      if (this.uiData.isDragging) return;
      let e = false;
      this.opts.sliceType === 4 && (e = true);
      let n = 0, r = 0;
      if (t !== null && ("targetTouches" in t ? (n = t.targetTouches[0].clientX - t.target.getBoundingClientRect().left, r = t.targetTouches[0].clientY - t.target.getBoundingClientRect().top) : (n = t.offsetX, r = t.offsetY), n *= this.uiData.dpr, r *= this.uiData.dpr, this.inRenderTile(n, r) >= 0 && (e = true)), e) {
        this.uiData.mouseDepthPicker = true, this.drawScene(), this.drawScene();
        return;
      }
      this.getCurrentDragMode() !== 4 && (this.volumes.length < 1 || this.uiData.doubleTouch || (this.volumes[0].cal_min = this.volumes[0].robust_min, this.volumes[0].cal_max = this.volumes[0].robust_max, this.onIntensityChange(this.volumes[0]), this.refreshLayers(this.volumes[0], 0), this.drawScene()));
    }
    setDragStart(t, e) {
      t *= this.uiData.dpr, e *= this.uiData.dpr, this.uiData.dragStart[0] = t, this.uiData.dragStart[1] = e;
    }
    setDragEnd(t, e) {
      t *= this.uiData.dpr, e *= this.uiData.dpr, this.uiData.dragEnd[0] = t, this.uiData.dragEnd[1] = e;
    }
    touchMoveListener(t) {
      if (this.uiData.touchdown && t.touches.length < 2) {
        const e = this.canvas.getBoundingClientRect();
        if (this.uiData.isDragging || (this.uiData.pan2DxyzmmAtMouseDown = Tl(this.scene.pan2Dxyzmm)), this.uiData.isDragging = true, this.uiData.doubleTouch && this.uiData.isDragging) {
          this.setDragEnd(t.targetTouches[0].clientX - t.target.getBoundingClientRect().left, t.targetTouches[0].clientY - t.target.getBoundingClientRect().top), this.drawScene();
          return;
        }
        const n = this.getTouchDragMode(false);
        n === 8 ? (this.mouseClick(t.touches[0].clientX - e.left, t.touches[0].clientY - e.top), this.mouseMove(t.touches[0].clientX - e.left, t.touches[0].clientY - e.top)) : n === 9 && (this.windowingHandler(t.touches[0].pageX, t.touches[0].pageY), this.drawScene());
      } else this.handlePinchZoom(t);
    }
    handlePinchZoom(t) {
      if (t.targetTouches.length === 2 && t.changedTouches.length === 2) {
        const e = Math.hypot(t.touches[0].pageX - t.touches[1].pageX, t.touches[0].pageY - t.touches[1].pageY), n = this.canvas.getBoundingClientRect();
        this.mousePos = [
          t.touches[0].clientX - n.left,
          t.touches[0].clientY - n.top
        ], e < this.uiData.lastTwoTouchDistance ? this.sliceScroll2D(-0.01, t.touches[0].clientX - n.left, t.touches[0].clientY - n.top) : this.sliceScroll2D(0.01, t.touches[0].clientX - n.left, t.touches[0].clientY - n.top), this.uiData.lastTwoTouchDistance = e;
      }
    }
    keyUpListener(t) {
      if (t.code === this.opts.clipPlaneHotKey) {
        const e = (/* @__PURE__ */ new Date()).getTime();
        if (e - this.lastCalled > this.opts.keyDebounceTime) {
          switch (this.currentClipPlaneIndex = (this.currentClipPlaneIndex + 1) % 7, this.currentClipPlaneIndex) {
            case 0:
              this.scene.clipPlaneDepthAziElev = [
                2,
                0,
                0
              ];
              break;
            case 1:
              this.scene.clipPlaneDepthAziElev = [
                0,
                270,
                0
              ];
              break;
            case 2:
              this.scene.clipPlaneDepthAziElev = [
                0,
                90,
                0
              ];
              break;
            case 3:
              this.scene.clipPlaneDepthAziElev = [
                0,
                0,
                0
              ];
              break;
            case 4:
              this.scene.clipPlaneDepthAziElev = [
                0,
                180,
                0
              ];
              break;
            case 5:
              this.scene.clipPlaneDepthAziElev = [
                0,
                0,
                -90
              ];
              break;
            case 6:
              this.scene.clipPlaneDepthAziElev = [
                0,
                0,
                90
              ];
              break;
          }
          this.setClipPlane(this.scene.clipPlaneDepthAziElev);
        }
        this.lastCalled = e;
      } else if (t.code === this.opts.viewModeHotKey) {
        const e = (/* @__PURE__ */ new Date()).getTime();
        e - this.lastCalled > this.opts.keyDebounceTime && (this.setSliceType((this.opts.sliceType + 1) % 5), this.lastCalled = e);
      }
    }
    keyDownListener(t) {
      t.code === "KeyH" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth - 1, this.scene.renderElevation) : t.code === "KeyL" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth + 1, this.scene.renderElevation) : t.code === "KeyJ" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth, this.scene.renderElevation + 1) : t.code === "KeyK" && this.opts.sliceType === 4 ? this.setRenderAzimuthElevation(this.scene.renderAzimuth, this.scene.renderElevation - 1) : t.code === "KeyH" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(-1, 0, 0) : t.code === "KeyL" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(1, 0, 0) : t.code === "KeyU" && this.opts.sliceType !== 4 && t.ctrlKey ? this.moveCrosshairInVox(0, 0, 1) : t.code === "KeyD" && this.opts.sliceType !== 4 && t.ctrlKey ? this.moveCrosshairInVox(0, 0, -1) : t.code === "KeyJ" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(0, -1, 0) : t.code === "KeyK" && this.opts.sliceType !== 4 ? this.moveCrosshairInVox(0, 1, 0) : t.code === "KeyM" && this.opts.sliceType !== 4 ? (this.opts.dragMode++, this.opts.dragMode >= 4 && (this.opts.dragMode = 0), ee.info("drag mode changed to ", ub[this.opts.dragMode])) : t.code === "ArrowLeft" ? this.setFrame4D(this.volumes[0].id, this.volumes[0].frame4D - 1) : t.code === "ArrowRight" ? this.setFrame4D(this.volumes[0].id, this.volumes[0].frame4D + 1) : t.code === "Slash" && t.shiftKey && alert(`NIIVUE VERSION: ${pC}`);
    }
    wheelListener(t) {
      if (this.thumbnailVisible || this.opts.sliceMosaicString.length > 0) return;
      t.preventDefault(), t.stopPropagation();
      const e = this.uiData.dragStart.reduce((l, c) => l + c, 0), n = this.uiData.dragEnd.reduce((l, c) => l + c, 0), r = e > 0 && n > 0;
      if (this.getCurrentDragMode() === 6 && r) {
        const l = t.deltaY > 0 ? 1 : -1;
        this.uiData.dragStart[0] < this.uiData.dragEnd[0] ? (this.uiData.dragStart[0] -= l, this.uiData.dragEnd[0] += l) : (this.uiData.dragStart[0] += l, this.uiData.dragEnd[0] -= l), this.uiData.dragStart[1] < this.uiData.dragEnd[1] ? (this.uiData.dragStart[1] -= l, this.uiData.dragEnd[1] += l) : (this.uiData.dragStart[1] += l, this.uiData.dragEnd[1] -= l), this.uiData.isDragging = true, this.drawScene(), this.uiData.isDragging = false;
        const c = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]);
        c >= 0 ? this.generateMouseUpCallback(this.screenXY2TextureFrac(this.uiData.dragStart[0], this.uiData.dragStart[1], c), this.screenXY2TextureFrac(this.uiData.dragEnd[0], this.uiData.dragEnd[1], c)) : ee.warn("Could not generate drag release callback for ROI selection: Invalid tile index.");
        return;
      }
      let i = t.deltaY < 0 ? -0.01 : 0.01;
      if (this.opts.invertScrollDirection && (i = -i), this.opts.clickToSegment) {
        i < 0 ? (this.opts.clickToSegmentPercent -= 0.01, this.opts.clickToSegmentPercent = Math.max(this.opts.clickToSegmentPercent, 0)) : (this.opts.clickToSegmentPercent += 0.01, this.opts.clickToSegmentPercent = Math.min(this.opts.clickToSegmentPercent, 1));
        const l = this.clickToSegmentXY[0], c = this.clickToSegmentXY[1], f = this.tileIndex(l, c);
        f >= 0 && this.screenSlices[f].axCorSag <= 2 && (ee.debug(`Adjusting clickToSegment threshold: ${this.opts.clickToSegmentPercent.toFixed(3)}`), this.clickToSegmentIsGrowing = true, this.doClickToSegment({
          x: l,
          y: c,
          tileIndex: f
        }));
        return;
      }
      const a = this.canvas.getBoundingClientRect(), s = t.clientX - a.left, o = t.clientY - a.top;
      if (this.getCurrentDragMode() === 3 && this.inRenderTile(this.uiData.dpr * s, this.uiData.dpr * o) === -1) {
        const l = i < 0 ? 1 : -1;
        let c = this.scene.pan2Dxyzmm[3] * (1 + 10 * (0.01 * l));
        c = Math.round(c * 10) / 10;
        const f = this.scene.pan2Dxyzmm[3] - c;
        this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = c), this.scene.pan2Dxyzmm[3] = c;
        const u = this.frac2mm(this.scene.crosshairPos);
        this.scene.pan2Dxyzmm[0] += f * u[0], this.scene.pan2Dxyzmm[1] += f * u[1], this.scene.pan2Dxyzmm[2] += f * u[2], this.drawScene(), this.canvas.focus(), this.sync();
        return;
      }
      this.sliceScroll2D(i, s, o);
    }
    registerInteractions() {
      if (!this.canvas) throw new Error("canvas undefined");
      this.canvas.addEventListener("mousedown", this.mouseDownListener.bind(this)), this.canvas.addEventListener("mouseup", this.mouseUpListener.bind(this)), this.canvas.addEventListener("mousemove", this.mouseMoveListener.bind(this)), this.canvas.addEventListener("mouseleave", this.mouseLeaveListener.bind(this)), this.canvas.addEventListener("touchstart", this.touchStartListener.bind(this)), this.canvas.addEventListener("touchend", this.touchEndListener.bind(this)), this.canvas.addEventListener("touchmove", this.touchMoveListener.bind(this)), this.canvas.addEventListener("wheel", this.wheelListener.bind(this)), this.canvas.addEventListener("contextmenu", this.mouseContextMenuListener.bind(this)), this.canvas.addEventListener("dblclick", this.resetBriCon.bind(this)), this.canvas.addEventListener("dragenter", this.dragEnterListener.bind(this), false), this.canvas.addEventListener("dragover", this.dragOverListener.bind(this), false), this.canvas.addEventListener("drop", (t) => {
        this.dropListener(t).catch(console.error);
      }, false), this.canvas.setAttribute("tabindex", "0"), this.canvas.addEventListener("keyup", this.keyUpListener.bind(this), false), this.canvas.addEventListener("keydown", this.keyDownListener.bind(this), false);
    }
    dragEnterListener(t) {
      t.stopPropagation(), t.preventDefault();
    }
    dragOverListener(t) {
      t.stopPropagation(), t.preventDefault();
    }
    getFileExt(t, e = true) {
      ee.debug("fullname: ", t);
      const n = /(?:\.([^.]+))?$/;
      let r = n.exec(t)[1];
      if (r = r.toUpperCase(), r === "GZ") r = n.exec(t.slice(0, -3))[1], r = r.toUpperCase();
      else if (r === "CBOR") {
        const i = r;
        r = n.exec(t.slice(0, -5))[1], r = r.toUpperCase(), r = `${r}.${i}`;
      }
      return e ? r : r.toLowerCase();
    }
    async addVolumeFromUrl(t) {
      const e = await Ci.loadFromUrl(t);
      return this.document.addImageOptions(e, t), e.onColormapChange = this.onColormapChange, this.mediaUrlMap.set(e, t.url), this.onVolumeAddedFromUrl && this.onVolumeAddedFromUrl(t, e), this.addVolume(e), e;
    }
    async addVolumesFromUrl(t) {
      const e = t.map(async (r) => {
        const i = this.getFileExt(r.name || r.url);
        if (i === "DCM") throw new Error("DICOM files must be loaded using useDicomLoader");
        if (this.loaders[i]) {
          let o = r.url;
          const l = this.loaders[i].toExt;
          let c = r.name || r.url;
          if (c = c.split("/").pop(), typeof r.url == "string") {
            const u = r.url;
            try {
              const h = await fetch(u);
              if (!h.ok) throw new Error(`Failed to load file: ${h.statusText}`);
              o = await h.arrayBuffer();
            } catch (h) {
              throw new Error(`Failed to load url ${u}: ${h}`);
            }
          }
          const f = await this.loaders[i].loader(o);
          r.url = f, r.name = `${c}.${l}`;
        }
        const a = {
          url: r.url,
          headers: r.headers,
          name: r.name,
          colormap: r.colormap ? r.colormap : r.colorMap,
          colormapNegative: r.colormapNegative ? r.colormapNegative : r.colorMapNegative,
          opacity: r.opacity,
          urlImgData: r.urlImgData,
          cal_min: r.cal_min,
          cal_max: r.cal_max,
          trustCalMinMax: this.opts.trustCalMinMax,
          isManifest: r.isManifest,
          frame4D: r.frame4D,
          limitFrames4D: r.limitFrames4D || this.opts.limitFrames4D,
          colorbarVisible: r.colorbarVisible
        }, s = await Ci.loadFromUrl(a);
        return this.document.addImageOptions(s, a), s.onColormapChange = this.onColormapChange, this.mediaUrlMap.set(s, a.url), this.onVolumeAddedFromUrl && this.onVolumeAddedFromUrl(a, s), s;
      }), n = await Promise.all(e);
      for (let r = 0; r < n.length; r++) this.addVolume(n[r]);
      return n;
    }
    getMediaByUrl(t) {
      return [
        ...this.mediaUrlMap.entries()
      ].filter((e) => e[1] === t).map((e) => e[0]).pop();
    }
    removeVolumeByUrl(t) {
      const e = this.getMediaByUrl(t);
      if (e) this.removeVolume(e);
      else throw new Error("No volume with URL present");
    }
    async traverseFileTree(t, e = "", n) {
      return new Promise((r) => {
        if (t.isFile) t.file((i) => {
          i.fullPath = e + i.name, i._webkitRelativePath = e + i.name, n.push(i), r(n);
        });
        else if (t.isDirectory) {
          const i = t.createReader(), a = () => {
            i.readEntries((s) => {
              if (s.length > 0) {
                const o = [];
                for (const l of s) o.push(this.traverseFileTree(l, e + t.name + "/", n));
                Promise.all(o).then(a).catch((l) => {
                  throw l;
                });
              } else r(n);
            });
          };
          a();
        }
      });
    }
    readDirectory(t) {
      const e = t.createReader();
      let n = [];
      const r = async (a) => {
        const s = [], o = async (l) => new Promise((c, f) => l.file(c, f));
        for (let l = 0; l < a.length; l++) s.push(await o(a[l]));
        return s;
      }, i = () => {
        e.readEntries((a) => {
          a.length ? (n = n.concat(a), i()) : r(n).then(async () => {
          }).catch((s) => {
            throw s;
          });
        });
      };
      return i(), n;
    }
    isMeshExt(t) {
      const e = this.getFileExt(t);
      return ee.debug("dropped ext"), ee.debug(e), hc.includes(e);
    }
    async loadFromArrayBuffer(t, e) {
      const n = this.getFileExt(e);
      if (hc.includes(n)) {
        await this.addMeshFromUrl({
          url: e,
          buffer: t
        });
        return;
      }
      const r = Cg(e);
      r.buffer = t, r.name = e, await this.addVolumeFromUrl(r);
    }
    async loadFromFile(t) {
      const e = this.getFileExt(t.name);
      if (hc.includes(e)) {
        await ou.loadFromFile({
          file: t,
          gl: this.gl,
          name: t.name
        }).then((n) => {
          this.addMesh(n);
        });
        return;
      }
      await Ci.loadFromFile({
        file: t,
        name: t.name
      }).then((n) => {
        this.addVolume(n);
      });
    }
    useLoader(t, e, n) {
      this.loaders = {
        ...this.loaders,
        [e.toUpperCase()]: {
          loader: t,
          toExt: n
        }
      };
    }
    useDicomLoader(t) {
      this.dicomLoader = t;
    }
    getDicomLoader() {
      return this.dicomLoader;
    }
    async dropListener(t) {
      if (t.stopPropagation(), t.preventDefault(), !this.opts.dragAndDropEnabled) return;
      const e = [], n = t.dataTransfer;
      if (!n) return;
      const r = n.getData("text/uri-list");
      if (r) {
        const i = Cg(r), a = this.getFileExt(r);
        ee.debug("dropped ext"), ee.debug(a), hc.includes(a) ? this.addMeshFromUrl({
          url: r
        }).catch((s) => {
          throw s;
        }) : a === "NVD" ? this.loadDocumentFromUrl(r).catch((s) => {
          throw s;
        }) : this.addVolumeFromUrl(i).catch((s) => {
          throw s;
        });
      } else {
        const i = n.items;
        if (i.length > 0) {
          !t.shiftKey && !t.altKey && (this.volumes = [], this.overlays = [], this.meshes = []), this.closeDrawing(), this.closePAQD();
          for (const a of Array.from(i)) {
            const s = a.webkitGetAsEntry();
            if (ee.debug(s), !s) throw new Error("could not get entry from file");
            if (s.isFile) {
              const o = this.getFileExt(s.name);
              let l;
              if (s.name.lastIndexOf("HEAD") !== -1) for (const c of Array.from(i)) {
                const f = c.webkitGetAsEntry();
                if (!f) throw new Error("could not get paired entry");
                const u = s.name.substring(0, s.name.lastIndexOf("HEAD")), h = f.name.substring(0, f.name.lastIndexOf("BRIK"));
                u === h && (l = f);
              }
              if (s.name.lastIndexOf("BRIK") !== -1) continue;
              if (this.loaders[o]) {
                const c = await qz(s);
                await this.loadImages([
                  {
                    url: c,
                    name: `${s.name}`
                  }
                ]);
                continue;
              }
              if (hc.includes(o)) {
                s.file((c) => {
                  (async () => {
                    try {
                      const f = await ou.loadFromFile({
                        file: c,
                        gl: this.gl,
                        name: c.name
                      });
                      this.addMesh(f);
                    } catch (f) {
                      console.error("Error loading mesh:", f);
                    }
                  })().catch((f) => console.error(f));
                });
                continue;
              } else if (o === "NVD") {
                s.file((c) => {
                  (async () => {
                    try {
                      const f = await t4.loadFromFile(c);
                      await this.loadDocument(f), ee.debug("loaded document");
                    } catch (f) {
                      console.error(f);
                    }
                  })().catch((f) => console.error(f));
                });
                break;
              }
              s.file((c) => {
                (async () => {
                  try {
                    if (l) l.file((f) => {
                      (async () => {
                        try {
                          const u = await Ci.loadFromFile({
                            file: c,
                            urlImgData: f,
                            limitFrames4D: this.opts.limitFrames4D
                          });
                          this.addVolume(u);
                        } catch (u) {
                          console.error(u);
                        }
                      })().catch(console.error);
                    });
                    else {
                      const f = await Ci.loadFromFile({
                        file: c,
                        urlImgData: l,
                        limitFrames4D: this.opts.limitFrames4D
                      });
                      t.altKey ? (ee.debug("alt key detected: assuming this is a drawing overlay"), this.drawClearAllUndoBitmaps(), this.loadDrawing(f)) : this.addVolume(f);
                    }
                  } catch (f) {
                    console.error(f);
                  }
                })().catch(console.error);
              });
            } else s.isDirectory && this.traverseFileTree(s, "", e).then((o) => {
              const l = this.getDicomLoader().loader;
              if (!l) throw new Error("No loader for DICOM files");
              l(o).then(async (c) => {
                const f = c.map((u) => Ci.loadFromUrl({
                  url: u.data,
                  name: u.name,
                  limitFrames4D: this.opts.limitFrames4D
                }));
                Promise.all(f).then(async (u) => {
                  await this.onDicomLoaderFinishedWithImages(u);
                }).catch((u) => {
                  throw u;
                });
              }).catch((c) => {
                console.error("Error loading DICOM files:", c);
              });
            }).catch((o) => {
              throw o;
            });
          }
        }
      }
      this.drawScene();
    }
    setMultiplanarPadPixels(t) {
      this.opts.multiplanarPadPixels = t, this.drawScene();
    }
    setMultiplanarLayout(t) {
      typeof t == "string" && (t = parseInt(t)), this.opts.multiplanarLayout = t, this.drawScene();
    }
    setCornerOrientationText(t) {
      this.opts.isCornerOrientationText = t, this.updateGLVolume();
    }
    setIsOrientationTextVisible(t) {
      this.opts.isOrientationTextVisible = t, this.drawScene();
    }
    setShowAllOrientationMarkers(t) {
      this.opts.showAllOrientationMarkers = t, this.drawScene();
    }
    setHeroImage(t) {
      this.opts.heroImageFraction = t, this.drawScene();
    }
    setCustomLayout(t) {
      for (let e = 0; e < t.length; e++) {
        const [n, r, i, a] = t[e].position, s = n + i, o = r + a;
        for (let l = e + 1; l < t.length; l++) {
          const [c, f, u, h] = t[l].position, g = c + u, v = f + h, m = n < g && s > c, y = r < v && o > f;
          if (m && y) throw new Error(`Custom layout is invalid. Tile ${e} overlaps with tile ${l}.`);
        }
      }
      this.customLayout = t, this.drawScene();
    }
    clearCustomLayout() {
      this.customLayout = null, this.drawScene();
    }
    getCustomLayout() {
      return this.customLayout;
    }
    setRadiologicalConvention(t) {
      this.opts.isRadiologicalConvention = t, this.updateGLVolume();
    }
    setDefaults(t = {}, e = false) {
      this.document.opts = {
        ...ns
      }, this.scene.sceneData = {
        ...k1
      };
      for (const n in t) typeof t[n] == "function" ? this[n] = t[n] : this.opts[n] = ns[n] === void 0 ? ns[n] : t[n];
      if (this.scene.pan2Dxyzmm = [
        0,
        0,
        0,
        1
      ], e && this.volumes && this.volumes.length > 0) for (let n = 0; n < this.volumes.length; n++) this.volumes[n].cal_min = this.volumes[n].robust_min, this.volumes[n].cal_max = this.volumes[n].robust_max;
      this.updateGLVolume();
    }
    setMeshThicknessOn2D(t) {
      this.opts.meshThicknessOn2D = t, this.updateGLVolume();
    }
    setSliceMosaicString(t) {
      this.sliceMosaicString = t, this.updateGLVolume();
    }
    setSliceMM(t) {
      this.opts.isSliceMM = t, this.updateGLVolume();
    }
    setAdditiveBlend(t) {
      this.opts.isAdditiveBlend = t, this.updateGLVolume();
    }
    getRadiologicalConvention() {
      return this.opts.isRadiologicalConvention;
    }
    setHighResolutionCapable(t) {
      typeof t == "boolean" && (t = t ? 0 : -1), this.opts.forceDevicePixelRatio = t, this.resizeListener(), this.drawScene();
    }
    watchOptsChanges(t) {
      this.onOptsChange = t;
    }
    unwatchOptsChanges() {
      this.onOptsChange = () => {
      };
    }
    addVolume(t) {
      this.volumes.push(t);
      const e = this.volumes.length === 1 ? 0 : this.volumes.length - 1;
      this.setVolume(t, e), this.onImageLoaded(t), ee.debug("loaded volume", t.name), ee.debug(t);
    }
    addMesh(t) {
      this.meshes.push(t);
      const e = this.meshes.length === 1 ? 0 : this.meshes.length - 1;
      this.setMesh(t, e), this.onMeshLoaded(t);
    }
    getVolumeIndexByID(t) {
      const e = this.volumes.length;
      for (let n = 0; n < e; n++) if (this.volumes[n].id === t) return n;
      return -1;
    }
    drawAddUndoBitmap(t = true) {
      if (!this.drawBitmap || this.drawBitmap.length < 1) {
        ee.debug("drawAddUndoBitmap error: No drawing open");
        return;
      }
      if (!t && this.drawUndoBitmaps.length > 0) {
        const e = this.drawBitmap.length, n = Pv(this.drawUndoBitmaps[this.currentDrawUndoBitmap], e);
        for (let r = 0; r < e; r++) n[r] > 0 && (this.drawBitmap[r] = n[r]);
        this.refreshDrawing(false);
      }
      this.currentDrawUndoBitmap++, this.currentDrawUndoBitmap >= this.opts.maxDrawUndoBitmaps && (this.currentDrawUndoBitmap = 0), this.drawUndoBitmaps[this.currentDrawUndoBitmap] = zG(this.drawBitmap);
    }
    drawClearAllUndoBitmaps() {
      if (this.currentDrawUndoBitmap = this.opts.maxDrawUndoBitmaps, !(!this.drawUndoBitmaps || this.drawUndoBitmaps.length < 1)) for (let t = this.drawUndoBitmaps.length - 1; t >= 0; t--) this.drawUndoBitmaps[t] = new Uint8Array();
    }
    drawUndo() {
      const { drawBitmap: t, currentDrawUndoBitmap: e } = WG({
        drawUndoBitmaps: this.drawUndoBitmaps,
        currentDrawUndoBitmap: this.currentDrawUndoBitmap,
        drawBitmap: this.drawBitmap
      });
      this.drawBitmap = t, this.currentDrawUndoBitmap = e, this.refreshDrawing(true);
    }
    loadDrawing(t) {
      if (this.drawBitmap && ee.debug("Overwriting open drawing!"), !this.back) throw new Error("back undefined");
      this.drawClearAllUndoBitmaps();
      const e = t.hdr.dims;
      if (e[1] !== this.back.hdr.dims[1] || e[2] !== this.back.hdr.dims[2] || e[3] !== this.back.hdr.dims[3]) return ee.debug("drawing dimensions do not match background image"), false;
      t.img.constructor !== Uint8Array && ee.debug("Drawings should be UINT8");
      const n = t.permRAS, r = e[1] * e[2] * e[3];
      this.drawBitmap = new Uint8Array(r), this.opts.is2DSliceShader ? this.drawTexture = this.r8Tex2D(this.drawTexture, sl, this.back.dims, true) : this.drawTexture = this.r8Tex(this.drawTexture, sl, this.back.dims, true);
      const i = [
        0,
        0,
        0
      ];
      for (let v = 0; v < 3; v++) for (let m = 0; m < 3; m++) Math.abs(n[v]) - 1 === m && (i[m] = v * Math.sign(n[v]));
      let a = 1;
      const s = [
        1,
        1,
        1
      ], o = [
        false,
        false,
        false
      ];
      for (let v = 0; v < i.length; v++) for (let m = 0; m < i.length; m++) Math.abs(i[m]) === v && (s[m] = a, (i[m] < 0 || Object.is(i[m], -0)) && (o[m] = true), a *= e[m + 1]);
      let l = ft.range(0, e[1] - 1, 1);
      o[0] && (l = ft.range(e[1] - 1, 0, -1));
      for (let v = 0; v < e[1]; v++) l[v] *= s[0];
      let c = ft.range(0, e[2] - 1, 1);
      o[1] && (c = ft.range(e[2] - 1, 0, -1));
      for (let v = 0; v < e[2]; v++) c[v] *= s[1];
      let f = ft.range(0, e[3] - 1, 1);
      o[2] && (f = ft.range(e[3] - 1, 0, -1));
      for (let v = 0; v < e[3]; v++) f[v] *= s[2];
      const u = t.img, h = this.drawBitmap;
      let g = 0;
      for (let v = 0; v < e[3]; v++) for (let m = 0; m < e[2]; m++) for (let y = 0; y < e[1]; y++) h[l[y] + c[m] + f[v]] = u[g], g++;
      return this.drawAddUndoBitmap(), this.refreshDrawing(false), this.drawScene(), true;
    }
    binarize(t) {
      const e = t.hdr.dims, n = e[1] * e[2] * e[3], r = new Uint8Array(n);
      for (let i = 0; i < n; i++) t.img[i] !== 0 && (r[i] = 1);
      t.img = r, t.hdr.datatypeCode = 2, t.hdr.cal_min = 0, t.hdr.cal_max = 1;
    }
    async loadDrawingFromUrl(t, e = false) {
      this.drawBitmap && ee.debug("Overwriting open drawing!"), this.drawClearAllUndoBitmaps();
      let n = false;
      try {
        const r = await Ci.loadFromUrl(Cg(t));
        e && await this.binarize(r), n = this.loadDrawing(r);
      } catch {
        ee.error("loadDrawingFromUrl() failed to load " + t), this.drawClearAllUndoBitmaps();
      }
      return n;
    }
    findOtsu(t = 2) {
      if (this.volumes.length < 1) return [];
      const e = this.volumes[0].img, n = e.length;
      if (n < 1) return [];
      const r = 256, i = r - 1, a = new Array(r).fill(0), s = this.volumes[0].cal_min, o = this.volumes[0].cal_max;
      if (o <= s) return [];
      const l = (o - s) / r;
      function c(w) {
        return w * l + s;
      }
      const f = (r - 1) / Math.abs(o - s), u = this.volumes[0].hdr.scl_inter, h = this.volumes[0].hdr.scl_slope;
      for (let w = 0; w < n; w++) {
        let C = e[w] * h + u;
        C = Math.min(Math.max(C, s), o), C = Math.round((C - s) * f), a[C]++;
      }
      const g = Array(r).fill(0).map(() => Array(r).fill(0)), v = Array(r).fill(0).map(() => Array(r).fill(0));
      for (let w = 1; w < r; ++w) g[w][w] = a[w], v[w][w] = w * a[w];
      for (let w = 1; w < r - 1; ++w) g[1][w + 1] = g[1][w] + a[w + 1], v[1][w + 1] = v[1][w] + (w + 1) * a[w + 1];
      for (let w = 2; w < r; w++) for (let C = w + 1; C < r; C++) g[w][C] = g[1][C] - g[1][w - 1], v[w][C] = v[1][C] - v[1][w - 1];
      for (let w = 1; w < r; ++w) for (let C = w + 1; C < r; C++) g[w][C] !== 0 && (g[w][C] = v[w][C] * v[w][C] / g[w][C]);
      let m = 0;
      const y = [
        1 / 0,
        1 / 0,
        1 / 0
      ];
      if (t > 3) for (let w = 0; w < r - 3; w++) for (let C = w + 1; C < r - 2; C++) for (let T = C + 1; T < r - 1; T++) {
        const S = g[0][w] + g[w + 1][C] + g[C + 1][T] + g[T + 1][i];
        S > m && (y[0] = w, y[1] = C, y[2] = T, m = S);
      }
      else if (t === 3) for (let w = 0; w < r - 2; w++) for (let C = w + 1; C < r - 1; C++) {
        const T = g[0][w] + g[w + 1][C] + g[C + 1][i];
        T > m && (y[0] = w, y[1] = C, m = T);
      }
      else for (let w = 0; w < r - 1; w++) {
        const C = g[0][w] + g[w + 1][i];
        C > m && (y[0] = w, m = C);
      }
      return [
        c(y[0]),
        c(y[1]),
        c(y[2])
      ];
    }
    drawOtsu(t = 2) {
      if (this.volumes.length === 0) return;
      const e = this.volumes[0].img.length, n = this.findOtsu(t);
      if (n.length < 3) return;
      this.drawBitmap || this.createEmptyDrawing();
      const r = this.drawBitmap, i = this.volumes[0].img;
      for (let a = 0; a < e; a++) {
        if (r[a] !== 0) continue;
        const s = i[a];
        s > n[0] && (r[a] = 1), s > n[1] && (r[a] = 2), s > n[2] && (r[a] = 3);
      }
      this.drawAddUndoBitmap(), this.refreshDrawing(true);
    }
    removeHaze(t = 5, e = 0) {
      const n = this.volumes[e].img, r = this.volumes[e].hdr, i = n.length;
      let a = 2;
      (t === 5 || t === 1) && (a = 4), (t === 4 || t === 2) && (a = 3);
      const s = this.findOtsu(a);
      if (s.length < 3) return;
      let o = s[0];
      t === 1 && (o = s[2]), t === 2 && (o = s[1]);
      const l = r.scl_inter, c = r.scl_slope, f = this.volumes[e].global_min;
      for (let u = 0; u < i; u++) n[u] * c + l < o && (n[u] = f);
      this.refreshLayers(this.volumes[e], 0), this.drawScene();
    }
    async saveImage(t = wC) {
      var _a3;
      const e = {
        ...wC,
        ...t
      }, { filename: n, isSaveDrawing: r, volumeByIndex: i } = e;
      if (ee.debug("saveImage", n, r, i), ((_a3 = this.back) == null ? void 0 : _a3.dims) === void 0) return ee.debug("No voxelwise image open"), false;
      if (r) {
        if (!this.drawBitmap) return ee.debug("No drawing open"), false;
        const s = this.volumes[0].permRAS;
        if (s[0] === 1 && s[1] === 2 && s[2] === 3) return ee.debug("saving drawing"), await this.volumes[0].saveToDisk(n, this.drawBitmap);
        {
          ee.debug("saving drawing");
          const o = this.volumes[0].hdr.dims, l = [
            0,
            0,
            0
          ];
          for (let T = 0; T < 3; T++) for (let S = 0; S < 3; S++) Math.abs(s[T]) - 1 === S && (l[S] = T * Math.sign(s[T]));
          let c = 1;
          const f = [
            1,
            1,
            1
          ], u = [
            false,
            false,
            false
          ];
          for (let T = 0; T < l.length; T++) for (let S = 0; S < l.length; S++) Math.abs(l[S]) === T && (f[S] = c, (l[S] < 0 || Object.is(l[S], -0)) && (u[S] = true), c *= o[S + 1]);
          let h = ft.range(0, o[1] - 1, 1);
          u[0] && (h = ft.range(o[1] - 1, 0, -1));
          for (let T = 0; T < o[1]; T++) h[T] *= f[0];
          let g = ft.range(0, o[2] - 1, 1);
          u[1] && (g = ft.range(o[2] - 1, 0, -1));
          for (let T = 0; T < o[2]; T++) g[T] *= f[1];
          let v = ft.range(0, o[3] - 1, 1);
          u[2] && (v = ft.range(o[3] - 1, 0, -1));
          for (let T = 0; T < o[3]; T++) v[T] *= f[2];
          const m = new Uint8Array(this.drawBitmap), y = new Uint8Array(o[1] * o[2] * o[3]);
          let w = 0;
          for (let T = 0; T < o[3]; T++) for (let S = 0; S < o[2]; S++) for (let E = 0; E < o[1]; E++) y[w] = m[h[E] + g[S] + v[T]], w++;
          return ee.debug("saving drawing"), this.volumes[0].saveToDisk(n, y);
        }
      }
      return ee.debug("saving image"), this.volumes[i].saveToDisk(n);
    }
    getMeshIndexByID(t) {
      if (typeof t == "number") return t >= this.meshes.length ? -1 : t;
      const e = this.meshes.length;
      for (let n = 0; n < e; n++) if (this.meshes[n].id === t) return n;
      return -1;
    }
    setMeshProperty(t, e, n) {
      const r = this.getMeshIndexByID(t);
      if (r < 0) {
        ee.warn("setMeshProperty() id not loaded", t);
        return;
      }
      this.meshes[r].setProperty(e, n, this.gl), this.updateGLVolume(), this.onMeshPropertyChanged(r, e, n);
    }
    indexNearestXYZmm(t, e, n, r) {
      const i = this.getMeshIndexByID(t);
      return i < 0 ? (ee.warn("indexNearestXYZmm() id not loaded", t), [
        NaN,
        NaN
      ]) : this.meshes[i].indexNearestXYZmm(e, n, r);
    }
    decimateHierarchicalMesh(t, e = 3) {
      const n = this.getMeshIndexByID(t);
      if (n < 0) {
        ee.warn("reverseFaces() id not loaded", t);
        return;
      }
      const r = this.meshes[n].decimateHierarchicalMesh(this.gl, e);
      return this.updateGLVolume(), r;
    }
    reverseFaces(t) {
      const e = this.getMeshIndexByID(t);
      if (e < 0) {
        ee.warn("reverseFaces() id not loaded", t);
        return;
      }
      this.meshes[e].reverseFaces(this.gl), this.updateGLVolume();
    }
    async setMeshLayerProperty(t, e, n, r) {
      const i = this.getMeshIndexByID(t);
      if (i < 0) {
        ee.warn("setMeshLayerProperty() id not loaded", t);
        return;
      }
      await this.meshes[i].setLayerProperty(e, n, r, this.gl), this.updateGLVolume();
    }
    setPan2Dxyzmm(t) {
      this.scene.pan2Dxyzmm = t, this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = t[3]), this.drawScene();
    }
    setRenderAzimuthElevation(t, e) {
      this.scene.renderAzimuth = t, this.scene.renderElevation = e, this.onAzimuthElevationChange(t, e), this.drawScene();
    }
    getOverlayIndexByID(t) {
      const e = this.overlays.length;
      for (let n = 0; n < e; n++) if (this.overlays[n].id === t) return n;
      return -1;
    }
    setVolume(t, e = 0) {
      const n = this.volumes.length;
      if (e > n) return;
      const r = this.getVolumeIndexByID(t.id);
      e === 0 ? (this.volumes.splice(r, 1), this.volumes.unshift(t), this.back = this.volumes[0], this.overlays = this.volumes.slice(1)) : e < 0 ? (this.volumes.splice(this.getVolumeIndexByID(t.id), 1), this.back = this.volumes[0], this.volumes.length > 1 ? this.overlays = this.volumes.slice(1) : this.overlays = []) : (this.volumes.splice(r, 1), this.volumes.splice(e, 0, t), this.overlays = this.volumes.slice(1), this.back = this.volumes[0]), this.updateGLVolume();
    }
    setMesh(t, e = 0) {
      this.meshes.forEach((i) => {
        ee.debug("MESH: ", i.name);
      });
      const n = this.meshes.length;
      if (e > n) return;
      const r = this.getMeshIndexByID(t.id);
      e === 0 ? (this.meshes.splice(r, 1), this.meshes.unshift(t)) : e < 0 ? this.meshes.splice(this.getMeshIndexByID(t.id), 1) : (this.meshes.splice(r, 1), this.meshes.splice(e, 0, t)), this.updateGLVolume(), this.meshes.forEach((i) => {
        ee.debug(i.name);
      });
    }
    removeVolume(t) {
      if (this.setVolume(t, -1), this.mediaUrlMap.has(t)) {
        const e = this.mediaUrlMap.get(t);
        this.onVolumeWithUrlRemoved(e), this.mediaUrlMap.delete(t);
      }
      this.drawScene();
    }
    removeVolumeByIndex(t) {
      if (t >= this.volumes.length) throw new Error("Index of volume out of bounds");
      this.removeVolume(this.volumes[t]);
    }
    removeMesh(t) {
      if (t.unloadMesh(this.gl), this.setMesh(t, -1), this.mediaUrlMap.has(t)) {
        const e = this.mediaUrlMap.get(t);
        this.onMeshWithUrlRemoved(e), this.mediaUrlMap.delete(t);
      }
    }
    removeMeshByUrl(t) {
      const e = this.getMediaByUrl(t);
      e && (this.removeMesh(e), this.mediaUrlMap.delete(e), this.onMeshWithUrlRemoved(t));
    }
    moveVolumeToBottom(t) {
      this.setVolume(t, 0);
    }
    moveVolumeUp(t) {
      const e = this.getVolumeIndexByID(t.id);
      this.setVolume(t, e + 1);
    }
    moveVolumeDown(t) {
      const e = this.getVolumeIndexByID(t.id);
      this.setVolume(t, e - 1);
    }
    moveVolumeToTop(t) {
      this.setVolume(t, this.volumes.length - 1);
    }
    mouseDown(t, e) {
      t *= this.uiData.dpr, e *= this.uiData.dpr, this.mousePos = [
        t,
        e
      ];
    }
    mouseMove(t, e) {
      t *= this.uiData.dpr, e *= this.uiData.dpr;
      const n = (t - this.mousePos[0]) / this.uiData.dpr, r = (e - this.mousePos[1]) / this.uiData.dpr;
      this.mousePos = [
        t,
        e
      ], !(this.inRenderTile(t, e) < 0) && (Math.abs(n) < 1 && Math.abs(r) < 1 || (this.scene.renderAzimuth += n, this.scene.renderElevation += r, this.drawScene()));
    }
    sph2cartDeg(t, e) {
      const n = -e * (Math.PI / 180), r = (t - 90) % 360 * (Math.PI / 180), i = [
        Math.cos(n) * Math.cos(r),
        Math.cos(n) * Math.sin(r),
        Math.sin(n)
      ], a = Math.sqrt(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]);
      return a <= 0 || (i[0] /= a, i[1] /= a, i[2] /= a), i;
    }
    setClipPlane(t) {
      const e = this.sph2cartDeg(t[1] + 180, t[2]);
      this.scene.clipPlane = [
        e[0],
        e[1],
        e[2],
        t[0]
      ], this.scene.clipPlaneDepthAziElev = t, this.onClipPlaneChange(this.scene.clipPlane), this.drawScene();
    }
    setCrosshairColor(t) {
      this.opts.crosshairColor = t, this.drawScene();
    }
    setCrosshairWidth(t) {
      this.opts.crosshairWidth = t, this.crosshairs3D && (this.crosshairs3D.mm[0] = NaN), this.drawScene();
    }
    setDrawColormap(t) {
      this.drawLut = Mn.makeDrawLut(t), this.updateGLVolume();
    }
    setDrawingEnabled(t) {
      this.opts.drawingEnabled = t, this.opts.drawingEnabled ? this.drawBitmap || this.createEmptyDrawing() : (this.clickToSegmentIsGrowing && (this.clickToSegmentIsGrowing = false, this.refreshDrawing(true, false)), this.drawPenLocation = [
        NaN,
        NaN,
        NaN
      ], this.drawPenAxCorSag = -1, this.drawPenFillPts = [], this.drawShapeStartLocation = [
        NaN,
        NaN,
        NaN
      ], this.drawShapePreviewBitmap && (this.drawBitmap = this.drawShapePreviewBitmap, this.drawShapePreviewBitmap = null)), this.drawScene();
    }
    setPenValue(t, e = false) {
      this.opts.penValue = t, this.opts.isFilledPen = e, this.drawScene();
    }
    setDrawOpacity(t) {
      this.drawOpacity = t, this.drawScene();
    }
    setSelectionBoxColor(t) {
      this.opts.selectionBoxColor = t;
    }
    sliceScroll2D(t, e, n, r = true) {
      if (this.opts.scrollRequiresFocus && this.canvas !== document.activeElement) {
        ee.warn("Canvas element does not have focus. Scroll events will not be processed.");
        return;
      }
      if (this.inGraphTile(e, n)) {
        let i = this.volumes[0].frame4D;
        t > 0 && i++, t < 0 && i--, this.setFrame4D(this.volumes[0].id, i);
        return;
      }
      if (t !== 0 && this.opts.dragMode === 3 && this.inRenderTile(this.uiData.dpr * e, this.uiData.dpr * n) === -1) {
        let i = this.scene.pan2Dxyzmm[3] * (1 + 10 * t);
        i = Math.round(i * 10) / 10;
        const a = this.scene.pan2Dxyzmm[3] - i;
        this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = i), this.scene.pan2Dxyzmm[3] = i;
        const s = this.frac2mm(this.scene.crosshairPos);
        this.scene.pan2Dxyzmm[0] += a * s[0], this.scene.pan2Dxyzmm[1] += a * s[1], this.scene.pan2Dxyzmm[2] += a * s[2], this.drawScene(), this.canvas.focus(), this.sync();
        return;
      }
      this.mouseClick(e, n, t, r);
    }
    setSliceType(t) {
      return this.opts.sliceType = t, this.drawScene(), this;
    }
    setOpacity(t, e) {
      this.volumes[t].opacity = e, this.updateGLVolume();
    }
    setScale(t) {
      this.scene.volScaleMultiplier = t, this.drawScene();
    }
    setClipPlaneColor(t) {
      this.opts.clipPlaneColor = t, this.renderShader.use(this.gl), this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor, this.opts.clipPlaneColor), this.drawScene();
    }
    setClipPlaneThick(t) {
      this.opts.clipThick = t, this.renderShader.use(this.gl), this.gl.uniform1f(this.renderShader.uniforms.clipThick, this.opts.clipThick), this.drawScene();
    }
    setClipVolume(t, e) {
      this.opts.clipVolumeLow = [
        Math.min(t[0], e[0]),
        Math.min(t[1], e[1]),
        Math.min(t[2], e[2])
      ], this.opts.clipVolumeHigh = [
        Math.max(t[0], e[0]),
        Math.max(t[1], e[1]),
        Math.max(t[2], e[2])
      ], this.renderShader.use(this.gl), this.gl.uniform3fv(this.renderShader.uniforms.clipLo, this.opts.clipVolumeLow), this.gl.uniform3fv(this.renderShader.uniforms.clipHi, this.opts.clipVolumeHigh), this.pickingImageShader.use(this.gl), this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo, this.opts.clipVolumeLow), this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi, this.opts.clipVolumeHigh), this.drawScene();
    }
    async setVolumeRenderIllumination(t = 0) {
      this.renderGradientValues = Number.isNaN(t), this.renderShader = this.renderVolumeShader, this.renderGradientValues ? this.renderShader = this.renderGradientValuesShader : (this.opts.gradientAmount = t, t > 0 || this.opts.gradientOpacity > 0 ? this.renderShader = this.renderGradientShader : t < 0 && (this.renderShader = this.renderSliceShader)), await this.refreshLayers(this.volumes[0], 0), this.initRenderShader(this.renderShader, t), this.renderShader.use(this.gl), this.setClipPlaneColor(this.opts.clipPlaneColor), Number.isNaN(t) ? this.gradientTextureAmount = 1 : this.gradientTextureAmount = t, !(this.volumes.length < 1) && this.drawScene();
    }
    async setGradientOpacity(t = 0, e = 0) {
      this.opts.gradientOpacity = t, this.opts.renderSilhouette = e, this.renderGradientValues ? this.renderShader = this.renderGradientValuesShader : this.gradientTextureAmount > 0 || t > 0 ? this.renderShader = this.renderGradientShader : this.gradientTextureAmount < 0 && (this.renderShader = this.renderSliceShader), this.initRenderShader(this.renderShader, this.gradientTextureAmount), this.renderShader.use(this.gl), this.gradientTextureAmount > 0 && this.refreshLayers(this.volumes[0], 0), this.drawScene();
    }
    overlayRGBA(t) {
      const e = t.hdr, n = e.dims[1] * e.dims[2] * e.dims[3], r = new Uint8ClampedArray(n * 4), i = 0.2 * Math.min(Math.min(e.dims[1], e.dims[2]), e.dims[3]), a = 0.5 * e.dims[1], s = 0.5 * e.dims[2], o = 0.5 * e.dims[3];
      let l = 0;
      for (let c = 0; c < e.dims[3]; c++) for (let f = 0; f < e.dims[2]; f++) for (let u = 0; u < e.dims[1]; u++) {
        const h = Math.abs(u - a), g = Math.abs(f - s), v = Math.abs(c - o), m = Math.sqrt(h * h + g * g + v * v);
        let y = 0;
        m < i && (y = 255), r[l++] = 0, r[l++] = y, r[l++] = 0, r[l++] = y * 0.5;
      }
      return r;
    }
    vox2mm(t, e) {
      return ft.vox2mm(t, e);
    }
    cloneVolume(t) {
      return this.volumes[t].clone();
    }
    async loadDocumentFromUrl(t) {
      const e = await t4.loadFromUrl(t);
      await this.loadDocument(e);
    }
    async loadDocument(t) {
      this.volumes = [], this.meshes = [], this.document = t, this.document.labels = this.document.labels ? this.document.labels : [];
      const e = {
        ...ns,
        ...t.opts
      };
      this.scene.pan2Dxyzmm = t.scene.pan2Dxyzmm ? t.scene.pan2Dxyzmm : [
        0,
        0,
        0,
        1
      ], this.document.opts = e, this.setClipPlane(this.scene.clipPlaneDepthAziElev), ee.debug("load document", t), this.mediaUrlMap.clear(), this.createEmptyDrawing();
      const n = t.encodedImageBlobs;
      for (let i = 0; i < t.imageOptionsArray.length; i++) {
        const a = t.imageOptionsArray[i], s = n[i];
        if (s) {
          "colorMap" in a && (a.colormap = a.colorMap);
          const o = await Ci.loadFromBase64({
            base64: s,
            ...a
          });
          if (o) {
            if (o.colormapLabel) {
              const l = Object.keys(o.colormapLabel.lut).length, c = new Uint8ClampedArray(l);
              for (const f in o.colormapLabel.lut) c[f] = o.colormapLabel.lut[f];
              o.colormapLabel.lut = c;
            }
            this.addVolume(o);
          }
        }
      }
      this.volumes.length > 0 && (this.back = this.volumes[0]);
      for (const i of t.meshDataObjects ?? []) {
        const a = {
          gl: this.gl,
          ...i
        };
        i.offsetPt0 && (a.rgba255[3] = 0, a.tris = new Uint32Array(i.offsetPt0)), ee.debug(a);
        const s = new ou(a.pts, a.tris, a.name, a.rgba255, a.opacity, a.visible, this.gl, a.connectome, a.dpg, a.dps, a.dpv);
        i.offsetPt0 && (s.fiberGroupColormap = i.fiberGroupColormap, s.fiberColor = i.fiberColor, s.fiberDither = i.fiberDither, s.fiberRadius = i.fiberRadius, s.colormap = i.colormap), s.meshShaderIndex = a.meshShaderIndex, s.layers = a.layers, s.updateMesh(this.gl), ee.debug(s), this.addMesh(s);
      }
      if (t.data.connectomes) for (const i of t.data.connectomes) {
        const a = JSON.parse(i), s = this.loadConnectomeAsMesh(a);
        s.updateMesh(this.gl), this.addMesh(s);
      }
      this.createEmptyDrawing();
      const r = t.encodedDrawingBlob;
      if (r) {
        const i = await ft.b64toUint8(r);
        if (i) {
          const a = this.back.dims;
          let s = a[1] * a[2] * a[3];
          if (i.length - 352 === s && (s += 352), i.length !== s) throw new Error(`drawBitmap size does not match the texture dimensions (${a[1]}\xD7${a[2]}\xD7${a[3]}) ${s} != ${a[1] * a[2] * a[3]}.`);
          this.drawBitmap = i, this.refreshDrawing();
        }
      }
      return await this.setGradientOpacity(this.opts.gradientOpacity), await this.setVolumeRenderIllumination(this.opts.gradientAmount), this.updateGLVolume(), this.drawScene(), this.onDocumentLoaded(t), this;
    }
    async generateLoadDocumentJavaScript(t, e) {
      const n = this.json(), r = await ft.compressToBase64String(JSON.stringify(n));
      return `
        ${e}

        async function saveNiivueAsHtml(pageName) {
          //get new docstring
          const docString = nv1.json();
          const html =
          document.getElementsByTagName("html")[0]
              .innerHTML.replace(base64, await NVUtilities.compressToBase64String(JSON.stringify(docString)));
          NVUtilities.download(html, pageName, "application/html");
        }

        var nv1 = new Niivue();
        await nv1.attachTo("${t}");
        var base64 = "${r}";
        NVUtilities.decompressBase64String(base64).then((jsonText) => {
          var json = JSON.parse(jsonText); // string -> JSON
          var doc = NVDocument.loadFromJSON(json);
          nv1.loadDocument(doc);
          nv1.updateGLVolume();
        });

      `;
    }
    async generateHTML(t = "gl1", e) {
      return `<!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8" />
            <meta http-equiv="X-UA-Compatible" content="IE=edge" />
            <meta name="viewport" content="width=device-width,initial-scale=1.0" />
            <title>Save as HTML</title>
            <style>
            html {
              height: auto;
              min-height: 100%;
              margin: 0;
            }
            body {
              display: flex;
              flex-direction: column;
              margin: 0;
              min-height: 100%;
              width: 100%;
              position: absolute;
              font-family: system-ui, Arial, Helvetica, sans-serif;
              background: #ffffff;
              color: black;
              user-select: none; /* Standard syntax */
            }
            header {
              margin: 10px;
            }
            main {
              flex: 1;
              background: #000000;
              position: relative;
            }
            footer {
              margin: 10px;
            }
            canvas {
              position: absolute;
              cursor: crosshair;
            }
            canvas:focus {
              outline: 0px;
            }
            div {
              display: table-row;
              background-color: blue;
            }
            </style>
          </head>
          <body>
            <noscript>niivue requires JavaScript.</noscript>
            <header>
            Save the current scene as HTML
            <button id="save">Save as HTML</button>
            </header>
            <main>
              <canvas id="gl1"></canvas>
            </main>
            <script type="module" async>
              ${await this.generateLoadDocumentJavaScript(t, e)}
              function saveAsHtml() {
                saveNiivueAsHtml("page.html");
              }
              // assign our event handler
              var button = document.getElementById("save");
              button.onclick = saveAsHtml;
            <\/script>
          </body>
        </html>`;
    }
    async saveHTML(t = "untitled.html", e = "gl1", n) {
      const r = await this.generateHTML(e, n);
      return ft.download(r, t, "application/html");
    }
    json() {
      return this.document.opts = this.opts, this.document.scene = this.scene, this.document.volumes = this.volumes, this.document.meshes = this.meshes, this.drawScene(), this.document.previewImageDataURL = this.canvas.toDataURL(), this.document.json();
    }
    async saveDocument(t = "untitled.nvd", e = true, n = {}) {
      const { embedImages: r = true, embedPreview: i = true } = n;
      this.document.title = t, this.document.volumes = this.volumes, this.document.meshes = this.meshes, i ? (this.drawScene(), this.document.previewImageDataURL = this.canvas.toDataURL()) : this.document.previewImageDataURL = "", await this.document.download(t, e, {
        embedImages: r
      });
    }
    async loadImages(t) {
      const e = [], n = [];
      for (const r of t) if ("url" in r) {
        const i = this.getFileExt(r.name ? r.name : r.url);
        if (this.loaders[i]) {
          const a = this.loaders[i].toExt.toUpperCase();
          hc.includes(a) ? n.push(r) : e.push(r);
          continue;
        }
        hc.includes(i.toUpperCase()) ? n.push(r) : e.push(r);
      }
      return e.length > 0 && await this.loadVolumes(e), n.length > 0 && await this.loadMeshes(n), this;
    }
    async loadDicoms(t) {
      if (!this.getDicomLoader()) throw new Error("No dicom loader set. Please set a dicom loader before loading dicoms");
      this.drawScene(), this.volumes = [], this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      const e = t.map(async (r) => {
        let i = null;
        if (r.isManifest) i = await Ci.fetchDicomData(r.url);
        else {
          const f = await fetch(r.url);
          if (!f.ok) throw new Error(`Failed to load file: ${f.statusText}`);
          const u = await f.arrayBuffer();
          i = [
            {
              name: r.url.split("/").pop(),
              data: u
            }
          ];
        }
        const a = this.getDicomLoader().loader, s = await a(i), o = s[0].name, l = s[0].data;
        return await Ci.loadFromUrl({
          url: l,
          name: o
        });
      }), n = await Promise.all(e);
      return n.length === 1 ? this.addVolume(n[0]) : this.onDicomLoaderFinishedWithImages(n), this;
    }
    async loadVolumes(t) {
      return this.drawScene(), this.thumbnailVisible ? (this.deferredVolumes = t, this) : (this.volumes = [], this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.closePAQD(), await this.addVolumesFromUrl(t), this);
    }
    async addMeshFromUrl(t) {
      const e = this.getFileExt(t.url);
      if (e === "JCON" || e === "JSON") {
        const i = await (await fetch(t.url, {})).json(), a = this.loadConnectomeAsMesh(i);
        return this.mediaUrlMap.set(a, t.url), this.onMeshAddedFromUrl(t, a), this.addMesh(a), a;
      }
      const n = await ou.loadFromUrl({
        ...t,
        gl: this.gl
      });
      return this.mediaUrlMap.set(n, t.url), this.onMeshAddedFromUrl(t, n), this.addMesh(n), n;
    }
    async addMeshesFromUrl(t) {
      const e = t.map(async (r) => {
        const i = this.getFileExt(r.name || r.url);
        if (this.loaders[i]) {
          let s = r.url;
          const o = this.loaders[i].toExt;
          let l = r.name || r.url;
          if (l = l.split("/").pop(), typeof r.url == "string") {
            const g = r.url;
            try {
              const v = await fetch(g);
              if (!v.ok) throw new Error(`Failed to load file: ${v.statusText}`);
              s = await v.arrayBuffer();
            } catch (v) {
              throw new Error(`Failed to load url ${g}: ${v}`);
            }
          }
          const { positions: c, indices: f, colors: u = null } = await this.loaders[i].loader(s);
          r.name = `${l}.${o}`;
          const h = await Ec.createMZ3Async(c, f, false, u);
          r.buffer = h;
        }
        if (i === "JCON" || i === "JSON") {
          const o = await (await fetch(r.url, {})).json(), l = this.loadConnectomeAsMesh(o);
          return this.mediaUrlMap.set(l, r.url), this.onMeshAddedFromUrl(r, l), l;
        }
        const a = await ou.loadFromUrl({
          ...r,
          gl: this.gl
        });
        return this.mediaUrlMap.set(a, r.url), this.onMeshAddedFromUrl(r, a), a;
      }), n = await Promise.all(e);
      for (let r = 0; r < n.length; r++) this.addMesh(n[r]);
      return n;
    }
    async loadMeshes(t) {
      return this.drawScene(), this.thumbnailVisible ? (this.deferredMeshes = t, this) : (this.initialized, this.meshes = [], this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), await this.addMeshesFromUrl(t), this.updateGLVolume(), this.drawScene(), this);
    }
    async loadConnectomeFromUrl(t, e = {}) {
      const r = await (await fetch(t, {
        headers: e
      })).json();
      return this.loadConnectome(r);
    }
    async loadFreeSurferConnectomeFromUrl(t, e = {}) {
      const r = await (await fetch(t, {
        headers: e
      })).json();
      return this.loadFreeSurferConnectome(r);
    }
    async loadFreeSurferConnectome(t) {
      const e = C2.convertFreeSurferConnectome(t);
      return this.loadConnectome(e);
    }
    handleNodeAdded(t) {
      const e = t.detail.node, n = [
        1,
        1,
        1,
        1
      ];
      this.addLabel(e.name, {
        textColor: n,
        bulletScale: 1,
        bulletColor: n,
        lineWidth: 0,
        lineColor: n,
        lineTerminator: "none",
        textScale: 1
      }, [
        e.x,
        e.y,
        e.z
      ]), this.drawScene();
    }
    loadConnectomeAsMesh(t) {
      let e = t;
      if ("data_type" in t && t.data_type === "fs_pointset") e = C2.convertFreeSurferConnectome(t), ee.warn("converted FreeSurfer connectome", e);
      else if ("nodes" in t) {
        const n = t.nodes;
        "names" in n && "X" in n && "Y" in n && "Z" in n && "Color" in n && "Size" in n && (e = C2.convertLegacyConnectome(t));
      } else throw new Error("not a known connectome format");
      return new C2(this.gl, e);
    }
    loadConnectome(t) {
      this.drawScene(), this.meshes = [], this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      const e = this.loadConnectomeAsMesh(t);
      return this.addMesh(e), this.drawScene(), this;
    }
    createEmptyDrawing() {
      if (this.back === null || !this.back.dims || Math.min(Math.min(this.back.dims[1], this.back.dims[2]), this.back.dims[3]) < 1) return;
      const e = this.back.dims[1] * this.back.dims[2] * this.back.dims[3];
      this.drawBitmap = new Uint8Array(e), this.clickToSegmentGrowingBitmap = new Uint8Array(e), this.drawClearAllUndoBitmaps(), this.drawAddUndoBitmap(), this.opts.is2DSliceShader ? this.drawTexture = this.r8Tex2D(this.drawTexture, sl, this.back.dims) : this.drawTexture = this.r8Tex(this.drawTexture, sl, this.back.dims, true), this.refreshDrawing(false);
    }
    r16Tex(t, e, n, r) {
      t && this.gl.deleteTexture(t), t = this.gl.createTexture(), this.gl.activeTexture(e), this.gl.bindTexture(this.gl.TEXTURE_3D, t), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16I, n[1], n[2], n[3]);
      const i = n[1] * n[2] * n[3];
      return r.length !== i && (r = new Int16Array(i)), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n[1], n[2], n[3], this.gl.RED_INTEGER, this.gl.SHORT, r), t;
    }
    drawGrowCut() {
      if (!this.back || !this.back.dims) throw new Error("back not defined");
      const t = this.back.hdr, e = this.gl, n = t.dims[1] * t.dims[2] * t.dims[3];
      if (!this.drawBitmap || this.drawBitmap.length !== n) {
        ee.debug("bitmap dims are wrong");
        return;
      }
      const r = e.createFramebuffer();
      e.bindFramebuffer(e.FRAMEBUFFER, r), e.disable(e.CULL_FACE), e.viewport(0, 0, this.back.dims[1], this.back.dims[2]), e.disable(e.BLEND);
      let i = Xz(this.back);
      const a = this.r16Tex(null, eW, this.back.dims, i);
      for (let S = 1; S < n; S++) i[S] = this.drawBitmap[S];
      const s = this.r16Tex(null, rW, this.back.dims, i), o = this.r16Tex(null, iW, this.back.dims, i), l = 1e4;
      for (let S = 1; S < n; S++) i[S] > 0 && (i[S] = l);
      const c = this.r16Tex(null, tW, this.back.dims, i), f = this.r16Tex(null, nW, this.back.dims, i);
      e.bindVertexArray(this.genericVAO);
      const u = this.growCutShader;
      u.use(e);
      const h = 128;
      e.uniform1i(u.uniforms.finalPass, 0), e.uniform1i(u.uniforms.backTex, 11);
      for (let S = 0; S < h; S++) {
        e.uniform1i(u.uniforms.labelTex, 14), e.uniform1i(u.uniforms.strengthTex, 12);
        for (let E = 0; E < this.back.dims[3]; E++) {
          const b = 1 / this.back.dims[3] * (E + 0.5);
          e.uniform1f(u.uniforms.coordZ, b), e.framebufferTextureLayer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, o, 0, E), e.framebufferTextureLayer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT1, f, 0, E), e.drawBuffers([
            e.COLOR_ATTACHMENT0,
            e.COLOR_ATTACHMENT1
          ]), e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && ee.error("Incomplete framebuffer"), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
        }
        S === h - 1 && e.uniform1i(u.uniforms.finalPass, 1), e.uniform1i(u.uniforms.labelTex, 15), e.uniform1i(u.uniforms.strengthTex, 13);
        for (let E = 0; E < this.back.dims[3]; E++) {
          const b = 1 / this.back.dims[3] * (E + 0.5);
          e.uniform1f(u.uniforms.coordZ, b), e.framebufferTextureLayer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, s, 0, E), e.framebufferTextureLayer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT1, c, 0, E), e.drawBuffers([
            e.COLOR_ATTACHMENT0,
            e.COLOR_ATTACHMENT1
          ]), e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && ee.error("Incomplete framebuffer"), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
        }
      }
      e.drawBuffers([
        e.COLOR_ATTACHMENT0
      ]);
      const g = e.COLOR_ATTACHMENT1, v = s;
      e.readBuffer(g);
      const m = e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT), y = e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE);
      (m !== e.RED_INTEGER || y !== e.SHORT) && ee.debug("readPixels will fail."), i = new Int16Array();
      const w = this.back.dims[1] * this.back.dims[2], C = new Int16Array(w);
      for (let S = 0; S < this.back.dims[3]; S++) e.framebufferTextureLayer(e.FRAMEBUFFER, g, v, 0, S), e.readPixels(0, 0, this.back.dims[1], this.back.dims[2], m, y, C), i = Int16Array.from([
        ...i,
        ...C
      ]);
      let T = i[0];
      for (let S = 0; S < i.length; S++) T = Math.max(T, i[S]);
      for (let S = 1; S < n; S++) this.drawBitmap[S] = i[S];
      e.deleteTexture(a), e.deleteTexture(c), e.deleteTexture(f), e.deleteTexture(s), e.deleteTexture(o), e.bindVertexArray(this.unusedVAO), e.viewport(0, 0, e.canvas.width, e.canvas.height), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(r), this.drawAddUndoBitmap(), this.refreshDrawing(true);
    }
    drawPt(t, e, n, r, i = null) {
      var _a3;
      if (i === null && (i = this.drawBitmap), !((_a3 = this.back) == null ? void 0 : _a3.dims)) throw new Error("back.dims not set");
      const a = this.back.dims[1], s = this.back.dims[2], o = this.back.dims[3];
      t = Math.min(Math.max(t, 0), a - 1), e = Math.min(Math.max(e, 0), s - 1), n = Math.min(Math.max(n, 0), o - 1), i[t + e * a + n * a * s] = r;
      const l = this.drawPenAxCorSag === 0, c = this.drawPenAxCorSag === 1, f = this.drawPenAxCorSag === 2;
      if (this.opts.penSize > 1) {
        const u = Math.floor(this.opts.penSize / 2);
        for (let h = -u; h <= u; h++) for (let g = -u; g <= u; g++) l ? i[t + h + (e + g) * a + n * a * s] = r : c ? i[t + h + e * a + (n + g) * a * s] = r : f && (i[t + (e + g) * a + (n + h) * a * s] = r);
      }
    }
    drawPenLine(t, e, n) {
      const r = Math.abs(t[0] - e[0]), i = Math.abs(t[1] - e[1]), a = Math.abs(t[2] - e[2]);
      let s = -1, o = -1, l = -1;
      e[0] > t[0] && (s = 1), e[1] > t[1] && (o = 1), e[2] > t[2] && (l = 1);
      let c = t[0], f = t[1], u = t[2];
      const h = e[0], g = e[1], v = e[2];
      if (r >= i && r >= a) {
        let m = 2 * i - r, y = 2 * a - r;
        for (; c !== h; ) c += s, m >= 0 && (f += o, m -= 2 * r), y >= 0 && (u += l, y -= 2 * r), m += 2 * i, y += 2 * a, this.drawPt(c, f, u, n);
      } else if (i >= r && i >= a) {
        let m = 2 * r - i, y = 2 * a - i;
        for (; f !== g; ) f += o, m >= 0 && (c += s, m -= 2 * i), y >= 0 && (u += l, y -= 2 * i), m += 2 * r, y += 2 * a, this.drawPt(c, f, u, n);
      } else {
        let m = 2 * i - a, y = 2 * r - a;
        for (; u !== v; ) u += l, m >= 0 && (f += o, m -= 2 * a), y >= 0 && (c += s, y -= 2 * a), m += 2 * i, y += 2 * r, this.drawPt(c, f, u, n);
      }
    }
    drawRectangleMask(t, e, n) {
      var _a3;
      if (!((_a3 = this.back) == null ? void 0 : _a3.dims)) throw new Error("back.dims not set");
      const r = this.back.dims[1], i = this.back.dims[2], a = this.back.dims[3], s = Math.min(Math.max(Math.min(t[0], e[0]), 0), r - 1), o = Math.min(Math.max(Math.min(t[1], e[1]), 0), i - 1), l = Math.min(Math.max(Math.min(t[2], e[2]), 0), a - 1), c = Math.min(Math.max(Math.max(t[0], e[0]), 0), r - 1), f = Math.min(Math.max(Math.max(t[1], e[1]), 0), i - 1), u = Math.min(Math.max(Math.max(t[2], e[2]), 0), a - 1);
      for (let h = l; h <= u; h++) for (let g = o; g <= f; g++) for (let v = s; v <= c; v++) this.drawPt(v, g, h, n);
    }
    drawEllipseMask(t, e, n) {
      var _a3;
      if (!((_a3 = this.back) == null ? void 0 : _a3.dims)) throw new Error("back.dims not set");
      const r = this.back.dims[1], i = this.back.dims[2], a = this.back.dims[3], s = Math.min(Math.max(Math.min(t[0], e[0]), 0), r - 1), o = Math.min(Math.max(Math.min(t[1], e[1]), 0), i - 1), l = Math.min(Math.max(Math.min(t[2], e[2]), 0), a - 1), c = Math.min(Math.max(Math.max(t[0], e[0]), 0), r - 1), f = Math.min(Math.max(Math.max(t[1], e[1]), 0), i - 1), u = Math.min(Math.max(Math.max(t[2], e[2]), 0), a - 1), h = (s + c) / 2, g = (o + f) / 2, v = (l + u) / 2, m = Math.abs(c - s) / 2, y = Math.abs(f - o) / 2, w = Math.abs(u - l) / 2;
      for (let C = l; C <= u; C++) for (let T = o; T <= f; T++) for (let S = s; S <= c; S++) {
        const E = (S - h) / (m + 0.5), b = (T - g) / (y + 0.5), D = (C - v) / (w + 0.5);
        E * E + b * b + D * D <= 1 && this.drawPt(S, T, C, n);
      }
    }
    drawingBinaryDilationWithSeed(t, e = 6) {
      try {
        let n = function(y) {
          return y[0] + y[1] * o + y[2] * l;
        };
        const r = this.drawBitmap, i = this.back.dims[1], a = this.back.dims[2], s = this.back.dims[3], o = i, l = i * a, c = l * s, f = n(t);
        if (f < 0 || f >= c) throw new Error("Seed index is out of bounds.");
        const u = r[f];
        if (u === 0) throw new Error("Seed voxel is not part of a filled cluster.");
        const h = r.slice();
        for (let y = 0; y < c; y++) h[y] = h[y] === u ? 1 : 0;
        this.drawFloodFillCore(h, f, e);
        const g = r.slice(), v = [], m = [
          -l,
          l,
          -i,
          i,
          -1,
          1
        ];
        v.push(...m), e > 6 && v.push(-i - 1, -i + 1, i - 1, i + 1, -l - i, -l + i, -l - 1, -l + 1, l - i, l + i, l - 1, l + 1), e > 18 && v.push(-l - i - 1, -l - i + 1, -l + i - 1, -l + i + 1, l - i - 1, l - i + 1, l + i - 1, l + i + 1);
        for (let y = 0; y < c; y++) if (h[y] === 2) {
          const w = y % i, C = Math.floor(y % l / i), T = Math.floor(y / l);
          for (const S of v) {
            const E = y + S;
            if (E < 0 || E >= c) continue;
            const b = E % i, D = Math.floor(E % l / i), R = Math.floor(E / l);
            Math.abs(b - w) > 1 || Math.abs(D - C) > 1 || Math.abs(R - T) > 1 || r[E] === 0 && (g[E] = u);
          }
        }
        this.drawBitmap = g, this.drawAddUndoBitmap(), this.refreshDrawing(true);
      } catch (n) {
        ee.error("Error in drawingBinaryDilationWithSeed:", n);
      }
    }
    drawFloodFillCore(t, e, n = 6) {
      var _a3;
      if (!((_a3 = this.back) == null ? void 0 : _a3.dims)) throw new Error("back.dims undefined");
      const r = [
        this.back.dims[1],
        this.back.dims[2],
        this.back.dims[3]
      ], i = r[0], a = i * r[1];
      function s(c) {
        return c[0] + c[1] * i + c[2] * a;
      }
      function o(c) {
        const f = Math.floor(c / a), u = Math.floor((c - f * a) / i);
        return [
          Math.floor(c % i),
          u,
          f
        ];
      }
      const l = [];
      for (l.push(e), t[e] = 2; l.length > 0; ) {
        let c = function(h) {
          const g = u.slice();
          if (g[0] += h[0], g[1] += h[1], g[2] += h[2], g[0] < 0 || g[1] < 0 || g[2] < 0 || g[0] >= r[0] || g[1] >= r[1] || g[2] >= r[2]) return;
          const v = s(g);
          t[v] === 1 && (t[v] = 2, l.push(v));
        };
        const f = l[0];
        l.shift();
        const u = o(f);
        c([
          0,
          0,
          -1
        ]), c([
          0,
          0,
          1
        ]), c([
          0,
          -1,
          0
        ]), c([
          0,
          1,
          0
        ]), c([
          -1,
          0,
          0
        ]), c([
          1,
          0,
          0
        ]), !(n <= 6) && (c([
          -1,
          -1,
          0
        ]), c([
          1,
          1,
          0
        ]), c([
          -1,
          1,
          0
        ]), c([
          1,
          1,
          0
        ]), c([
          0,
          -1,
          -1
        ]), c([
          0,
          1,
          -1
        ]), c([
          -1,
          0,
          -1
        ]), c([
          1,
          0,
          -1
        ]), c([
          0,
          -1,
          1
        ]), c([
          0,
          1,
          1
        ]), c([
          -1,
          0,
          1
        ]), c([
          1,
          0,
          1
        ]), !(n <= 18) && (c([
          -1,
          -1,
          -1
        ]), c([
          1,
          -1,
          -1
        ]), c([
          -1,
          1,
          -1
        ]), c([
          1,
          1,
          -1
        ]), c([
          -1,
          -1,
          1
        ]), c([
          1,
          -1,
          1
        ]), c([
          -1,
          1,
          1
        ]), c([
          1,
          1,
          1
        ])));
      }
    }
    drawFloodFill(t, e = 0, n = 0, r = NaN, i = NaN, a = 6, s = Number.POSITIVE_INFINITY, o = false, l = null, c = false) {
      var _a3;
      if (!this.drawBitmap && (ee.warn("drawFloodFill called without an initialized drawBitmap."), this.createEmptyDrawing(), !this.drawBitmap)) {
        ee.error("Failed to create drawing bitmap.");
        return;
      }
      if (this.clickToSegmentIsGrowing && !this.clickToSegmentGrowingBitmap) {
        if (ee.warn("drawFloodFill called in preview mode without initialized clickToSegmentGrowingBitmap."), this.drawBitmap) this.clickToSegmentGrowingBitmap = this.drawBitmap.slice();
        else {
          ee.error("Cannot initialize growing bitmap as drawBitmap is null.");
          return;
        }
        if (!this.clickToSegmentGrowingBitmap) {
          ee.error("Failed to create growing bitmap.");
          return;
        }
      }
      if (l === null && (l = this.drawBitmap), !l) {
        ee.error("drawFloodFill targetBitmap is null.");
        return;
      }
      if (!((_a3 = this.back) == null ? void 0 : _a3.dims)) throw new Error("back.dims undefined");
      e = Math.abs(e);
      const f = [
        this.back.dims[1],
        this.back.dims[2],
        this.back.dims[3]
      ];
      if (t[0] < 0 || t[1] < 0 || t[2] < 0 || t[0] >= f[0] || t[1] >= f[1] || t[2] >= f[2]) return;
      const u = f[0], h = u * f[1], g = h * f[2], v = this.clickToSegmentIsGrowing ? this.drawBitmap : l;
      if (!v) {
        ee.error("Could not determine original bitmap state.");
        return;
      }
      const m = new Uint8Array(g).fill(0);
      let y = -1;
      o && this.drawPenAxCorSag === 0 ? y = 2 : o && this.drawPenAxCorSag === 1 ? y = 1 : o && this.drawPenAxCorSag === 2 && (y = 0);
      function w(O) {
        const L = Math.floor(O / h), N = Math.floor((O - L * h) / u);
        return [
          Math.floor(O % u),
          N,
          L
        ];
      }
      function C(O) {
        return O[0] + O[1] * u + O[2] * h;
      }
      const T = (O) => this.vox2mm(O, this.back.matRAS), S = T(t), E = s ** 2;
      function b(O) {
        const L = w(O);
        if (y >= 0 && L[y] !== t[y]) return false;
        const N = T(L);
        return (N[0] - S[0]) ** 2 + (N[1] - S[1]) ** 2 + (N[2] - S[2]) ** 2 <= E;
      }
      const D = C(t), R = v[D];
      if (c && R === 0) {
        ee.debug("Grow/Erase Cluster tool requires starting on a masked voxel."), this.clickToSegmentIsGrowing && this.clickToSegmentGrowingBitmap && this.drawBitmap && (this.clickToSegmentGrowingBitmap.set(this.drawBitmap), this.refreshDrawing(true, true));
        return;
      }
      if (n === 0 && R === e && !c && e !== 0 && (ee.debug("drawFloodFill selected voxel is already desired color"), !this.clickToSegmentIsGrowing)) return;
      let I = NaN;
      if (c && (n === Number.POSITIVE_INFINITY || n === Number.NEGATIVE_INFINITY)) {
        const O = v.slice();
        for (let _ = 0; _ < g; _++) O[_] = O[_] === R && b(_) ? 1 : 0;
        if (O[D] !== 1) {
          ee.error("Seed voxel could not be marked for cluster ID.");
          return;
        }
        this.drawFloodFillCore(O, D, a);
        const L = this.volumes[0].img2RAS();
        let N = 0, F = 0;
        for (let _ = 0; _ < g; _++) O[_] === 2 && (N += L[_], F++);
        I = F > 0 ? N / F : L[D], ee.debug(`Grow Cluster using mean intensity: ${I.toFixed(2)} from ${F} voxels.`);
        let V = -1 / 0, k = 1 / 0;
        n === Number.POSITIVE_INFINITY && (V = I), n === Number.NEGATIVE_INFINITY && (k = I);
        for (let _ = 0; _ < g; _++) if (O[_] === 2) m[_] = 1;
        else if (v[_] === 0) {
          const K = L[_];
          K >= V && K <= k && b(_) && (m[_] = 1);
        }
        e = R;
      } else if (n === 0) if (c && e === 0) {
        ee.debug(`Erase Cluster: Identifying cluster with color ${R}`);
        for (let O = 0; O < g; O++) m[O] = v[O] === R && b(O) ? 1 : 0;
      } else for (let O = 0; O < g; O++) v[O] === R && b(O) && R !== 0 && (m[O] = 1);
      else {
        const O = this.volumes[0].img2RAS();
        I = O[D];
        let L = -1 / 0, N = 1 / 0;
        isFinite(r) && isFinite(i) ? (L = r, N = i) : n === Number.POSITIVE_INFINITY ? L = I : n === Number.NEGATIVE_INFINITY && (N = I);
        for (let F = 0; F < g; F++) {
          const V = O[F];
          V >= L && V <= N && b(F) && (m[F] = 1);
        }
        e = v[D], e === 0 && (e = this.opts.penValue, (e < 1 || !isFinite(e)) && (e = 1));
      }
      if (m[D] !== 1) {
        let O = false;
        if (c && n !== 0 ? R !== 0 && (O = true) : (R !== 0 || e === 0) && (O = true), O && b(D)) m[D] = 1, ee.debug("Forcing seed voxel to 1 in working buffer.");
        else {
          ee.debug("Seed voxel not marked as candidate '1' and not valid originally."), this.clickToSegmentIsGrowing && this.clickToSegmentGrowingBitmap && this.drawBitmap && this.clickToSegmentGrowingBitmap.set(this.drawBitmap);
          return;
        }
      }
      this.drawFloodFillCore(m, D, a);
      for (let O = 0; O < g; O++) m[O] === 2 ? l[O] = e : this.clickToSegmentIsGrowing && l === this.clickToSegmentGrowingBitmap && (l[O] = v[O]);
      this.clickToSegmentIsGrowing ? this.refreshDrawing(true, true) : (this.drawAddUndoBitmap(), this.refreshDrawing(true, false));
    }
    floodFillSectionFIFO(t, e, n, r) {
      const i = e[0], [a, s] = n, [o, l] = r, c = 4 * (o - a + l - s + 2), f = new Int32Array(c * 2);
      let u = 0, h = 0;
      function g(y, w) {
        if (y < a || y > o || w < s || w > l) return;
        const C = y + w * i;
        t[C] === 0 && (t[C] = 2, f[h] = y, f[h + 1] = w, h = (h + 2) % f.length);
      }
      function v() {
        if (u === h) return null;
        const y = f[u], w = f[u + 1];
        return u = (u + 2) % f.length, [
          y,
          w
        ];
      }
      for (let y = a; y <= o; y++) g(y, s), g(y, l);
      for (let y = s + 1; y <= l - 1; y++) g(a, y), g(o, y);
      let m;
      for (; (m = v()) !== null; ) {
        const [y, w] = m;
        g(y - 1, w), g(y + 1, w), g(y, w - 1), g(y, w + 1);
      }
    }
    drawPenFilled() {
      var _a3;
      const t = this.drawPenFillPts.length;
      if (t < 2) {
        this.drawPenFillPts = [];
        return;
      }
      const e = this.drawPenAxCorSag;
      let n = 0, r = 1;
      if (e === 1 && (r = 2), e === 2 && (n = 1, r = 2), !((_a3 = this.back) == null ? void 0 : _a3.dims)) throw new Error("back.dims undefined");
      const i = [
        this.back.dims[n + 1],
        this.back.dims[r + 1]
      ], a = new Uint8Array(i[0] * i[1]);
      let s = 1;
      function o(y, w) {
        const C = Math.abs(y[0] - w[0]), T = Math.abs(y[1] - w[1]);
        a[y[0] + y[1] * i[0]] = s, a[w[0] + w[1] * i[0]] = s;
        let S = -1, E = -1;
        w[0] > y[0] && (S = 1), w[1] > y[1] && (E = 1);
        let b = y[0], D = y[1];
        const R = w[0], I = w[1];
        if (C >= T) {
          let O = 2 * T - C;
          for (; b !== R; ) b += S, O >= 0 && (D += E, O -= 2 * C), O += 2 * T, a[b + D * i[0]] = s;
        } else {
          let O = 2 * C - T;
          for (; D !== I; ) D += E, O >= 0 && (b += S, O -= 2 * T), O += 2 * C, a[b + D * i[0]] = s;
        }
      }
      function l(y) {
        const w = Math.min(Math.max(y[0], 0), i[0] - 1), C = Math.min(Math.max(y[1], 0), i[1] - 1);
        return [
          w,
          C
        ];
      }
      const c = l([
        this.drawPenFillPts[0][n],
        this.drawPenFillPts[0][r]
      ]);
      let f = [
        ...c
      ], u = [
        ...c
      ], h = c;
      for (let y = 1; y < t; y++) {
        let w = [
          this.drawPenFillPts[y][n],
          this.drawPenFillPts[y][r]
        ];
        w = l(w), f = [
          Math.min(w[0], f[0]),
          Math.min(w[1], f[1])
        ], u = [
          Math.max(w[0], u[0]),
          Math.max(w[1], u[1])
        ], o(h, w), h = w;
      }
      o(c, h);
      const g = 1;
      f[0] = Math.max(0, f[0] - g), f[1] = Math.max(0, f[1] - g), u[0] = Math.min(i[0] - 1, u[0] + g), u[1] = Math.min(i[1] - 1, u[1] + g);
      for (let y = 0; y < i[1]; y++) for (let w = 0; w < i[0]; w++) {
        if (w >= f[0] && w < u[0] && y >= f[1] && y <= u[1]) continue;
        const C = w + y * i[0];
        a[C] === 0 && (a[C] = 2);
      }
      const v = Date.now();
      this.floodFillSectionFIFO(a, i, f, u), ee.debug(`FloodFill ${Date.now() - v}`), s = this.opts.penValue;
      const m = this.drawPenFillPts[0][3 - (n + r)];
      if (!this.drawBitmap) throw new Error("drawBitmap undefined");
      if (e === 0) {
        const y = m * i[0] * i[1];
        for (let w = 0; w < i[0] * i[1]; w++) a[w] !== 2 && (this.drawBitmap[w + y] = s);
      } else {
        let y = 1;
        const w = this.back.dims[1] * this.back.dims[2];
        let C = m * this.back.dims[1];
        e === 2 && (y = this.back.dims[1], C = m);
        let T = 0;
        for (let S = 0; S < i[1]; S++) for (let E = 0; E < i[0]; E++) a[T] !== 2 && (this.drawBitmap[E * y + S * w + C] = s), T++;
      }
      if (!this.drawFillOverwrites && this.drawUndoBitmaps[this.currentDrawUndoBitmap].length > 0) {
        const y = this.drawBitmap.length, w = Pv(this.drawUndoBitmaps[this.currentDrawUndoBitmap], y);
        for (let C = 0; C < y; C++) w[C] !== 0 && (this.drawBitmap[C] = w[C]);
      }
      this.drawPenFillPts = [], this.drawAddUndoBitmap(), this.refreshDrawing(false);
    }
    closeDrawing() {
      this.drawClearAllUndoBitmaps(), this.drawTexture = this.rgbaTex(this.drawTexture, sl, [
        2,
        2,
        2,
        2
      ], true), this.drawBitmap = null, this.clickToSegmentGrowingBitmap = null, this.drawScene();
    }
    refreshDrawing(t = true, e = false) {
      var _a3;
      e && (!this.opts.drawingEnabled || !this.opts.clickToSegment) && (ee.debug("refreshDrawing: Conditions not met for clickToSegment bitmap, using drawBitmap."), e = false);
      const n = e ? this.clickToSegmentGrowingBitmap : this.drawBitmap;
      !n && !e && this.clickToSegmentGrowingBitmap ? ee.warn("refreshDrawing: drawBitmap is null, but clickToSegmentGrowingBitmap exists. Check state.") : !n && e && this.drawBitmap ? (ee.warn("refreshDrawing: clickToSegmentGrowingBitmap is null, falling back to drawBitmap."), e = false) : n || ee.warn("refreshDrawing: Both bitmaps are null. Uploading empty data.");
      const r = e ? this.clickToSegmentGrowingBitmap : this.drawBitmap;
      if (!((_a3 = this.back) == null ? void 0 : _a3.dims)) {
        ee.warn("refreshDrawing: back.dims undefined, cannot refresh drawing texture yet.");
        return;
      }
      const i = this.back.dims.slice(), a = this.back.dims[1] * this.back.dims[2] * this.back.dims[3];
      if (!r) {
        ee.warn(`refreshDrawing: Bitmap data source (${e ? "growing" : "main"}) is null. Cannot update texture.`), t && this.drawScene();
        return;
      }
      if (r.length === 8 ? (i[1] = 2, i[2] = 2, i[3] = 2) : a !== r.length && ee.warn(`Drawing bitmap length (${r.length}) must match the background image (${a})`), this.gl.activeTexture(sl), this.opts.is2DSliceShader) {
        const s = this.frac2vox(this.scene.crosshairPos), o = Math.min(Math.max(s[2], 0), i[3] - 1), l = i[1] * i[2], c = o * l;
        ee.debug(`refresh huge 2D drawing x\xD7y\xD7z ${i[1]}\xD7${i[2]}\xD7${i[3]} slice ${c}`);
        const f = r.subarray(c, c + l);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.drawTexture), this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, i[1], i[2], this.gl.RED, this.gl.UNSIGNED_BYTE, f);
      } else this.gl.bindTexture(this.gl.TEXTURE_3D, this.drawTexture), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, i[1], i[2], i[3], this.gl.RED, this.gl.UNSIGNED_BYTE, r);
      if (!this.drawTexture) {
        ee.error("refreshDrawing: drawTexture (GPU texture) is null.");
        return;
      }
      t && this.drawScene();
    }
    closePAQD() {
      !this._gl || !this.paqdTexture || (this.paqdTexture = this.rgbaTex(this.paqdTexture, d1, [
        2,
        2,
        2,
        2
      ], true));
    }
    r8Tex2D(t, e, n, r = false) {
      if (t && this.gl.deleteTexture(t), t = this.gl.createTexture(), this.gl.activeTexture(e), this.gl.bindTexture(this.gl.TEXTURE_2D, t), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.R8, n[1], n[2]), r) {
        const i = new Uint8Array(n[1] * n[2]);
        this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, n[1], n[2], this.gl.RED, this.gl.UNSIGNED_BYTE, i);
      }
      return t;
    }
    r8Tex(t, e, n, r = false) {
      if (t && this.gl.deleteTexture(t), t = this.gl.createTexture(), this.gl.activeTexture(e), this.gl.bindTexture(this.gl.TEXTURE_3D, t), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R8, n[1], n[2], n[3]), r) {
        const i = new Uint8Array(n[1] * n[2] * n[3]);
        this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n[1], n[2], n[3], this.gl.RED, this.gl.UNSIGNED_BYTE, i);
      }
      return t;
    }
    rgbaTex2D(t, e, n, r = null, i = true) {
      if (t && this.gl.deleteTexture(t), t = this.gl.createTexture(), this.gl.activeTexture(e), this.gl.bindTexture(this.gl.TEXTURE_2D, t), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, n[1], n[2]), r) {
        let a = r;
        const s = n[1], o = n[2];
        if (i) {
          a = new Uint8Array(r.length);
          const l = s * 4;
          for (let c = 0; c < o; c++) {
            const f = c * l, u = (o - 1 - c) * l;
            a.set(r.subarray(f, f + l), u);
          }
        }
        this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, s, o, this.gl.RGBA, this.gl.UNSIGNED_BYTE, a);
      }
      return t;
    }
    rgbaTex(t, e, n, r = false) {
      if (t && this.gl.deleteTexture(t), t = this.gl.createTexture(), this.gl.activeTexture(e), this.gl.bindTexture(this.gl.TEXTURE_3D, t), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA8, n[1], n[2], n[3]), r) {
        const i = new Uint8Array(n[1] * n[2] * n[3] * 4);
        this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n[1], n[2], n[3], this.gl.RGBA, this.gl.UNSIGNED_BYTE, i);
      }
      return t;
    }
    rgba16Tex(t, e, n, r = false) {
      if (t && this.gl.deleteTexture(t), t = this.gl.createTexture(), this.gl.activeTexture(e), this.gl.bindTexture(this.gl.TEXTURE_3D, t), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 2), this.gl.pixelStorei(this.gl.PACK_ALIGNMENT, 2), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA16UI, n[1], n[2], n[3]), r) {
        const i = new Uint16Array(n[1] * n[2] * n[3] * 4);
        this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n[1], n[2], n[3], this.gl.RGBA_INTEGER, this.gl.UNSIGNED_SHORT, i);
      }
      return t;
    }
    requestCORSIfNotSameOrigin(t, e) {
      new URL(e, window.location.href).origin !== window.location.origin && (t.crossOrigin = "");
    }
    async loadPngAsTexture(t, e) {
      return new Promise((n, r) => {
        const i = new Image();
        i.onload = () => {
          if (!this.bmpShader) return;
          let a;
          e === 4 ? (this.bmpTexture !== null && this.gl.deleteTexture(this.bmpTexture), this.bmpTexture = this.gl.createTexture(), a = this.bmpTexture, this.bmpTextureWH = i.width / i.height, this.gl.activeTexture($z), this.bmpShader.use(this.gl), this.gl.uniform1i(this.bmpShader.uniforms.bmpTexture, 4)) : e === 5 ? (this.gl.activeTexture(mC), this.matCapTexture !== null && this.gl.deleteTexture(this.matCapTexture), this.matCapTexture = this.gl.createTexture(), a = this.matCapTexture) : (this.fontShader.use(this.gl), this.gl.activeTexture(Jz), this.gl.uniform1i(this.fontShader.uniforms.fontTexture, 3), this.fontTexture !== null && this.gl.deleteTexture(this.fontTexture), this.fontTexture = this.gl.createTexture(), a = this.fontTexture), this.gl.bindTexture(this.gl.TEXTURE_2D, a), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, i), n(a), e !== 4 && this.drawScene();
        }, i.onerror = r, this.requestCORSIfNotSameOrigin(i, t), i.src = t;
      });
    }
    async loadFontTexture(t) {
      return this.loadPngAsTexture(t, 3);
    }
    async loadBmpTexture(t) {
      return this.loadPngAsTexture(t, 4);
    }
    async loadMatCapTexture(t) {
      return this.loadPngAsTexture(t, 5);
    }
    initFontMets() {
      if (!this.fontMetrics) throw new Error("fontMetrics undefined");
      this.fontMets = {
        distanceRange: this.fontMetrics.atlas.distanceRange,
        size: this.fontMetrics.atlas.size,
        mets: {}
      };
      for (let n = 0; n < 256; n++) this.fontMets.mets[n] = {
        xadv: 0,
        uv_lbwh: [
          0,
          0,
          0,
          0
        ],
        lbwh: [
          0,
          0,
          0,
          0
        ]
      };
      const t = this.fontMetrics.atlas.width, e = this.fontMetrics.atlas.height;
      for (let n = 0; n < this.fontMetrics.glyphs.length; n++) {
        const r = this.fontMetrics.glyphs[n], i = r.unicode;
        if (this.fontMets.mets[i].xadv = r.advance, r.planeBounds === void 0) continue;
        let a = r.atlasBounds.left / t, s = (e - r.atlasBounds.top) / e, o = (r.atlasBounds.right - r.atlasBounds.left) / t, l = (r.atlasBounds.top - r.atlasBounds.bottom) / e;
        this.fontMets.mets[i].uv_lbwh = [
          a,
          s,
          o,
          l
        ], a = r.planeBounds.left, s = r.planeBounds.bottom, o = r.planeBounds.right - r.planeBounds.left, l = r.planeBounds.top - r.planeBounds.bottom, this.fontMets.mets[i].lbwh = [
          a,
          s,
          o,
          l
        ];
      }
    }
    async loadFont(t = iC, e = aC) {
      await this.loadFontTexture(t);
      const n = await fetch(e);
      if (!n.ok) throw Error(n.statusText);
      const r = await n.text();
      this.fontMetrics = JSON.parse(r), this.initFontMets(), this.fontShader.use(this.gl), this.drawScene();
    }
    async loadDefaultMatCap() {
      return this.loadMatCapTexture(PG);
    }
    async loadDefaultFont() {
      await this.loadFontTexture(this.DEFAULT_FONT_GLYPH_SHEET), this.fontMetrics = this.DEFAULT_FONT_METRICS, this.initFontMets();
    }
    async initText() {
      this.fontShader = new un(this.gl, uz, fz), this.fontShader.use(this.gl), await this.loadDefaultFont(), await this.loadDefaultMatCap(), this.drawLoadingText(this.opts.loadingText);
    }
    meshShaderNameToNumber(t = "Phong") {
      const e = t.toLowerCase();
      for (let n = 0; n < this.meshShaders.length; n++) if (this.meshShaders[n].Name.toLowerCase() === e) return n;
    }
    setMeshShader(t, e = 2) {
      let n = 0;
      if (typeof e == "number" ? n = e : n = this.meshShaderNameToNumber(e), n === void 0) throw new Error("shaderIndex undefined");
      n = Math.min(n, this.meshShaders.length - 1), n = Math.max(n, 0);
      const r = this.getMeshIndexByID(t);
      if (r >= this.meshes.length) {
        ee.debug("Unable to change shader until mesh is loaded (maybe you need async)");
        return;
      }
      this.meshes[r].meshShaderIndex = n, this.updateGLVolume(), this.onMeshShaderChanged(r, n);
    }
    createCustomMeshShader(t, e = "Custom") {
      if (!t) throw new Error("Need fragment shader");
      const n = this.meshShaderNameToNumber(e);
      n >= 0 && (this.gl.deleteProgram(this.meshShaders[n].shader.program), this.meshShaders.splice(n, 1));
      const r = new un(this.gl, s4, t);
      return r.use(this.gl), {
        Name: e,
        Frag: t,
        shader: r
      };
    }
    setCustomSliceShader(t = "") {
      const e = this.gl;
      if (this.customSliceShader && (e.deleteProgram(this.customSliceShader.program), this.customSliceShader = null), !t) {
        this.updateGLVolume();
        return;
      }
      const n = new un(e, T2, t);
      n.use(e), e.uniform1i(n.uniforms.volume, 0), e.uniform1i(n.uniforms.colormap, 1), e.uniform1i(n.uniforms.overlay, 2), e.uniform1i(n.uniforms.drawing, 7), e.uniform1i(n.uniforms.paqd, 8), e.uniform1f(n.uniforms.drawOpacity, this.drawOpacity), this.customSliceShader = n, this.updateGLVolume();
    }
    setCustomMeshShader(t = "", e = "Custom") {
      const n = this.createCustomMeshShader(t, e);
      return this.meshShaders.push(n), this.onCustomMeshShaderAdded(t, e), this.meshShaders.length - 1;
    }
    meshShaderNames(t = true) {
      const e = [];
      for (let n = 0; n < this.meshShaders.length; n++) e.push(this.meshShaders[n].Name);
      return t === true ? e.sort() : e;
    }
    initRenderShader(t, e = 0) {
      t.use(this.gl), this.gl.uniform1i(t.uniforms.volume, 0), this.gl.uniform1i(t.uniforms.colormap, 1), this.gl.uniform1i(t.uniforms.overlay, 2), this.gl.uniform1i(t.uniforms.drawing, 7), this.gl.uniform1i(t.uniforms.paqd, 8), this.gl.uniform1fv(t.uniforms.renderDrawAmbientOcclusion, [
        this.renderDrawAmbientOcclusion,
        1
      ]), this.gl.uniform1f(t.uniforms.gradientAmount, e), this.gl.uniform1f(t.uniforms.silhouettePower, this.opts.renderSilhouette);
      const n = new Float32Array(ah);
      for (let r = 0; r < ah; r++) this.opts.gradientOpacity === 0 ? n[r] = 1 : n[r] = Math.pow(r / (ah - 1), this.opts.gradientOpacity * 8);
      this.gl.uniform1fv(this.gl.getUniformLocation(t.program, "gradientOpacity"), n);
    }
    async init() {
      const t = this.gl.getExtension("WEBGL_debug_renderer_info");
      if (t) {
        const a = this.gl.getParameter(t.UNMASKED_VENDOR_WEBGL), s = this.gl.getParameter(t.UNMASKED_RENDERER_WEBGL);
        ee.info("renderer vendor: ", a), ee.info("renderer: ", s);
      } else ee.info("debug_renderer_info unavailable");
      const e = this.gl.getParameter(this.gl.RENDERER);
      ee.info("firefox renderer: ", e), this.gl.clearDepth(0), this.gl.enable(this.gl.CULL_FACE), this.gl.cullFace(this.gl.FRONT), this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA), this.volumeTexture = this.rgbaTex(this.volumeTexture, Y0, [
        2,
        2,
        2,
        2
      ], true), this.overlayTexture = this.rgbaTex(this.overlayTexture, f4, [
        2,
        2,
        2,
        2
      ], true), this.drawTexture = this.r8Tex(this.drawTexture, sl, [
        2,
        2,
        2,
        2
      ], true), this.paqdTexture = this.rgbaTex(this.paqdTexture, d1, [
        2,
        2,
        2,
        2
      ], true);
      const n = [
        1,
        1,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0
      ], r = this.gl;
      this.cuboidVertexBuffer = r.createBuffer(), r.bindBuffer(r.ARRAY_BUFFER, this.cuboidVertexBuffer), r.bufferData(r.ARRAY_BUFFER, new Float32Array(n), r.STATIC_DRAW), this.genericVAO = r.createVertexArray(), r.bindVertexArray(this.genericVAO), r.bindBuffer(r.ARRAY_BUFFER, this.cuboidVertexBuffer), r.enableVertexAttribArray(0), r.vertexAttribPointer(0, 3, r.FLOAT, false, 0, 0), r.bindVertexArray(this.unusedVAO), this.pickingMeshShader = new un(r, s4, Sz), this.pickingMeshShader.use(r), this.pickingImageShader = new un(r, u1, _z), this.pickingImageShader.use(r), r.uniform1i(this.pickingImageShader.uniforms.volume, 0), r.uniform1i(this.pickingImageShader.uniforms.colormap, 1), r.uniform1i(this.pickingImageShader.uniforms.overlay, 2), r.uniform1i(this.pickingImageShader.uniforms.drawing, 7), this.slice2DShader = new un(r, T2, ez), this.slice2DShader.use(r), r.uniform1i(this.slice2DShader.uniforms.volume, 0), r.uniform1i(this.slice2DShader.uniforms.colormap, 1), r.uniform1i(this.slice2DShader.uniforms.overlay, 2), r.uniform1i(this.slice2DShader.uniforms.drawing, 7), r.uniform1f(this.slice2DShader.uniforms.drawOpacity, this.drawOpacity), this.sliceMMShader = new un(r, T2, tz), this.sliceMMShader.use(r), r.uniform1i(this.sliceMMShader.uniforms.volume, 0), r.uniform1i(this.sliceMMShader.uniforms.colormap, 1), r.uniform1i(this.sliceMMShader.uniforms.overlay, 2), r.uniform1i(this.sliceMMShader.uniforms.drawing, 7), r.uniform1f(this.sliceMMShader.uniforms.drawOpacity, this.drawOpacity), this.sliceV1Shader = new un(r, T2, nz), this.sliceV1Shader.use(r), r.uniform1i(this.sliceV1Shader.uniforms.volume, 0), r.uniform1i(this.sliceV1Shader.uniforms.colormap, 1), r.uniform1i(this.sliceV1Shader.uniforms.overlay, 2), r.uniform1i(this.sliceV1Shader.uniforms.drawing, 7), r.uniform1f(this.sliceV1Shader.uniforms.drawOpacity, this.drawOpacity), this.orientCubeShader = new un(r, kz, Pz), this.orientCubeShaderVAO = r.createVertexArray(), r.bindVertexArray(this.orientCubeShaderVAO);
      const i = r.createBuffer();
      r.enableVertexAttribArray(0), r.enableVertexAttribArray(1), r.bindBuffer(r.ARRAY_BUFFER, i), r.bufferData(r.ARRAY_BUFFER, lP, r.STATIC_DRAW), r.vertexAttribPointer(0, 3, r.FLOAT, false, 24, 0), r.enableVertexAttribArray(1), r.vertexAttribPointer(1, 3, r.FLOAT, false, 24, 12), r.bindVertexArray(this.unusedVAO), this.rectShader = new un(r, oC, i4), this.rectShader.use(r), this.rectOutlineShader = new un(r, oC, rz), this.rectOutlineShader.use(r), this.lineShader = new un(r, sz, i4), this.lineShader.use(r), this.line3DShader = new un(r, oz, i4), this.line3DShader.use(r), this.circleShader = new un(r, hz, dz), this.circleShader.use(r), this.renderVolumeShader = new un(r, u1, QG), this.initRenderShader(this.renderVolumeShader), this.renderSliceShader = new un(r, u1, ZG), this.initRenderShader(this.renderSliceShader), this.renderGradientShader = new un(r, u1, JG), this.initRenderShader(this.renderGradientShader, 0.3), r.uniform1i(this.renderGradientShader.uniforms.matCap, 5), r.uniform1i(this.renderGradientShader.uniforms.gradient, 6), this.renderGradientValuesShader = new un(r, u1, $G), this.initRenderShader(this.renderGradientValuesShader), r.uniform1i(this.renderGradientValuesShader.uniforms.matCap, 5), r.uniform1i(this.renderGradientValuesShader.uniforms.gradient, 6), this.renderShader = this.renderVolumeShader, this.colorbarShader = new un(r, iz, az), this.colorbarShader.use(r), r.uniform1i(this.colorbarShader.uniforms.colormap, 1), this.blurShader = new un(r, A2, Wz), this.sobelBlurShader = new un(r, A2, Hz), this.sobelFirstOrderShader = new un(r, A2, jz), this.sobelSecondOrderShader = new un(r, A2, Kz), this.growCutShader = new un(r, vz, yz), this.passThroughShader = new un(r, Gz, zz), this.orientShaderAtlasU = new un(r, fc, S2.concat(cC)), this.orientShaderAtlasI = new un(r, fc, lC.concat(cC)), this.orientShaderU = new un(r, fc, S2.concat(a4)), this.orientShaderI = new un(r, fc, lC.concat(a4)), this.orientShaderF = new un(r, fc, gz.concat(a4)), this.orientShaderRGBU = new un(r, fc, S2.concat(mz)), this.orientShaderPAQD = new un(r, fc, S2.concat(pz)), this.surfaceShader = new un(r, xz, wz), this.surfaceShader.use(r), this.fiberShader = new un(r, Cz, Tz), this.pickingImageShader.use(r);
      for (let a = 0; a < this.meshShaders.length; a++) {
        const s = this.meshShaders[a];
        s.Name === "Flat" ? s.shader = new un(r, Bz, uC) : s.shader = new un(r, s4, s.Frag), s.shader.use(r), s.shader.isMatcap = s.Name === "Matcap", s.shader.isMatcap && r.uniform1i(s.shader.uniforms.matCap, 5);
      }
      return this.bmpShader = new un(r, lz, cz), await this.initText(), this.opts.thumbnail.length > 0 && (await this.loadBmpTexture(this.opts.thumbnail), this.thumbnailVisible = true), this.updateGLVolume(), this.initialized = true, this.resizeListener(), this.drawScene(), this;
    }
    gradientGL(t) {
      const e = this.gl;
      e.bindVertexArray(this.genericVAO);
      const n = e.createFramebuffer();
      e.bindFramebuffer(e.FRAMEBUFFER, n), e.viewport(0, 0, t.dims[1], t.dims[2]), e.disable(e.BLEND);
      const r = this.rgbaTex(null, vC, t.dims, true), i = this.opts.gradientOrder === 2 ? this.sobelBlurShader : this.blurShader;
      i.use(e), e.activeTexture(Y0), e.bindTexture(e.TEXTURE_3D, this.volumeTexture), e.texParameteri(e.TEXTURE_3D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_3D, e.TEXTURE_MAG_FILTER, e.LINEAR);
      const a = 0.7;
      e.uniform1i(i.uniforms.intensityVol, 0), e.uniform1f(i.uniforms.dX, a / t.dims[1]), e.uniform1f(i.uniforms.dY, a / t.dims[2]), e.uniform1f(i.uniforms.dZ, a / t.dims[3]);
      for (let l = 0; l < t.dims[3] - 1; l++) {
        const c = 1 / t.dims[3] * (l + 0.5);
        e.uniform1f(i.uniforms.coordZ, c), e.framebufferTextureLayer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, r, 0, l);
        const f = e.checkFramebufferStatus(e.FRAMEBUFFER);
        f !== e.FRAMEBUFFER_COMPLETE && ee.error("blur shader: ", f), e.clear(e.DEPTH_BUFFER_BIT), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
      }
      const s = this.opts.gradientOrder === 2 ? this.sobelSecondOrderShader : this.sobelFirstOrderShader;
      s.use(e), e.activeTexture(vC), e.bindTexture(e.TEXTURE_3D, r), e.texParameteri(e.TEXTURE_3D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_3D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.uniform1i(s.uniforms.intensityVol, 8);
      const o = 0.7;
      e.uniform1f(s.uniforms.dX, o / t.dims[1]), e.uniform1f(s.uniforms.dY, o / t.dims[2]), e.uniform1f(s.uniforms.dZ, o / t.dims[3]), this.opts.gradientOrder === 2 && (e.uniform1f(s.uniforms.dX2, 2 * o / t.dims[1]), e.uniform1f(s.uniforms.dY2, 2 * o / t.dims[2]), e.uniform1f(s.uniforms.dZ2, 2 * o / t.dims[3])), e.uniform1f(s.uniforms.coordZ, 0.5), this.gradientTexture !== null && e.deleteTexture(this.gradientTexture), this.gradientTexture = this.rgbaTex(this.gradientTexture, h4, t.dims);
      for (let l = 0; l < t.dims[3] - 1; l++) {
        const c = 1 / t.dims[3] * (l + 0.5);
        e.uniform1f(s.uniforms.coordZ, c), e.framebufferTextureLayer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, this.gradientTexture, 0, l);
        const f = e.checkFramebufferStatus(e.FRAMEBUFFER);
        f !== e.FRAMEBUFFER_COMPLETE && ee.error("sobel shader: ", f), e.clear(e.DEPTH_BUFFER_BIT), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
      }
      e.deleteFramebuffer(n), e.deleteTexture(r), e.bindFramebuffer(e.FRAMEBUFFER, null), e.activeTexture(d1), e.bindTexture(e.TEXTURE_3D, this.paqdTexture), this.gl.bindVertexArray(this.unusedVAO);
    }
    getGradientTextureData() {
      if (!this.gradientTexture || !this.back) return null;
      const t = this.gl, e = this.back.dims, n = e[1], r = e[2], i = e[3], a = n * r * i, s = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, s);
      const o = new Float32Array(a * 4);
      try {
        for (let l = 0; l < i; l++) {
          t.framebufferTextureLayer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, this.gradientTexture, 0, l);
          const c = t.checkFramebufferStatus(t.FRAMEBUFFER);
          if (c !== t.FRAMEBUFFER_COMPLETE) {
            console.warn("Framebuffer not complete for gradient texture reading, slice", l, "status:", c.toString(16));
            continue;
          }
          try {
            const f = new Uint8Array(n * r * 4);
            t.readPixels(0, 0, n, r, t.RGBA, t.UNSIGNED_BYTE, f);
            const u = new Float32Array(n * r * 4);
            for (let g = 0; g < f.length; g++) u[g] = f[g] / 127.5 - 1;
            const h = l * n * r * 4;
            o.set(u, h);
          } catch (f) {
            console.warn("Failed to read pixels for slice", l, ":", f);
            const u = l * n * r * 4, h = new Float32Array(n * r * 4);
            o.set(h, u);
          }
        }
      } catch (l) {
        return console.error("Error reading gradient texture:", l), null;
      } finally {
        t.deleteFramebuffer(s), t.bindFramebuffer(t.FRAMEBUFFER, null);
      }
      return o;
    }
    setCustomGradientTexture(t, e) {
      const n = this.gl;
      if (t === null) {
        this.useCustomGradientTexture = false, this.back && this.gradientTextureAmount > 0 && this.gradientGL(this.back.hdr);
        return;
      }
      if (!e && !this.back) {
        console.warn("No dimensions provided and no background volume loaded");
        return;
      }
      const r = e || this.back.dims, i = r[1], a = r[2], s = r[3], o = i * a * s * 4;
      if (t.length !== o) {
        console.warn(`Custom gradient data size mismatch. Expected ${o}, got ${t.length}`);
        return;
      }
      this.useCustomGradientTexture = true, this.gradientTexture !== null && n.deleteTexture(this.gradientTexture), this.gradientTexture = n.createTexture(), n.activeTexture(h4), n.bindTexture(n.TEXTURE_3D, this.gradientTexture), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.pixelStorei(n.UNPACK_ALIGNMENT, 1);
      let l;
      if (t instanceof Float32Array) {
        l = new Uint8Array(t.length);
        for (let c = 0; c < t.length; c++) {
          const f = Math.max(-1, Math.min(1, t[c]));
          l[c] = Math.round((f + 1) * 127.5);
        }
      } else l = t;
      n.texStorage3D(n.TEXTURE_3D, 1, n.RGBA8, i, a, s), n.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, i, a, s, n.RGBA, n.UNSIGNED_BYTE, l), this.drawScene();
    }
    updateGLVolume() {
      var _a3;
      let t = 0;
      const e = this.volumes.length;
      this.refreshColormaps(), this.closePAQD();
      for (let n = 0; n < e; n++) this.volumes[n].toRAS && (this.refreshLayers(this.volumes[n], t), t++);
      if (this.furthestVertexFromOrigin = 0, e > 0 && (this.furthestVertexFromOrigin = ((_a3 = this.volumeObject3D) == null ? void 0 : _a3.furthestVertexFromOrigin) ?? 0), this.meshes) for (let n = 0; n < this.meshes.length; n++) this.furthestVertexFromOrigin = Math.max(this.furthestVertexFromOrigin, this.meshes[n].furthestVertexFromOrigin);
      this.onVolumeUpdated && this.onVolumeUpdated(), this.drawScene();
    }
    getDescriptives(t) {
      const { layer: e = 0, masks: n = [], drawingIsMask: r = false, roiIsMask: i = false, startVox: a = [
        0,
        0,
        0
      ], endVox: s = [
        0,
        0,
        0
      ] } = t;
      let o = null;
      const l = this.volumes[e].hdr, c = this.volumes[e].pixDimsRAS;
      let f = l.scl_slope;
      isNaN(f) && (f = 1);
      let u = l.scl_inter;
      isNaN(u) && (u = 1);
      const h = this.volumes[e].img, g = h.length, v = new Float32Array(g);
      for (let N = 0; N < g; N++) v[N] = h[N] * f + u;
      const m = new Uint8Array(g);
      for (let N = 0; N < g; N++) m[N] = 1;
      if (n.length > 0) for (let N = 0; N < n.length; N++) {
        const F = this.volumes[n[N]].img;
        if (F.length !== g) {
          ee.debug("Mask resolution does not match image. Skipping masking layer " + n[N]);
          continue;
        }
        for (let V = 0; V < g; V++) (F[V] === 0 || isNaN(F[V])) && (m[V] = 0);
      }
      else if (n.length < 1 && r) for (let N = 0; N < g; N++) (this.drawBitmap[N] === 0 || isNaN(this.drawBitmap[N])) && (m[N] = 0);
      else if (n.length < 1 && i) {
        m.fill(0);
        let N = -1;
        if (a[0] === s[0]) N = 0;
        else if (a[1] === s[1]) N = 1;
        else if (a[2] === s[2]) N = 2;
        else {
          console.error("Error: No constant dimension found.");
          return;
        }
        const V = [
          0,
          1,
          2
        ].filter((Pe) => Pe !== N), k = [];
        k[N] = a[N], k[V[0]] = (a[V[0]] + s[V[0]]) / 2, k[V[1]] = (a[V[1]] + s[V[1]]) / 2;
        const _ = Math.abs(s[V[0]] - a[V[0]]) / 2, K = Math.abs(s[V[1]] - a[V[1]]) / 2, Z = l.dims[1], j = l.dims[2], B = Math.max(0, Math.floor(k[V[0]] - _)), Y = Math.min(l.dims[V[0] + 1] - 1, Math.ceil(k[V[0]] + _)), X = Math.max(0, Math.floor(k[V[1]] - K)), ie = Math.min(l.dims[V[1] + 1] - 1, Math.ceil(k[V[1]] + K)), oe = k[N];
        if (oe < 0 || oe >= l.dims[N + 1]) {
          console.error("Error: Constant dimension value is out of bounds.");
          return;
        }
        for (let Pe = B; Pe <= Y; Pe++) for (let ot = X; ot <= ie; ot++) {
          const vt = [];
          vt[N] = oe, vt[V[0]] = Pe, vt[V[1]] = ot;
          const wt = (vt[V[0]] - k[V[0]]) / _, Qe = (vt[V[1]] - k[V[1]]) / K;
          if (wt * wt + Qe * Qe <= 1) {
            const G = vt[0], Se = vt[1], re = vt[2] * Z * j + Se * Z + G;
            m[re] = 1;
          }
        }
        const he = _ * c[V[0] + 1], Le = K * c[V[1] + 1];
        o = Math.PI * he * Le;
      }
      let y = 0, w = 0, C = 0, T = Number.NEGATIVE_INFINITY, S = Number.POSITIVE_INFINITY, E = 0, b = 0, D = 0;
      for (let N = 0; N < g; N++) {
        if (m[N] < 1) continue;
        const F = v[N];
        y++;
        let V = w + (F - w) / y;
        C = C + (F - w) * (F - V), w = V, F !== 0 && (E++, V = b + (F - b) / E, D = D + (F - b) * (F - V), b = V, S = Math.min(F, S), T = Math.max(F, T));
      }
      const R = Math.sqrt(C / (y - 1)), I = Math.sqrt(D / (E - 1)), O = S, L = T;
      return y !== E && (S = Math.min(0, S), T = Math.max(0, T)), {
        mean: w,
        stdev: R,
        nvox: y,
        volumeMM3: y * l.pixDims[1] * l.pixDims[2] * l.pixDims[3],
        volumeML: y * l.pixDims[1] * l.pixDims[2] * l.pixDims[3] * 1e-3,
        min: S,
        max: T,
        meanNot0: b,
        stdevNot0: I,
        nvoxNot0: E,
        minNot0: O,
        maxNot0: L,
        cal_min: this.volumes[e].cal_min,
        cal_max: this.volumes[e].cal_max,
        robust_min: this.volumes[e].robust_min,
        robust_max: this.volumes[e].robust_max,
        area: o
      };
    }
    refreshLayers(t, e) {
      var _a3;
      if (this.volumes.length < 1) return;
      this.refreshColormaps();
      const n = t.hdr;
      let r = t.img;
      t.frame4D > 0 && t.frame4D < t.nFrame4D && (r = t.img.slice(t.frame4D * t.nVox3D, (t.frame4D + 1) * t.nVox3D));
      const i = t.opacity;
      if (e > 1 && i === 0) return;
      let a = null;
      if (!this.back) throw new Error("back undefined");
      this.gl.bindVertexArray(this.unusedVAO), this.crosshairs3D && (this.crosshairs3D.mm[0] = NaN);
      let s = Tr(t.toRAS);
      if (e === 0) {
        this.volumeObject3D = GG(t, this.VOLUME_ID, this.gl), Ti(s, s), this.back.matRAS = t.matRAS, this.back.dims = t.dimsRAS, this.back.pixDims = t.pixDimsRAS;
        const { volScale: b, vox: D } = this.sliceScale(true);
        this.volScale = b, this.vox = D, this.volumeObject3D.scale = b, (n.dims[1] > this.uiData.max2D || n.dims[2] > this.uiData.max2D) && ee.error("Image dimensions exceed maximum texture size of hardware.");
        const I = n.dims[1] > this.uiData.max3D || n.dims[2] > this.uiData.max3D || n.dims[3] > this.uiData.max3D;
        if (I && n.datatypeCode === 2304 && n.dims[3] < 2) {
          ee.info(`Large RGBA image (>${this.uiData.max3D}) requires Texture2D`), this.opts.is2DSliceShader = true, a = this.rgbaTex2D(this.volumeTexture, Y0, t.dimsRAS, r);
          return;
        }
        if (I) {
          ee.info(`Large scalar image (>${this.uiData.max3D}) requires Texture2D (${n.dims[1]}\xD7${n.dims[2]}\xD7${n.dims[3]})`);
          const L = n.dims[1] * n.dims[2], N = this.frac2vox(this.scene.crosshairPos), V = Math.min(Math.max(N[2], 0), n.dims[3] - 1) * L, k = new Uint8Array(L * 4), _ = new Uint32Array(k.buffer), K = Math.floor(t.opacity * 255), Z = 255 * n.scl_slope / (t.cal_max - t.cal_min), j = 255 * (n.scl_inter - t.cal_min) / (t.cal_max - t.cal_min), B = new Uint8Array(this.colormap(t.colormap)), Y = new Uint32Array(B.buffer);
          let X = -1;
          for (let ie = 0; ie < L; ie++) {
            const oe = r[ie + V] * Z + j, he = Math.round(Math.min(255, Math.max(0, oe)));
            _[ie] = Y[he], k[X += 4] = K;
          }
          this.opts.is2DSliceShader = true, a = this.rgbaTex2D(this.volumeTexture, Y0, t.dimsRAS, k, false);
          return;
        }
        if (I && ee.warn(`dimensions exceed 3D limits ${n.dims}`), this.opts.is2DSliceShader = false, a = this.rgbaTex(this.volumeTexture, Y0, t.dimsRAS), !this.renderShader) throw new Error("renderShader undefined");
        this.renderShader.use(this.gl), this.gl.uniform3fv(this.renderShader.uniforms.texVox, D), this.gl.uniform3fv(this.renderShader.uniforms.volScale, b);
        const O = this.pickingImageShader;
        O.use(this.gl), this.gl.uniform1i(O.uniforms.volume, 0), this.gl.uniform1i(O.uniforms.colormap, 1), this.gl.uniform1i(O.uniforms.overlay, 2), this.gl.uniform3fv(O.uniforms.volScale, b), ee.debug(this.volumeObject3D);
      } else {
        ((_a3 = this.back) == null ? void 0 : _a3.dims) === void 0 && ee.error("Fatal error: Unable to render overlay: background dimensions not defined!");
        const b = this.mm2frac(t.mm000, 0, true);
        let D = this.mm2frac(t.mm100, 0, true), R = this.mm2frac(t.mm010, 0, true), I = this.mm2frac(t.mm001, 0, true);
        D = Ft(D, D, b), R = Ft(R, R, b), I = Ft(I, I, b), s = Qi(D[0], R[0], I[0], b[0], D[1], R[1], I[1], b[1], D[2], R[2], I[2], b[2], 0, 0, 0, 1), Ti(s, s), e === 1 ? (a = this.rgbaTex(this.overlayTexture, f4, this.back.dims), this.overlayTexture = a, this.overlayTextureID = a) : a = this.overlayTextureID;
      }
      const o = this.gl.createFramebuffer();
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, o), this.gl.disable(this.gl.CULL_FACE), this.gl.viewport(0, 0, this.back.dims[1], this.back.dims[2]), this.gl.disable(this.gl.BLEND);
      const l = this.gl.createTexture();
      this.gl.activeTexture(yC), this.gl.bindTexture(this.gl.TEXTURE_3D, l), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
      let c = this.orientShaderU;
      if (!n) throw new Error("hdr undefined");
      if (!r) throw new Error("img undefined");
      if (n.datatypeCode === 2) n.intent_code === 1002 && (c = this.orientShaderAtlasU), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R8UI, n.dims[1], n.dims[2], n.dims[3]), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RED_INTEGER, this.gl.UNSIGNED_BYTE, r);
      else if (n.datatypeCode === 4) c = this.orientShaderI, n.intent_code === 1002 && (c = this.orientShaderAtlasI), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16I, n.dims[1], n.dims[2], n.dims[3]), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RED_INTEGER, this.gl.SHORT, r);
      else if (n.datatypeCode === 16) this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R32F, n.dims[1], n.dims[2], n.dims[3]), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RED, this.gl.FLOAT, r), c = this.orientShaderF;
      else if (n.datatypeCode === 64) {
        let b = new Float32Array();
        b = Float32Array.from(r), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R32F, n.dims[1], n.dims[2], n.dims[3]), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RED, this.gl.FLOAT, b), c = this.orientShaderF;
      } else if (n.datatypeCode === 128) c = this.orientShaderRGBU, c.use(this.gl), this.gl.uniform1i(c.uniforms.hasAlpha, 0), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGB8UI, n.dims[1], n.dims[2], n.dims[3]), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RGB_INTEGER, this.gl.UNSIGNED_BYTE, r);
      else if (n.datatypeCode === 512) n.intent_code === 1002 && (c = this.orientShaderAtlasU), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.R16UI, n.dims[1], n.dims[2], n.dims[3]), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RED_INTEGER, this.gl.UNSIGNED_SHORT, r);
      else if (n.datatypeCode === 2304) {
        if (c = this.orientShaderRGBU, t.colormapLabel) {
          c = this.orientShaderPAQD;
          let b = true;
          for (let D = 0; D < e; D++) {
            const R = this.volumes[D].hdr.datatypeCode === 2304, I = !!this.volumes[D].colormapLabel;
            R && I && (b = false);
          }
          b ? this.paqdTexture = this.rgbaTex(this.paqdTexture, d1, this.back.dims) : ee.warn("Current version only one probabilistic atlas (PAQD) at a time"), a = this.paqdTexture, this.gl.activeTexture(yC);
        }
        c.use(this.gl), this.gl.uniform1i(c.uniforms.hasAlpha, 1), this.gl.texStorage3D(this.gl.TEXTURE_3D, 1, this.gl.RGBA8UI, n.dims[1], n.dims[2], n.dims[3]), this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RGBA_INTEGER, this.gl.UNSIGNED_BYTE, r);
      }
      t.global_min === void 0 && t.calMinMax();
      let f = null;
      if (this.gl.bindVertexArray(this.genericVAO), e > 1) {
        if (!this.back.dims) throw new Error("back.dims undefined");
        f = this.rgbaTex(f, xC, this.back.dims), this.gl.bindTexture(this.gl.TEXTURE_3D, f);
        const b = this.passThroughShader;
        b.use(this.gl), this.gl.uniform1i(b.uniforms.in3D, 2);
        for (let D = 0; D < this.back.dims[3]; D++) {
          const R = 1 / this.back.dims[3] * (D + 0.5);
          this.gl.uniform1f(b.uniforms.coordZ, R), this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, f, 0, D), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        }
      } else f = this.rgbaTex(f, xC, [
        2,
        2,
        2,
        2
      ]);
      c.use(this.gl), this.gl.activeTexture(E2);
      let u = null;
      if (t.colormapLabel !== null && t.colormapLabel.lut.length > 7) {
        const b = t.colormapLabel.max - t.colormapLabel.min + 1;
        u = this.createColormapTexture(u, 1, b), this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, b, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, t.colormapLabel.lut), this.gl.uniform1f(c.uniforms.cal_min, t.colormapLabel.min - 0.5), this.gl.uniform1f(c.uniforms.cal_max, t.colormapLabel.max + 0.5), this.gl.bindTexture(this.gl.TEXTURE_2D, u);
      } else this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture), this.gl.uniform1f(c.uniforms.cal_min, t.cal_min), this.gl.uniform1f(c.uniforms.cal_max, t.cal_max);
      "alphaThreshold" in t && (ee.warn("alphaThreshold is deprecated: use colormapType"), t.alphaThreshold === true && (t.colormapType = 2), t.alphaThreshold === false && (t.colormapType = 1), delete t.alphaThreshold);
      const h = t.colormapType !== 0 ? 1 : 0, g = t.colormapType === 2 ? 1 : 0;
      this.gl.uniform1i(c.uniforms.isAlphaThreshold, g), this.gl.uniform1i(c.uniforms.isColorbarFromZero, h), this.gl.uniform1i(c.uniforms.isAdditiveBlend, this.opts.isAdditiveBlend ? 1 : 0);
      let v = Number.POSITIVE_INFINITY, m = Number.NEGATIVE_INFINITY;
      if (t.colormapNegative.length > 0 && (v = Math.min(-t.cal_min, -t.cal_max), m = Math.max(-t.cal_min, -t.cal_max), isFinite(t.cal_minNeg) && isFinite(t.cal_maxNeg) && (v = Math.min(t.cal_minNeg, t.cal_maxNeg), m = Math.max(t.cal_minNeg, t.cal_maxNeg))), e > 0 && this.overlayOutlineWidth > 0) {
        const b = t.cal_min, D = t.cal_max;
        let R = Math.min(b, D) <= 0 && Math.max(b, D) >= 0;
        !R && v < m && (R = v <= 0 && m >= 0), R && ee.error("issue1139: do not use overlayOutlineWidth when thresholds cross or touch zero");
      }
      if (!c) throw new Error("orientShader undefined");
      this.gl.uniform1f(c.uniforms.layer ?? null, e), this.gl.uniform1f(c.uniforms.cal_minNeg ?? null, v), this.gl.uniform1f(c.uniforms.cal_maxNeg ?? null, m), this.gl.bindTexture(this.gl.TEXTURE_3D, l), this.gl.uniform1i(c.uniforms.intensityVol ?? null, 9), this.gl.uniform1i(c.uniforms.blend3D ?? null, 10), this.gl.uniform1i(c.uniforms.colormap ?? null, 1), this.gl.uniform1f(c.uniforms.scl_inter ?? null, n.scl_inter), this.gl.uniform1f(c.uniforms.scl_slope ?? null, n.scl_slope), this.gl.uniform1f(c.uniforms.opacity ?? null, i), this.gl.uniform1i(c.uniforms.modulationVol ?? null, 7);
      let y = null;
      if (t.modulationImage !== null && t.modulationImage >= 0 && t.modulationImage < this.volumes.length) {
        ee.debug("modulating", this.volumes);
        const b = this.volumes[t.modulationImage].hdr;
        if (b.dims[1] === n.dims[1] && b.dims[2] === n.dims[2] && b.dims[3] === n.dims[3]) {
          t.modulateAlpha ? (this.gl.uniform1i(c.uniforms.modulation, 2), this.gl.uniform1f(c.uniforms.opacity, 1)) : this.gl.uniform1i(c.uniforms.modulation, 1), y = this.r8Tex(y, this.gl.TEXTURE7, n.dims, true), this.gl.activeTexture(this.gl.TEXTURE7), this.gl.bindTexture(this.gl.TEXTURE_3D, y);
          const D = n.dims[1] * n.dims[2] * n.dims[3], R = new Uint8Array(D), I = this.volumes[t.modulationImage].cal_min, O = 1 / (this.volumes[t.modulationImage].cal_max - I), L = this.volumes[t.modulationImage].img.buffer;
          let N = new Uint8Array(L);
          switch (b.datatypeCode) {
            case 4:
              N = new Int16Array(L);
              break;
            case 16:
              N = new Float32Array(L);
              break;
            case 64:
              N = new Float64Array(L);
              break;
            case 128:
              N = new Uint8Array(L);
              break;
            case 512:
              N = new Uint16Array(L);
              break;
          }
          ee.debug(this.volumes[t.modulationImage]);
          const F = this.volumes[t.modulationImage].colormapNegative.length > 0;
          let V = this.volumes[t.modulationImage].cal_min, k = this.volumes[t.modulationImage].cal_max;
          isFinite(this.volumes[t.modulationImage].cal_minNeg) && isFinite(this.volumes[t.modulationImage].cal_maxNeg) && (V = this.volumes[t.modulationImage].cal_minNeg, k = this.volumes[t.modulationImage].cal_minNeg), V = Math.abs(V), k = Math.abs(k), V > k && ([V, k] = [
            k,
            V
          ]);
          const _ = 1 / (k - V);
          let K = Math.abs(t.modulateAlpha);
          K = Math.max(K, 1);
          const Z = this.volumes[t.modulationImage].frame4D * D;
          for (let j = 0; j < D; j++) {
            const B = N[j + Z] * b.scl_slope + b.scl_inter;
            let Y = (B - I) * O;
            F && B < 0 && (Y = (Math.abs(B) - V) * _), Y = Math.min(Math.max(Y, 0), 1), Y = Math.pow(Y, K) * 255, R[j] = Y;
          }
          this.gl.texSubImage3D(this.gl.TEXTURE_3D, 0, 0, 0, 0, n.dims[1], n.dims[2], n.dims[3], this.gl.RED, this.gl.UNSIGNED_BYTE, R);
        } else ee.debug("Modulation image dimensions do not match target");
      } else this.gl.uniform1i(c.uniforms.modulation, 0);
      if (this.gl.uniformMatrix4fv(c.uniforms.mtx, false, s), !this.back.dims) throw new Error("back.dims undefined");
      let w = 0;
      n.intent_code === 1002 && (w = this.opts.atlasOutline, this.gl.uniform1ui(c.uniforms.activeIndex, this.opts.atlasActiveIndex | 0)), this.gl.uniform4fv(c.uniforms.xyzaFrac, [
        1 / this.back.dims[1],
        1 / this.back.dims[2],
        1 / this.back.dims[3],
        w
      ]), ee.debug("back dims: ", this.back.dims);
      for (let b = 0; b < this.back.dims[3]; b++) {
        const D = 1 / this.back.dims[3] * (b + 0.5);
        this.gl.uniform1f(c.uniforms.coordZ, D), this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, a, 0, b), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      }
      if (this.gl.bindVertexArray(this.unusedVAO), this.gl.deleteTexture(l), this.gl.deleteTexture(y), this.gl.deleteTexture(f), this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.deleteFramebuffer(o), e === 0 && (this.volumeTexture = a, this.gradientTextureAmount > 0 && !this.useCustomGradientTexture ? (this.gradientGL(n), this.gl.bindVertexArray(this.genericVAO)) : this.gradientTextureAmount <= 0 && (this.gradientTexture !== null && this.gl.deleteTexture(this.gradientTexture), this.gradientTexture = null)), !this.renderShader) throw new Error("renderShader undefined");
      this.renderShader.use(this.gl);
      const C = this.sliceScale(true), T = C.vox, S = C.volScale;
      if (this.gl.uniform1f(this.renderShader.uniforms.overlays, this.overlays.length), this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor, this.opts.clipPlaneColor), this.gl.uniform1f(this.renderShader.uniforms.clipThick, this.opts.clipThick), this.gl.uniform3fv(this.renderShader.uniforms.clipLo, this.opts.clipVolumeLow), this.gl.uniform3fv(this.renderShader.uniforms.clipHi, this.opts.clipVolumeHigh), this.gl.uniform1f(this.renderShader.uniforms.backOpacity, this.volumes[0].opacity), this.gl.uniform1f(this.renderShader.uniforms.renderOverlayBlend, this.opts.renderOverlayBlend), this.gl.uniform4fv(this.renderShader.uniforms.clipPlane, this.scene.clipPlane), this.gl.uniform3fv(this.renderShader.uniforms.texVox, T), this.gl.uniform3fv(this.renderShader.uniforms.volScale, S), !this.pickingImageShader) throw new Error("pickingImageShader undefined");
      this.pickingImageShader.use(this.gl), this.gl.uniform1f(this.pickingImageShader.uniforms.overlays, this.overlays.length), this.gl.uniform3fv(this.pickingImageShader.uniforms.texVox, T), this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo, this.opts.clipVolumeLow), this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi, this.opts.clipVolumeHigh);
      let E = this.sliceMMShader;
      if (this.opts.is2DSliceShader && (E = this.slice2DShader), this.opts.isV1SliceShader && (E = this.sliceV1Shader), this.customSliceShader && (E = this.customSliceShader), !E) throw new Error("slice shader undefined");
      E.use(this.gl), this.gl.uniform1f(E.uniforms.overlays, this.overlays.length), this.gl.uniform1f(E.uniforms.drawOpacity, this.drawOpacity), u !== null && (this.gl.deleteTexture(u), this.gl.activeTexture(E2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture)), this.gl.uniform1i(E.uniforms.drawing, 7), this.gl.activeTexture(sl), this.opts.is2DSliceShader ? this.gl.bindTexture(this.gl.TEXTURE_2D, this.drawTexture) : this.gl.bindTexture(this.gl.TEXTURE_3D, this.drawTexture), this.gl.uniform4fv(E.uniforms.paqdUniforms, this.opts.paqdUniforms), this.gl.uniform1i(E.uniforms.paqd, 8), this.gl.activeTexture(d1), this.gl.bindTexture(this.gl.TEXTURE_3D, this.paqdTexture), this.updateInterpolation(e);
    }
    colormaps() {
      return Mn.colormaps();
    }
    addColormap(t, e) {
      Mn.addColormap(t, e);
    }
    setColormap(t, e) {
      const n = this.getVolumeIndexByID(t);
      this.volumes[n].colormap = e, this.updateGLVolume();
    }
    idx(t, e, n, r) {
      return n * r[0] * r[1] + e * r[0] + t;
    }
    check_previous_slice(t, e, n, r, i, a, s, o) {
      const l = new Uint32Array(27);
      let c = 0;
      if (!i) return 0;
      const f = t[this.idx(n, r, i, a)];
      if (s >= 6) {
        const u = this.idx(n, r, i - 1, a);
        f === t[u] && (l[c++] = e[u]);
      }
      if (s >= 18) {
        if (n) {
          const u = this.idx(n - 1, r, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
        if (r) {
          const u = this.idx(n, r - 1, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
        if (n < a[0] - 1) {
          const u = this.idx(n + 1, r, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
        if (r < a[1] - 1) {
          const u = this.idx(n, r + 1, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
      }
      if (s === 26) {
        if (n && r) {
          const u = this.idx(n - 1, r - 1, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
        if (n < a[0] - 1 && r) {
          const u = this.idx(n + 1, r - 1, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
        if (n && r < a[1] - 1) {
          const u = this.idx(n - 1, r + 1, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
        if (n < a[0] - 1 && r < a[1] - 1) {
          const u = this.idx(n + 1, r + 1, i - 1, a);
          f === t[u] && (l[c++] = e[u]);
        }
      }
      return c ? (this.fill_tratab(o, l, c), l[0]) : 0;
    }
    do_initial_labelling(t, e, n) {
      let r = 1;
      const i = 8192;
      let a = i, s = new Uint32Array(a).fill(0);
      const o = new Uint32Array(e[0] * e[1] * e[2]).fill(0), l = new Uint32Array(27);
      for (let c = 0; c < e[2]; c++) for (let f = 0; f < e[1]; f++) for (let u = 0; u < e[0]; u++) {
        let h = 0;
        const g = t[this.idx(u, f, c, e)];
        if (g !== 0) {
          if (l[0] = this.check_previous_slice(t, o, u, f, c, e, n, s), l[0] && (h += 1), n >= 6) {
            if (u) {
              const v = this.idx(u - 1, f, c, e);
              g === t[v] && (l[h++] = o[v]);
            }
            if (f) {
              const v = this.idx(u, f - 1, c, e);
              g === t[v] && (l[h++] = o[v]);
            }
          }
          if (n >= 18) {
            if (f && u) {
              const v = this.idx(u - 1, f - 1, c, e);
              g === t[v] && (l[h++] = o[v]);
            }
            if (f && u < e[0] - 1) {
              const v = this.idx(u + 1, f - 1, c, e);
              g === t[v] && (l[h++] = o[v]);
            }
          }
          if (h) o[this.idx(u, f, c, e)] = l[0], this.fill_tratab(s, l, h);
          else {
            if (o[this.idx(u, f, c, e)] = r, r >= a) {
              a += i;
              const v = new Uint32Array(a);
              v.set(s), s = v;
            }
            s[r - 1] = r, r++;
          }
        }
      }
      for (let c = 0; c < r - 1; c++) {
        let f = c;
        for (; s[f] !== f + 1; ) f = s[f] - 1;
        s[c] = f + 1;
      }
      return [
        r - 1,
        s,
        o
      ];
    }
    fill_tratab(t, e, n) {
      let r = 0;
      const i = new Uint32Array(n + 5).fill(0);
      let s = 2147483647;
      for (let o = 0; o < n; o++) {
        let l = e[o];
        for (r = 0; t[l - 1] !== l; ) if (l = t[l - 1], r++, r > 100) {
          ee.info(`
Ooh no!!`);
          break;
        }
        i[o] = l, s = Math.min(s, l);
      }
      for (let o = 0; o < n; o++) t[i[o] - 1] = s;
    }
    translate_labels(t, e, n, r) {
      const i = e[0] * e[1] * e[2];
      let a = 0;
      const s = new Uint32Array(i).fill(0);
      for (let c = 0; c < r; c++) a = Math.max(a, n[c]);
      const o = new Uint32Array(a).fill(0);
      let l = 0;
      for (let c = 0; c < i; c++) t[c] && (o[n[t[c] - 1] - 1] || (l += 1, o[n[t[c] - 1] - 1] = l), s[c] = o[n[t[c] - 1] - 1]);
      return [
        l,
        s
      ];
    }
    largest_original_cluster_labels(t, e, n) {
      const r = t.length, i = new Uint32Array(e + 1).fill(0), a = new Uint32Array(e + 1).fill(0);
      for (let l = 0; l < r; l++) {
        const c = t[l], f = n[l];
        i[f] = c, a[f]++;
      }
      let s = 0;
      for (let l = 0; l < e + 1; l++) {
        const c = i[l];
        s = Math.max(s, c);
        for (let f = 0; f < e + 1; f++) f !== l && c === i[f] && (a[l] < a[f] || a[l] === a[f] && l < f) && (i[l] = 0);
      }
      const o = new Uint32Array(r).fill(0);
      for (let l = 0; l < r; l++) o[l] = i[n[l]];
      return [
        s,
        o
      ];
    }
    bwlabel(t, e, n = 26, r = false, i = false) {
      const a = Date.now(), s = e[0] * e[1] * e[2], o = new Uint32Array(s).fill(0);
      if (![
        6,
        18,
        26
      ].includes(n)) return ee.info("bwlabel: conn must be 6, 18 or 26."), [
        0,
        o
      ];
      if (e[0] < 2 || e[1] < 2 || e[2] < 1) return ee.info("bwlabel: img must be 2 or 3-dimensional"), [
        0,
        o
      ];
      if (r) for (let g = 0; g < s; g++) t[g] !== 0 && (o[g] = 1);
      else o.set(t);
      let [l, c, f] = this.do_initial_labelling(o, e, n);
      c === void 0 && (c = new Uint32Array());
      const [u, h] = this.translate_labels(f, e, c, l);
      if (ee.info(n + " neighbor clustering into " + u + " regions in " + (Date.now() - a) + "ms"), i) {
        const [g, v] = this.largest_original_cluster_labels(o, u, h);
        return [
          g,
          v
        ];
      }
      return [
        u,
        h
      ];
    }
    async createConnectedLabelImage(t, e = 26, n = false, r = false) {
      var _a3, _b3;
      const i = this.getVolumeIndexByID(t), a = Uint32Array.from(((_a3 = this.volumes[i].dims) == null ? void 0 : _a3.slice(1, 4)) ?? []), s = Uint32Array.from(((_b3 = this.volumes[i].img) == null ? void 0 : _b3.slice()) ?? []), [o, l] = this.bwlabel(s, a, e, n, r), c = this.volumes[i].clone();
      c.opacity = 0.5, c.colormap = "random";
      for (let f = 0; f < c.img.length; f++) c.img[f] = l[f];
      return c.cal_min = 0, c.cal_max = o, c;
    }
    async scalecropUint8(t, e = 0, n = 255, r, i) {
      const a = t.length, s = new Uint8Array(a);
      for (let o = 0; o < a; o++) {
        let l = t[o];
        l = e + i * (l - r), l = Math.max(l, e), l = Math.min(l, n), s[o] = l;
      }
      return s;
    }
    async scalecropFloat32(t, e = 0, n = 1, r, i) {
      const a = t.length, s = new Float32Array(a);
      for (let o = 0; o < a; o++) {
        let l = t[o];
        l = e + i * (l - r), l = Math.max(l, e), l = Math.min(l, n), s[o] = l;
      }
      return s;
    }
    getScale(t, e = 0, n = 255, r = 0, i = 0.999) {
      let a = t.global_min, s = t.global_max;
      if (t.hdr.datatypeCode === 2) return [
        a,
        1
      ];
      if ((!isFinite(r) || !isFinite(i)) && isFinite(t.cal_min) && isFinite(t.cal_max) && t.cal_max > t.cal_min) {
        a = t.cal_min, s = t.cal_max;
        const C = (n - e) / (s - a);
        return ee.info(" Robust Rescale:  min: " + a + "  max: " + s + " scale: " + C), [
          a,
          C
        ];
      }
      let o = t.img;
      const l = t.hdr.dims[1] * t.hdr.dims[2] * t.hdr.dims[3];
      if (t.hdr.scl_slope !== 1 || t.hdr.scl_inter !== 0) {
        const C = t.img;
        o = new Float32Array(t.img.length);
        for (let T = 0; T < l; T++) o[T] = C[T] * t.hdr.scl_slope + t.hdr.scl_inter;
      }
      if (a < 0 && ee.warn("WARNING: Input image has value(s) below 0.0 !"), ee.info(" Input:    min: " + a + "  max: " + s), r === 0 && i === 1) return [
        a,
        1
      ];
      let c = 0;
      for (let C = 0; C < l; C++) Math.abs(o[C]) >= 1e-15 && c++;
      const f = 1e3, u = (s - a) / f, h = new Array(f).fill(0);
      for (let C = 0; C < l; C++) {
        const T = o[C];
        let S = Math.floor((T - a) / u);
        S = Math.min(S, f - 1), h[S]++;
      }
      const g = new Array(f).fill(0);
      g[0] = h[0];
      for (let C = 1; C < f; C++) g[C] = g[C - 1] + h[C];
      let v = Math.floor(r * l), m = 0;
      for (; m < f && !(g[m] >= v); ) m++;
      const y = a;
      for (a = m * u + y, v = l - Math.floor((1 - i) * c), m = 0; m < f - 1 && !(g[m + 1] >= v); ) m++;
      s = m * u + y;
      let w = 1;
      return a !== s && (w = (n - e) / (s - a)), ee.info(" Rescale:  min: " + a + "  max: " + s + " scale: " + w), [
        a,
        w
      ];
    }
    conformVox2Vox(t, e, n = 256, r = 1, i = false) {
      const a = e.flat(), s = Qi(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]), o = zn(t[1] / 2, t[2] / 2, t[3] / 2, 1), l = Rs(), c = Yt();
      _i(c, s), Zr(l, o, c);
      const f = Ue(l[0], l[1], l[2]), u = Ue(r, r, r);
      let h = Qi(-1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
      i && (h = Qi(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)), _i(h, h);
      const g = zn(n, n, n, 1), v = Yt();
      Vv(v, h, u);
      const m = zn(g[0], g[1], g[2], 1);
      Zr(m, m, v), O_(m, m, 0.5);
      const y = He();
      Ft(y, f, Ue(m[0], m[1], m[2]));
      const w = Yt();
      _i(w, v), w[3] = y[0], w[7] = y[1], w[11] = y[2];
      const C = Yt();
      Ti(C, w);
      const T = Yt();
      ME(T, s, C);
      const S = Yt();
      return Ti(S, T), [
        w,
        T,
        S
      ];
    }
    async createNiftiArray(t = [
      256,
      256,
      256
    ], e = [
      1,
      1,
      1
    ], n = [
      1,
      0,
      0,
      -128,
      0,
      1,
      0,
      -128,
      0,
      0,
      1,
      -128,
      0,
      0,
      0,
      1
    ], r = 2, i = new Uint8Array()) {
      return await Ci.createNiftiArray(t, e, n, r, i);
    }
    async niftiArray2NVImage(t = new Uint8Array()) {
      return await Ci.loadFromUrl({
        url: t
      });
    }
    async loadFromUrl(t) {
      return await Ci.loadFromUrl({
        url: t
      });
    }
    async conform(t, e = false, n = true, r = false, i = false) {
      const o = this.conformVox2Vox(t.hdr.dims, t.hdr.affine.flat(), 256, 1, e), l = o[0], c = o[2], f = 256 * 256 * 256, u = new Float32Array(f), h = new Float32Array(t.img), g = t.hdr.dims[1] * t.hdr.dims[2] * t.hdr.dims[3];
      if (t.hdr.scl_slope !== 1 || t.hdr.scl_inter !== 0) for (let O = 0; O < g; O++) h[O] = h[O] * t.hdr.scl_slope + t.hdr.scl_inter;
      const v = t.hdr.dims[1], m = t.hdr.dims[2], y = t.hdr.dims[3], w = v * m;
      let C = -1;
      function T(O, L, N) {
        return O + L * v + N * w;
      }
      const S = c[0], E = c[4], b = c[8];
      if (n) for (let O = 0; O < 256; O++) for (let L = 0; L < 256; L++) {
        const N = L * c[1] + O * c[2] + c[3], F = L * c[5] + O * c[6] + c[7], V = L * c[9] + O * c[10] + c[11];
        for (let k = 0; k < 256; k++) {
          const _ = k * S + N, K = k * E + F, Z = k * b + V, j = Math.floor(_), B = Math.floor(K), Y = Math.floor(Z);
          if (C++, j < 0 || B < 0 || Y < 0) continue;
          const X = Math.ceil(_), ie = Math.ceil(K), oe = Math.ceil(Z);
          if (X >= v || ie >= m || oe >= y) continue;
          const he = _ - j, Le = K - B, Je = Z - Y, Pe = 1 - he, ot = 1 - Le, vt = 1 - Je, wt = T(j, B, Y);
          let Qe = 0;
          Qe += h[wt] * Pe * ot * vt, Qe += h[wt + w] * Pe * ot * Je, Qe += h[wt + v] * Pe * Le * vt, Qe += h[wt + v + w] * Pe * Le * Je, Qe += h[wt + 1] * he * ot * vt, Qe += h[wt + 1 + w] * he * ot * Je, Qe += h[wt + 1 + v] * he * Le * vt, Qe += h[wt + 1 + v + w] * he * Le * Je, u[C] = Qe;
        }
      }
      else for (let O = 0; O < 256; O++) for (let L = 0; L < 256; L++) {
        const N = L * c[1] + O * c[2] + c[3], F = L * c[5] + O * c[6] + c[7], V = L * c[9] + O * c[10] + c[11];
        for (let k = 0; k < 256; k++) {
          const _ = Math.round(k * S + N), K = Math.round(k * E + F), Z = Math.round(k * b + V);
          C++, !(_ < 0 || K < 0 || Z < 0) && (_ >= v || K >= m || Z >= y || (u[C] = h[T(_, K, Z)]));
        }
      }
      let D = 0;
      i && (D = NaN);
      let R = new Uint8Array();
      if (r) {
        const O = await this.getScale(t, 0, 1, D), L = await this.scalecropFloat32(u, 0, 1, O[0], O[1]);
        R = await this.createNiftiArray([
          256,
          256,
          256
        ], [
          1,
          1,
          1
        ], Array.from(l), 16, new Uint8Array(L.buffer));
      } else {
        const O = await this.getScale(t, 0, 255, D), L = await this.scalecropUint8(u, 0, 255, O[0], O[1]);
        R = await this.createNiftiArray([
          256,
          256,
          256
        ], [
          1,
          1,
          1
        ], Array.from(l), 2, L);
      }
      return await this.niftiArray2NVImage(R);
    }
    setRenderDrawAmbientOcclusion(t) {
      if (!this.renderShader) throw new Error("renderShader undefined");
      this.renderDrawAmbientOcclusion = t, this.renderShader.use(this.gl), this.gl.uniform1fv(this.renderShader.uniforms.renderDrawAmbientOcclusion, [
        this.renderDrawAmbientOcclusion,
        1
      ]), this.drawScene();
    }
    setColorMap(t, e) {
      this.setColormap(t, e);
    }
    setColormapNegative(t, e) {
      const n = this.getVolumeIndexByID(t);
      this.volumes[n].colormapNegative = e, this.updateGLVolume();
    }
    setModulationImage(t, e, n = 0) {
      const r = this.getVolumeIndexByID(t);
      let i = null;
      e.length > 0 && (i = this.getVolumeIndexByID(e)), this.volumes[r].modulationImage = i, this.volumes[r].modulateAlpha = n, this.updateGLVolume();
    }
    setGamma(t = 1) {
      this.scene.gamma = t, Mn.gamma = t, this.updateGLVolume();
    }
    async loadDeferred4DVolumes(t) {
      const e = this.getVolumeIndexByID(t), n = this.volumes[e];
      if (n.nTotalFrame4D <= n.nFrame4D) return;
      n.nTotalFrame4D = n.nFrame4D;
      let r;
      n.fileObject ? r = await Ci.loadFromFile({
        file: n.fileObject
      }) : r = await Ci.loadFromUrl({
        url: n.url
      }), r && (n.img = r.img.slice(), n.nTotalFrame4D = r.nTotalFrame4D, n.nFrame4D = r.nFrame4D, this.updateGLVolume());
    }
    setFrame4D(t, e) {
      const n = this.getVolumeIndexByID(t), r = this.volumes[n];
      e > r.nFrame4D - 1 && (e = r.nFrame4D - 1), e < 0 && (e = 0), e !== r.frame4D && (r.frame4D = e, this.updateGLVolume(), this.onFrameChange(r, e), this.createOnLocationChange());
    }
    getFrame4D(t) {
      const e = this.getVolumeIndexByID(t);
      return this.volumes[e].frame4D;
    }
    colormapFromKey(t) {
      return Mn.colormapFromKey(t);
    }
    colormap(t = "", e = false) {
      return Mn.colormap(t, e);
    }
    createColormapTexture(t = null, e = 0, n = 256) {
      return t !== null && this.gl.deleteTexture(t), e < 1 || n < 1 ? null : (t = this.gl.createTexture(), this.gl.activeTexture(E2), this.gl.bindTexture(this.gl.TEXTURE_2D, t), this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, n, e), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1), t);
    }
    addColormapList(t = "", e = NaN, n = NaN, r = false, i = false, a = true, s = false) {
      t.length < 1 && (a = false), this.colormapLists.push({
        name: t,
        min: e,
        max: n,
        isColorbarFromZero: r,
        negative: i,
        visible: a,
        invert: s
      });
    }
    refreshColormaps() {
      if (this.colormapLists = [], this.volumes.length < 1 && this.meshes.length < 1) return;
      const t = this.volumes.length;
      if (t > 0) for (let a = 0; a < t; a++) {
        const s = this.volumes[a], o = o4(s.cal_min, s.cal_max, s.cal_minNeg, s.cal_maxNeg), l = s.colormapType !== 0;
        this.addColormapList(s.colormapNegative, o[0], o[1], l, true, s.colorbarVisible, s.colormapInvert), this.addColormapList(s.colormap, s.cal_min, s.cal_max, l, false, s.colorbarVisible, s.colormapInvert);
      }
      const e = this.meshes.length;
      if (e > 0) for (let a = 0; a < e; a++) {
        const s = this.meshes[a];
        if (!s.colorbarVisible) continue;
        const o = s.layers.length;
        if ("edgeColormap" in s && "edges" in s && s.edges !== void 0) {
          const l = o4(s.edgeMin, s.edgeMax, NaN, NaN);
          this.addColormapList(s.edgeColormapNegative, l[0], l[1], false, true, true, s.colormapInvert), this.addColormapList(s.edgeColormap, s.edgeMin, s.edgeMax, false, false, true, s.colormapInvert);
        }
        if (!(o < 1)) for (let l = 0; l < o; l++) {
          const c = this.meshes[a].layers[l];
          if (!c.colorbarVisible || c.colormap.length < 1) continue;
          const f = c.colormapType !== 0;
          if (c.useNegativeCmap) {
            const u = o4(c.cal_min, c.cal_max, c.cal_minNeg, c.cal_maxNeg);
            this.addColormapList(c.colormapNegative, u[0], u[1], f, true, true, c.colormapInvert);
          }
          this.addColormapList(c.colormap, c.cal_min, c.cal_max, f, false, true, c.colormapInvert);
        }
      }
      const n = this.colormapLists.length;
      if (n < 1) return;
      this.colormapTexture = this.createColormapTexture(this.colormapTexture, n + 1);
      let r = new Uint8ClampedArray();
      function i(a) {
        const s = new Uint8ClampedArray(r.length + a.length);
        s.set(r), s.set(a, r.length), r = s;
      }
      for (let a = 0; a < n; a++) i(Array.from(this.colormap(this.colormapLists[a].name, this.colormapLists[a].invert)));
      return i(Array.from(this.drawLut.lut)), this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, 256, n + 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, r), this;
    }
    sliceScale(t = false) {
      var _a3;
      let e = this.screenFieldOfViewMM(0);
      t && (e = this.screenFieldOfViewVox(0));
      const n = Math.max(e[0], Math.max(e[1], e[2])), r = [
        e[0] / n,
        e[1] / n,
        e[2] / n
      ];
      if (!((_a3 = this.back) == null ? void 0 : _a3.dims)) throw new Error("back.dims undefined");
      const i = [
        this.back.dims[1],
        this.back.dims[2],
        this.back.dims[3]
      ];
      return {
        volScale: r,
        vox: i,
        longestAxis: n,
        dimsMM: e
      };
    }
    tileIndex(t, e) {
      for (let n = 0; n < this.screenSlices.length; n++) {
        const r = this.screenSlices[n].leftTopWidthHeight;
        if (t > r[0] && e > r[1] && t < r[0] + r[2] && e < r[1] + r[3]) return n;
      }
      return -1;
    }
    inRenderTile(t, e) {
      const n = this.tileIndex(t, e);
      return n >= 0 && this.screenSlices[n].axCorSag === 4 ? n : -1;
    }
    sliceScroll3D(t = 0) {
      if (t !== 0) {
        if (this.volumes.length > 0 && this.scene.clipPlaneDepthAziElev[0] < 1.8) {
          const e = this.scene.clipPlaneDepthAziElev.slice();
          return t > 0 && (e[0] = Math.min(1.5, e[0] + 0.025)), t < 0 && (e[0] = Math.max(-1.5, e[0] - 0.025)), e[0] !== this.scene.clipPlaneDepthAziElev[0] ? (this.scene.clipPlaneDepthAziElev = e, this.setClipPlane(this.scene.clipPlaneDepthAziElev)) : void 0;
        }
        t > 0 && (this.scene.volScaleMultiplier = Math.min(2, this.scene.volScaleMultiplier * 1.1)), t < 0 && (this.scene.volScaleMultiplier = Math.max(0.5, this.scene.volScaleMultiplier * 0.9)), this.drawScene();
      }
    }
    deleteThumbnail() {
      this.bmpTexture && (this.gl.deleteTexture(this.bmpTexture), this.bmpTexture = null, this.thumbnailVisible = false);
    }
    inGraphTile(t, e) {
      if (this.graph.opacity <= 0 || this.volumes.length < 1 || this.volumes[0].nFrame4D < 1 || !this.graph.plotLTWH || this.graph.plotLTWH[2] < 1 || this.graph.plotLTWH[3] < 1) return false;
      const n = [
        (t - this.graph.LTWH[0]) / this.graph.LTWH[2],
        (e - this.graph.LTWH[1]) / this.graph.LTWH[3]
      ];
      return n[0] > 0 && n[1] > 0 && n[0] <= 1 && n[1] <= 1;
    }
    updateBitmapFromClickToSegment() {
      if (this.clickToSegmentGrowingBitmap === null || this.drawBitmap === null || this.clickToSegmentGrowingBitmap.length !== this.drawBitmap.length) return;
      const t = this.drawBitmap.length;
      for (let e = 0; e < t; e++) this.drawBitmap[e] = this.clickToSegmentGrowingBitmap[e];
    }
    sumBitmap(t) {
      let e = 0;
      for (let n = 0; n < t.length; n++) e += t[n];
      return e;
    }
    doClickToSegment(t) {
      const { tileIndex: e } = t;
      if (e < 0 || e >= this.screenSlices.length) {
        ee.warn(`Invalid tileIndex ${e} received in doClickToSegment.`);
        return;
      }
      const n = this.screenSlices[e].axCorSag;
      if (n > 2) {
        ee.warn("ClickToSegment attempted on non-2D slice tile.");
        return;
      }
      const r = this.screenXY2TextureFrac(this.clickToSegmentXY[0], this.clickToSegmentXY[1], e, false);
      if (r[0] < 0) {
        ee.debug("Click location outside valid texture fraction for the tile.");
        return;
      }
      const i = this.frac2vox(r), a = this.opts.clickToSegmentPercent;
      let s = this.back.getValue(i[0], i[1], i[2]);
      this.opts.clickToSegmentAutoIntensity && (a !== 0 && (s === 0 && (s = 0.01), this.opts.clickToSegmentIntensityMax = s * (1 + a), this.opts.clickToSegmentIntensityMin = s * (1 - a)), s > (this.back.cal_min + this.back.cal_max) * 0.5 ? this.opts.clickToSegmentBright = true : this.opts.clickToSegmentBright = false);
      const o = this.opts.clickToSegmentBright ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      this.drawPenAxCorSag = n;
      const l = this.clickToSegmentIsGrowing ? this.clickToSegmentGrowingBitmap : this.drawBitmap;
      if (!l) {
        if (ee.error("Target bitmap for flood fill is null."), this.clickToSegmentIsGrowing) {
          if (this.drawBitmap || this.createEmptyDrawing(), !this.drawBitmap) return;
          this.clickToSegmentGrowingBitmap = this.drawBitmap.slice();
        } else if (this.createEmptyDrawing(), !this.drawBitmap) return;
        ee.warn("Initialized missing bitmap in doClickToSegment.");
      }
      if (this.drawFloodFill([
        i[0],
        i[1],
        i[2]
      ], this.opts.penValue, o, this.opts.clickToSegmentIntensityMin, this.opts.clickToSegmentIntensityMax, this.opts.floodFillNeighbors, this.opts.clickToSegmentMaxDistanceMM, this.opts.clickToSegmentIs2D, l), !this.clickToSegmentIsGrowing && (ee.debug("Applying clickToSegment mask to drawBitmap."), this.drawBitmap ? (this.refreshDrawing(false, false), this.drawScene()) : ee.error("Cannot refresh drawing after click-to-segment apply, drawBitmap is null."), this.drawBitmap)) {
        const c = this.getDescriptives({
          layer: 0,
          masks: [],
          drawingIsMask: true
        });
        this.onClickToSegment({
          mL: c.volumeML,
          mm3: c.volumeMM3
        });
      }
      this.createOnLocationChange(n);
    }
    mouseClick(t, e, n = 0, r = true) {
      if (t *= this.uiData.dpr, e *= this.uiData.dpr, this.canvas.focus(), this.thumbnailVisible) {
        this.thumbnailVisible = false, Promise.all([
          this.loadVolumes(this.deferredVolumes),
          this.loadMeshes(this.deferredMeshes)
        ]).catch((i) => {
          throw i;
        });
        return;
      }
      if (this.inGraphTile(t, e)) {
        if (!this.graph.plotLTWH) throw new Error("plotLTWH undefined");
        const i = [
          (t - this.graph.plotLTWH[0]) / this.graph.plotLTWH[2],
          (e - this.graph.plotLTWH[1]) / this.graph.plotLTWH[3]
        ];
        if (i[0] > 0 && i[1] > 0 && i[0] <= 1 && i[1] <= 1) {
          const a = Math.round(i[0] * (this.volumes[0].nFrame4D - 1));
          this.setFrame4D(this.volumes[0].id, a);
          return;
        }
        i[0] > 0.5 && i[1] > 1 && this.loadDeferred4DVolumes(this.volumes[0].id).catch((a) => {
          throw a;
        });
        return;
      }
      if (this.inRenderTile(t, e) >= 0) {
        this.sliceScroll3D(n), this.drawScene();
        return;
      }
      if (!(this.screenSlices.length < 1 || this.gl.canvas.height < 1 || this.gl.canvas.width < 1)) for (let i = 0; i < this.screenSlices.length; i++) {
        const a = this.screenSlices[i].axCorSag;
        if (this.drawPenAxCorSag >= 0 && this.drawPenAxCorSag !== a || a > 2 && !this.opts.clickToSegment && n === 0) continue;
        const s = this.screenXY2TextureFrac(t, e, i, true);
        if (!(s[0] < 0)) {
          if (n !== 0 || !r) {
            if (!r) {
              a <= 2 && (this.scene.crosshairPos[2 - a] = n, this.drawScene(), this.createOnLocationChange(a));
              return;
            }
            const o = n < 0 ? -1 : 1, l = [
              0,
              0,
              0
            ];
            a <= 2 && (l[2 - a] = o, this.moveCrosshairInVox(l[0], l[1], l[2]));
            return;
          }
          if (this.opts.isForceMouseClickToVoxelCenters ? this.scene.crosshairPos = ki(this.vox2frac(this.frac2vox(s))) : this.scene.crosshairPos = ki(s), this.opts.drawingEnabled) {
            const o = this.frac2vox(this.scene.crosshairPos);
            if (!isFinite(this.opts.penValue) || this.opts.penValue < 0 || Object.is(this.opts.penValue, -0)) {
              let l = 0, c = Math.abs(this.opts.penValue);
              const f = true;
              Object.is(this.opts.penValue, -0) ? (l = 0, c = 0, ee.debug("Erase Cluster selected")) : (l = this.opts.penValue, ee.debug("Intensity Grow selected", l)), this.drawFloodFill(o, c, l, NaN, NaN, this.opts.floodFillNeighbors, Number.POSITIVE_INFINITY, false, this.drawBitmap, f), this.drawScene(), this.createOnLocationChange(a);
              return;
            } else if (this.opts.clickToSegment) {
              a <= 2 && (this.clickToSegmentIsGrowing = false, this.doClickToSegment({
                x: this.clickToSegmentXY[0],
                y: this.clickToSegmentXY[1],
                tileIndex: i
              })), this.createOnLocationChange(a);
              return;
            } else if (this.opts.penType === 0) {
              if (isNaN(this.drawPenLocation[0])) this.drawPenAxCorSag = a, this.drawPenFillPts = [], this.drawPt(...o, this.opts.penValue);
              else {
                if (o[0] === this.drawPenLocation[0] && o[1] === this.drawPenLocation[1] && o[2] === this.drawPenLocation[2]) {
                  this.drawScene(), this.createOnLocationChange(a);
                  return;
                }
                this.drawPenLine(o, this.drawPenLocation, this.opts.penValue);
              }
              this.drawPenLocation = o, this.opts.isFilledPen && this.drawPenFillPts.push(o), this.refreshDrawing(false, false);
            } else (this.opts.penType === 1 || this.opts.penType === 2) && (isNaN(this.drawShapeStartLocation[0]) ? (this.drawPenAxCorSag = a, this.drawShapeStartLocation = [
              ...o
            ], this.drawBitmap && (this.drawShapePreviewBitmap = this.drawBitmap.slice())) : this.drawShapePreviewBitmap && this.drawBitmap && (this.drawBitmap.set(this.drawShapePreviewBitmap), this.opts.penType === 1 ? this.drawRectangleMask(this.drawShapeStartLocation, o, this.opts.penValue) : this.opts.penType === 2 && this.drawEllipseMask(this.drawShapeStartLocation, o, this.opts.penValue), this.refreshDrawing(false, false)));
          }
          this.drawScene(), this.createOnLocationChange(a);
          return;
        }
      }
    }
    drawRuler() {
      let t = [], e = [];
      for (let f = 0; f < this.screenSlices.length; f++) if (this.screenSlices[f].axCorSag !== 4 && this.screenSlices[f].fovMM.length > 1) {
        e = this.screenSlices[f].leftTopWidthHeight, t = this.screenSlices[f].fovMM;
        break;
      }
      if (e.length < 4) return;
      const r = 100 / t[0] * e[2], i = Math.max(Math.round(r * 0.1), 2), a = Math.floor(e[0] + 0.5 * e[2] - 0.5 * r), s = Number(this.opts.rulerWidth), o = Math.floor(e[1] + e[3] - i) + 0.5 * s, l = [
        a,
        o,
        a + r,
        o
      ];
      let c = [
        0,
        0,
        0,
        1
      ];
      this.opts.rulerColor[0] + this.opts.rulerColor[1] + this.opts.rulerColor[2] < 0.8 && (c = [
        1,
        1,
        1,
        1
      ]), this.drawRuler10cm(l, c, s + 1), this.drawRuler10cm(l, this.opts.rulerColor, s);
    }
    drawRuler10cm(t, e, n = 1) {
      if (!this.lineShader) throw new Error("lineShader undefined");
      this.gl.bindVertexArray(this.genericVAO), this.lineShader.use(this.gl), this.gl.uniform4fv(this.lineShader.uniforms.lineColor, e), this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.uniform1f(this.lineShader.uniforms.thickness, n), this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, t), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      const r = -0.1 * (t[0] - t[2]), i = t[1] - Math.floor(0.5 * this.opts.rulerWidth), a = Math.floor(i - 0.35 * r), s = Math.floor(i - 0.7 * r);
      for (let o = 0; o < 11; o++) {
        let l = t[0] + o * r;
        l = Math.max(l, t[0] + 0.5 * n), l = Math.min(l, t[2] - 0.5 * n);
        const c = [
          l,
          i,
          l,
          a
        ];
        o % 5 === 0 && (c[3] = s), this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, c), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      }
      this.gl.bindVertexArray(this.unusedVAO);
    }
    screenXY2mm(t, e, n = -1) {
      let r;
      for (let i = 0; i < this.screenSlices.length; i++) {
        let a = i;
        if (n >= 0 && (a = n), this.screenSlices[a].axCorSag > 2) continue;
        const o = this.screenSlices[a].leftTopWidthHeight;
        if (t < o[0] || e < o[1] || t > o[0] + o[2] || e > o[1] + o[3] || (r = this.screenXY2TextureFrac(t, e, a, false), r[0] < 0)) continue;
        const l = this.frac2mm(r);
        return zn(l[0], l[1], l[2], a);
      }
      return zn(NaN, NaN, NaN, NaN);
    }
    dragForPanZoom(t) {
      const e = this.screenXY2mm(t[2], t[3]);
      if (isNaN(e[0])) return;
      const n = this.screenXY2mm(t[0], t[1], e[3]);
      if (isNaN(n[0]) || isNaN(e[0]) || isNaN(e[3])) return;
      const r = Rs(), i = this.uiData.pan2DxyzmmAtMouseDown[3];
      I_(r, e, n), this.scene.pan2Dxyzmm[0] = this.uiData.pan2DxyzmmAtMouseDown[0] + i * r[0], this.scene.pan2Dxyzmm[1] = this.uiData.pan2DxyzmmAtMouseDown[1] + i * r[1], this.scene.pan2Dxyzmm[2] = this.uiData.pan2DxyzmmAtMouseDown[2] + i * r[2], this.canvas.focus();
    }
    dragForCenterButton(t) {
      this.dragForPanZoom(t);
    }
    dragForSlicer3D(t) {
      let e = this.uiData.pan2DxyzmmAtMouseDown[3];
      const n = t[3] - t[1];
      e += n * 0.01, e = Math.max(e, 0.1), e = Math.min(e, 10);
      const i = this.scene.pan2Dxyzmm[3] - e;
      this.opts.yoke3Dto2DZoom && (this.scene.volScaleMultiplier = e), this.scene.pan2Dxyzmm[3] = e;
      const a = this.frac2mm(this.scene.crosshairPos);
      this.scene.pan2Dxyzmm[0] += i * a[0], this.scene.pan2Dxyzmm[1] += i * a[1], this.scene.pan2Dxyzmm[2] += i * a[2];
    }
    drawMeasurementTool(t, e = true) {
      function n(c, f, u, h, g) {
        const v = c - u, m = f - h;
        if (v === 0 && m === 0) return {
          origin: [
            u + g,
            h
          ],
          terminus: [
            u + g,
            h
          ]
        };
        const y = Math.sqrt(v * v + m * m), w = g * v / y, C = g * m / y;
        return {
          origin: [
            c + w,
            f + C
          ],
          terminus: [
            u - w,
            h - C
          ]
        };
      }
      const r = this.gl;
      if (r.bindVertexArray(this.genericVAO), r.depthFunc(r.ALWAYS), r.enable(r.BLEND), r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), !this.lineShader) throw new Error("lineShader undefined");
      this.lineShader.use(this.gl), r.uniform4fv(this.lineShader.uniforms.lineColor, this.opts.rulerColor), r.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [
        r.canvas.width,
        r.canvas.height
      ]), r.uniform1f(this.lineShader.uniforms.thickness, this.opts.rulerWidth), r.uniform4fv(this.lineShader.uniforms.startXYendXY, t), r.drawArrays(r.TRIANGLE_STRIP, 0, 4);
      const i = this.opts.measureLineColor;
      i[3] = 1, r.uniform4fv(this.lineShader.uniforms.lineColor, i);
      const a = this.opts.rulerWidth;
      r.uniform1f(this.lineShader.uniforms.thickness, a * 2);
      let s = [
        t[0],
        t[1] - a,
        t[0],
        t[1] + a
      ];
      r.uniform4fv(this.lineShader.uniforms.startXYendXY, s), r.drawArrays(r.TRIANGLE_STRIP, 0, 4), s = [
        t[2],
        t[3] - a,
        t[2],
        t[3] + a
      ], r.uniform4fv(this.lineShader.uniforms.startXYendXY, s), r.drawArrays(r.TRIANGLE_STRIP, 0, 4);
      let o = this.canvasPos2frac([
        t[0],
        t[1]
      ]), l = this.canvasPos2frac([
        t[2],
        t[3]
      ]);
      if (o[0] >= 0 && l[0] >= 0) {
        const c = this.frac2mm(o);
        o = Ue(c[0], c[1], c[2]);
        const f = this.frac2mm(l);
        l = Ue(f[0], f[1], f[2]);
        const u = He();
        hi(u, o, l);
        const h = Pc(u);
        let g = 2;
        h > 9 && (g = 1), h > 99 && (g = 0);
        let v = h.toFixed(g);
        this.opts.showMeasureUnits && (v = `${v} mm`);
        let m = t;
        const [y, w, C, T] = t, { origin: S, terminus: E } = n(y, w, C, T, 30);
        switch (this.opts.measureTextJustify) {
          case "start":
            m = [
              ...S,
              ...S.map((b) => b + 1)
            ];
            break;
          case "end":
            m = m = [
              ...E,
              ...E.map((b) => b + 1)
            ];
            break;
          default:
            m = t;
            break;
        }
        e && this.drawTextBetween(m, v, this.opts.measureTextHeight / 0.06, this.opts.measureTextColor);
      }
      r.bindVertexArray(this.unusedVAO);
    }
    drawAngleMeasurementTool() {
      this.uiData.angleState === "drawing_first_line" ? this.drawMeasurementTool([
        this.uiData.dragStart[0],
        this.uiData.dragStart[1],
        this.uiData.dragEnd[0],
        this.uiData.dragEnd[1]
      ], false) : this.uiData.angleState === "drawing_second_line" && (this.drawMeasurementTool(this.uiData.angleFirstLine, false), this.drawMeasurementTool([
        this.uiData.angleFirstLine[2],
        this.uiData.angleFirstLine[3],
        this.uiData.dragEnd[0],
        this.uiData.dragEnd[1]
      ], false), this.drawAngleText());
    }
    drawAngleText() {
      const t = this.uiData.angleFirstLine, e = [
        this.uiData.angleFirstLine[2],
        this.uiData.angleFirstLine[3],
        this.uiData.dragEnd[0],
        this.uiData.dragEnd[1]
      ], n = this.calculateAngleBetweenLines(t, e), r = this.uiData.angleFirstLine[2], i = this.uiData.angleFirstLine[3], a = `${n.toFixed(1)}\xB0`;
      this.drawTextBetween([
        r,
        i,
        r + 1,
        i + 1
      ], a, this.opts.measureTextHeight / 0.06, this.opts.measureTextColor);
    }
    drawAngleTextForAngle(t) {
      const e = this.calculateAngleBetweenLines(t.firstLine, t.secondLine), n = t.firstLine[2], r = t.firstLine[3], i = `${e.toFixed(1)}\xB0`;
      this.drawTextBetween([
        n,
        r,
        n + 1,
        r + 1
      ], i, this.opts.measureTextHeight / 0.06, this.opts.measureTextColor);
    }
    calculateAngleBetweenLines(t, e) {
      const n = t[2], r = t[3], i = t[0] - n, a = t[1] - r, s = e[2] - n, o = e[3] - r, l = i * s + a * o, c = Math.sqrt(i * i + a * a), f = Math.sqrt(s * s + o * o);
      if (c === 0 || f === 0) return 0;
      const u = Math.max(-1, Math.min(1, l / (c * f)));
      return Math.acos(u) * (180 / Math.PI);
    }
    resetAngleMeasurement() {
      this.uiData.angleState = "none", this.uiData.angleFirstLine = [
        0,
        0,
        0,
        0
      ];
    }
    getCurrentSliceInfo() {
      const t = this.tileIndex(this.uiData.dragStart[0], this.uiData.dragStart[1]);
      if (t >= 0 && t < this.screenSlices.length) {
        const r = this.screenSlices[t].axCorSag;
        let i = 0;
        return r === 0 ? i = this.scene.crosshairPos[2] : r === 1 ? i = this.scene.crosshairPos[1] : r === 2 && (i = this.scene.crosshairPos[0]), {
          sliceIndex: t,
          sliceType: r,
          slicePosition: i
        };
      }
      const e = this.opts.sliceType;
      let n = 0;
      return e === 0 ? n = this.scene.crosshairPos[2] : e === 1 ? n = this.scene.crosshairPos[1] : e === 2 ? n = this.scene.crosshairPos[0] : e === 3 && this.canvasPos2frac([
        this.uiData.dragStart[0],
        this.uiData.dragStart[1]
      ])[0] >= 0 && (n = this.scene.crosshairPos[2]), {
        sliceIndex: -1,
        sliceType: e,
        slicePosition: n
      };
    }
    getCurrentSlicePosition(t) {
      return t === 0 ? this.scene.crosshairPos[2] : t === 1 ? this.scene.crosshairPos[1] : t === 2 ? this.scene.crosshairPos[0] : 0;
    }
    shouldDrawOnCurrentSlice(t, e, n) {
      if (this.opts.sliceType === 3) {
        if (e > 2) return false;
        for (let o = 0; o < this.screenSlices.length; o++) if (this.screenSlices[o].axCorSag === e) {
          const l = this.getCurrentSlicePosition(e);
          if (Math.abs(l - n) < 1e-3) return true;
        }
        return false;
      } else if (this.opts.sliceType !== e) return false;
      const r = this.getCurrentSlicePosition(e);
      return Math.abs(r - n) < 1e-3;
    }
    clearMeasurements() {
      this.document.completedMeasurements = [], this.drawScene();
    }
    clearAngles() {
      this.document.completedAngles = [], this.drawScene();
    }
    clearAllMeasurements() {
      this.document.completedMeasurements = [], this.document.completedAngles = [], this.drawScene();
    }
    setDragMode(t) {
      if (typeof t == "string") switch (t) {
        case "none":
          this.opts.dragMode = 0;
          break;
        case "contrast":
          this.opts.dragMode = 1;
          break;
        case "measurement":
          this.opts.dragMode = 2;
          break;
        case "angle":
          this.opts.dragMode = 7;
          break;
        case "pan":
          this.opts.dragMode = 3;
          break;
        case "slicer3D":
          this.opts.dragMode = 4;
          break;
        case "callbackOnly":
          this.opts.dragMode = 5;
          break;
        case "roiSelection":
          this.opts.dragMode = 6;
          break;
        default:
          console.warn(`Unknown drag mode: ${t}`);
          return;
      }
      else this.opts.dragMode = t;
      this.opts.dragMode !== 7 && this.resetAngleMeasurement(), this.clearActiveDragMode();
    }
    setMouseEventConfig(t) {
      this.opts.mouseEventConfig = t, this.clearActiveDragMode();
    }
    setTouchEventConfig(t) {
      this.opts.touchEventConfig = t, this.clearActiveDragMode();
    }
    getMouseEventConfig() {
      return this.opts.mouseEventConfig;
    }
    getTouchEventConfig() {
      return this.opts.touchEventConfig;
    }
    drawRect(t, e = [
      1,
      0,
      0,
      -1
    ]) {
      if (e[3] < 0 && (e = this.opts.crosshairColor), !this.rectShader) throw new Error("rectShader undefined");
      this.opts.selectionBoxIsOutline ? (this.drawCircle(t, e, 0.1), this.rectOutlineShader.use(this.gl), this.gl.enable(this.gl.BLEND), this.gl.uniform1f(this.rectOutlineShader.uniforms.thickness, this.opts.selectionBoxLineThickness), this.gl.uniform4fv(this.rectOutlineShader.uniforms.lineColor, e), this.gl.uniform2fv(this.rectOutlineShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.uniform4f(this.rectOutlineShader.uniforms.leftTopWidthHeight, t[0], t[1], t[2], t[3]), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO)) : (this.rectShader.use(this.gl), this.gl.enable(this.gl.BLEND), this.gl.uniform4fv(this.rectShader.uniforms.lineColor, e), this.gl.uniform2fv(this.rectShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.uniform4f(this.rectShader.uniforms.leftTopWidthHeight, t[0], t[1], t[2], t[3]), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO));
    }
    drawCircle(t, e = this.opts.fontColor, n = 1) {
      if (!this.circleShader) throw new Error("circleShader undefined");
      this.circleShader.use(this.gl), this.gl.enable(this.gl.BLEND), this.gl.uniform4fv(this.circleShader.uniforms.circleColor, e), this.gl.uniform2fv(this.circleShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.uniform4f(this.circleShader.uniforms.leftTopWidthHeight, t[0], t[1], t[2], t[3]), this.gl.uniform1f(this.circleShader.uniforms.fillPercent, n), this.gl.uniform4fv(this.circleShader.uniforms.circleColor, e), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
    }
    drawSelectionBox(t) {
      if (this.getCurrentDragMode() === 6) {
        this.drawCircle(t, this.opts.selectionBoxColor, 0.1);
        return;
      }
      this.drawRect(t, this.opts.selectionBoxColor);
    }
    effectiveCanvasHeight() {
      return this.gl.canvas.height - this.colorbarHeight;
    }
    effectiveCanvasWidth() {
      return this.gl.canvas.width - this.getLegendPanelWidth();
    }
    getAllLabels() {
      const r = this.meshes.filter((a) => a.type === "connectome").flatMap((a) => a.nodes).map((a) => a.label).filter((a) => a !== void 0);
      return [
        ...this.document.labels,
        ...r
      ];
    }
    getConnectomeLabels() {
      const r = this.meshes.filter((o) => o.type === "connectome" && o.showLegend !== false).flatMap((o) => o.nodes).map((o) => o.label).filter((o) => o !== void 0 && o.text !== ""), i = this.document.labels.filter((o) => o.anchor == null || o.anchor === 0), a = new Set(r);
      for (const o of i) a.add(o);
      const s = this.meshes.filter((o) => o.type === "mesh");
      for (let o = 0; o < s.length; o++) for (let l = 0; l < s[o].layers.length; l++) if (s[o].layers[l].labels) for (let c = 0; c < s[o].layers[l].labels.length; c++) a.add(s[o].layers[l].labels[c]);
      return Array.from(a);
    }
    getBulletMarginWidth() {
      let t = 0;
      const e = this.getConnectomeLabels();
      if (e.length === 0) return 0;
      const n = e.length === 1 ? e[0].style.bulletScale : e.reduce((a, s) => a.style.bulletScale > s.style.bulletScale ? a : s).style.bulletScale, r = e.length === 1 ? e[0] : e.reduce((a, s) => {
        const o = this.fontPx * a.style.textScale, l = this.fontPx * s.style.textScale;
        return this.textHeight(o, a.text) > this.textHeight(l, s.text) ? a : s;
      }), i = this.fontPx * r.style.textScale;
      return t = this.textHeight(i, r.text) * n, t += i, t;
    }
    getLegendPanelWidth() {
      const t = this.getConnectomeLabels();
      if (!this.opts.showLegend || t.length === 0) return 0;
      const n = this.fontPx * 1;
      let r = 0;
      const i = t.reduce((l, c) => {
        const f = this.fontPx * l.style.textScale, u = this.fontPx * c.style.textScale;
        return this.textWidth(f, l.text) > this.textWidth(u, c.text) ? l : c;
      }), a = this.fontPx * i.style.textScale, s = this.textWidth(a, i.text), o = this.getBulletMarginWidth();
      return s && (r = o + s, r += n * 2), r >= this.gl.canvas.width ? 0 : r;
    }
    getLegendPanelHeight(t = 1) {
      const e = this.getConnectomeLabels();
      let n = 0;
      const r = this.fontPx;
      for (const i of e) {
        const a = this.fontPx * i.style.textScale * t, s = this.textHeight(a, i.text);
        n += s;
      }
      return n && (n += r / 2 * (e.length + 1) * t), n;
    }
    reserveColorbarPanel() {
      const t = 3 * this.fontPx;
      if (t < 0) return [
        0,
        0,
        0,
        0
      ];
      const n = (this.opts.colorbarWidth > 0 && this.opts.colorbarWidth <= 1 ? this.opts.colorbarWidth : 1) * this.gl.canvas.width, r = [
        (this.gl.canvas.width - n) / 2,
        this.gl.canvas.height - t,
        n,
        t
      ];
      return this.colorbarHeight = r[3] + 1, r;
    }
    drawColorbarCore(t = 0, e = [
      0,
      0,
      0,
      0
    ], n = false, r = 0, i = 1, a) {
      if (e[2] <= 0 || e[3] <= 0) return;
      const s = this.fontPx;
      if (s <= 0) return;
      let o = s;
      const l = 3 * s;
      let c = s;
      if (e[3] < l) {
        if (e[3] < 3) return;
        o = 1, c = e[3] - 2;
      }
      this.gl.disable(this.gl.DEPTH_TEST), this.colorbarHeight = e[3] + 1;
      const f = [
        e[0] + o,
        e[1],
        e[2] - 2 * o,
        c
      ], u = [
        f[0] - 1,
        f[1] - 1,
        f[2] + 2,
        f[3] + 2
      ];
      if (this.opts.showColorbarBorder && this.drawRect(u, this.opts.crosshairColor), !this.colorbarShader) throw new Error("colorbarShader undefined");
      this.colorbarShader.use(this.gl), this.gl.activeTexture(E2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.colormapTexture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
      const h = t;
      if (this.gl.uniform1f(this.colorbarShader.uniforms.layer, h), this.gl.uniform2fv(this.colorbarShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.disable(this.gl.CULL_FACE), n) {
        const b = [
          f[0] + f[2],
          f[1],
          -f[2],
          f[3]
        ];
        this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight, b);
      } else this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight, f);
      this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
      let g = 0;
      if (a && i < 0 && n ? (g = i, i = 0) : a && r > 0 && (g = r, r = 0), r === i || s < 1) return;
      const v = Math.abs(i - r);
      let [m, y] = dC(r, i);
      y < r && (y += m);
      function w(b) {
        return b.toFixed(6).replace(/\.?0*$/, "");
      }
      let C = y;
      const T = [
        0,
        f[1] + f[3] - s * 0.5,
        2,
        s * 0.75
      ], S = T[1] + T[3], E = 1;
      for (; C <= i; ) {
        T[0] = f[0] + (C - r) / v * f[2], this.drawRect(T);
        const b = w(E * C);
        this.drawTextBelow([
          T[0],
          S
        ], b), C += m;
      }
      if (g !== 0) {
        const b = [
          f[0] + (g - r) / v * f[2],
          f[1] - f[3] * 0.25,
          2,
          f[3] * 1.5
        ];
        this.drawRect(b);
      }
    }
    drawColorbar() {
      const t = this.colormapLists, e = t.length;
      if (e < 1) return;
      let n = 0;
      for (let s = 0; s < e; s++) t[s].visible && n++;
      if (n < 1) return;
      let r = this.reserveColorbarPanel();
      const i = 3 * this.fontPx;
      if (i < 0) return;
      let a = r[2] / n;
      (r[2] <= 0 || r[3] <= 0) && (a = this.gl.canvas.width / n, r = [
        0,
        this.gl.canvas.height - i,
        a,
        i
      ]), r[2] = a;
      for (let s = 0; s < e; s++) t[s].visible && (this.drawColorbarCore(s, r, t[s].negative, t[s].min, t[s].max, t[s].isColorbarFromZero), r[0] += a);
    }
    textWidth(t, e) {
      if (!e) return 0;
      let n = 0;
      const r = new TextEncoder().encode(e);
      for (let i = 0; i < e.length; i++) n += t * this.fontMets.mets[r[i]].xadv;
      return n;
    }
    textHeight(t, e) {
      if (!e) return 0;
      const n = new Set(Array.from(e)), r = new TextEncoder().encode(Array.from(n).join("")), a = Object.values(this.fontMets.mets).filter((s, o) => r.includes(o)).reduce((s, o) => s.lbwh[3] > o.lbwh[3] ? s : o).lbwh[3];
      return t * a;
    }
    drawChar(t, e, n) {
      if (!this.fontShader) throw new Error("fontShader undefined");
      const r = this.fontMets.mets[n], i = t[0] + e * r.lbwh[0], a = -(e * r.lbwh[1]), s = e * r.lbwh[2], o = e * r.lbwh[3], l = t[1] + (a - o) + e;
      return this.gl.uniform4f(this.fontShader.uniforms.leftTopWidthHeight, i, l, s, o), this.gl.uniform4fv(this.fontShader.uniforms.uvLeftTopWidthHeight, r.uv_lbwh), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), e * r.xadv;
    }
    drawLoadingText(t) {
      if (t) {
        if (!this.canvas) throw new Error("canvas undefined");
        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.gl.enable(this.gl.CULL_FACE), this.gl.enable(this.gl.BLEND), this.drawTextBelow([
          this.canvas.width / 2,
          this.canvas.height / 2
        ], t, 3);
      }
    }
    drawText(t, e, n = 1, r = null) {
      if (this.fontPx <= 0) return;
      if (!this.fontShader) throw new Error("fontShader undefined");
      this.fontShader.use(this.gl);
      const i = this.fontPx * n;
      this.gl.enable(this.gl.BLEND), this.gl.uniform2f(this.fontShader.uniforms.canvasWidthHeight, this.gl.canvas.width, this.gl.canvas.height), r === null && (r = this.opts.fontColor), this.gl.uniform4fv(this.fontShader.uniforms.fontColor, r);
      let a = i / this.fontMets.size * this.fontMets.distanceRange;
      a = Math.max(a, 1), this.gl.uniform1f(this.fontShader.uniforms.screenPxRange, a);
      const s = new TextEncoder().encode(e);
      this.gl.bindVertexArray(this.genericVAO);
      for (let o = 0; o < e.length; o++) t[0] += this.drawChar(t, i, s[o]);
      this.gl.bindVertexArray(this.unusedVAO);
    }
    drawTextRight(t, e, n = 1, r = null) {
      this.fontPx <= 0 || (t[1] -= 0.5 * this.fontPx, this.drawText(t, e, n, r));
    }
    drawTextLeft(t, e, n = 1, r = null) {
      if (this.fontPx <= 0) return;
      const i = this.fontPx * n;
      t[0] -= this.textWidth(i, e), t[1] -= 0.5 * i, this.drawText(t, e, n, r);
    }
    drawTextRightBelow(t, e, n = 1, r = null) {
      this.fontPx <= 0 || this.drawText(t, e, n, r);
    }
    drawTextBetween(t, e, n = 1, r = null) {
      if (this.fontPx <= 0) return;
      const i = [
        (t[0] + t[2]) * 0.5,
        (t[1] + t[3]) * 0.5
      ], a = this.fontPx * n, s = this.textWidth(a, e);
      i[0] -= 0.5 * s, i[1] -= 0.5 * a;
      const o = [
        i[0] - 1,
        i[1] - 1,
        s + 2,
        a + 2
      ];
      let l = r;
      l === null && (l = this.opts.crosshairColor), l && l[0] + l[1] + l[2] > 0.8 ? l = [
        0,
        0,
        0,
        0.5
      ] : l = [
        1,
        1,
        1,
        0.5
      ], this.drawRect(o, l), this.drawText(i, e, n, r);
    }
    drawTextBelow(t, e, n = 1, r = null) {
      if (this.fontPx <= 0) return;
      if (!this.canvas) throw new Error("canvas undefined");
      let i = this.fontPx * n, a = this.textWidth(i, e);
      a > this.canvas.width && (n *= (this.canvas.width - 2) / a, i = this.fontPx * n, a = this.textWidth(i, e)), t[0] -= 0.5 * this.textWidth(i, e), t[0] = Math.max(t[0], 1), t[0] = Math.min(t[0], this.canvas.width - a - 1), this.drawText(t, e, n, r);
    }
    drawTextAbove(t, e, n = 1, r = null) {
      if (this.fontPx <= 0) return;
      if (!this.canvas) throw new Error("canvas undefined");
      let i = this.fontPx * n, a = this.textWidth(i, e);
      a > this.canvas.width && (n *= (this.canvas.width - 2) / a, i = this.fontPx * n, a = this.textWidth(i, e)), t[0] -= 0.5 * this.textWidth(i, e), t[0] = Math.max(t[0], 1), t[0] = Math.min(t[0], this.canvas.width - a - 1), t[1] -= i, this.drawText(t, e, n, r);
    }
    updateInterpolation(t, e = false) {
      let n = this.gl.LINEAR;
      !e && this.opts.isNearestInterpolation && (n = this.gl.NEAREST), t === 0 ? this.gl.activeTexture(Y0) : this.gl.activeTexture(f4), this.opts.is2DSliceShader ? (this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, n), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, n)) : (this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MIN_FILTER, n), this.gl.texParameteri(this.gl.TEXTURE_3D, this.gl.TEXTURE_MAG_FILTER, n));
    }
    setAtlasOutline(t) {
      this.opts.atlasOutline = t, this.updateGLVolume(), this.drawScene();
    }
    setInterpolation(t) {
      this.opts.isNearestInterpolation = t;
      const e = this.volumes.length;
      if (!(e < 1)) {
        for (let n = 0; n < e; n++) this.updateInterpolation(n);
        this.drawScene();
      }
    }
    calculateMvpMatrix2D(t, e, n, r = 1 / 0, i = 0, a = 0, s = 0, o) {
      this.gl.viewport(t[0], this.gl.canvas.height - (t[1] + t[3]), t[2], t[3]);
      let c = e[0], f = n[0], u = [
        c,
        e[1]
      ], h = [
        f - c,
        n[1] - e[1]
      ];
      o && (u = [
        n[0],
        e[1]
      ], h = [
        e[0] - n[0],
        n[1] - e[1]
      ], c = -n[0], f = -e[0]);
      const g = 2 * Math.max(Math.abs(e[2]), Math.abs(n[2])), v = Yt();
      let m = 0.01, y = g * 8;
      if (r !== 1 / 0) {
        let b = o;
        s === 0 && (a === 0 || a === 180) && (b = !b);
        let D = g * 1.8 - i;
        b || (D = g * 1.8 + i), m = D - r, y = D + r;
      }
      U1(v, c, f, e[1], n[1], m, y);
      const w = Yt();
      w[0] = -1;
      const C = Ue(0, 0, -g * 1.8);
      au(w, w, C), m2(w, w, al(270 - s)), v2(w, w, al(a - 180));
      const T = Yt();
      Ti(T, w);
      const S = Yt();
      _i(S, T);
      const E = Yt();
      return ml(E, v, w), {
        modelViewProjectionMatrix: E,
        modelMatrix: w,
        normalMatrix: S,
        leftTopMM: u,
        fovMM: h
      };
    }
    swizzleVec3MM(t, e) {
      return e === 1 ? t = hr(t, [
        0,
        2,
        1
      ]) : e === 2 && (t = hr(t, [
        1,
        2,
        0
      ])), t;
    }
    screenFieldOfViewVox(t = 0) {
      const e = ki(this.volumeObject3D.fieldOfViewDeObliqueMM);
      return this.swizzleVec3MM(e, t);
    }
    screenFieldOfViewMM(t = 0, e = false) {
      if (this.volumes.length < 1) {
        let o = Ue(this.extentsMin[0], this.extentsMin[1], this.extentsMin[2]), l = Ue(this.extentsMax[0], this.extentsMax[1], this.extentsMax[2]);
        o = this.swizzleVec3MM(o, t), l = this.swizzleVec3MM(l, t);
        const c = He();
        return Ft(c, l, o), c;
      }
      if (!e && !this.opts.isSliceMM) return this.screenFieldOfViewVox(t);
      const n = this.volumeObject3D.extentsMin, r = this.volumeObject3D.extentsMax;
      let i = Ue(n[0], n[1], n[2]), a = Ue(r[0], r[1], r[2]);
      i = this.swizzleVec3MM(i, t), a = this.swizzleVec3MM(a, t);
      const s = He();
      return Ft(s, a, i), s;
    }
    screenFieldOfViewExtendedVox(t = 0) {
      const e = this.volumes[0].extentsMinOrtho, n = this.volumes[0].extentsMaxOrtho;
      let r = Ue(e[0], e[1], e[2]), i = Ue(n[0], n[1], n[2]);
      const a = Yt();
      r = this.swizzleVec3MM(r, t), i = this.swizzleVec3MM(i, t);
      const s = He();
      return Ft(s, i, r), {
        mnMM: r,
        mxMM: i,
        rotation: a,
        fovMM: s
      };
    }
    screenFieldOfViewExtendedMM(t = 0) {
      if (this.volumes.length < 1) {
        let o = Ue(this.extentsMin[0], this.extentsMin[1], this.extentsMin[2]), l = Ue(this.extentsMax[0], this.extentsMax[1], this.extentsMax[2]);
        const c = Yt();
        o = this.swizzleVec3MM(o, t), l = this.swizzleVec3MM(l, t);
        const f = He();
        return Ft(f, l, o), {
          mnMM: o,
          mxMM: l,
          rotation: c,
          fovMM: f
        };
      }
      if (!this.volumeObject3D) throw new Error("volumeObject3D undefined");
      const e = this.volumeObject3D.extentsMin, n = this.volumeObject3D.extentsMax;
      let r = Ue(e[0], e[1], e[2]), i = Ue(n[0], n[1], n[2]);
      const a = Yt();
      r = this.swizzleVec3MM(r, t), i = this.swizzleVec3MM(i, t);
      const s = He();
      return Ft(s, i, r), {
        mnMM: r,
        mxMM: i,
        rotation: a,
        fovMM: s
      };
    }
    drawSliceOrientationText(t, e, n = [
      NaN,
      NaN
    ]) {
      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
      let r = "S";
      e === 0 && (r = "A");
      let i = this.opts.isRadiologicalConvention ? "R" : "L";
      e === 2 && (i = this.opts.sagittalNoseLeft ? "A" : "P");
      let a = "I";
      e === 0 && (a = "P");
      let s = this.opts.isRadiologicalConvention ? "L" : "R";
      if (e === 2 && (s = this.opts.sagittalNoseLeft ? "P" : "A"), this.opts.isCornerOrientationText) {
        this.drawTextRightBelow([
          t[0],
          t[1]
        ], i + r);
        return;
      }
      let o = true, l = true;
      const c = this.opts.showAllOrientationMarkers, f = this.opts.showAllOrientationMarkers;
      if (!isNaN(n[0])) {
        const u = this.fontPx + 2;
        n[1] > u && (this.drawTextBelow([
          t[0] + t[2] * 0.5,
          t[1] + n[1] - u
        ], r), o = false);
        const h = this.textWidth(u, i) + 2;
        n[0] > h && (this.drawTextRight([
          t[0] + n[0] - h,
          t[1] + t[3] * 0.5
        ], i), l = false);
      }
      o && this.drawTextBelow([
        t[0] + t[2] * 0.5,
        t[1]
      ], r), l && this.drawTextRight([
        t[0],
        t[1] + t[3] * 0.5
      ], i), c && this.drawTextAbove([
        t[0] + t[2] * 0.5,
        t[1] + t[3]
      ], a), f && this.drawTextLeft([
        t[0] + t[2],
        t[1] + t[3] * 0.5
      ], s);
    }
    xyMM2xyzMM(t, e) {
      let n = 2;
      t === 1 && (n = 1), t === 2 && (n = 0);
      let r = [
        0,
        0,
        0
      ], i = [
        1,
        1,
        0
      ], a = [
        1,
        0,
        1
      ];
      r[n] = e, i[n] = e, a[n] = e, r = this.frac2mm(r), i = this.frac2mm(i), a = this.frac2mm(a), r = this.swizzleVec3MM(Ue(r[0], r[1], r[2]), t), i = this.swizzleVec3MM(Ue(i[0], i[1], i[2]), t), a = this.swizzleVec3MM(Ue(a[0], a[1], a[2]), t);
      const s = (i[0] - r[0]) * (a[1] - r[1]) - (a[0] - r[0]) * (i[1] - r[1]);
      let o = (i[0] - r[0]) * (a[2] - r[2]) - (a[0] - r[0]) * (i[2] - r[2]);
      o /= s;
      let l = (i[1] - r[1]) * (a[2] - r[2]) - (a[1] - r[1]) * (i[2] - r[2]);
      l /= s;
      const c = [
        0,
        0,
        0,
        0,
        0
      ];
      return c[0] = r[0], c[1] = r[1], c[2] = r[2], c[3] = l, c[4] = o, c;
    }
    draw2DMain(t, e, n = NaN) {
      let r = new Float32Array([
        0,
        0,
        0
      ]);
      this.volumes.length > 0 && (r = new Float32Array(this.volumes[0].frac2mm.slice()));
      let i = this.screenFieldOfViewExtendedMM(e), a = Yt();
      !this.opts.isSliceMM && this.volumes.length > 0 && (r = new Float32Array(this.volumes[0].frac2mmOrtho.slice()), a = Tr(this.volumes[0].mm2ortho), i = this.screenFieldOfViewExtendedVox(e));
      let s = this.opts.isRadiologicalConvention && e < 2;
      n === 1 / 0 || n === -1 / 0 ? (s = n !== 1 / 0, e === 1 && (s = !s)) : this.opts.sagittalNoseLeft && e === 2 && (s = !s);
      let o = 0, l = 0;
      e === 2 ? l = s ? 90 : -90 : e === 1 ? l = s ? 180 : 0 : (l = s ? 180 : 0, o = s ? -90 : 90);
      const c = this.gl;
      let f = false;
      if (t[2] === 0 || t[3] === 0) {
        f = true;
        const y = c.canvas.width / i.fovMM[0], w = c.canvas.height / i.fovMM[1], C = Math.min(y, w), T = y / C, S = w / C;
        i.fovMM[0] *= T, i.fovMM[1] *= S;
        let E = (i.mnMM[0] + i.mxMM[0]) * 0.5;
        i.mnMM[0] = E - i.fovMM[0] * 0.5, i.mxMM[0] = E + i.fovMM[0] * 0.5, E = (i.mnMM[1] + i.mxMM[1]) * 0.5, i.mnMM[1] = E - i.fovMM[1] * 0.5, i.mxMM[1] = E + i.fovMM[1] * 0.5, t = [
          0,
          0,
          c.canvas.width,
          c.canvas.height
        ];
      }
      if (isNaN(n)) {
        const y = this.scene.pan2Dxyzmm, w = this.swizzleVec3MM(Ue(y[0], y[1], y[2]), e), C = this.scene.pan2Dxyzmm[3];
        i.mnMM[0] -= w[0], i.mxMM[0] -= w[0], i.mnMM[1] -= w[1], i.mxMM[1] -= w[1], i.mnMM[0] /= C, i.mxMM[0] /= C, i.mnMM[1] /= C, i.mxMM[1] /= C;
      }
      let u = 2;
      e === 1 && (u = 1), e === 2 && (u = 0);
      let h = this.scene.crosshairPos[u], g = this.frac2mm(this.scene.crosshairPos);
      !isNaN(n) && n !== 1 / 0 && n !== -1 / 0 && (g = this.frac2mm([
        0.5,
        0.5,
        0.5
      ]), g[u] = n, h = this.mm2frac(g)[u]);
      const v = g[u];
      c.clear(c.DEPTH_BUFFER_BIT);
      let m = this.calculateMvpMatrix2D(t, i.mnMM, i.mxMM, 1 / 0, 0, l, o, s);
      if (n === 1 / 0 || n === -1 / 0) {
        const y = t.slice();
        this.draw3D(t, m.modelViewProjectionMatrix, m.modelMatrix, m.normalMatrix, l, o);
        const w = this.screenSlices[this.screenSlices.length - 1];
        w.leftTopWidthHeight = y, w.axCorSag = e, w.sliceFrac = 1 / 0, w.AxyzMxy = this.xyMM2xyzMM(e, h), w.leftTopMM = m.leftTopMM, w.fovMM = m.fovMM;
        return;
      }
      if (c.enable(c.DEPTH_TEST), c.blendFunc(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA), c.disable(c.BLEND), c.depthFunc(c.GREATER), c.disable(c.CULL_FACE), this.volumes.length > 0) {
        let y = this.sliceMMShader;
        if (this.opts.is2DSliceShader && (y = this.slice2DShader), this.opts.isV1SliceShader && (y = this.sliceV1Shader), this.customSliceShader && (y = this.customSliceShader), !y) throw new Error("slice Shader undefined");
        y.use(this.gl), c.uniform1f(y.uniforms.overlayOutlineWidth, this.overlayOutlineWidth), c.uniform1f(y.uniforms.overlayAlphaShader, this.overlayAlphaShader), c.uniform1i(y.uniforms.isAlphaClipDark, this.isAlphaClipDark ? 1 : 0), c.uniform1i(y.uniforms.backgroundMasksOverlays, this.backgroundMasksOverlays), c.uniform1f(y.uniforms.drawOpacity, this.drawOpacity), c.uniform1f(y.uniforms.drawRimOpacity, this.drawRimOpacity), c.enable(c.BLEND), c.blendFunc(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA), c.uniform1f(y.uniforms.opacity, this.volumes[0].opacity), c.uniform1i(y.uniforms.axCorSag, e), c.uniform1f(y.uniforms.slice, h), c.uniformMatrix4fv(y.uniforms.frac2mm, false, r), c.uniformMatrix4fv(y.uniforms.mvpMtx, false, m.modelViewProjectionMatrix.slice()), c.bindVertexArray(this.genericVAO), c.drawArrays(c.TRIANGLE_STRIP, 0, 4), c.bindVertexArray(this.unusedVAO), this.screenSlices.push({
          leftTopWidthHeight: t,
          axCorSag: e,
          sliceFrac: h,
          AxyzMxy: this.xyMM2xyzMM(e, h),
          leftTopMM: m.leftTopMM,
          screen2frac: [],
          fovMM: m.fovMM
        });
      }
      if (isNaN(n) && this.drawCrosshairs3D(true, 1, m.modelViewProjectionMatrix, true, this.opts.isSliceMM), this.opts.meshThicknessOn2D > 0) {
        this.opts.meshThicknessOn2D !== 1 / 0 && (m = this.calculateMvpMatrix2D(t, i.mnMM, i.mxMM, this.opts.meshThicknessOn2D, v, l, o, s));
        const y = Tr(m.modelViewProjectionMatrix);
        ml(y, y, a), this.drawMesh3D(true, 1, y, m.modelMatrix, m.normalMatrix);
      }
      isNaN(n) && this.drawCrosshairs3D(false, 0.15, m.modelViewProjectionMatrix, true, this.opts.isSliceMM), f && this.opts.isOrientationTextVisible && this.drawSliceOrientationText(t, e), this.readyForSync = true;
    }
    draw2D(t, e, n = NaN, r = [
      NaN,
      NaN
    ]) {
      const i = [
        NaN,
        NaN
      ];
      if (r[0] === 1 / 0) {
        const a = this.sliceScale().volScale;
        let s = this.scaleSlice(a[0], a[1], [
          0,
          0
        ], [
          t[2],
          t[3]
        ]);
        e === 1 && (s = this.scaleSlice(a[0], a[2], [
          0,
          0
        ], [
          t[2],
          t[3]
        ])), e === 2 && (s = this.scaleSlice(a[1], a[2], [
          0,
          0
        ], [
          t[2],
          t[3]
        ])), r[0] = s[2], r[1] = s[3];
      }
      if (isNaN(r[0])) this.draw2DMain(t, e, n);
      else {
        const a = t.slice();
        i[0] = Math.floor(0.5 * (a[2] - r[0])), i[1] = Math.floor(0.5 * (a[3] - r[1])), a[0] += i[0], a[1] += i[1], a[2] = r[0], a[3] = r[1], this.draw2DMain(a, e, n);
      }
      n === 1 / 0 || n === -1 / 0 || e === 4 || t[2] !== 0 && t[3] !== 0 && this.opts.isOrientationTextVisible && this.drawSliceOrientationText(t, e, i);
    }
    calculateMvpMatrix(t, e = [
      0,
      0,
      0,
      0
    ], n, r) {
      (e[2] === 0 || e[3] === 0) && (e = [
        0,
        0,
        this.gl.canvas.width,
        this.gl.canvas.height
      ]);
      const i = e[2] / e[3];
      let a = this.furthestFromPivot;
      const s = this.pivot3D, o = Yt();
      a = 0.8 * a / this.scene.volScaleMultiplier, i < 1 ? U1(o, -a, a, -a / i, a / i, a * 0.01, a * 8) : U1(o, -a * i, a * i, -a, a, a * 0.01, a * 8);
      const l = Yt();
      l[0] = -1;
      const c = Ue(0, 0, -a * 1.8);
      au(l, l, c), this.position && au(l, l, this.position), m2(l, l, al(270 - r)), v2(l, l, al(n - 180)), au(l, l, [
        -s[0],
        -s[1],
        -s[2]
      ]);
      const f = Yt();
      Ti(f, l);
      const u = Yt();
      _i(u, f);
      const h = Yt();
      return ml(h, o, l), [
        h,
        l,
        u
      ];
    }
    calculateModelMatrix(t, e) {
      if (!this.back) throw new Error("back undefined");
      const n = Yt();
      if (n[0] = -1, m2(n, n, al(270 - e)), v2(n, n, al(t - 180)), this.back.obliqueRAS) {
        const r = Tr(this.back.obliqueRAS);
        ml(n, n, r);
      }
      return n;
    }
    calculateRayDirection(t, e) {
      const n = this.calculateModelMatrix(t, e), r = Qi(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1), i = Yt();
      ml(i, r, n);
      const a = Yt();
      Ti(a, i);
      const s = zn(0, 0, -1, 1);
      Zr(s, s, a);
      const o = Ue(s[0], s[1], s[2]);
      Pr(o, o);
      const l = 5e-5;
      return Math.abs(o[0]) < l && (o[0] = l), Math.abs(o[1]) < l && (o[1] = l), Math.abs(o[2]) < l && (o[2] = l), o;
    }
    sceneExtentsMinMax(t = true) {
      let e = Ue(0, 0, 0), n = Ue(0, 0, 0);
      if (this.volumes.length > 0) {
        if (!this.volumeObject3D) throw new Error("volumeObject3D undefined");
        e = Ue(this.volumeObject3D.extentsMin[0], this.volumeObject3D.extentsMin[1], this.volumeObject3D.extentsMin[2]), n = Ue(this.volumeObject3D.extentsMax[0], this.volumeObject3D.extentsMax[1], this.volumeObject3D.extentsMax[2]), t || (e = Ue(this.volumes[0].extentsMinOrtho[0], this.volumes[0].extentsMinOrtho[1], this.volumes[0].extentsMinOrtho[2]), n = Ue(this.volumes[0].extentsMaxOrtho[0], this.volumes[0].extentsMaxOrtho[1], this.volumes[0].extentsMaxOrtho[2]));
      }
      if (this.meshes.length > 0) {
        if (this.volumes.length < 1) {
          const i = this.meshes[0].extentsMin, a = this.meshes[0].extentsMax;
          e = Ue(i[0], i[1], i[2]), n = Ue(a[0], a[1], a[2]);
        }
        for (let i = 0; i < this.meshes.length; i++) {
          const a = this.meshes[i].extentsMin, s = this.meshes[i].extentsMax, o = Ue(a[0], a[1], a[2]);
          z6(e, e, o);
          const l = Ue(s[0], s[1], s[2]);
          W6(n, n, l);
        }
      }
      const r = He();
      return Ft(r, n, e), [
        e,
        n,
        r
      ];
    }
    setPivot3D() {
      const [t, e] = this.sceneExtentsMinMax(), n = He();
      Ai(n, t, e), a5(n, n, 0.5), this.pivot3D = [
        n[0],
        n[1],
        n[2]
      ], Ft(n, e, t), this.extentsMin = t, this.extentsMax = e, this.furthestFromPivot = Ms(n) * 0.5;
    }
    getMaxVols() {
      if (this.volumes.length < 1) return 0;
      let t = 0;
      for (let e = 0; e < this.volumes.length; e++) t = Math.max(t, this.volumes[e].nFrame4D);
      return t;
    }
    detectPartialllyLoaded4D() {
      if (this.volumes.length < 1) return false;
      for (let t = 0; t < this.volumes.length; t++) if (this.volumes[t].nFrame4D < this.volumes[t].hdr.dims[4]) return true;
      return false;
    }
    drawGraph() {
      if (this.getMaxVols() < 2) return;
      const t = this.graph;
      let e = 0;
      if (this.graph.autoSizeMultiplanar && this.opts.sliceType === 3) for (let Z = 0; Z < this.screenSlices.length; Z++) {
        const j = this.screenSlices[Z].axCorSag;
        if (j === 0 && (e = this.screenSlices[Z].leftTopWidthHeight[1]), j !== 2) continue;
        const B = this.screenSlices[Z].leftTopWidthHeight.slice();
        B[1] === e ? (t.LTWH[0] = B[0] + B[2], t.LTWH[1] = B[1]) : (t.LTWH[0] = B[0], t.LTWH[1] = B[1] + B[3]), t.LTWH[2] = B[2], t.LTWH[3] = B[2];
      }
      if (t.opacity <= 0 || t.LTWH[2] <= 5 || t.LTWH[3] <= 5 || Math.floor(t.LTWH[0] + t.LTWH[2]) > this.gl.canvas.width || Math.floor(t.LTWH[1] + t.LTWH[3]) > this.gl.canvas.height) return;
      t.backColor = [
        0.15,
        0.15,
        0.15,
        t.opacity
      ], t.lineColor = [
        1,
        1,
        1,
        1
      ], this.opts.backColor[0] + this.opts.backColor[1] + this.opts.backColor[2] > 1.5 && (t.backColor = [
        0.95,
        0.95,
        0.95,
        t.opacity
      ], t.lineColor = [
        0,
        0,
        0,
        1
      ]);
      const n = 0.2, r = 0.3;
      t.lineColor[3] = n, t.textColor = t.lineColor.slice(), t.textColor[3] = 1, t.lineThickness = 3, t.gridLineThickness = 1, t.lineAlpha = 1, t.lines = [];
      const i = [];
      if (t.vols.length < 1) this.volumes[0] != null && i.push(0);
      else for (let Z = 0; Z < t.vols.length; Z++) {
        const j = t.vols[Z];
        this.volumes[j] == null || this.volumes[j].nFrame4D < 2 || i.push(j);
      }
      if (i.length < 1) return;
      const a = this.volumes[i[0]].nFrame4D;
      if (this.graph.selectedColumn = this.volumes[i[0]].frame4D, a < 2) {
        ee.debug("Unable to generate a graph: Selected volume is 3D not 4D");
        return;
      }
      for (let Z = 0; Z < i.length; Z++) {
        t.lines[Z] = [];
        const j = this.frac2vox(this.scene.crosshairPos), B = this.volumes[i[Z]];
        let Y = B.nFrame4D;
        Y = Math.min(Y, a);
        for (let X = 0; X < Y; X++) {
          const ie = B.getValue(j[0], j[1], j[2], X);
          t.lines[Z].push(ie);
        }
      }
      t.lineRGB = [
        [
          0.8,
          0,
          0
        ],
        [
          0,
          0.7,
          0
        ],
        [
          0,
          0,
          0.9
        ],
        [
          0.7,
          0.7,
          0
        ],
        [
          0.8,
          0,
          0.8
        ],
        [
          0,
          0.7,
          0.7
        ],
        [
          0.6,
          0.6,
          0.6
        ],
        [
          0,
          0,
          0
        ]
      ];
      let s = t.lines[0][0], o = t.lines[0][0];
      for (let Z = 0; Z < t.lines.length; Z++) for (let j = 0; j < t.lines[Z].length; j++) {
        const B = t.lines[Z][j];
        s = Math.min(B, s), o = Math.max(B, o);
      }
      const l = this.volumes[i[0]].cal_min, c = this.volumes[i[0]].cal_max;
      if (t.isRangeCalMinMax && l < c && isFinite(l) && isFinite(c) && (s = l, o = c), t.normalizeValues && o > s) {
        const Z = o - s;
        for (let j = 0; j < t.lines.length; j++) for (let B = 0; B < t.lines[j].length; B++) {
          const Y = t.lines[j][B];
          t.lines[j][B] = (Y - s) / Z;
        }
        s = 0, o = 1;
      }
      s >= o && (o = s + 1), this.drawRect(t.LTWH, t.backColor);
      const [f, u, h] = dC(s, o), g = Math.max(0, -1 * Math.floor(Math.log(f) / Math.log(10)));
      s = Math.min(u, s), o = Math.max(h, o);
      function v(Z) {
        return Z.toFixed(6).replace(/\.?0*$/, "");
      }
      let m = this.fontPx * 0.7;
      const y = this.gl.canvas.width / this.uiData.dpr, w = this.gl.canvas.height / this.uiData.dpr, C = y * w, T = 800 * 600;
      C < T ? m = 0 : m = Math.max(m, this.opts.fontMinPx);
      const S = m / this.fontPx;
      let E = 0, b = u;
      if (m > 0) for (; b <= o; ) {
        const Z = b.toFixed(g), j = this.textWidth(m, Z);
        E = Math.max(j, E), b += f;
      }
      const D = 0.05, R = Math.abs(t.LTWH[2]), I = Math.abs(t.LTWH[3]), O = [
        t.LTWH[0] + D * R + E,
        t.LTWH[1] + D * I,
        t.LTWH[2] - E - 2 * D * R,
        t.LTWH[3] - m - 2.5 * D * I
      ];
      this.graph.LTWH = t.LTWH, this.graph.plotLTWH = O, this.drawRect(O, this.opts.backColor);
      const L = o - s, N = O[3] / L, F = O[2] / (t.lines[0].length - 1), V = O[1] + O[3];
      b = u + 0.5 * f;
      const k = t.lineColor.slice();
      for (k[3] = 0.5 * t.lineColor[3]; b <= o; ) {
        const Z = V - (b - s) * N;
        this.drawLine([
          O[0],
          Z,
          O[0] + O[2],
          Z
        ], t.gridLineThickness, k), b += f;
      }
      b = u;
      const _ = 0.5 * t.gridLineThickness;
      for (; b <= o; ) {
        const Z = V - (b - s) * N;
        this.drawLine([
          O[0] - _,
          Z,
          O[0] + O[2] + t.gridLineThickness,
          Z
        ], t.gridLineThickness, t.lineColor);
        const j = b.toFixed(g);
        m > 0 && this.drawTextLeft([
          O[0] - 6,
          Z
        ], j, S, t.textColor), b += f;
      }
      let K = 1;
      for (; t.lines[0].length / K > 20; ) K *= 5;
      for (let Z = 0; Z < t.lines[0].length; Z += K) {
        const j = Z * F + O[0];
        let B = t.gridLineThickness;
        if (Z % 2 === 1) B *= 0.5, this.drawLine([
          j,
          O[1],
          j,
          O[1] + O[3]
        ], B, k);
        else {
          const Y = v(Z);
          m > 0 && this.drawTextBelow([
            j,
            2 + O[1] + O[3]
          ], Y, S, t.textColor), this.drawLine([
            j,
            O[1],
            j,
            O[1] + O[3]
          ], B, t.lineColor);
        }
      }
      for (let Z = 0; Z < t.lines.length; Z++) {
        let j = [
          1,
          0,
          0,
          t.lineAlpha
        ];
        Z < t.lineRGB.length && (j = [
          t.lineRGB[Z][0],
          t.lineRGB[Z][1],
          t.lineRGB[Z][2],
          t.lineAlpha
        ]);
        for (let B = 1; B < t.lines[Z].length; B++) {
          const Y = (B - 1) * F, X = B * F, ie = (t.lines[Z][B - 1] - s) * N, oe = (t.lines[Z][B] - s) * N, he = [
            O[0] + Y,
            O[1] + O[3] - ie,
            O[0] + X,
            O[1] + O[3] - oe
          ];
          this.drawLine(he, t.lineThickness, j);
        }
      }
      if (t.selectedColumn >= 0 && t.selectedColumn < t.lines[0].length) {
        const Z = t.selectedColumn * F + O[0];
        this.drawLine([
          Z,
          O[1],
          Z,
          O[1] + O[3]
        ], t.lineThickness, [
          t.lineRGB[0][0],
          t.lineRGB[0][1],
          t.lineRGB[0][2],
          r
        ]);
      }
      m > 0 && t.LTWH[1] + t.LTWH[3] > O[1] + O[3] + m * 2.4 && this.drawTextBelow([
        O[0] + 0.5 * O[2],
        O[1] + O[3] + m * 1.2
      ], "Volume", S, t.textColor), this.detectPartialllyLoaded4D() && this.drawTextBelow([
        O[0] + O[2],
        O[1] + O[3] + m * 0.5
      ], "...", S, t.textColor);
    }
    depthPicker(t, e) {
      if (!this.uiData.mouseDepthPicker) return;
      this.uiData.mouseDepthPicker = false;
      const n = this.gl, r = this.mousePos[0] * t[2] / t[2], i = n.canvas.height - this.mousePos[1] * t[3] / t[3] - 1, a = new Uint8Array(4);
      if (n.readPixels(r, i, 1, 1, n.RGBA, n.UNSIGNED_BYTE, a), this.selectedObjectId = a[3], this.selectedObjectId === this.VOLUME_ID) {
        this.scene.crosshairPos = new Float32Array(a.slice(0, 3)).map((u) => u / 255);
        return;
      }
      const s = Zz(a);
      if (s > 1) return;
      const o = (this.mousePos[0] - t[0]) / t[2], l = (n.canvas.height - this.mousePos[1] - t[1]) / t[3], c = Qz(o, l, s, e), f = this.mm2frac(c, 0, true);
      f[0] < 0 || f[0] > 1 || f[1] < 0 || f[1] > 1 || f[2] < 0 || f[2] > 1 || (this.scene.crosshairPos = this.mm2frac(c, 0, true));
    }
    drawImage3D(t, e, n) {
      if (this.volumes.length === 0) return;
      const r = this.gl, i = this.calculateRayDirection(e, n), a = this.volumeObject3D;
      if (a) {
        r.enable(r.BLEND), r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), r.enable(r.CULL_FACE), r.cullFace(r.FRONT);
        let s = this.renderShader;
        if (this.uiData.mouseDepthPicker && (s = this.pickingImageShader), s.use(this.gl), r.uniform1i(s.uniforms.backgroundMasksOverlays, this.backgroundMasksOverlays), this.gradientTextureAmount > 0 && s.uniforms.normMtx && this.gradientTexture) {
          r.activeTexture(h4), r.bindTexture(r.TEXTURE_3D, this.gradientTexture);
          const o = this.calculateModelMatrix(e, n), l = Yt();
          Ti(l, o);
          const c = Yt();
          _i(c, l), r.uniformMatrix4fv(s.uniforms.normMtx, false, c);
        }
        this.drawBitmap && this.drawBitmap.length > 8 ? r.uniform2f(s.uniforms.renderDrawAmbientOcclusionXY, this.renderDrawAmbientOcclusion, this.drawOpacity) : r.uniform2f(s.uniforms.renderDrawAmbientOcclusionXY, this.renderDrawAmbientOcclusion, 0), this.gl.uniform4fv(s.uniforms.paqdUniforms, this.opts.paqdUniforms), r.uniformMatrix4fv(s.uniforms.mvpMtx, false, t), r.uniformMatrix4fv(s.uniforms.matRAS, false, this.back.matRAS), r.uniform3fv(s.uniforms.rayDir, i), this.gradientTextureAmount < 0 ? r.uniform4fv(s.uniforms.clipPlane, [
          this.scene.crosshairPos[0],
          this.scene.crosshairPos[1],
          this.scene.crosshairPos[2],
          30
        ]) : r.uniform4fv(s.uniforms.clipPlane, this.scene.clipPlane), r.uniform1f(s.uniforms.drawOpacity, 1), r.bindVertexArray(a.vao), r.drawElements(a.mode, a.indexCount, r.UNSIGNED_SHORT, 0), r.bindVertexArray(this.unusedVAO);
      }
    }
    drawOrientationCube(t, e = 0, n = 0) {
      if (!this.opts.isOrientCube) return;
      const r = 0.05 * Math.min(t[2], t[3]);
      if (r < 5) return;
      const i = this.gl;
      i.enable(i.CULL_FACE), i.cullFace(i.BACK), this.orientCubeShader.use(this.gl), i.bindVertexArray(this.orientCubeShaderVAO);
      const a = Yt(), s = Yt();
      U1(s, 0, i.canvas.width, 0, i.canvas.height, -10 * r, 10 * r);
      let o = 0;
      t[1] === 0 && (o = i.canvas.height - this.effectiveCanvasHeight()), au(a, a, [
        1.8 * r + t[0],
        o + 1.8 * r + t[1],
        0
      ]), Vv(a, a, [
        r,
        r,
        r
      ]), m2(a, a, al(270 - n)), v2(a, a, al(-e));
      const l = Yt();
      ml(l, s, a), i.uniformMatrix4fv(this.orientCubeShader.uniforms.u_matrix, false, l), i.drawArrays(i.TRIANGLE_STRIP, 0, 168), i.bindVertexArray(this.unusedVAO), this.gl.disable(this.gl.CULL_FACE);
    }
    createOnLocationChange(t = NaN) {
      const [e, n, r] = this.sceneExtentsMinMax(true), i = Math.max(Math.max(r[0], r[1]), r[2]);
      function a(u) {
        return Math.max(0, -Math.ceil(Math.log10(Math.abs(u))));
      }
      let s = a(i * 1e-3);
      const o = this.frac2mm(this.scene.crosshairPos, 0, true);
      function l(u, h = 0) {
        return parseFloat(u.toFixed(h));
      }
      let c = l(o[0], s) + "\xD7" + l(o[1], s) + "\xD7" + l(o[2], s);
      if (this.volumes.length > 0 && this.volumes[0].nFrame4D > 0 && (c += "\xD7" + l(this.volumes[0].frame4D)), this.volumes.length > 0) {
        let u = " = ";
        for (let v = 0; v < this.volumes.length; v++) {
          const m = this.volumes[v].mm2vox(o);
          let y = this.volumes[v].getValue(m[0], m[1], m[2], this.volumes[v].frame4D);
          if (s = 3, this.volumes[v].colormapLabel !== null) {
            const w = Math.round(y);
            if (this.volumes[v].hdr.intent_code === 1002 && this.volumes[v].hdr.datatypeCode === 2304) {
              const C = this.volumes[v].getValues(m[0], m[1], m[2], this.volumes[v].frame4D);
              if (C[2] > 2) {
                const T = Math.round(100 * C[2] / 255);
                if (u += this.volumes[v].colormapLabel.labels[C[0]] + ` (${T}%)`, C[3] > 2) {
                  const S = Math.round(100 * C[3] / 255);
                  u += " " + this.volumes[v].colormapLabel.labels[C[1]] + ` (${S}%)`;
                }
              }
            } else w >= 0 && this.volumes[v].colormapLabel.labels && w < this.volumes[v].colormapLabel.labels.length ? u += this.volumes[v].colormapLabel.labels[w] : u += "undefined(" + l(y, s) + ")";
          } else u += l(y, s);
          this.volumes[v].imaginary && (y = this.volumes[v].getValue(m[0], m[1], m[2], this.volumes[v].frame4D, true), y >= 0 && (u += "+"), u += l(y, s)), u += "   ";
        }
        c += u;
        const h = this.back.dimsRAS, g = h[1] * h[2] * h[3];
        if (this.drawBitmap && this.drawBitmap.length === g) {
          const v = this.frac2vox(this.scene.crosshairPos), m = v[0] + v[1] * h[1] + v[2] * h[1] * h[2];
          c += " " + this.drawLut.labels[this.drawBitmap[m]];
        }
      }
      const f = {
        mm: this.frac2mm(this.scene.crosshairPos, 0, true),
        axCorSag: t,
        vox: this.frac2vox(this.scene.crosshairPos),
        frac: this.scene.crosshairPos,
        xy: [
          this.mousePos[0],
          this.mousePos[1]
        ],
        values: this.volumes.map((u) => {
          const h = this.frac2mm(this.scene.crosshairPos, 0, true), g = u.mm2vox(h), v = u.getValue(g[0], g[1], g[2], u.frame4D);
          return {
            name: u.name,
            value: v,
            id: u.id,
            mm: h,
            vox: g
          };
        }),
        string: c
      };
      this.onLocationChange(f);
    }
    addLabel(t, e, n, r, i) {
      const a = {
        textColor: this.opts.legendTextColor,
        textScale: 1,
        textAlignment: "left",
        lineWidth: 0,
        lineColor: this.opts.legendTextColor,
        lineTerminator: "none",
        bulletScale: 0,
        bulletColor: this.opts.legendTextColor
      }, s = e ? {
        ...a,
        ...e
      } : {
        ...a
      }, o = new u8(t, {
        ...s
      }, n, r, i);
      return this.document.labels.push(o), o;
    }
    calculateScreenPoint(t, e, n) {
      const r = Rs();
      return Zr(r, [
        ...t,
        1
      ], e), r[3] !== 0 && (r[0] = (r[0] / r[3] + 1) * 0.5 * n[2], r[1] = (1 - r[1] / r[3]) * 0.5 * n[3], r[2] /= r[3], r[0] += n[0], r[1] += n[1]), r;
    }
    getLabelAtPoint(t) {
      const e = this.legendFontScaling, n = this.fontPx * e, r = this.fontPx * e;
      for (const c of this.document.labels) {
        if (c.anchor == null || c.anchor === 0) continue;
        const f = this.fontPx * c.style.textScale * e, u = this.textHeight(f, c.text), h = this.textWidth(f, c.text);
        if (!(c.anchor & 1 && t[0] > h) && !(c.anchor & 2 && (t[0] < (this.gl.canvas.width - h) / 2 || t[0] > (this.gl.canvas.width + h) / 2)) && !(c.anchor & 4 && t[0] < this.gl.canvas.width - h) && !(c.anchor & 8 && (t[1] < r / 2 || t[1] > u + r / 2)) && !(c.anchor & 16 && (t[1] < (this.gl.canvas.height - u - r) / 2 || t[1] > (this.gl.canvas.height + u - r / 2) / 2)) && !(c.anchor & 32 && (t[1] < this.gl.canvas.height - u - r || t[1] > this.gl.canvas.height - r / 2))) return c;
      }
      ee.debug("screenPoint", t);
      const i = this.getLegendPanelHeight(e), a = this.getLegendPanelWidth(), s = this.gl.canvas.width - a;
      let o = (this.canvas.height - i) / 2;
      if (ee.debug("panelrect", s, o, s + a, o + i), t[0] < s || t[1] < o || t[0] > s + a || t[1] > o + i) return null;
      const l = this.getConnectomeLabels();
      for (const c of l) {
        const f = this.fontPx * c.style.textScale * e, u = this.textHeight(f, c.text);
        if (t[1] >= o && t[1] <= o + u + n / 2) return ee.debug(`label clicked ${c.text}`), c;
        o += u, o += n / 2;
      }
      return null;
    }
    drawLabelLine(t, e, n, r, i = false) {
      const a = Array.isArray(t.points) && Array.isArray(t.points[0]) ? t.points : [
        t.points
      ];
      for (const s of a) {
        const o = this.calculateScreenPoint(s, n, r);
        i ? this.drawDottedLine([
          ...e,
          o[0],
          o[1]
        ], t.style.lineWidth, t.style.lineColor) : this.draw3DLine(e, [
          o[0],
          o[1],
          o[2]
        ], t.style.lineWidth, t.style.lineColor);
      }
    }
    draw3DLabel(t, e, n, r, i, a, s, o = 1) {
      const l = t.text, c = e[0], f = e[1], u = this.fontPx * o, h = this.textHeight(t.style.textScale, l) * u;
      if (t.style.lineWidth > 0 && Array.isArray(t.points) && this.drawLabelLine(t, [
        c,
        f + h
      ], n, r, s), t.style.bulletScale) {
        const m = t.style.bulletScale * h, y = h - m, w = f + y / 2 + m / 2, C = c + (i - m) / 2;
        this.drawCircle([
          C,
          w,
          m,
          m
        ], t.style.bulletColor);
      }
      let g = c;
      if (a) if (t.style.textAlignment !== "left") {
        const m = this.textWidth(t.style.textScale, t.text) * u;
        if (t.style.textAlignment === "right") g = c + a - u * 1.5 - m;
        else {
          const y = a - (i || u);
          g += (y - m) / 2;
        }
      } else g += i;
      const v = t.style.textScale;
      this.drawText([
        g,
        f
      ], l, v, t.style.textColor);
    }
    draw3DLabels(t, e, n = false) {
      const r = this.getConnectomeLabels();
      if (!this.opts.showLegend || r.length === 0) return;
      let i = this.getLegendPanelHeight(1);
      if (!this.canvas || i < 1) return;
      const a = this.gl;
      if (a.disable(a.CULL_FACE), a.viewport(0, 0, this.canvas.width, this.canvas.height), this.legendFontScaling = 1, i > this.canvas.height) {
        const g = 10 * this.uiData.dpr;
        this.legendFontScaling = Math.max(this.canvas.height - g, 1) / i, ee.debug(`Legend too large for screen, font reduction factor x${this.legendFontScaling}`), i = this.getLegendPanelHeight(this.legendFontScaling);
      }
      const s = this.fontPx * this.legendFontScaling, o = this.getBulletMarginWidth(), l = this.getLegendPanelWidth(), c = a.canvas.width - l;
      let f = (this.canvas.height - i) / 2;
      this.drawRect([
        a.canvas.width - l,
        f,
        l - s,
        i
      ], this.opts.legendBackgroundColor);
      const u = a.getParameter(a.BLEND), h = a.getParameter(a.DEPTH_FUNC);
      n || (a.disable(a.BLEND), a.depthFunc(a.GREATER));
      for (const g of r) {
        this.draw3DLabel(g, [
          c,
          f
        ], t, e, o, l, n, this.legendFontScaling);
        const v = this.fontPx * g.style.textScale, m = this.textHeight(v, g.text) * this.legendFontScaling;
        f += m, f += s / 2;
      }
      n || (a.depthFunc(h), u && a.enable(a.BLEND));
    }
    drawAnchoredLabels() {
      const t = this.fontPx, e = this.document.labels.filter((n) => n.anchor != null && n.anchor !== 0);
      for (const n of e) {
        const r = n.text, i = this.textHeight(n.style.textScale, r) * t, a = this.textWidth(n.style.textScale, r) * t;
        let s, o;
        const c = this.fontPx * 1, f = c;
        let u = c / 4, h = 0, g = 0;
        n.anchor & 1 && (s = 0), n.anchor & 4 && (s = this.canvas.width - a, h -= c / 4), n.anchor & 2 && (s = (this.canvas.width - a) / 2, h -= c / 4, u += c / 4), n.anchor & 8 && (o = 0), n.anchor & 16 && (o = (this.canvas.height - i - c) / 2, g -= c / 4), n.anchor & 32 && (o = this.canvas.height - i - c, g -= c / 4), this.drawRect([
          s + h,
          o + g,
          a + u,
          i + f
        ], n.style.backgroundColor), this.draw3DLabel(n, [
          s,
          o
        ]);
      }
    }
    draw3D(t = [
      0,
      0,
      0,
      0
    ], e = null, n = null, r = null, i = null, a = 0) {
      const s = i !== null;
      this.setPivot3D(), s || (i = this.scene.renderAzimuth, a = this.scene.renderElevation);
      const o = this.gl;
      e === null && ([e, n, r] = this.calculateMvpMatrix(null, t, i, a));
      let l = [
        ...t
      ];
      if (t[2] === 0 || t[3] === 0 ? (t = [
        0,
        0,
        o.canvas.width,
        o.canvas.height
      ], l = [
        ...t
      ], this.screenSlices.push({
        leftTopWidthHeight: t,
        axCorSag: 4,
        sliceFrac: 0,
        AxyzMxy: [],
        leftTopMM: [],
        fovMM: [
          gC(n),
          0
        ]
      })) : (this.screenSlices.push({
        leftTopWidthHeight: t.slice(),
        axCorSag: 4,
        sliceFrac: 0,
        AxyzMxy: [],
        leftTopMM: [],
        fovMM: [
          gC(n),
          0
        ]
      }), t[1] = o.canvas.height - t[3] - t[1]), o.enable(o.DEPTH_TEST), o.depthFunc(o.ALWAYS), o.depthMask(true), o.clearDepth(0), this.draw3DLabels(e, l, false), o.viewport(t[0], t[1], t[2], t[3]), this.volumes.length > 0 && (this.updateInterpolation(0, true), this.updateInterpolation(1, true), this.drawImage3D(e, i, a)), this.updateInterpolation(0), this.updateInterpolation(1), s || this.drawCrosshairs3D(true, 1, e), this.drawMesh3D(true, 1, e, n, r), this.uiData.mouseDepthPicker) {
        this.depthPicker(t, e), this.createOnLocationChange(), this.draw3D(t, e, n, r, i, a);
        return;
      }
      this.opts.meshXRay > 0 && this.drawMesh3D(false, this.opts.meshXRay, e, n, r), this.draw3DLabels(e, l, false), o.viewport(t[0], t[1], t[2], t[3]), s || this.drawCrosshairs3D(false, 0.15, e), o.viewport(0, 0, o.canvas.width, o.canvas.height), this.drawOrientationCube(t, i, a);
      const c = "azimuth: " + this.scene.renderAzimuth.toFixed(0) + " elevation: " + this.scene.renderElevation.toFixed(0);
      return this.readyForSync = true, this.sync(), this.draw3DLabels(e, l, true), c;
    }
    drawMesh3D(t = true, e = 1, n, r, i) {
      if (this.meshes.length < 1) return;
      const a = this.gl;
      n || ([n, r, i] = this.calculateMvpMatrix(this.volumeObject3D, void 0, this.scene.renderAzimuth, this.scene.renderElevation)), a.enable(a.DEPTH_TEST), a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA), a.disable(a.BLEND), a.depthFunc(a.GREATER), a.disable(a.CULL_FACE), t ? a.depthFunc(a.GREATER) : (a.enable(a.BLEND), a.depthFunc(a.ALWAYS), a.enable(a.CULL_FACE)), a.cullFace(a.BACK);
      let s = this.meshShaders[0].shader, o = false;
      for (let l = 0; l < this.meshes.length; l++) {
        if (this.meshes[l].visible === false || this.meshes[l].opacity <= 0) continue;
        let c = e;
        if (t && (c = this.meshes[l].opacity, a.depthFunc(a.GREATER), a.depthMask(true), c < 1 ? (a.depthMask(false), a.enable(a.DEPTH_TEST), a.enable(a.BLEND), a.cullFace(a.BACK), a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA)) : (a.enable(a.DEPTH_TEST), a.disable(a.BLEND))), s = this.meshShaders[this.meshes[l].meshShaderIndex].shader, this.uiData.mouseDepthPicker && (s = this.pickingMeshShader), s.use(this.gl), a.uniformMatrix4fv(s.uniforms.mvpMtx, false, n), a.uniformMatrix4fv(s.uniforms.normMtx, false, i), a.uniform1f(s.uniforms.opacity, c), !(this.meshes[l].indexCount < 3)) {
          if (this.meshes[l].offsetPt0 && (this.meshes[l].fiberSides < 3 || this.meshes[l].fiberRadius <= 0)) {
            o = true;
            continue;
          }
          s.isMatcap && (a.activeTexture(mC), a.bindTexture(a.TEXTURE_2D, this.matCapTexture)), a.bindVertexArray(this.meshes[l].vao), a.drawElements(a.TRIANGLES, this.meshes[l].indexCount, a.UNSIGNED_INT, 0), a.bindVertexArray(this.unusedVAO);
        }
      }
      if (a.depthMask(true), !o) {
        a.enable(a.BLEND), a.depthFunc(a.ALWAYS);
        return;
      }
      s = this.fiberShader, s.use(this.gl), a.uniformMatrix4fv(s.uniforms.mvpMtx, false, n), a.uniform1f(s.uniforms.opacity, e);
      for (let l = 0; l < this.meshes.length; l++) this.meshes[l].indexCount < 3 || this.meshes[l].offsetPt0 && (this.meshes[l].fiberSides >= 3 && this.meshes[l].fiberRadius > 0 || (a.bindVertexArray(this.meshes[l].vaoFiber), a.drawElements(a.LINE_STRIP, this.meshes[l].indexCount, a.UNSIGNED_INT, 0), a.bindVertexArray(this.unusedVAO)));
      a.enable(a.BLEND), a.depthFunc(a.ALWAYS), this.readyForSync = true;
    }
    drawCrosshairs3D(t = true, e = 1, n = null, r = false, i = true) {
      var _a3, _b3;
      if (!this.opts.show3Dcrosshair && !r || this.opts.crosshairWidth <= 0 && r) return;
      const a = this.gl, s = this.frac2mm(this.scene.crosshairPos, 0, i);
      let o = 1;
      const [l, c, f] = this.sceneExtentsMinMax(i);
      if (this.volumes.length > 0) {
        if (!this.back) throw new Error("back undefined");
        o = 0.5 * Math.min(Math.min(this.back.pixDims[1], this.back.pixDims[2]), this.back.pixDims[3]);
      } else (f[0] < 50 || f[0] > 1e3) && (o = f[0] * 0.02);
      if (o *= this.opts.crosshairWidth, ((_a3 = this.opts) == null ? void 0 : _a3.crosshairWidthUnit) === "percent" && (o = f[0] * this.opts.crosshairWidth * 0.5 * 0.01), ((_b3 = this.opts) == null ? void 0 : _b3.crosshairWidthUnit) === "mm" && (o = this.opts.crosshairWidth * 0.5), (this.crosshairs3D === null || this.crosshairs3D.mm[0] !== s[0] || this.crosshairs3D.mm[1] !== s[1] || this.crosshairs3D.mm[2] !== s[2]) && (this.crosshairs3D !== null && (a.deleteBuffer(this.crosshairs3D.indexBuffer), a.deleteBuffer(this.crosshairs3D.vertexBuffer)), this.crosshairs3D = zc.generateCrosshairs(this.gl, 1, s, l, c, o, 20, this.opts.crosshairGap), this.crosshairs3D.mm = s), !this.surfaceShader) throw new Error("surfaceShader undefined");
      const u = this.surfaceShader;
      u.use(this.gl), n == null && ([n] = this.calculateMvpMatrix(this.crosshairs3D, void 0, this.scene.renderAzimuth, this.scene.renderElevation)), a.uniformMatrix4fv(u.uniforms.mvpMtx, false, n), a.disable(a.CULL_FACE), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.crosshairs3D.indexBuffer), a.enable(a.DEPTH_TEST);
      const h = [
        ...this.opts.crosshairColor
      ];
      t ? (a.disable(a.BLEND), a.depthFunc(a.GREATER)) : (a.enable(a.BLEND), a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA), a.depthFunc(a.ALWAYS)), h[3] = e, a.uniform4fv(u.uniforms.surfaceColor, h), a.bindVertexArray(this.crosshairs3D.vao), a.drawElements(a.TRIANGLES, this.crosshairs3D.indexCount, a.UNSIGNED_INT, 0), a.bindVertexArray(this.unusedVAO);
    }
    mm2frac(t, e = 0, n = false) {
      if (this.volumes.length < 1) {
        const r = Ue(0.1, 0.5, 0.5), [i, a, s] = this.sceneExtentsMinMax();
        return r[0] = (t[0] - i[0]) / s[0], r[1] = (t[1] - i[1]) / s[1], r[2] = (t[2] - i[2]) / s[2], isFinite(r) || (isFinite(r[0]) || (r[0] = 0.5), isFinite(r[1]) || (r[1] = 0.5), isFinite(r[2]) || (r[2] = 0.5), this.meshes.length < 1 && ee.error("mm2frac() not finite: objects not (yet) loaded.")), r;
      }
      return this.volumes[e].convertMM2Frac(t, n || this.opts.isSliceMM);
    }
    vox2frac(t, e = 0) {
      return this.volumes[e].convertVox2Frac(t);
    }
    frac2vox(t, e = 0) {
      return this.volumes.length <= e ? [
        0,
        0,
        0
      ] : this.volumes[e].convertFrac2Vox(t);
    }
    moveCrosshairInVox(t, e, n) {
      const r = this.frac2vox(this.scene.crosshairPos), i = r[2];
      r[0] += t, r[1] += e, r[2] += n, r[0] = l4(r[0], 0, this.volumes[0].dimsRAS[1] - 1), r[1] = l4(r[1], 0, this.volumes[0].dimsRAS[2] - 1), r[2] = l4(r[2], 0, this.volumes[0].dimsRAS[3] - 1), this.scene.crosshairPos = this.vox2frac(r), this.createOnLocationChange(), this.opts.is2DSliceShader && i !== r[2] && (this.updateGLVolume(), this.refreshDrawing(false)), this.drawScene();
    }
    frac2mm(t, e = 0, n = false) {
      const r = zn(t[0], t[1], t[2], 1);
      if (this.volumes.length > 0) return this.volumes[e].convertFrac2MM(t, n || this.opts.isSliceMM);
      {
        const [i, a] = this.sceneExtentsMinMax(), s = (o, l, c) => o * (1 - c) + l * c;
        r[0] = s(i[0], a[0], t[0]), r[1] = s(i[1], a[1], t[1]), r[2] = s(i[2], a[2], t[2]);
      }
      return r;
    }
    screenXY2TextureFrac(t, e, n, r = true) {
      const i = Ue(-1, -1, -1), a = this.screenSlices[n].axCorSag;
      if (a > 2) return i;
      const s = this.screenSlices[n].leftTopWidthHeight.slice();
      let o = false;
      s[2] < 0 && (o = true, s[0] += s[2], s[2] = -s[2]);
      let l = (t - s[0]) / s[2];
      o && (l = 1 - l);
      const c = 1 - (e - s[1]) / s[3];
      if (l < 0 || l > 1 || c < 0 || c > 1 || this.screenSlices[n].AxyzMxy.length < 4) return i;
      let f = Ue(0, 0, 0);
      f[0] = this.screenSlices[n].leftTopMM[0] + l * this.screenSlices[n].fovMM[0], f[1] = this.screenSlices[n].leftTopMM[1] + c * this.screenSlices[n].fovMM[1];
      const u = this.screenSlices[n].AxyzMxy;
      f[2] = u[2] + u[4] * (f[1] - u[1]) - u[3] * (f[0] - u[0]), a === 1 && (f = hr(f, [
        0,
        2,
        1
      ])), a === 2 && (f = hr(f, [
        2,
        0,
        1
      ]));
      const h = this.mm2frac(f);
      return r && (h[0] < 0 || h[0] > 1 || h[1] < 0 || h[1] > 1 || h[2] < 0 || h[2] > 1) ? i : h;
    }
    canvasPos2frac(t) {
      for (let e = 0; e < this.screenSlices.length; e++) {
        const n = this.screenXY2TextureFrac(t[0], t[1], e);
        if (n[0] >= 0) return n;
      }
      return [
        -1,
        -1,
        -1
      ];
    }
    frac2canvasPosWithTile(t, e) {
      const n = this.frac2mm(t);
      let r = {
        distance: 1 / 0
      };
      for (let i = 0; i < this.screenSlices.length; i++) {
        const a = this.screenSlices[i].axCorSag;
        if (a > 2 || this.screenSlices[i].AxyzMxy.length < 4 || e !== void 0 && a !== e) continue;
        let s = Ue(n[0], n[1], n[2]);
        a === 1 && (s = hr(s, [
          0,
          2,
          1
        ])), a === 2 && (s = hr(s, [
          1,
          2,
          0
        ]));
        const o = this.screenSlices[i].AxyzMxy, l = o[2] + o[4] * (s[1] - o[1]) - o[3] * (s[0] - o[0]), c = Math.abs(s[2] - l), f = this.opts.sliceType === 3 ? 1 : 0.1;
        if (c < r.distance && (r = {
          index: i,
          distance: c
        }), c <= f) {
          const u = (s[0] - this.screenSlices[i].leftTopMM[0]) / this.screenSlices[i].fovMM[0], h = (s[1] - this.screenSlices[i].leftTopMM[1]) / this.screenSlices[i].fovMM[1];
          if (u >= 0 && u <= 1 && h >= 0 && h <= 1) {
            const g = this.screenSlices[i].leftTopWidthHeight.slice();
            let v = false;
            g[2] < 0 && (v = true, g[0] += g[2], g[2] = -g[2]);
            let m = u;
            v && (m = 1 - u);
            const y = 1 - h, w = g[0] + m * g[2], C = g[1] + y * g[3];
            return {
              pos: [
                w,
                C
              ],
              tileIndex: i
            };
          }
        }
      }
      return null;
    }
    frac2canvasPos(t) {
      const e = this.frac2mm(t);
      let n = {
        index: -1,
        distance: 1 / 0
      };
      for (let r = 0; r < this.screenSlices.length; r++) {
        const i = this.screenSlices[r].axCorSag;
        if (i > 2 || this.screenSlices[r].AxyzMxy.length < 4) continue;
        let a = Ue(e[0], e[1], e[2]);
        i === 1 && (a = hr(a, [
          0,
          2,
          1
        ])), i === 2 && (a = hr(a, [
          1,
          2,
          0
        ]));
        const s = this.screenSlices[r].AxyzMxy, o = s[2] + s[4] * (a[1] - s[1]) - s[3] * (a[0] - s[0]), l = Math.abs(a[2] - o), c = this.opts.sliceType === 3 ? 1 : 0.1;
        if (l < n.distance && (n = {
          index: r,
          distance: l
        }), l <= c) {
          const f = (a[0] - this.screenSlices[r].leftTopMM[0]) / this.screenSlices[r].fovMM[0], u = (a[1] - this.screenSlices[r].leftTopMM[1]) / this.screenSlices[r].fovMM[1];
          if (f >= 0 && f <= 1 && u >= 0 && u <= 1) {
            const h = this.screenSlices[r].leftTopWidthHeight.slice();
            let g = false;
            h[2] < 0 && (g = true, h[0] += h[2], h[2] = -h[2]);
            let v = f;
            g && (v = 1 - f);
            const m = 1 - u, y = h[0] + v * h[2], w = h[1] + m * h[3];
            return [
              y,
              w
            ];
          }
        }
      }
      if (n.index >= 0 && n.distance < 2) {
        const r = n.index, i = this.screenSlices[r].axCorSag;
        let a = Ue(e[0], e[1], e[2]);
        i === 1 && (a = hr(a, [
          0,
          2,
          1
        ])), i === 2 && (a = hr(a, [
          1,
          2,
          0
        ]));
        const s = this.screenSlices[r].AxyzMxy;
        a[2] = s[2] + s[4] * (a[1] - s[1]) - s[3] * (a[0] - s[0]);
        const o = (a[0] - this.screenSlices[r].leftTopMM[0]) / this.screenSlices[r].fovMM[0], l = (a[1] - this.screenSlices[r].leftTopMM[1]) / this.screenSlices[r].fovMM[1];
        if (o >= -0.1 && o <= 1.1 && l >= -0.1 && l <= 1.1) {
          const c = Math.max(0, Math.min(1, o)), f = Math.max(0, Math.min(1, l)), u = this.screenSlices[r].leftTopWidthHeight.slice();
          let h = false;
          u[2] < 0 && (h = true, u[0] += u[2], u[2] = -u[2]);
          let g = c;
          h && (g = 1 - c);
          const v = 1 - f, m = u[0] + g * u[2], y = u[1] + v * u[3];
          return [
            m,
            y
          ];
        }
      }
      return null;
    }
    scaleSlice(t, e, n = [
      0,
      0
    ], r = [
      0,
      0
    ]) {
      const i = r[0] === 0 ? this.effectiveCanvasWidth() - n[0] : r[0] - n[0], a = r[1] === 0 ? this.effectiveCanvasHeight() - n[1] : r[1] - n[1];
      let s = i / t;
      e * s > a && (s = a / e);
      const o = t * s, l = e * s;
      return [
        (i - o) * 0.5,
        (a - l) * 0.5,
        o,
        l,
        s
      ];
    }
    drawThumbnail() {
      if (!this.bmpShader) throw new Error("bmpShader undefined");
      this.bmpShader.use(this.gl), this.gl.uniform2f(this.bmpShader.uniforms.canvasWidthHeight, this.gl.canvas.width, this.gl.canvas.height);
      let t = this.gl.canvas.height, e = this.gl.canvas.height * this.bmpTextureWH;
      e > this.gl.canvas.width && (t = this.gl.canvas.width / this.bmpTextureWH, e = this.gl.canvas.width);
      const n = (this.gl.canvas.width - e) / 2, r = (this.gl.canvas.height - t) / 2;
      this.gl.uniform4f(this.bmpShader.uniforms.leftTopWidthHeight, n, r, e, t), this.gl.bindVertexArray(this.genericVAO), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
    }
    drawLine(t, e = 1, n = [
      1,
      0,
      0,
      -1
    ]) {
      if (this.gl.bindVertexArray(this.genericVAO), !this.lineShader) throw new Error("lineShader undefined");
      this.lineShader.use(this.gl), n[3] < 0 && (n = this.opts.crosshairColor), this.gl.uniform4fv(this.lineShader.uniforms.lineColor, n), this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.uniform1f(this.lineShader.uniforms.thickness, e), this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, t), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
    }
    draw3DLine(t, e, n = 1, r = [
      1,
      0,
      0,
      -1
    ]) {
      if (this.gl.bindVertexArray(this.genericVAO), !this.line3DShader) throw new Error("line3DShader undefined");
      this.line3DShader.use(this.gl), r[3] < 0 && (r = this.opts.crosshairColor), this.gl.uniform4fv(this.line3DShader.uniforms.lineColor, r), this.gl.uniform2fv(this.line3DShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.uniform1f(this.line3DShader.uniforms.thickness, n), this.gl.uniform2fv(this.line3DShader.uniforms.startXY, t), this.gl.uniform3fv(this.line3DShader.uniforms.endXYZ, e), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.gl.bindVertexArray(this.unusedVAO);
    }
    drawDottedLine(t, e = 1, n = [
      1,
      0,
      0,
      -1
    ]) {
      if (this.gl.bindVertexArray(this.genericVAO), !this.lineShader) throw new Error("lineShader undefined");
      this.lineShader.use(this.gl);
      const r = n[3] < 0 ? [
        ...this.opts.crosshairColor
      ] : [
        ...n
      ];
      r[3] = 0.3;
      const i = $g(t[2] - t[0], t[3] - t[1]), a = Bw(i);
      j6(i, i);
      const o = this.fontPx * 1;
      Nv(i, i, o / 2);
      const l = Bw(i);
      let c = Math.floor(a / l);
      a % l && c++;
      const f = [
        t[0],
        t[1]
      ];
      this.gl.uniform4fv(this.lineShader.uniforms.lineColor, r), this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight, [
        this.gl.canvas.width,
        this.gl.canvas.height
      ]), this.gl.uniform1f(this.lineShader.uniforms.thickness, e);
      for (let u = 0; u < c - 1; u++) {
        if (u % 2) {
          f[0] += i[0], f[1] += i[1];
          continue;
        }
        const h = [
          f[0],
          f[1],
          f[0] + i[0],
          f[1] + i[1]
        ];
        this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY, h), this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), f[0] += i[0], f[1] += i[1];
      }
      this.gl.bindVertexArray(this.unusedVAO);
    }
    drawGraphLine(t, e = [
      1,
      0,
      0,
      0.5
    ], n = 2) {
      this.drawLine(t, n, e);
    }
    drawCrossLinesMM(t, e, n, r, i) {
      if (t < 0 || this.screenSlices.length <= t) return;
      const a = this.screenSlices[t];
      let s = a.sliceFrac;
      s === 1 / 0 && ee.debug("Rendering approximate cross lines in world view mode"), s === 1 / 0 && (s = 0.5);
      let l = r.slice(), c = i.slice();
      const f = Math.max(1, this.opts.crosshairWidth);
      e === 1 && (l = n.slice()), e === 2 && (l = n.slice(), c = r.slice());
      function u(h) {
        const g = $g(0, 0);
        return g[0] = a.leftTopWidthHeight[0] + (h[0] - a.leftTopMM[0]) / a.fovMM[0] * a.leftTopWidthHeight[2], g[1] = a.leftTopWidthHeight[1] + a.leftTopWidthHeight[3] - (h[1] - a.leftTopMM[1]) / a.fovMM[1] * a.leftTopWidthHeight[3], g;
      }
      if (l.length > 0 && e === 0) {
        const h = s, g = 1;
        for (let v = 0; v < l.length; v++) {
          const m = this.frac2mm([
            0.5,
            0.5,
            0.5
          ]);
          m[g] = l[v];
          let y = this.mm2frac(m);
          y = y[g];
          let w = this.frac2mm([
            0,
            y,
            h
          ]);
          w = hr(w, [
            0,
            1,
            2
          ]);
          let C = this.frac2mm([
            1,
            y,
            h
          ]);
          C = hr(C, [
            0,
            1,
            2
          ]), w = u(w), C = u(C), this.drawLine([
            w[0],
            w[1],
            C[0],
            C[1]
          ], f);
        }
      }
      if (l.length > 0 && e === 1) {
        const h = s, g = 2;
        for (let v = 0; v < l.length; v++) {
          const m = this.frac2mm([
            0.5,
            0.5,
            0.5
          ]);
          m[g] = l[v];
          let y = this.mm2frac(m);
          y = y[g];
          let w = this.frac2mm([
            0,
            h,
            y
          ]);
          w = hr(w, [
            0,
            2,
            1
          ]);
          let C = this.frac2mm([
            1,
            h,
            y
          ]);
          C = hr(C, [
            0,
            2,
            1
          ]), w = u(w), C = u(C), this.drawLine([
            w[0],
            w[1],
            C[0],
            C[1]
          ], f);
        }
      }
      if (l.length > 0 && e === 2) {
        const h = s, g = 2;
        for (let v = 0; v < l.length; v++) {
          const m = this.frac2mm([
            0.5,
            0.5,
            0.5
          ]);
          m[g] = l[v];
          let y = this.mm2frac(m);
          y = y[g];
          let w = this.frac2mm([
            h,
            0,
            y
          ]);
          w = hr(w, [
            1,
            2,
            0
          ]);
          let C = this.frac2mm([
            h,
            1,
            y
          ]);
          C = hr(C, [
            1,
            2,
            0
          ]), w = u(w), C = u(C), this.drawLine([
            w[0],
            w[1],
            C[0],
            C[1]
          ], f);
        }
      }
      if (c.length > 0 && e === 0) {
        const h = s, g = 0;
        for (let v = 0; v < c.length; v++) {
          const m = this.frac2mm([
            0.5,
            0.5,
            0.5
          ]);
          m[g] = c[v];
          let y = this.mm2frac(m);
          y = y[g];
          let w = this.frac2mm([
            y,
            0,
            h
          ]);
          w = hr(w, [
            0,
            1,
            2
          ]);
          let C = this.frac2mm([
            y,
            1,
            h
          ]);
          C = hr(C, [
            0,
            1,
            2
          ]), w = u(w), C = u(C), this.drawLine([
            w[0],
            w[1],
            C[0],
            C[1]
          ], f);
        }
      }
      if (c.length > 0 && e === 1) {
        const h = s, g = 0;
        for (let v = 0; v < c.length; v++) {
          const m = this.frac2mm([
            0.5,
            0.5,
            0.5
          ]);
          m[g] = c[v];
          let y = this.mm2frac(m);
          y = y[g];
          let w = this.frac2mm([
            y,
            h,
            0
          ]);
          w = hr(w, [
            0,
            2,
            1
          ]);
          let C = this.frac2mm([
            y,
            h,
            1
          ]);
          C = hr(C, [
            0,
            2,
            1
          ]), w = u(w), C = u(C), this.drawLine([
            w[0],
            w[1],
            C[0],
            C[1]
          ], f);
        }
      }
      if (c.length > 0 && e === 2) {
        const h = s, g = 1;
        for (let v = 0; v < c.length; v++) {
          const m = this.frac2mm([
            0.5,
            0.5,
            0.5
          ]);
          m[g] = c[v];
          let y = this.mm2frac(m);
          y = y[g];
          let w = this.frac2mm([
            h,
            y,
            0
          ]);
          w = hr(w, [
            1,
            2,
            0
          ]);
          let C = this.frac2mm([
            h,
            y,
            1
          ]);
          C = hr(C, [
            1,
            2,
            0
          ]), w = u(w), C = u(C), this.drawLine([
            w[0],
            w[1],
            C[0],
            C[1]
          ], f);
        }
      }
    }
    drawCrossLines(t, e, n, r, i) {
      if (t < 0 || this.screenSlices.length <= t) return;
      if (this.opts.isSliceMM) return this.drawCrossLinesMM(t, e, n, r, i);
      if (this.screenSlices[t].sliceFrac === 1 / 0) return this.drawCrossLinesMM(t, e, n, r, i);
      const a = this.screenSlices[t];
      let s = r.slice(), o = i.slice();
      if (e === 1 && (s = n.slice()), e === 2 && (s = n.slice(), o = r.slice()), s.length > 0) {
        const l = a.leftTopWidthHeight.slice();
        let c = 2;
        e === 0 && (c = 1);
        const f = this.frac2mm([
          0.5,
          0.5,
          0.5
        ]);
        for (let u = 0; u < s.length; u++) {
          f[c] = s[u];
          const h = this.mm2frac(f);
          this.drawRect([
            l[0],
            l[1] + l[3] - h[c] * l[3],
            l[2],
            1
          ]);
        }
      }
      if (o.length > 0) {
        const l = a.leftTopWidthHeight.slice(), c = a.fovMM[0] < 0;
        let f = 0;
        e === 2 && (f = 1);
        const u = this.frac2mm([
          0.5,
          0.5,
          0.5
        ]);
        for (let h = 0; h < o.length; h++) {
          u[f] = o[h];
          const g = this.mm2frac(u);
          c ? this.drawRect([
            l[0] + (l[2] - g[f] * l[2]),
            l[1],
            1,
            l[3]
          ]) : this.drawRect([
            l[0] + g[f] * l[2],
            l[1],
            1,
            l[3]
          ]);
        }
      }
    }
    drawMosaic(t) {
      var _a3;
      this.screenSlices = [];
      const e = this.screenFieldOfViewMM(0, true), n = this.screenFieldOfViewMM(0);
      t = t.replaceAll(";", " ;").trim();
      const r = [], i = [], a = [], s = t.split(/\s+/);
      let o = 1;
      const l = this.fontPx;
      let c = 0, f = 0, u = 0;
      ((_a3 = this.volumes[0]) == null ? void 0 : _a3.dims) || (u = Math.ceil(this.opts.tileMargin * 0.3));
      for (let h = 0; h < 2; h++) {
        let g = false, v = false;
        g = false;
        let m = 0, y = 0, w = 0, C = 0, T = false, S = 0, E = 0, b = 0, D = 0;
        for (let O = 0; O < s.length; O++) {
          const L = s[O];
          if (L.includes("X")) {
            v = true;
            continue;
          }
          if (L.includes("L")) {
            T = !L.includes("-");
            continue;
          }
          if (L.includes("H")) {
            O++, E = Math.max(0, Math.min(1, parseFloat(s[O]))), E = Math.abs(E);
            continue;
          }
          if (L.includes("V")) {
            O++;
            continue;
          }
          if (L.includes("A")) {
            S = 0;
            continue;
          }
          if (L.includes("C")) {
            S = 1;
            continue;
          }
          if (L.includes("S")) {
            S = 2;
            continue;
          }
          if (L.includes("R")) {
            g = true;
            continue;
          }
          if (L.includes(";")) {
            w += m, C = Math.max(C, y + b), m = 0, y = 0, b = 0;
            continue;
          }
          D = b, E > 0 && !g && (D = Math.round(D * (1 - E))), ee.debug(`item ${O} width with overlap ${D} pixels`), y += D, D = 0;
          const N = parseFloat(L);
          if (isNaN(N)) continue;
          let F = 0, V = n;
          if (g && (V = e), S === 2 ? D = V[1] : D = V[0], S === 0 ? F = V[1] : F = V[2], h === 0) g || (S === 0 && r.push(N), S === 1 && i.push(N), S === 2 && a.push(N));
          else {
            const k = [
              c + o * y,
              f + o * w,
              o * D,
              o * F
            ];
            if (this.fontPx = T ? l : 0, g) {
              let _ = N < 0 ? -1 / 0 : 1 / 0;
              Object.is(N, -0) && (_ = -1 / 0), this.draw2D(k, S, _);
            } else this.draw2D(k, S, N);
            v && this.drawCrossLines(this.screenSlices.length - 1, S, r, i, a), g = false, v = false;
          }
          b = D, y += u, m = Math.max(m, F);
        }
        if (w += m, C = Math.max(C, y + b), C <= 0 || w <= 0) break;
        const R = (this.gl.canvas.width - 2 * this.opts.tileMargin - u) / C, I = (this.effectiveCanvasHeight() - 2 * this.opts.tileMargin) / w;
        o = Math.min(R, I), this.opts.centerMosaic ? (c = Math.floor(0.5 * (this.gl.canvas.width - C * o)), f = Math.floor(0.5 * (this.effectiveCanvasHeight() - w * o))) : (c = this.opts.tileMargin, f = this.opts.tileMargin);
      }
      this.fontPx = l;
    }
    calculateWidthHeight(t, e, n, r) {
      let i, a;
      switch (t) {
        case 0:
          i = e[0], a = e[1];
          break;
        case 1:
          i = e[0], a = e[2];
          break;
        case 2:
          i = e[1], a = e[2];
          break;
        default:
          return [
            n,
            r
          ];
      }
      const s = i / a, o = n / r;
      let l, c;
      return s > o ? (l = n, c = n / s) : (c = r, l = r * s), [
        l,
        c
      ];
    }
    drawSceneCore() {
      var _a3, _b3, _c3;
      if (!this.initialized) return;
      if (this.colorbarHeight = 0, this.gl.clearColor(this.opts.backColor[0], this.opts.backColor[1], this.opts.backColor[2], this.opts.backColor[3]), this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT), this.bmpTexture && this.thumbnailVisible) {
        this.drawThumbnail();
        return;
      }
      let t = "";
      if (this.volumes.length === 0 || typeof this.volumes[0].dims > "u") {
        if (this.meshes.length > 0) {
          if (this.sliceMosaicString.length > 0) {
            this.opts.isColorbar && this.reserveColorbarPanel(), this.drawMosaic(this.sliceMosaicString), this.opts.isColorbar && this.drawColorbar();
            return;
          }
          this.screenSlices = [], this.draw3D(), this.opts.isColorbar && this.drawColorbar();
          return;
        }
        this.drawLoadingText(this.opts.loadingText);
        return;
      }
      if (this.uiData.isDragging && this.scene.clipPlaneDepthAziElev[0] < 1.8 && this.inRenderTile(this.uiData.dragStart[0], this.uiData.dragStart[1]) >= 0) {
        const i = this.uiData.dragStart[0] - this.uiData.dragEnd[0], a = this.uiData.dragStart[1] - this.uiData.dragEnd[1], s = this.uiData.dragClipPlaneStartDepthAziElev.slice();
        if (s[1] -= i, s[1] = s[1] % 360, s[2] += a, s[1] !== this.scene.clipPlaneDepthAziElev[1] || s[2] !== this.scene.clipPlaneDepthAziElev[2]) return this.scene.clipPlaneDepthAziElev = s, this.setClipPlane(this.scene.clipPlaneDepthAziElev);
      }
      if (this.sliceMosaicString.length < 1 && this.opts.sliceType === 4) {
        this.opts.isColorbar && this.reserveColorbarPanel(), this.screenSlices = [], this.draw3D(), this.opts.isColorbar && this.drawColorbar();
        return;
      }
      this.opts.isColorbar && this.reserveColorbarPanel();
      const e = this.getMaxVols(), n = this.opts.sliceType === 3 && e > 1 && this.graph.autoSizeMultiplanar && this.graph.opacity > 0;
      if (this.sliceMosaicString.length > 0) this.drawMosaic(this.sliceMosaicString);
      else {
        const i = [
          0,
          0
        ];
        let a = false;
        if (this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.screenSlices = [], this.customLayout && this.customLayout.length > 0) {
          this.screenSlices = [], this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
          const { volScale: s } = this.sliceScale(), o = [
            this.effectiveCanvasWidth(),
            this.effectiveCanvasHeight()
          ];
          for (const l of this.customLayout) {
            const { sliceType: c, position: f, sliceMM: u } = l, h = f.slice();
            if (f[0] >= 0 && f[0] <= 1 && f[2] <= 1 && (h[0] = f[0] * o[0], h[2] = f[2] * o[0]), f[1] >= 0 && f[1] <= 1 && f[3] <= 1 && (h[1] = f[1] * o[1], h[3] = f[3] * o[1]), h[0] + h[2] > o[0] && (ee.warn("adjusting slice width because it would have been clipped"), h[2] = o[0] - h[0]), h[1] + h[3] > o[1] && (ee.warn("adjusting slice height because it would have been clipped"), h[3] = o[1] - h[1]), c === 4) this.draw3D(h);
            else if (c === 0 || c === 1 || c === 2) {
              const g = this.calculateWidthHeight(c, s, h[2], h[3]);
              this.draw2D(h, c, u ?? NaN, g);
            }
          }
        } else if (this.opts.sliceType === 0) this.draw2D([
          0,
          0,
          0,
          0
        ], 0);
        else if (this.opts.sliceType === 1) this.draw2D([
          0,
          0,
          0,
          0
        ], 1);
        else if (this.opts.sliceType === 2) this.draw2D([
          0,
          0,
          0,
          0
        ], 2);
        else {
          let s = function(k, _) {
            return [
              (k - 1) * u + k * h,
              (_ - 1) * u + _ * h
            ];
          }, o = false;
          this.opts.multiplanarForceRender ? (o = true, this.opts.multiplanarForceRender ? this.opts.multiplanarShowRender = 1 : this.opts.multiplanarShowRender = 2, delete this.opts.multiplanarForceRender) : this.opts.multiplanarShowRender === 1 && (o = true);
          const l = isFinite(this.drawPenLocation[0]) && this.opts.drawingEnabled, { volScale: c } = this.sliceScale(), f = c.slice();
          this.opts.multiplanarEqualSize && (c[0] = 1, c[1] = 1, c[2] = 1), typeof this.opts.multiplanarPadPixels != "number" && ee.debug("multiplanarPadPixels must be numeric");
          const u = parseFloat(`${this.opts.multiplanarPadPixels}`) * this.uiData.dpr;
          let h = this.opts.tileMargin * this.uiData.dpr;
          h < 0 && (h = 2 * (2 + Math.ceil(this.fontPx)));
          let g = [
            this.effectiveCanvasWidth(),
            this.effectiveCanvasHeight()
          ];
          this.opts.heroImageFraction > 0 && this.opts.heroImageFraction < 1 && (o = false, a = true, g[0] > g[1] && this.opts.multiplanarLayout !== 3 ? i[0] = g[0] * this.opts.heroImageFraction : i[1] = g[1] * this.opts.heroImageFraction, g = [
            g[0] - i[0],
            g[1] - i[1]
          ]);
          const v = this.scaleSlice(c[0] + c[1], c[1] + c[2], s(2, 2), g), m = Math.max(Math.max(c[1], c[2]), c[0]), y = this.scaleSlice(c[0] + c[0] + c[1], Math.max(c[1], c[2]), s(3, 1), g), w = this.scaleSlice(c[0] + c[0] + c[1] + m, Math.max(c[1], c[2]), s(4, 1), g), C = this.scaleSlice(m, c[1] + c[2] + c[2], s(1, 3), g), T = this.scaleSlice(m, c[1] + c[2] + c[2] + m, s(1, 4), g);
          let S = !l && (e < 2 || !n), E = false, b = false, D = false;
          this.opts.multiplanarLayout === 1 ? E = true : this.opts.multiplanarLayout === 2 ? b = true : this.opts.multiplanarLayout === 3 ? D = true : C[4] > y[4] && C[4] > v[4] ? E = true : y[4] > v[4] ? D = true : b = true;
          let R = v;
          if (E ? (R = C, !a && (o || this.opts.multiplanarShowRender === 2 && T[4] >= C[4]) ? R = T : S = false) : D && (R = y, !a && (o || this.opts.multiplanarShowRender === 2 && w[4] >= y[4]) ? R = w : S = false), a) {
            const k = i[0] === 0 ? this.effectiveCanvasWidth() : i[0], _ = i[1] === 0 ? this.effectiveCanvasHeight() : i[1];
            if (((_a3 = this.opts) == null ? void 0 : _a3.heroSliceType) === 0 || ((_b3 = this.opts) == null ? void 0 : _b3.heroSliceType) === 1 || ((_c3 = this.opts) == null ? void 0 : _c3.heroSliceType) === 2) this.draw2D([
              0,
              0,
              k,
              _
            ], this.opts.heroSliceType, NaN, [
              1 / 0,
              1 / 0
            ]);
            else {
              const K = R.slice(), Z = this.effectiveCanvasWidth();
              k === Z && (K[0] = 0), this.draw3D([
                K[0],
                0,
                k,
                _
              ]);
            }
            R[0] += i[0], R[1] += i[1], S = false;
          }
          const I = c[0] * R[4] + h, O = c[1] * R[4] + h, L = c[2] * R[4] + h, N = f[0] * R[4], F = f[1] * R[4], V = f[2] * R[4];
          if (E) {
            if (this.draw2D([
              R[0],
              R[1],
              I,
              O
            ], 0, NaN, [
              N,
              F
            ]), this.draw2D([
              R[0],
              R[1] + O + u,
              I,
              L
            ], 1, NaN, [
              N,
              V
            ]), this.draw2D([
              R[0],
              R[1] + O + u + L + u,
              O,
              L
            ], 2, NaN, [
              F,
              V
            ]), S) {
              const k = m * R[4];
              this.draw3D([
                R[0],
                R[1] + O + L + L + u * 3,
                k,
                k
              ]);
            }
          } else if (D) {
            if (this.draw2D([
              R[0],
              R[1],
              I,
              O
            ], 0, NaN, [
              N,
              F
            ]), this.draw2D([
              R[0] + I + u,
              R[1],
              I,
              L
            ], 1, NaN, [
              N,
              V
            ]), this.draw2D([
              R[0] + I + I + u * 2,
              R[1],
              O,
              L
            ], 2, NaN, [
              F,
              V
            ]), S) {
              const k = m * R[4];
              this.draw3D([
                R[0] + I + I + O + u * 3,
                R[1],
                k,
                k
              ]);
            }
          } else b && (o || (S = false), this.opts.multiplanarShowRender === 2 && (S = true), a && (S = false), this.draw2D([
            R[0],
            R[1] + L + u,
            I,
            O
          ], 0, NaN, [
            N,
            F
          ]), this.draw2D([
            R[0],
            R[1],
            I,
            L
          ], 1, NaN, [
            N,
            V
          ]), this.draw2D([
            R[0] + I + u,
            R[1],
            O,
            L
          ], 2, NaN, [
            F,
            V
          ]), S && this.draw3D([
            R[0] + I + u,
            R[1] + L + u,
            O,
            O
          ]));
        }
      }
      if (this.opts.isRuler && this.drawRuler(), this.opts.isColorbar && this.drawColorbar(), n && this.drawGraph(), this.uiData.isDragging) {
        if (this.uiData.mouseButtonCenterDown) {
          this.dragForCenterButton([
            this.uiData.dragStart[0],
            this.uiData.dragStart[1],
            this.uiData.dragEnd[0],
            this.uiData.dragEnd[1]
          ]);
          return;
        }
        if (this.getCurrentDragMode() === 4) {
          this.dragForSlicer3D([
            this.uiData.dragStart[0],
            this.uiData.dragStart[1],
            this.uiData.dragEnd[0],
            this.uiData.dragEnd[1]
          ]);
          return;
        }
        if (this.getCurrentDragMode() === 3) {
          this.dragForPanZoom([
            this.uiData.dragStart[0],
            this.uiData.dragStart[1],
            this.uiData.dragEnd[0],
            this.uiData.dragEnd[1]
          ]);
          return;
        }
        if (this.inRenderTile(this.uiData.dragStart[0], this.uiData.dragStart[1]) >= 0) return;
        this.getCurrentDragMode() === 2 && this.drawMeasurementTool([
          this.uiData.dragStart[0],
          this.uiData.dragStart[1],
          this.uiData.dragEnd[0],
          this.uiData.dragEnd[1]
        ]), this.getCurrentDragMode() === 7 && this.drawAngleMeasurementTool();
        const i = this.getCurrentDragMode();
        if (i === 1 || i === 6) {
          const a = Math.abs(this.uiData.dragStart[0] - this.uiData.dragEnd[0]), s = Math.abs(this.uiData.dragStart[1] - this.uiData.dragEnd[1]);
          this.drawSelectionBox([
            Math.min(this.uiData.dragStart[0], this.uiData.dragEnd[0]),
            Math.min(this.uiData.dragStart[1], this.uiData.dragEnd[1]),
            a,
            s
          ]);
        }
      }
      for (const i of this.document.completedMeasurements) if (this.shouldDrawOnCurrentSlice(i.sliceIndex, i.sliceType, i.slicePosition)) {
        const a = this.mm2frac(i.startMM), s = this.mm2frac(i.endMM), o = this.frac2canvasPosWithTile(a, i.sliceType), l = this.frac2canvasPosWithTile(s, i.sliceType);
        o && l && o.tileIndex === l.tileIndex && this.drawMeasurementTool([
          o.pos[0],
          o.pos[1],
          l.pos[0],
          l.pos[1]
        ]);
      }
      for (let i = 0; i < this.document.completedAngles.length; i++) {
        const a = this.document.completedAngles[i];
        if (this.shouldDrawOnCurrentSlice(a.sliceIndex, a.sliceType, a.slicePosition)) {
          const o = this.mm2frac(a.firstLineMM.start), l = this.mm2frac(a.firstLineMM.end), c = this.mm2frac(a.secondLineMM.start), f = this.mm2frac(a.secondLineMM.end), u = this.frac2canvasPosWithTile(o, a.sliceType), h = this.frac2canvasPosWithTile(l, a.sliceType), g = this.frac2canvasPosWithTile(c, a.sliceType), v = this.frac2canvasPosWithTile(f, a.sliceType);
          if (u && h && g && v && u.tileIndex === h.tileIndex && u.tileIndex === g.tileIndex && u.tileIndex === v.tileIndex) {
            this.drawMeasurementTool([
              u.pos[0],
              u.pos[1],
              h.pos[0],
              h.pos[1]
            ], false), this.drawMeasurementTool([
              g.pos[0],
              g.pos[1],
              v.pos[0],
              v.pos[1]
            ], false);
            const m = {
              firstLine: [
                u.pos[0],
                u.pos[1],
                h.pos[0],
                h.pos[1]
              ],
              secondLine: [
                g.pos[0],
                g.pos[1],
                v.pos[0],
                v.pos[1]
              ],
              sliceIndex: a.sliceIndex,
              sliceType: a.sliceType,
              slicePosition: a.slicePosition
            };
            this.drawAngleTextForAngle(m);
          }
        }
      }
      const r = this.frac2mm([
        this.scene.crosshairPos[0],
        this.scene.crosshairPos[1],
        this.scene.crosshairPos[2]
      ]);
      return t = r[0].toFixed(2) + "\xD7" + r[1].toFixed(2) + "\xD7" + r[2].toFixed(2), this.readyForSync = true, this.sync(), this.drawAnchoredLabels(), t;
    }
    drawScene() {
      if (this.isBusy) {
        this.needsRefresh = true;
        return;
      }
      this.isBusy = false, this.needsRefresh = false;
      let t = this.drawSceneCore();
      return this._gl !== null && this.gl.finish(), this.needsRefresh && (t = this.drawScene()), t;
    }
    get gl() {
      if (!this._gl) throw new Error("unable to get WebGL context. Maybe the browser doesn't support WebGL2.");
      return this._gl;
    }
    set gl(t) {
      this._gl = t;
    }
    findDrawingBoundarySlices(t) {
      if (!this.back || !this.back.dims || !this.drawBitmap) return null;
      const e = {
        dimX: this.back.dims[1],
        dimY: this.back.dims[2],
        dimZ: this.back.dims[3]
      };
      return HG(t, this.drawBitmap, e);
    }
    interpolateMaskSlices(t, e, n = {}) {
      if (!this.back || !this.back.dims || !this.drawBitmap) throw new Error("Background image and drawing bitmap must be loaded");
      const r = {
        dimX: this.back.dims[1],
        dimY: this.back.dims[2],
        dimZ: this.back.dims[3]
      }, i = this.back.img, a = this.back.global_max;
      XG(this.drawBitmap, r, i, a, t, e, n, () => this.refreshDrawing(true));
    }
  };
  var sW = {
    outline: {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    filled: {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      stroke: "none"
    }
  };
  const Yu = (t, e, n, r) => {
    const i = me.forwardRef(({ color: a = "currentColor", size: s = 24, stroke: o = 2, title: l, className: c, children: f, ...u }, h) => me.createElement("svg", {
      ref: h,
      ...sW[t],
      width: s,
      height: s,
      className: [
        "tabler-icon",
        `tabler-icon-${e}`,
        c
      ].join(" "),
      strokeWidth: o,
      stroke: a,
      ...u
    }, [
      l && me.createElement("title", {
        key: "svg-title"
      }, l),
      ...r.map(([g, v]) => me.createElement(g, v)),
      ...Array.isArray(f) ? f : [
        f
      ]
    ]));
    return i.displayName = `${n}`, i;
  };
  const oW = [
    [
      "path",
      {
        d: "M5 12l14 0",
        key: "svg-0"
      }
    ],
    [
      "path",
      {
        d: "M5 12l6 6",
        key: "svg-1"
      }
    ],
    [
      "path",
      {
        d: "M5 12l6 -6",
        key: "svg-2"
      }
    ]
  ], lW = Yu("outline", "arrow-left", "ArrowLeft", oW);
  const cW = [
    [
      "path",
      {
        d: "M9 6l6 6l-6 6",
        key: "svg-0"
      }
    ]
  ], uW = Yu("outline", "chevron-right", "ChevronRight", cW);
  const fW = [
    [
      "path",
      {
        d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2",
        key: "svg-0"
      }
    ],
    [
      "path",
      {
        d: "M7 11l5 5l5 -5",
        key: "svg-1"
      }
    ],
    [
      "path",
      {
        d: "M12 4l0 12",
        key: "svg-2"
      }
    ]
  ], hW = Yu("outline", "download", "Download", fW);
  const dW = [
    [
      "path",
      {
        d: "M5 12l-2 0l9 -9l9 9l-2 0",
        key: "svg-0"
      }
    ],
    [
      "path",
      {
        d: "M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7",
        key: "svg-1"
      }
    ],
    [
      "path",
      {
        d: "M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6",
        key: "svg-2"
      }
    ]
  ], gW = Yu("outline", "home", "Home", dW);
  const pW = [
    [
      "path",
      {
        d: "M8 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h5.697",
        key: "svg-0"
      }
    ],
    [
      "path",
      {
        d: "M18 14v4h4",
        key: "svg-1"
      }
    ],
    [
      "path",
      {
        d: "M18 11v-4a2 2 0 0 0 -2 -2h-2",
        key: "svg-2"
      }
    ],
    [
      "path",
      {
        d: "M8 3m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v0a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z",
        key: "svg-3"
      }
    ],
    [
      "path",
      {
        d: "M18 18m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0",
        key: "svg-4"
      }
    ],
    [
      "path",
      {
        d: "M8 11h4",
        key: "svg-5"
      }
    ],
    [
      "path",
      {
        d: "M8 15h3",
        key: "svg-6"
      }
    ]
  ], mW = Yu("outline", "report", "Report", pW);
  const vW = [
    [
      "path",
      {
        d: "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z",
        key: "svg-0"
      }
    ],
    [
      "path",
      {
        d: "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0",
        key: "svg-1"
      }
    ]
  ], yW = Yu("outline", "settings", "Settings", vW);
  function xW({ opacityValue: t, handleOpacityOnSliderChange: e, handleOpacityOnFormSubmit: n }) {
    const [r, i] = me.useState(t);
    me.useEffect(() => {
      i(t);
    }, [
      t
    ]);
    const a = (o) => {
      i(Number(o.target.value));
    }, s = (o) => {
      o.preventDefault();
      let l = Number(r);
      isNaN(l) || (l = Math.max(0, Math.min(100, l)), i(l), n(l));
    };
    return be.jsx("div", {
      className: "windowing-slider",
      children: be.jsxs("div", {
        className: "flex gap-1 flex-col justify-center items-center border",
        children: [
          be.jsxs("div", {
            className: "flex justify-between w-full items-center",
            children: [
              be.jsx("div", {
                style: {
                  color: "white"
                },
                children: "Label Opacity"
              }),
              be.jsx("form", {
                onSubmit: s,
                className: "w-1/3",
                children: be.jsx("input", {
                  type: "text",
                  value: r,
                  onChange: a,
                  className: "text-white rounded-md border p-1 w-full"
                })
              })
            ]
          }),
          be.jsx("input", {
            type: "range",
            min: "0",
            max: "100",
            step: "1",
            className: "w-full",
            value: t,
            onChange: e
          })
        ]
      })
    });
  }
  const g1 = (t) => {
    for (let e = 0; e < Rv.length; e++) if (Rv[e] === t) return e;
    return 0;
  };
  function wW({ system: t, labelColorMap: e, checkState: n, setCheckState: r }) {
    const [i, a] = me.useState(false), [s, o] = me.useState(true);
    return me.useEffect(() => {
      Lw[t].forEach((l) => {
        r((c) => {
          const f = [
            ...c
          ];
          return f[g1(l) + 1] = s, f;
        });
      });
    }, [
      s,
      r,
      t
    ]), be.jsxs("div", {
      className: "flex gap-2 flex-col",
      children: [
        be.jsxs("div", {
          className: "flex justify-between items-center",
          children: [
            be.jsxs("div", {
              className: "flex items-center gap-2 cursor-pointer",
              onClick: () => a((l) => !l),
              children: [
                be.jsx(uW, {
                  className: `cursor-pointer text-white hover:bg-gray-700 rounded-md flex items-center justify-center transition-all duration origin-center ${i ? "rotate-90" : ""}`
                }),
                be.jsx("div", {
                  className: "text-white text-lg",
                  children: t
                })
              ]
            }),
            be.jsx("input", {
              type: "checkbox",
              className: "w-4 h-4 text-blue-600 !bg-gray-700 border-gray-600 !rounded-sm focus:ring-blue-600 ring-offset-gray-800 focus:ring-2",
              checked: s,
              onChange: (l) => o(l.target.checked)
            })
          ]
        }),
        be.jsx("div", {
          className: `flex flex-col gap-2 transition-all duration-100 origin-top ${i ? "scale-y-100" : "hidden scale-y-0"}`,
          children: Lw[t].map((l) => {
            const c = e[g1(l)], f = c ? `rgb(${c[0]}, ${c[1]}, ${c[2]})` : "gray";
            return be.jsxs("div", {
              className: "flex items-center gap-2 pl-4",
              children: [
                be.jsx("div", {
                  className: "cursor-pointer text-white hover:bg-gray-700 rounded-md flex items-center justify-center transition-all duration origin-center"
                }),
                be.jsx("div", {
                  className: `text-white text-md rounded-md p-1 cursor-pointer hover:border-3 ${n[g1(l) + 1] ? "border-2" : "border-0"}`,
                  style: {
                    borderColor: f
                  },
                  onClick: () => {
                    r((u) => {
                      const h = [
                        ...u
                      ];
                      return h[g1(l) + 1] = !h[g1(l) + 1], h;
                    });
                  },
                  children: l
                })
              ]
            }, l);
          })
        })
      ]
    });
  }
  function CW({ setCheckState: t, checkBoxData: e, checkState: n, sessionId: r, clabelId: i, setShowTaskDetails: a, setShowOrganDetails: s, showOrganDetails: o }) {
    const [l, c] = me.useState({}), f = `labelColorMap_${r}`;
    me.useEffect(() => {
      (async () => {
        try {
          const v = await (await fetch(`${ls.API_ORIGIN}/api/get-label-colormap/${i}`)).json(), m = {};
          for (const y in v) {
            const w = v[y];
            w && w.R !== void 0 && (m[Number(y)] = [
              w.R,
              w.G,
              w.B,
              w.A ?? 255
            ]);
          }
          sessionStorage.setItem(f, JSON.stringify(m)), c(m);
        } catch (g) {
          console.warn("\u2757 Failed to fetch colormap:", g);
        }
      })();
    }, [
      r
    ]);
    const u = () => {
      t((h) => {
        let g = [
          ...h
        ];
        return g.filter((m) => m === true).length > g.length / 2 ? g = g.map(() => false) : g = g.map(() => true), g;
      });
    };
    return console.log(e), be.jsxs("div", {
      className: `flex w-2xs h-screen flex-col gap-4 p-3 z-3 absolute top-0 left-0 bg-[#0f0824] duration-100 transition-all ${o ? "translate-x-0" : "-translate-x-full"} origin-left`,
      children: [
        be.jsxs("div", {
          className: "flex gap-4 items-center justify-start",
          children: [
            be.jsx(lW, {
              className: "cursor-pointer text-white hover:bg-gray-700 rounded-md flex items-center justify-center",
              onClick: () => {
                a(false), s(false);
              }
            }),
            be.jsx("div", {
              className: "text-white text-2xl",
              children: "Organs"
            })
          ]
        }),
        be.jsx("button", {
          className: "w-full mt-3",
          onClick: () => u(),
          children: "Toggle all"
        }),
        be.jsx("div", {
          className: "flex flex-col gap-2 overflow-scroll",
          children: u_.map((h, g) => be.jsx(wW, {
            system: h,
            labelColorMap: l,
            checkState: n,
            setCheckState: t
          }, g))
        }),
        be.jsx("div", {
          className: "w-full"
        })
      ]
    });
  }
  const TW = ({ id: t, onClose: e }) => (me.useEffect(() => {
    fetch(`${ls.API_ORIGIN}/api/get-report/${t}`, {
      method: "GET"
    }).then(async (n) => {
      if (!n.ok) {
        const r = await n.text();
        throw new Error(`Failed to fetch report PDF: ${n.status} ${n.statusText} - ${r}`);
      }
      return n.blob();
    }).then((n) => {
      const r = URL.createObjectURL(n);
      window.open(r, "_blank", "noopener,noreferrer"), e();
    }).catch(() => {
      e();
    });
  }, [
    t,
    e
  ]), null);
  function SW({ windowWidth: t, windowCenter: e, onWindowChange: n }) {
    const [r, i] = me.useState(t), [a, s] = me.useState(e), o = (u) => {
      i(Number(u.target.value));
    }, l = (u) => {
      s(Number(u.target.value));
    }, c = (u) => {
      u.preventDefault();
      let h = r;
      isNaN(h) || (h = Math.min(Math.max(h, 1), 400), n(h, null));
    }, f = (u) => {
      u.preventDefault();
      let h = a;
      isNaN(h) || (h = Math.min(Math.max(h, -1e3), 50), n(null, h));
    };
    return be.jsxs("div", {
      className: "windowing-slider w-full flex flex-col gap-3",
      children: [
        be.jsxs("div", {
          className: "flex gap-1 flex-col w-full justify-center items-center",
          children: [
            be.jsxs("div", {
              className: "flex justify-between w-full items-center",
              children: [
                be.jsx("label", {
                  style: {
                    color: "white"
                  },
                  children: "Level"
                }),
                be.jsx("form", {
                  onSubmit: f,
                  className: "w-1/3",
                  children: be.jsx("input", {
                    type: "text",
                    value: a,
                    onChange: l,
                    className: "text-white rounded-md p-1 border w-full"
                  })
                })
              ]
            }),
            be.jsx("input", {
              type: "range",
              min: "-1000",
              max: "1000",
              step: "1",
              value: e,
              onChange: (u) => {
                const h = parseInt(u.target.value);
                s(h), n(null, h);
              },
              className: "w-full"
            })
          ]
        }),
        be.jsxs("div", {
          className: "flex gap-2 flex-col w-full justify-center items-center",
          children: [
            be.jsxs("div", {
              className: "flex justify-between w-full items-center",
              children: [
                be.jsx("label", {
                  style: {
                    color: "white"
                  },
                  children: "Window"
                }),
                be.jsx("form", {
                  onSubmit: c,
                  className: "w-1/3",
                  children: be.jsx("input", {
                    type: "text",
                    value: r,
                    onChange: o,
                    className: "border text-white p-1 rounded-md w-full"
                  })
                })
              ]
            }),
            be.jsx("input", {
              type: "range",
              min: "1",
              max: "2000",
              step: "1",
              value: t,
              onChange: (u) => {
                const h = parseInt(u.target.value);
                i(h), n(h, null);
              },
              className: "w-full"
            })
          ]
        })
      ]
    });
  }
  var ze;
  (function(t) {
    t.ERROR_EVENT = "CORNERSTONE_ERROR", t.CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED", t.IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR", t.CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED", t.CAMERA_RESET = "CORNERSTONE_CAMERA_RESET", t.VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED", t.PRESET_MODIFIED = "CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED", t.DISPLAY_AREA_MODIFIED = "CORNERSTONE_DISPLAY_AREA_MODIFIED", t.ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED", t.ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED", t.IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED", t.IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED", t.IMAGE_VOLUME_LOADING_COMPLETED = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED", t.IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED", t.IMAGE_RETRIEVAL_STAGE = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE", t.IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED", t.VOLUME_VIEWPORT_NEW_VOLUME = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME", t.VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED", t.VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED", t.IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED", t.IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED", t.VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED", t.VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED", t.STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE", t.VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE", t.PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE", t.IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED", t.STACK_VIEWPORT_NEW_STACK = "CORNERSTONE_STACK_VIEWPORT_NEW_STACK", t.STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL", t.STACK_SCROLL_OUT_OF_BOUNDS = "STACK_SCROLL_OUT_OF_BOUNDS", t.GEOMETRY_CACHE_GEOMETRY_ADDED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED", t.VOLUME_SCROLL_OUT_OF_BOUNDS = "VOLUME_SCROLL_OUT_OF_BOUNDS", t.VOLUME_VIEWPORT_SCROLL = "VOLUME_VIEWPORT_SCROLL", t.CLIPPING_PLANES_UPDATED = "CORNERSTONE_CLIPPING_PLANES_UPDATED", t.WEB_WORKER_PROGRESS = "CORNERSTONE_WEB_WORKER_PROGRESS", t.COLORMAP_MODIFIED = "CORNERSTONE_COLORMAP_MODIFIED";
  })(ze || (ze = {}));
  var ar;
  (function(t) {
    t.Interaction = "interaction", t.Thumbnail = "thumbnail", t.Prefetch = "prefetch", t.Compute = "compute";
  })(ar || (ar = {}));
  var Hn;
  (function(t) {
    t.STACK = "stack", t.ORTHOGRAPHIC = "orthographic", t.PERSPECTIVE = "perspective", t.VOLUME_3D = "volume3d", t.VIDEO = "video", t.WholeSlide = "wholeSlide";
  })(Hn || (Hn = {}));
  var ho;
  (function(t) {
    t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR", t[t.FAST_LINEAR = 2] = "FAST_LINEAR";
  })(ho || (ho = {}));
  const mb = {
    COMPOSITE_BLEND: 0,
    MAXIMUM_INTENSITY_BLEND: 1,
    MINIMUM_INTENSITY_BLEND: 2,
    AVERAGE_INTENSITY_BLEND: 3,
    ADDITIVE_INTENSITY_BLEND: 4,
    RADON_TRANSFORM_BLEND: 5
  }, AW = {
    OFF: 0,
    NORMALIZED: 1,
    RAW: 2
  };
  var EW = {
    BlendMode: mb,
    FilterMode: AW
  }, ip;
  (function(t) {
    t[t.COMPOSITE = 0] = "COMPOSITE", t[t.MAXIMUM_INTENSITY_BLEND = 1] = "MAXIMUM_INTENSITY_BLEND", t[t.MINIMUM_INTENSITY_BLEND = 2] = "MINIMUM_INTENSITY_BLEND", t[t.AVERAGE_INTENSITY_BLEND = 3] = "AVERAGE_INTENSITY_BLEND";
  })(ip || (ip = {}));
  var vo;
  (function(t) {
    t.AXIAL = "axial", t.CORONAL = "coronal", t.SAGITTAL = "sagittal", t.ACQUISITION = "acquisition";
  })(vo || (vo = {}));
  var Ds;
  (function(t) {
    t.TRUE = "true", t.FALSE = "false", t.AUTO = "auto";
  })(Ds || (Ds = {}));
  var Ao;
  (function(t) {
    t.CONTOUR = "contour", t.SURFACE = "Surface";
  })(Ao || (Ao = {}));
  var Gv;
  (function(t) {
    t.CLOSED_PLANAR = "CLOSED_PLANAR", t.OPEN_PLANAR = "OPEN_PLANAR";
  })(Gv || (Gv = {}));
  const bW = Gv;
  var yo;
  (function(t) {
    t.LINEAR = "LINEAR", t.SAMPLED_SIGMOID = "SIGMOID";
  })(yo || (yo = {}));
  var zv;
  (function(t) {
    t.SUM = "SUM", t.AVERAGE = "AVERAGE", t.SUBTRACT = "SUBTRACT";
  })(zv || (zv = {}));
  const DW = zv;
  var Wv;
  (function(t) {
    t.NOT_APPLICABLE = "", t.ERMF = "ERMF", t.USER = "User", t.PROJECTION = "Proj", t.REGION = "Region", t.ERROR = "Error", t.UNCALIBRATED = "Uncalibrated";
  })(Wv || (Wv = {}));
  const MW = Wv;
  var Bi;
  (function(t) {
    t.NO_DATA = "noData", t.LOADING = "loading", t.PRE_RENDER = "preRender", t.RESIZE = "resize", t.RENDERED = "rendered";
  })(Bi || (Bi = {}));
  var Fc;
  (function(t) {
    t[t.FAR_REPLICATE = 1] = "FAR_REPLICATE", t[t.ADJACENT_REPLICATE = 3] = "ADJACENT_REPLICATE", t[t.SUBRESOLUTION = 6] = "SUBRESOLUTION", t[t.LOSSY = 7] = "LOSSY", t[t.FULL_RESOLUTION = 8] = "FULL_RESOLUTION";
  })(Fc || (Fc = {}));
  var wh;
  (function(t) {
    t.FRAME = "f", t.SECOND = "s";
  })(wh || (wh = {}));
  const RW = Object.freeze(Object.defineProperty({
    __proto__: null,
    get SpeedUnit() {
      return wh;
    }
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var ma;
  (function(t) {
    t.CALIBRATION = "calibrationModule", t.CINE = "cineModule", t.GENERAL_IMAGE = "generalImageModule", t.GENERAL_SERIES = "generalSeriesModule", t.GENERAL_STUDY = "generalStudyModule", t.IMAGE_PIXEL = "imagePixelModule", t.IMAGE_PLANE = "imagePlaneModule", t.IMAGE_URL = "imageUrlModule", t.MODALITY_LUT = "modalityLutModule", t.MULTIFRAME = "multiframeModule", t.NM_MULTIFRAME_GEOMETRY = "nmMultiframeGeometryModule", t.OVERLAY_PLANE = "overlayPlaneModule", t.PATIENT = "patientModule", t.PATIENT_STUDY = "patientStudyModule", t.PET_IMAGE = "petImageModule", t.PET_ISOTOPE = "petIsotopeModule", t.PET_SERIES = "petSeriesModule", t.SOP_COMMON = "sopCommonModule", t.ULTRASOUND_ENHANCED_REGION = "ultrasoundEnhancedRegionModule", t.VOI_LUT = "voiLutModule", t.WADO_WEB_CLIENT = "wadoWebClient";
  })(ma || (ma = {}));
  const OW = Object.freeze(Object.defineProperty({
    __proto__: null,
    BlendModes: ip,
    CalibrationTypes: MW,
    ContourType: bW,
    DynamicOperatorType: DW,
    Events: ze,
    GeometryType: Ao,
    ImageQualityStatus: Fc,
    InterpolationType: ho,
    MetadataModules: ma,
    OrientationAxis: vo,
    RequestType: ar,
    SharedArrayBufferModes: Ds,
    VOILUTFunctionType: yo,
    VideoEnums: RW,
    ViewportStatus: Bi,
    ViewportType: Hn
  }, Symbol.toStringTag, {
    value: "Module"
  })), Hv = {
    hotIron: {
      name: "Hot Iron",
      numOfColors: 256,
      colors: [
        [
          0,
          0,
          0,
          255
        ],
        [
          2,
          0,
          0,
          255
        ],
        [
          4,
          0,
          0,
          255
        ],
        [
          6,
          0,
          0,
          255
        ],
        [
          8,
          0,
          0,
          255
        ],
        [
          10,
          0,
          0,
          255
        ],
        [
          12,
          0,
          0,
          255
        ],
        [
          14,
          0,
          0,
          255
        ],
        [
          16,
          0,
          0,
          255
        ],
        [
          18,
          0,
          0,
          255
        ],
        [
          20,
          0,
          0,
          255
        ],
        [
          22,
          0,
          0,
          255
        ],
        [
          24,
          0,
          0,
          255
        ],
        [
          26,
          0,
          0,
          255
        ],
        [
          28,
          0,
          0,
          255
        ],
        [
          30,
          0,
          0,
          255
        ],
        [
          32,
          0,
          0,
          255
        ],
        [
          34,
          0,
          0,
          255
        ],
        [
          36,
          0,
          0,
          255
        ],
        [
          38,
          0,
          0,
          255
        ],
        [
          40,
          0,
          0,
          255
        ],
        [
          42,
          0,
          0,
          255
        ],
        [
          44,
          0,
          0,
          255
        ],
        [
          46,
          0,
          0,
          255
        ],
        [
          48,
          0,
          0,
          255
        ],
        [
          50,
          0,
          0,
          255
        ],
        [
          52,
          0,
          0,
          255
        ],
        [
          54,
          0,
          0,
          255
        ],
        [
          56,
          0,
          0,
          255
        ],
        [
          58,
          0,
          0,
          255
        ],
        [
          60,
          0,
          0,
          255
        ],
        [
          62,
          0,
          0,
          255
        ],
        [
          64,
          0,
          0,
          255
        ],
        [
          66,
          0,
          0,
          255
        ],
        [
          68,
          0,
          0,
          255
        ],
        [
          70,
          0,
          0,
          255
        ],
        [
          72,
          0,
          0,
          255
        ],
        [
          74,
          0,
          0,
          255
        ],
        [
          76,
          0,
          0,
          255
        ],
        [
          78,
          0,
          0,
          255
        ],
        [
          80,
          0,
          0,
          255
        ],
        [
          82,
          0,
          0,
          255
        ],
        [
          84,
          0,
          0,
          255
        ],
        [
          86,
          0,
          0,
          255
        ],
        [
          88,
          0,
          0,
          255
        ],
        [
          90,
          0,
          0,
          255
        ],
        [
          92,
          0,
          0,
          255
        ],
        [
          94,
          0,
          0,
          255
        ],
        [
          96,
          0,
          0,
          255
        ],
        [
          98,
          0,
          0,
          255
        ],
        [
          100,
          0,
          0,
          255
        ],
        [
          102,
          0,
          0,
          255
        ],
        [
          104,
          0,
          0,
          255
        ],
        [
          106,
          0,
          0,
          255
        ],
        [
          108,
          0,
          0,
          255
        ],
        [
          110,
          0,
          0,
          255
        ],
        [
          112,
          0,
          0,
          255
        ],
        [
          114,
          0,
          0,
          255
        ],
        [
          116,
          0,
          0,
          255
        ],
        [
          118,
          0,
          0,
          255
        ],
        [
          120,
          0,
          0,
          255
        ],
        [
          122,
          0,
          0,
          255
        ],
        [
          124,
          0,
          0,
          255
        ],
        [
          126,
          0,
          0,
          255
        ],
        [
          128,
          0,
          0,
          255
        ],
        [
          130,
          0,
          0,
          255
        ],
        [
          132,
          0,
          0,
          255
        ],
        [
          134,
          0,
          0,
          255
        ],
        [
          136,
          0,
          0,
          255
        ],
        [
          138,
          0,
          0,
          255
        ],
        [
          140,
          0,
          0,
          255
        ],
        [
          142,
          0,
          0,
          255
        ],
        [
          144,
          0,
          0,
          255
        ],
        [
          146,
          0,
          0,
          255
        ],
        [
          148,
          0,
          0,
          255
        ],
        [
          150,
          0,
          0,
          255
        ],
        [
          152,
          0,
          0,
          255
        ],
        [
          154,
          0,
          0,
          255
        ],
        [
          156,
          0,
          0,
          255
        ],
        [
          158,
          0,
          0,
          255
        ],
        [
          160,
          0,
          0,
          255
        ],
        [
          162,
          0,
          0,
          255
        ],
        [
          164,
          0,
          0,
          255
        ],
        [
          166,
          0,
          0,
          255
        ],
        [
          168,
          0,
          0,
          255
        ],
        [
          170,
          0,
          0,
          255
        ],
        [
          172,
          0,
          0,
          255
        ],
        [
          174,
          0,
          0,
          255
        ],
        [
          176,
          0,
          0,
          255
        ],
        [
          178,
          0,
          0,
          255
        ],
        [
          180,
          0,
          0,
          255
        ],
        [
          182,
          0,
          0,
          255
        ],
        [
          184,
          0,
          0,
          255
        ],
        [
          186,
          0,
          0,
          255
        ],
        [
          188,
          0,
          0,
          255
        ],
        [
          190,
          0,
          0,
          255
        ],
        [
          192,
          0,
          0,
          255
        ],
        [
          194,
          0,
          0,
          255
        ],
        [
          196,
          0,
          0,
          255
        ],
        [
          198,
          0,
          0,
          255
        ],
        [
          200,
          0,
          0,
          255
        ],
        [
          202,
          0,
          0,
          255
        ],
        [
          204,
          0,
          0,
          255
        ],
        [
          206,
          0,
          0,
          255
        ],
        [
          208,
          0,
          0,
          255
        ],
        [
          210,
          0,
          0,
          255
        ],
        [
          212,
          0,
          0,
          255
        ],
        [
          214,
          0,
          0,
          255
        ],
        [
          216,
          0,
          0,
          255
        ],
        [
          218,
          0,
          0,
          255
        ],
        [
          220,
          0,
          0,
          255
        ],
        [
          222,
          0,
          0,
          255
        ],
        [
          224,
          0,
          0,
          255
        ],
        [
          226,
          0,
          0,
          255
        ],
        [
          228,
          0,
          0,
          255
        ],
        [
          230,
          0,
          0,
          255
        ],
        [
          232,
          0,
          0,
          255
        ],
        [
          234,
          0,
          0,
          255
        ],
        [
          236,
          0,
          0,
          255
        ],
        [
          238,
          0,
          0,
          255
        ],
        [
          240,
          0,
          0,
          255
        ],
        [
          242,
          0,
          0,
          255
        ],
        [
          244,
          0,
          0,
          255
        ],
        [
          246,
          0,
          0,
          255
        ],
        [
          248,
          0,
          0,
          255
        ],
        [
          250,
          0,
          0,
          255
        ],
        [
          252,
          0,
          0,
          255
        ],
        [
          254,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          2,
          0,
          255
        ],
        [
          255,
          4,
          0,
          255
        ],
        [
          255,
          6,
          0,
          255
        ],
        [
          255,
          8,
          0,
          255
        ],
        [
          255,
          10,
          0,
          255
        ],
        [
          255,
          12,
          0,
          255
        ],
        [
          255,
          14,
          0,
          255
        ],
        [
          255,
          16,
          0,
          255
        ],
        [
          255,
          18,
          0,
          255
        ],
        [
          255,
          20,
          0,
          255
        ],
        [
          255,
          22,
          0,
          255
        ],
        [
          255,
          24,
          0,
          255
        ],
        [
          255,
          26,
          0,
          255
        ],
        [
          255,
          28,
          0,
          255
        ],
        [
          255,
          30,
          0,
          255
        ],
        [
          255,
          32,
          0,
          255
        ],
        [
          255,
          34,
          0,
          255
        ],
        [
          255,
          36,
          0,
          255
        ],
        [
          255,
          38,
          0,
          255
        ],
        [
          255,
          40,
          0,
          255
        ],
        [
          255,
          42,
          0,
          255
        ],
        [
          255,
          44,
          0,
          255
        ],
        [
          255,
          46,
          0,
          255
        ],
        [
          255,
          48,
          0,
          255
        ],
        [
          255,
          50,
          0,
          255
        ],
        [
          255,
          52,
          0,
          255
        ],
        [
          255,
          54,
          0,
          255
        ],
        [
          255,
          56,
          0,
          255
        ],
        [
          255,
          58,
          0,
          255
        ],
        [
          255,
          60,
          0,
          255
        ],
        [
          255,
          62,
          0,
          255
        ],
        [
          255,
          64,
          0,
          255
        ],
        [
          255,
          66,
          0,
          255
        ],
        [
          255,
          68,
          0,
          255
        ],
        [
          255,
          70,
          0,
          255
        ],
        [
          255,
          72,
          0,
          255
        ],
        [
          255,
          74,
          0,
          255
        ],
        [
          255,
          76,
          0,
          255
        ],
        [
          255,
          78,
          0,
          255
        ],
        [
          255,
          80,
          0,
          255
        ],
        [
          255,
          82,
          0,
          255
        ],
        [
          255,
          84,
          0,
          255
        ],
        [
          255,
          86,
          0,
          255
        ],
        [
          255,
          88,
          0,
          255
        ],
        [
          255,
          90,
          0,
          255
        ],
        [
          255,
          92,
          0,
          255
        ],
        [
          255,
          94,
          0,
          255
        ],
        [
          255,
          96,
          0,
          255
        ],
        [
          255,
          98,
          0,
          255
        ],
        [
          255,
          100,
          0,
          255
        ],
        [
          255,
          102,
          0,
          255
        ],
        [
          255,
          104,
          0,
          255
        ],
        [
          255,
          106,
          0,
          255
        ],
        [
          255,
          108,
          0,
          255
        ],
        [
          255,
          110,
          0,
          255
        ],
        [
          255,
          112,
          0,
          255
        ],
        [
          255,
          114,
          0,
          255
        ],
        [
          255,
          116,
          0,
          255
        ],
        [
          255,
          118,
          0,
          255
        ],
        [
          255,
          120,
          0,
          255
        ],
        [
          255,
          122,
          0,
          255
        ],
        [
          255,
          124,
          0,
          255
        ],
        [
          255,
          126,
          0,
          255
        ],
        [
          255,
          128,
          4,
          255
        ],
        [
          255,
          130,
          8,
          255
        ],
        [
          255,
          132,
          12,
          255
        ],
        [
          255,
          134,
          16,
          255
        ],
        [
          255,
          136,
          20,
          255
        ],
        [
          255,
          138,
          24,
          255
        ],
        [
          255,
          140,
          28,
          255
        ],
        [
          255,
          142,
          32,
          255
        ],
        [
          255,
          144,
          36,
          255
        ],
        [
          255,
          146,
          40,
          255
        ],
        [
          255,
          148,
          44,
          255
        ],
        [
          255,
          150,
          48,
          255
        ],
        [
          255,
          152,
          52,
          255
        ],
        [
          255,
          154,
          56,
          255
        ],
        [
          255,
          156,
          60,
          255
        ],
        [
          255,
          158,
          64,
          255
        ],
        [
          255,
          160,
          68,
          255
        ],
        [
          255,
          162,
          72,
          255
        ],
        [
          255,
          164,
          76,
          255
        ],
        [
          255,
          166,
          80,
          255
        ],
        [
          255,
          168,
          84,
          255
        ],
        [
          255,
          170,
          88,
          255
        ],
        [
          255,
          172,
          92,
          255
        ],
        [
          255,
          174,
          96,
          255
        ],
        [
          255,
          176,
          100,
          255
        ],
        [
          255,
          178,
          104,
          255
        ],
        [
          255,
          180,
          108,
          255
        ],
        [
          255,
          182,
          112,
          255
        ],
        [
          255,
          184,
          116,
          255
        ],
        [
          255,
          186,
          120,
          255
        ],
        [
          255,
          188,
          124,
          255
        ],
        [
          255,
          190,
          128,
          255
        ],
        [
          255,
          192,
          132,
          255
        ],
        [
          255,
          194,
          136,
          255
        ],
        [
          255,
          196,
          140,
          255
        ],
        [
          255,
          198,
          144,
          255
        ],
        [
          255,
          200,
          148,
          255
        ],
        [
          255,
          202,
          152,
          255
        ],
        [
          255,
          204,
          156,
          255
        ],
        [
          255,
          206,
          160,
          255
        ],
        [
          255,
          208,
          164,
          255
        ],
        [
          255,
          210,
          168,
          255
        ],
        [
          255,
          212,
          172,
          255
        ],
        [
          255,
          214,
          176,
          255
        ],
        [
          255,
          216,
          180,
          255
        ],
        [
          255,
          218,
          184,
          255
        ],
        [
          255,
          220,
          188,
          255
        ],
        [
          255,
          222,
          192,
          255
        ],
        [
          255,
          224,
          196,
          255
        ],
        [
          255,
          226,
          200,
          255
        ],
        [
          255,
          228,
          204,
          255
        ],
        [
          255,
          230,
          208,
          255
        ],
        [
          255,
          232,
          212,
          255
        ],
        [
          255,
          234,
          216,
          255
        ],
        [
          255,
          236,
          220,
          255
        ],
        [
          255,
          238,
          224,
          255
        ],
        [
          255,
          240,
          228,
          255
        ],
        [
          255,
          242,
          232,
          255
        ],
        [
          255,
          244,
          236,
          255
        ],
        [
          255,
          246,
          240,
          255
        ],
        [
          255,
          248,
          244,
          255
        ],
        [
          255,
          250,
          248,
          255
        ],
        [
          255,
          252,
          252,
          255
        ],
        [
          255,
          255,
          255,
          255
        ]
      ]
    },
    pet: {
      name: "PET",
      numColors: 256,
      colors: [
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          2,
          1,
          255
        ],
        [
          0,
          4,
          3,
          255
        ],
        [
          0,
          6,
          5,
          255
        ],
        [
          0,
          8,
          7,
          255
        ],
        [
          0,
          10,
          9,
          255
        ],
        [
          0,
          12,
          11,
          255
        ],
        [
          0,
          14,
          13,
          255
        ],
        [
          0,
          16,
          15,
          255
        ],
        [
          0,
          18,
          17,
          255
        ],
        [
          0,
          20,
          19,
          255
        ],
        [
          0,
          22,
          21,
          255
        ],
        [
          0,
          24,
          23,
          255
        ],
        [
          0,
          26,
          25,
          255
        ],
        [
          0,
          28,
          27,
          255
        ],
        [
          0,
          30,
          29,
          255
        ],
        [
          0,
          32,
          31,
          255
        ],
        [
          0,
          34,
          33,
          255
        ],
        [
          0,
          36,
          35,
          255
        ],
        [
          0,
          38,
          37,
          255
        ],
        [
          0,
          40,
          39,
          255
        ],
        [
          0,
          42,
          41,
          255
        ],
        [
          0,
          44,
          43,
          255
        ],
        [
          0,
          46,
          45,
          255
        ],
        [
          0,
          48,
          47,
          255
        ],
        [
          0,
          50,
          49,
          255
        ],
        [
          0,
          52,
          51,
          255
        ],
        [
          0,
          54,
          53,
          255
        ],
        [
          0,
          56,
          55,
          255
        ],
        [
          0,
          58,
          57,
          255
        ],
        [
          0,
          60,
          59,
          255
        ],
        [
          0,
          62,
          61,
          255
        ],
        [
          0,
          65,
          63,
          255
        ],
        [
          0,
          67,
          65,
          255
        ],
        [
          0,
          69,
          67,
          255
        ],
        [
          0,
          71,
          69,
          255
        ],
        [
          0,
          73,
          71,
          255
        ],
        [
          0,
          75,
          73,
          255
        ],
        [
          0,
          77,
          75,
          255
        ],
        [
          0,
          79,
          77,
          255
        ],
        [
          0,
          81,
          79,
          255
        ],
        [
          0,
          83,
          81,
          255
        ],
        [
          0,
          85,
          83,
          255
        ],
        [
          0,
          87,
          85,
          255
        ],
        [
          0,
          89,
          87,
          255
        ],
        [
          0,
          91,
          89,
          255
        ],
        [
          0,
          93,
          91,
          255
        ],
        [
          0,
          95,
          93,
          255
        ],
        [
          0,
          97,
          95,
          255
        ],
        [
          0,
          99,
          97,
          255
        ],
        [
          0,
          101,
          99,
          255
        ],
        [
          0,
          103,
          101,
          255
        ],
        [
          0,
          105,
          103,
          255
        ],
        [
          0,
          107,
          105,
          255
        ],
        [
          0,
          109,
          107,
          255
        ],
        [
          0,
          111,
          109,
          255
        ],
        [
          0,
          113,
          111,
          255
        ],
        [
          0,
          115,
          113,
          255
        ],
        [
          0,
          117,
          115,
          255
        ],
        [
          0,
          119,
          117,
          255
        ],
        [
          0,
          121,
          119,
          255
        ],
        [
          0,
          123,
          121,
          255
        ],
        [
          0,
          125,
          123,
          255
        ],
        [
          0,
          128,
          125,
          255
        ],
        [
          1,
          126,
          127,
          255
        ],
        [
          3,
          124,
          129,
          255
        ],
        [
          5,
          122,
          131,
          255
        ],
        [
          7,
          120,
          133,
          255
        ],
        [
          9,
          118,
          135,
          255
        ],
        [
          11,
          116,
          137,
          255
        ],
        [
          13,
          114,
          139,
          255
        ],
        [
          15,
          112,
          141,
          255
        ],
        [
          17,
          110,
          143,
          255
        ],
        [
          19,
          108,
          145,
          255
        ],
        [
          21,
          106,
          147,
          255
        ],
        [
          23,
          104,
          149,
          255
        ],
        [
          25,
          102,
          151,
          255
        ],
        [
          27,
          100,
          153,
          255
        ],
        [
          29,
          98,
          155,
          255
        ],
        [
          31,
          96,
          157,
          255
        ],
        [
          33,
          94,
          159,
          255
        ],
        [
          35,
          92,
          161,
          255
        ],
        [
          37,
          90,
          163,
          255
        ],
        [
          39,
          88,
          165,
          255
        ],
        [
          41,
          86,
          167,
          255
        ],
        [
          43,
          84,
          169,
          255
        ],
        [
          45,
          82,
          171,
          255
        ],
        [
          47,
          80,
          173,
          255
        ],
        [
          49,
          78,
          175,
          255
        ],
        [
          51,
          76,
          177,
          255
        ],
        [
          53,
          74,
          179,
          255
        ],
        [
          55,
          72,
          181,
          255
        ],
        [
          57,
          70,
          183,
          255
        ],
        [
          59,
          68,
          185,
          255
        ],
        [
          61,
          66,
          187,
          255
        ],
        [
          63,
          64,
          189,
          255
        ],
        [
          65,
          63,
          191,
          255
        ],
        [
          67,
          61,
          193,
          255
        ],
        [
          69,
          59,
          195,
          255
        ],
        [
          71,
          57,
          197,
          255
        ],
        [
          73,
          55,
          199,
          255
        ],
        [
          75,
          53,
          201,
          255
        ],
        [
          77,
          51,
          203,
          255
        ],
        [
          79,
          49,
          205,
          255
        ],
        [
          81,
          47,
          207,
          255
        ],
        [
          83,
          45,
          209,
          255
        ],
        [
          85,
          43,
          211,
          255
        ],
        [
          86,
          41,
          213,
          255
        ],
        [
          88,
          39,
          215,
          255
        ],
        [
          90,
          37,
          217,
          255
        ],
        [
          92,
          35,
          219,
          255
        ],
        [
          94,
          33,
          221,
          255
        ],
        [
          96,
          31,
          223,
          255
        ],
        [
          98,
          29,
          225,
          255
        ],
        [
          100,
          27,
          227,
          255
        ],
        [
          102,
          25,
          229,
          255
        ],
        [
          104,
          23,
          231,
          255
        ],
        [
          106,
          21,
          233,
          255
        ],
        [
          108,
          19,
          235,
          255
        ],
        [
          110,
          17,
          237,
          255
        ],
        [
          112,
          15,
          239,
          255
        ],
        [
          114,
          13,
          241,
          255
        ],
        [
          116,
          11,
          243,
          255
        ],
        [
          118,
          9,
          245,
          255
        ],
        [
          120,
          7,
          247,
          255
        ],
        [
          122,
          5,
          249,
          255
        ],
        [
          124,
          3,
          251,
          255
        ],
        [
          126,
          1,
          253,
          255
        ],
        [
          128,
          0,
          255,
          255
        ],
        [
          130,
          2,
          252,
          255
        ],
        [
          132,
          4,
          248,
          255
        ],
        [
          134,
          6,
          244,
          255
        ],
        [
          136,
          8,
          240,
          255
        ],
        [
          138,
          10,
          236,
          255
        ],
        [
          140,
          12,
          232,
          255
        ],
        [
          142,
          14,
          228,
          255
        ],
        [
          144,
          16,
          224,
          255
        ],
        [
          146,
          18,
          220,
          255
        ],
        [
          148,
          20,
          216,
          255
        ],
        [
          150,
          22,
          212,
          255
        ],
        [
          152,
          24,
          208,
          255
        ],
        [
          154,
          26,
          204,
          255
        ],
        [
          156,
          28,
          200,
          255
        ],
        [
          158,
          30,
          196,
          255
        ],
        [
          160,
          32,
          192,
          255
        ],
        [
          162,
          34,
          188,
          255
        ],
        [
          164,
          36,
          184,
          255
        ],
        [
          166,
          38,
          180,
          255
        ],
        [
          168,
          40,
          176,
          255
        ],
        [
          170,
          42,
          172,
          255
        ],
        [
          171,
          44,
          168,
          255
        ],
        [
          173,
          46,
          164,
          255
        ],
        [
          175,
          48,
          160,
          255
        ],
        [
          177,
          50,
          156,
          255
        ],
        [
          179,
          52,
          152,
          255
        ],
        [
          181,
          54,
          148,
          255
        ],
        [
          183,
          56,
          144,
          255
        ],
        [
          185,
          58,
          140,
          255
        ],
        [
          187,
          60,
          136,
          255
        ],
        [
          189,
          62,
          132,
          255
        ],
        [
          191,
          64,
          128,
          255
        ],
        [
          193,
          66,
          124,
          255
        ],
        [
          195,
          68,
          120,
          255
        ],
        [
          197,
          70,
          116,
          255
        ],
        [
          199,
          72,
          112,
          255
        ],
        [
          201,
          74,
          108,
          255
        ],
        [
          203,
          76,
          104,
          255
        ],
        [
          205,
          78,
          100,
          255
        ],
        [
          207,
          80,
          96,
          255
        ],
        [
          209,
          82,
          92,
          255
        ],
        [
          211,
          84,
          88,
          255
        ],
        [
          213,
          86,
          84,
          255
        ],
        [
          215,
          88,
          80,
          255
        ],
        [
          217,
          90,
          76,
          255
        ],
        [
          219,
          92,
          72,
          255
        ],
        [
          221,
          94,
          68,
          255
        ],
        [
          223,
          96,
          64,
          255
        ],
        [
          225,
          98,
          60,
          255
        ],
        [
          227,
          100,
          56,
          255
        ],
        [
          229,
          102,
          52,
          255
        ],
        [
          231,
          104,
          48,
          255
        ],
        [
          233,
          106,
          44,
          255
        ],
        [
          235,
          108,
          40,
          255
        ],
        [
          237,
          110,
          36,
          255
        ],
        [
          239,
          112,
          32,
          255
        ],
        [
          241,
          114,
          28,
          255
        ],
        [
          243,
          116,
          24,
          255
        ],
        [
          245,
          118,
          20,
          255
        ],
        [
          247,
          120,
          16,
          255
        ],
        [
          249,
          122,
          12,
          255
        ],
        [
          251,
          124,
          8,
          255
        ],
        [
          253,
          126,
          4,
          255
        ],
        [
          255,
          128,
          0,
          255
        ],
        [
          255,
          130,
          4,
          255
        ],
        [
          255,
          132,
          8,
          255
        ],
        [
          255,
          134,
          12,
          255
        ],
        [
          255,
          136,
          16,
          255
        ],
        [
          255,
          138,
          20,
          255
        ],
        [
          255,
          140,
          24,
          255
        ],
        [
          255,
          142,
          28,
          255
        ],
        [
          255,
          144,
          32,
          255
        ],
        [
          255,
          146,
          36,
          255
        ],
        [
          255,
          148,
          40,
          255
        ],
        [
          255,
          150,
          44,
          255
        ],
        [
          255,
          152,
          48,
          255
        ],
        [
          255,
          154,
          52,
          255
        ],
        [
          255,
          156,
          56,
          255
        ],
        [
          255,
          158,
          60,
          255
        ],
        [
          255,
          160,
          64,
          255
        ],
        [
          255,
          162,
          68,
          255
        ],
        [
          255,
          164,
          72,
          255
        ],
        [
          255,
          166,
          76,
          255
        ],
        [
          255,
          168,
          80,
          255
        ],
        [
          255,
          170,
          85,
          255
        ],
        [
          255,
          172,
          89,
          255
        ],
        [
          255,
          174,
          93,
          255
        ],
        [
          255,
          176,
          97,
          255
        ],
        [
          255,
          178,
          101,
          255
        ],
        [
          255,
          180,
          105,
          255
        ],
        [
          255,
          182,
          109,
          255
        ],
        [
          255,
          184,
          113,
          255
        ],
        [
          255,
          186,
          117,
          255
        ],
        [
          255,
          188,
          121,
          255
        ],
        [
          255,
          190,
          125,
          255
        ],
        [
          255,
          192,
          129,
          255
        ],
        [
          255,
          194,
          133,
          255
        ],
        [
          255,
          196,
          137,
          255
        ],
        [
          255,
          198,
          141,
          255
        ],
        [
          255,
          200,
          145,
          255
        ],
        [
          255,
          202,
          149,
          255
        ],
        [
          255,
          204,
          153,
          255
        ],
        [
          255,
          206,
          157,
          255
        ],
        [
          255,
          208,
          161,
          255
        ],
        [
          255,
          210,
          165,
          255
        ],
        [
          255,
          212,
          170,
          255
        ],
        [
          255,
          214,
          174,
          255
        ],
        [
          255,
          216,
          178,
          255
        ],
        [
          255,
          218,
          182,
          255
        ],
        [
          255,
          220,
          186,
          255
        ],
        [
          255,
          222,
          190,
          255
        ],
        [
          255,
          224,
          194,
          255
        ],
        [
          255,
          226,
          198,
          255
        ],
        [
          255,
          228,
          202,
          255
        ],
        [
          255,
          230,
          206,
          255
        ],
        [
          255,
          232,
          210,
          255
        ],
        [
          255,
          234,
          214,
          255
        ],
        [
          255,
          236,
          218,
          255
        ],
        [
          255,
          238,
          222,
          255
        ],
        [
          255,
          240,
          226,
          255
        ],
        [
          255,
          242,
          230,
          255
        ],
        [
          255,
          244,
          234,
          255
        ],
        [
          255,
          246,
          238,
          255
        ],
        [
          255,
          248,
          242,
          255
        ],
        [
          255,
          250,
          246,
          255
        ],
        [
          255,
          252,
          250,
          255
        ],
        [
          255,
          255,
          255,
          255
        ]
      ]
    },
    hotMetalBlue: {
      name: "Hot Metal Blue",
      numColors: 256,
      colors: [
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          2,
          255
        ],
        [
          0,
          0,
          4,
          255
        ],
        [
          0,
          0,
          6,
          255
        ],
        [
          0,
          0,
          8,
          255
        ],
        [
          0,
          0,
          10,
          255
        ],
        [
          0,
          0,
          12,
          255
        ],
        [
          0,
          0,
          14,
          255
        ],
        [
          0,
          0,
          16,
          255
        ],
        [
          0,
          0,
          17,
          255
        ],
        [
          0,
          0,
          19,
          255
        ],
        [
          0,
          0,
          21,
          255
        ],
        [
          0,
          0,
          23,
          255
        ],
        [
          0,
          0,
          25,
          255
        ],
        [
          0,
          0,
          27,
          255
        ],
        [
          0,
          0,
          29,
          255
        ],
        [
          0,
          0,
          31,
          255
        ],
        [
          0,
          0,
          33,
          255
        ],
        [
          0,
          0,
          35,
          255
        ],
        [
          0,
          0,
          37,
          255
        ],
        [
          0,
          0,
          39,
          255
        ],
        [
          0,
          0,
          41,
          255
        ],
        [
          0,
          0,
          43,
          255
        ],
        [
          0,
          0,
          45,
          255
        ],
        [
          0,
          0,
          47,
          255
        ],
        [
          0,
          0,
          49,
          255
        ],
        [
          0,
          0,
          51,
          255
        ],
        [
          0,
          0,
          53,
          255
        ],
        [
          0,
          0,
          55,
          255
        ],
        [
          0,
          0,
          57,
          255
        ],
        [
          0,
          0,
          59,
          255
        ],
        [
          0,
          0,
          61,
          255
        ],
        [
          0,
          0,
          63,
          255
        ],
        [
          0,
          0,
          65,
          255
        ],
        [
          0,
          0,
          67,
          255
        ],
        [
          0,
          0,
          69,
          255
        ],
        [
          0,
          0,
          71,
          255
        ],
        [
          0,
          0,
          73,
          255
        ],
        [
          0,
          0,
          75,
          255
        ],
        [
          0,
          0,
          77,
          255
        ],
        [
          0,
          0,
          79,
          255
        ],
        [
          0,
          0,
          81,
          255
        ],
        [
          0,
          0,
          83,
          255
        ],
        [
          0,
          0,
          84,
          255
        ],
        [
          0,
          0,
          86,
          255
        ],
        [
          0,
          0,
          88,
          255
        ],
        [
          0,
          0,
          90,
          255
        ],
        [
          0,
          0,
          92,
          255
        ],
        [
          0,
          0,
          94,
          255
        ],
        [
          0,
          0,
          96,
          255
        ],
        [
          0,
          0,
          98,
          255
        ],
        [
          0,
          0,
          100,
          255
        ],
        [
          0,
          0,
          102,
          255
        ],
        [
          0,
          0,
          104,
          255
        ],
        [
          0,
          0,
          106,
          255
        ],
        [
          0,
          0,
          108,
          255
        ],
        [
          0,
          0,
          110,
          255
        ],
        [
          0,
          0,
          112,
          255
        ],
        [
          0,
          0,
          114,
          255
        ],
        [
          0,
          0,
          116,
          255
        ],
        [
          0,
          0,
          117,
          255
        ],
        [
          0,
          0,
          119,
          255
        ],
        [
          0,
          0,
          121,
          255
        ],
        [
          0,
          0,
          123,
          255
        ],
        [
          0,
          0,
          125,
          255
        ],
        [
          0,
          0,
          127,
          255
        ],
        [
          0,
          0,
          129,
          255
        ],
        [
          0,
          0,
          131,
          255
        ],
        [
          0,
          0,
          133,
          255
        ],
        [
          0,
          0,
          135,
          255
        ],
        [
          0,
          0,
          137,
          255
        ],
        [
          0,
          0,
          139,
          255
        ],
        [
          0,
          0,
          141,
          255
        ],
        [
          0,
          0,
          143,
          255
        ],
        [
          0,
          0,
          145,
          255
        ],
        [
          0,
          0,
          147,
          255
        ],
        [
          0,
          0,
          149,
          255
        ],
        [
          0,
          0,
          151,
          255
        ],
        [
          0,
          0,
          153,
          255
        ],
        [
          0,
          0,
          155,
          255
        ],
        [
          0,
          0,
          157,
          255
        ],
        [
          0,
          0,
          159,
          255
        ],
        [
          0,
          0,
          161,
          255
        ],
        [
          0,
          0,
          163,
          255
        ],
        [
          0,
          0,
          165,
          255
        ],
        [
          0,
          0,
          167,
          255
        ],
        [
          3,
          0,
          169,
          255
        ],
        [
          6,
          0,
          171,
          255
        ],
        [
          9,
          0,
          173,
          255
        ],
        [
          12,
          0,
          175,
          255
        ],
        [
          15,
          0,
          177,
          255
        ],
        [
          18,
          0,
          179,
          255
        ],
        [
          21,
          0,
          181,
          255
        ],
        [
          24,
          0,
          183,
          255
        ],
        [
          26,
          0,
          184,
          255
        ],
        [
          29,
          0,
          186,
          255
        ],
        [
          32,
          0,
          188,
          255
        ],
        [
          35,
          0,
          190,
          255
        ],
        [
          38,
          0,
          192,
          255
        ],
        [
          41,
          0,
          194,
          255
        ],
        [
          44,
          0,
          196,
          255
        ],
        [
          47,
          0,
          198,
          255
        ],
        [
          50,
          0,
          200,
          255
        ],
        [
          52,
          0,
          197,
          255
        ],
        [
          55,
          0,
          194,
          255
        ],
        [
          57,
          0,
          191,
          255
        ],
        [
          59,
          0,
          188,
          255
        ],
        [
          62,
          0,
          185,
          255
        ],
        [
          64,
          0,
          182,
          255
        ],
        [
          66,
          0,
          179,
          255
        ],
        [
          69,
          0,
          176,
          255
        ],
        [
          71,
          0,
          174,
          255
        ],
        [
          74,
          0,
          171,
          255
        ],
        [
          76,
          0,
          168,
          255
        ],
        [
          78,
          0,
          165,
          255
        ],
        [
          81,
          0,
          162,
          255
        ],
        [
          83,
          0,
          159,
          255
        ],
        [
          85,
          0,
          156,
          255
        ],
        [
          88,
          0,
          153,
          255
        ],
        [
          90,
          0,
          150,
          255
        ],
        [
          93,
          2,
          144,
          255
        ],
        [
          96,
          4,
          138,
          255
        ],
        [
          99,
          6,
          132,
          255
        ],
        [
          102,
          8,
          126,
          255
        ],
        [
          105,
          9,
          121,
          255
        ],
        [
          108,
          11,
          115,
          255
        ],
        [
          111,
          13,
          109,
          255
        ],
        [
          114,
          15,
          103,
          255
        ],
        [
          116,
          17,
          97,
          255
        ],
        [
          119,
          19,
          91,
          255
        ],
        [
          122,
          21,
          85,
          255
        ],
        [
          125,
          23,
          79,
          255
        ],
        [
          128,
          24,
          74,
          255
        ],
        [
          131,
          26,
          68,
          255
        ],
        [
          134,
          28,
          62,
          255
        ],
        [
          137,
          30,
          56,
          255
        ],
        [
          140,
          32,
          50,
          255
        ],
        [
          143,
          34,
          47,
          255
        ],
        [
          146,
          36,
          44,
          255
        ],
        [
          149,
          38,
          41,
          255
        ],
        [
          152,
          40,
          38,
          255
        ],
        [
          155,
          41,
          35,
          255
        ],
        [
          158,
          43,
          32,
          255
        ],
        [
          161,
          45,
          29,
          255
        ],
        [
          164,
          47,
          26,
          255
        ],
        [
          166,
          49,
          24,
          255
        ],
        [
          169,
          51,
          21,
          255
        ],
        [
          172,
          53,
          18,
          255
        ],
        [
          175,
          55,
          15,
          255
        ],
        [
          178,
          56,
          12,
          255
        ],
        [
          181,
          58,
          9,
          255
        ],
        [
          184,
          60,
          6,
          255
        ],
        [
          187,
          62,
          3,
          255
        ],
        [
          190,
          64,
          0,
          255
        ],
        [
          194,
          66,
          0,
          255
        ],
        [
          198,
          68,
          0,
          255
        ],
        [
          201,
          70,
          0,
          255
        ],
        [
          205,
          72,
          0,
          255
        ],
        [
          209,
          73,
          0,
          255
        ],
        [
          213,
          75,
          0,
          255
        ],
        [
          217,
          77,
          0,
          255
        ],
        [
          221,
          79,
          0,
          255
        ],
        [
          224,
          81,
          0,
          255
        ],
        [
          228,
          83,
          0,
          255
        ],
        [
          232,
          85,
          0,
          255
        ],
        [
          236,
          87,
          0,
          255
        ],
        [
          240,
          88,
          0,
          255
        ],
        [
          244,
          90,
          0,
          255
        ],
        [
          247,
          92,
          0,
          255
        ],
        [
          251,
          94,
          0,
          255
        ],
        [
          255,
          96,
          0,
          255
        ],
        [
          255,
          98,
          3,
          255
        ],
        [
          255,
          100,
          6,
          255
        ],
        [
          255,
          102,
          9,
          255
        ],
        [
          255,
          104,
          12,
          255
        ],
        [
          255,
          105,
          15,
          255
        ],
        [
          255,
          107,
          18,
          255
        ],
        [
          255,
          109,
          21,
          255
        ],
        [
          255,
          111,
          24,
          255
        ],
        [
          255,
          113,
          26,
          255
        ],
        [
          255,
          115,
          29,
          255
        ],
        [
          255,
          117,
          32,
          255
        ],
        [
          255,
          119,
          35,
          255
        ],
        [
          255,
          120,
          38,
          255
        ],
        [
          255,
          122,
          41,
          255
        ],
        [
          255,
          124,
          44,
          255
        ],
        [
          255,
          126,
          47,
          255
        ],
        [
          255,
          128,
          50,
          255
        ],
        [
          255,
          130,
          53,
          255
        ],
        [
          255,
          132,
          56,
          255
        ],
        [
          255,
          134,
          59,
          255
        ],
        [
          255,
          136,
          62,
          255
        ],
        [
          255,
          137,
          65,
          255
        ],
        [
          255,
          139,
          68,
          255
        ],
        [
          255,
          141,
          71,
          255
        ],
        [
          255,
          143,
          74,
          255
        ],
        [
          255,
          145,
          76,
          255
        ],
        [
          255,
          147,
          79,
          255
        ],
        [
          255,
          149,
          82,
          255
        ],
        [
          255,
          151,
          85,
          255
        ],
        [
          255,
          152,
          88,
          255
        ],
        [
          255,
          154,
          91,
          255
        ],
        [
          255,
          156,
          94,
          255
        ],
        [
          255,
          158,
          97,
          255
        ],
        [
          255,
          160,
          100,
          255
        ],
        [
          255,
          162,
          103,
          255
        ],
        [
          255,
          164,
          106,
          255
        ],
        [
          255,
          166,
          109,
          255
        ],
        [
          255,
          168,
          112,
          255
        ],
        [
          255,
          169,
          115,
          255
        ],
        [
          255,
          171,
          118,
          255
        ],
        [
          255,
          173,
          121,
          255
        ],
        [
          255,
          175,
          124,
          255
        ],
        [
          255,
          177,
          126,
          255
        ],
        [
          255,
          179,
          129,
          255
        ],
        [
          255,
          181,
          132,
          255
        ],
        [
          255,
          183,
          135,
          255
        ],
        [
          255,
          184,
          138,
          255
        ],
        [
          255,
          186,
          141,
          255
        ],
        [
          255,
          188,
          144,
          255
        ],
        [
          255,
          190,
          147,
          255
        ],
        [
          255,
          192,
          150,
          255
        ],
        [
          255,
          194,
          153,
          255
        ],
        [
          255,
          196,
          156,
          255
        ],
        [
          255,
          198,
          159,
          255
        ],
        [
          255,
          200,
          162,
          255
        ],
        [
          255,
          201,
          165,
          255
        ],
        [
          255,
          203,
          168,
          255
        ],
        [
          255,
          205,
          171,
          255
        ],
        [
          255,
          207,
          174,
          255
        ],
        [
          255,
          209,
          176,
          255
        ],
        [
          255,
          211,
          179,
          255
        ],
        [
          255,
          213,
          182,
          255
        ],
        [
          255,
          215,
          185,
          255
        ],
        [
          255,
          216,
          188,
          255
        ],
        [
          255,
          218,
          191,
          255
        ],
        [
          255,
          220,
          194,
          255
        ],
        [
          255,
          222,
          197,
          255
        ],
        [
          255,
          224,
          200,
          255
        ],
        [
          255,
          226,
          203,
          255
        ],
        [
          255,
          228,
          206,
          255
        ],
        [
          255,
          229,
          210,
          255
        ],
        [
          255,
          231,
          213,
          255
        ],
        [
          255,
          233,
          216,
          255
        ],
        [
          255,
          235,
          219,
          255
        ],
        [
          255,
          237,
          223,
          255
        ],
        [
          255,
          239,
          226,
          255
        ],
        [
          255,
          240,
          229,
          255
        ],
        [
          255,
          242,
          232,
          255
        ],
        [
          255,
          244,
          236,
          255
        ],
        [
          255,
          246,
          239,
          255
        ],
        [
          255,
          248,
          242,
          255
        ],
        [
          255,
          250,
          245,
          255
        ],
        [
          255,
          251,
          249,
          255
        ],
        [
          255,
          253,
          252,
          255
        ],
        [
          255,
          255,
          255,
          255
        ]
      ]
    },
    pet20Step: {
      name: "PET 20 Step",
      numColors: 256,
      colors: [
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          0,
          0,
          0,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          96,
          0,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          80,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          48,
          48,
          112,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          80,
          80,
          128,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          96,
          96,
          176,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          112,
          112,
          192,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          128,
          128,
          224,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          96,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          48,
          144,
          48,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          80,
          192,
          80,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          64,
          224,
          64,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          224,
          224,
          80,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          208,
          96,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          176,
          64,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          208,
          144,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          192,
          96,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          176,
          48,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          0,
          0,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ],
        [
          255,
          255,
          255,
          255
        ]
      ]
    },
    gray: {
      name: "Gray",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ],
        blue: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ]
      }
    },
    jet: {
      name: "Jet",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            0.35,
            0,
            0
          ],
          [
            0.66,
            1,
            1
          ],
          [
            0.89,
            1,
            1
          ],
          [
            1,
            0.5,
            0.5
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            0.125,
            0,
            0
          ],
          [
            0.375,
            1,
            1
          ],
          [
            0.64,
            1,
            1
          ],
          [
            0.91,
            0,
            0
          ],
          [
            1,
            0,
            0
          ]
        ],
        blue: [
          [
            0,
            0.5,
            0.5
          ],
          [
            0.11,
            1,
            1
          ],
          [
            0.34,
            1,
            1
          ],
          [
            0.65,
            0,
            0
          ],
          [
            1,
            0,
            0
          ]
        ]
      }
    },
    hsv: {
      name: "HSV",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            1,
            1
          ],
          [
            0.15873,
            1,
            1
          ],
          [
            0.174603,
            0.96875,
            0.96875
          ],
          [
            0.333333,
            0.03125,
            0.03125
          ],
          [
            0.349206,
            0,
            0
          ],
          [
            0.666667,
            0,
            0
          ],
          [
            0.68254,
            0.03125,
            0.03125
          ],
          [
            0.84127,
            0.96875,
            0.96875
          ],
          [
            0.857143,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            0.15873,
            0.9375,
            0.9375
          ],
          [
            0.174603,
            1,
            1
          ],
          [
            0.507937,
            1,
            1
          ],
          [
            0.666667,
            0.0625,
            0.0625
          ],
          [
            0.68254,
            0,
            0
          ],
          [
            1,
            0,
            0
          ]
        ],
        blue: [
          [
            0,
            0,
            0
          ],
          [
            0.333333,
            0,
            0
          ],
          [
            0.349206,
            0.0625,
            0.0625
          ],
          [
            0.507937,
            1,
            1
          ],
          [
            0.84127,
            1,
            1
          ],
          [
            0.857143,
            0.9375,
            0.9375
          ],
          [
            1,
            0.09375,
            0.09375
          ]
        ]
      }
    },
    hot: {
      name: "Hot",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0.0416,
            0.0416
          ],
          [
            0.365079,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            0.365079,
            0,
            0
          ],
          [
            0.746032,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        blue: [
          [
            0,
            0,
            0
          ],
          [
            0.746032,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ]
      }
    },
    cool: {
      name: "Cool",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            1,
            1
          ],
          [
            1,
            0,
            0
          ]
        ],
        blue: [
          [
            0,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ]
      }
    },
    spring: {
      name: "Spring",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ],
        blue: [
          [
            0,
            1,
            1
          ],
          [
            1,
            0,
            0
          ]
        ]
      }
    },
    summer: {
      name: "Summer",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0.5,
            0.5
          ],
          [
            1,
            1,
            1
          ]
        ],
        blue: [
          [
            0,
            0.4,
            0.4
          ],
          [
            1,
            0.4,
            0.4
          ]
        ]
      }
    },
    autumn: {
      name: "Autumn",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ],
        blue: [
          [
            0,
            0,
            0
          ],
          [
            1,
            0,
            0
          ]
        ]
      }
    },
    winter: {
      name: "Winter",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            1,
            0,
            0
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            1,
            1,
            1
          ]
        ],
        blue: [
          [
            0,
            1,
            1
          ],
          [
            1,
            0.5,
            0.5
          ]
        ]
      }
    },
    bone: {
      name: "Bone",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            0.746032,
            0.652778,
            0.652778
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            0.365079,
            0.319444,
            0.319444
          ],
          [
            0.746032,
            0.777778,
            0.777778
          ],
          [
            1,
            1,
            1
          ]
        ],
        blue: [
          [
            0,
            0,
            0
          ],
          [
            0.365079,
            0.444444,
            0.444444
          ],
          [
            1,
            1,
            1
          ]
        ]
      }
    },
    copper: {
      name: "Copper",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            0.809524,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            1,
            0.7812,
            0.7812
          ]
        ],
        blue: [
          [
            0,
            0,
            0
          ],
          [
            1,
            0.4975,
            0.4975
          ]
        ]
      }
    },
    spectral: {
      name: "Spectral",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0,
            0
          ],
          [
            0.05,
            0.4667,
            0.4667
          ],
          [
            0.1,
            0.5333,
            0.5333
          ],
          [
            0.15,
            0,
            0
          ],
          [
            0.2,
            0,
            0
          ],
          [
            0.25,
            0,
            0
          ],
          [
            0.3,
            0,
            0
          ],
          [
            0.35,
            0,
            0
          ],
          [
            0.4,
            0,
            0
          ],
          [
            0.45,
            0,
            0
          ],
          [
            0.5,
            0,
            0
          ],
          [
            0.55,
            0,
            0
          ],
          [
            0.6,
            0,
            0
          ],
          [
            0.65,
            0.7333,
            0.7333
          ],
          [
            0.7,
            0.9333,
            0.9333
          ],
          [
            0.75,
            1,
            1
          ],
          [
            0.8,
            1,
            1
          ],
          [
            0.85,
            1,
            1
          ],
          [
            0.9,
            0.8667,
            0.8667
          ],
          [
            0.95,
            0.8,
            0.8
          ],
          [
            1,
            0.8,
            0.8
          ]
        ],
        green: [
          [
            0,
            0,
            0
          ],
          [
            0.05,
            0,
            0
          ],
          [
            0.1,
            0,
            0
          ],
          [
            0.15,
            0,
            0
          ],
          [
            0.2,
            0,
            0
          ],
          [
            0.25,
            0.4667,
            0.4667
          ],
          [
            0.3,
            0.6,
            0.6
          ],
          [
            0.35,
            0.6667,
            0.6667
          ],
          [
            0.4,
            0.6667,
            0.6667
          ],
          [
            0.45,
            0.6,
            0.6
          ],
          [
            0.5,
            0.7333,
            0.7333
          ],
          [
            0.55,
            0.8667,
            0.8667
          ],
          [
            0.6,
            1,
            1
          ],
          [
            0.65,
            1,
            1
          ],
          [
            0.7,
            0.9333,
            0.9333
          ],
          [
            0.75,
            0.8,
            0.8
          ],
          [
            0.8,
            0.6,
            0.6
          ],
          [
            0.85,
            0,
            0
          ],
          [
            0.9,
            0,
            0
          ],
          [
            0.95,
            0,
            0
          ],
          [
            1,
            0.8,
            0.8
          ]
        ],
        blue: [
          [
            0,
            0,
            0
          ],
          [
            0.05,
            0.5333,
            0.5333
          ],
          [
            0.1,
            0.6,
            0.6
          ],
          [
            0.15,
            0.6667,
            0.6667
          ],
          [
            0.2,
            0.8667,
            0.8667
          ],
          [
            0.25,
            0.8667,
            0.8667
          ],
          [
            0.3,
            0.8667,
            0.8667
          ],
          [
            0.35,
            0.6667,
            0.6667
          ],
          [
            0.4,
            0.5333,
            0.5333
          ],
          [
            0.45,
            0,
            0
          ],
          [
            0.5,
            0,
            0
          ],
          [
            0.55,
            0,
            0
          ],
          [
            0.6,
            0,
            0
          ],
          [
            0.65,
            0,
            0
          ],
          [
            0.7,
            0,
            0
          ],
          [
            0.75,
            0,
            0
          ],
          [
            0.8,
            0,
            0
          ],
          [
            0.85,
            0,
            0
          ],
          [
            0.9,
            0,
            0
          ],
          [
            0.95,
            0,
            0
          ],
          [
            1,
            0.8,
            0.8
          ]
        ]
      }
    },
    coolwarm: {
      name: "CoolWarm",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0.2298057,
            0.2298057
          ],
          [
            0.03125,
            0.26623388,
            0.26623388
          ],
          [
            0.0625,
            0.30386891,
            0.30386891
          ],
          [
            0.09375,
            0.342804478,
            0.342804478
          ],
          [
            0.125,
            0.38301334,
            0.38301334
          ],
          [
            0.15625,
            0.424369608,
            0.424369608
          ],
          [
            0.1875,
            0.46666708,
            0.46666708
          ],
          [
            0.21875,
            0.509635204,
            0.509635204
          ],
          [
            0.25,
            0.552953156,
            0.552953156
          ],
          [
            0.28125,
            0.596262162,
            0.596262162
          ],
          [
            0.3125,
            0.639176211,
            0.639176211
          ],
          [
            0.34375,
            0.681291281,
            0.681291281
          ],
          [
            0.375,
            0.722193294,
            0.722193294
          ],
          [
            0.40625,
            0.761464949,
            0.761464949
          ],
          [
            0.4375,
            0.798691636,
            0.798691636
          ],
          [
            0.46875,
            0.833466556,
            0.833466556
          ],
          [
            0.5,
            0.865395197,
            0.865395197
          ],
          [
            0.53125,
            0.897787179,
            0.897787179
          ],
          [
            0.5625,
            0.924127593,
            0.924127593
          ],
          [
            0.59375,
            0.944468518,
            0.944468518
          ],
          [
            0.625,
            0.958852946,
            0.958852946
          ],
          [
            0.65625,
            0.96732803,
            0.96732803
          ],
          [
            0.6875,
            0.969954137,
            0.969954137
          ],
          [
            0.71875,
            0.966811177,
            0.966811177
          ],
          [
            0.75,
            0.958003065,
            0.958003065
          ],
          [
            0.78125,
            0.943660866,
            0.943660866
          ],
          [
            0.8125,
            0.923944917,
            0.923944917
          ],
          [
            0.84375,
            0.89904617,
            0.89904617
          ],
          [
            0.875,
            0.869186849,
            0.869186849
          ],
          [
            0.90625,
            0.834620542,
            0.834620542
          ],
          [
            0.9375,
            0.795631745,
            0.795631745
          ],
          [
            0.96875,
            0.752534934,
            0.752534934
          ],
          [
            1,
            0.705673158,
            0.705673158
          ]
        ],
        green: [
          [
            0,
            0.298717966,
            0.298717966
          ],
          [
            0.03125,
            0.353094838,
            0.353094838
          ],
          [
            0.0625,
            0.406535296,
            0.406535296
          ],
          [
            0.09375,
            0.458757618,
            0.458757618
          ],
          [
            0.125,
            0.50941904,
            0.50941904
          ],
          [
            0.15625,
            0.558148092,
            0.558148092
          ],
          [
            0.1875,
            0.604562568,
            0.604562568
          ],
          [
            0.21875,
            0.648280772,
            0.648280772
          ],
          [
            0.25,
            0.688929332,
            0.688929332
          ],
          [
            0.28125,
            0.726149107,
            0.726149107
          ],
          [
            0.3125,
            0.759599947,
            0.759599947
          ],
          [
            0.34375,
            0.788964712,
            0.788964712
          ],
          [
            0.375,
            0.813952739,
            0.813952739
          ],
          [
            0.40625,
            0.834302879,
            0.834302879
          ],
          [
            0.4375,
            0.849786142,
            0.849786142
          ],
          [
            0.46875,
            0.860207984,
            0.860207984
          ],
          [
            0.5,
            0.86541021,
            0.86541021
          ],
          [
            0.53125,
            0.848937047,
            0.848937047
          ],
          [
            0.5625,
            0.827384882,
            0.827384882
          ],
          [
            0.59375,
            0.800927443,
            0.800927443
          ],
          [
            0.625,
            0.769767752,
            0.769767752
          ],
          [
            0.65625,
            0.734132809,
            0.734132809
          ],
          [
            0.6875,
            0.694266682,
            0.694266682
          ],
          [
            0.71875,
            0.650421156,
            0.650421156
          ],
          [
            0.75,
            0.602842431,
            0.602842431
          ],
          [
            0.78125,
            0.551750968,
            0.551750968
          ],
          [
            0.8125,
            0.49730856,
            0.49730856
          ],
          [
            0.84375,
            0.439559467,
            0.439559467
          ],
          [
            0.875,
            0.378313092,
            0.378313092
          ],
          [
            0.90625,
            0.312874446,
            0.312874446
          ],
          [
            0.9375,
            0.24128379,
            0.24128379
          ],
          [
            0.96875,
            0.157246067,
            0.157246067
          ],
          [
            1,
            0.01555616,
            0.01555616
          ]
        ],
        blue: [
          [
            0,
            0.753683153,
            0.753683153
          ],
          [
            0.03125,
            0.801466763,
            0.801466763
          ],
          [
            0.0625,
            0.84495867,
            0.84495867
          ],
          [
            0.09375,
            0.883725899,
            0.883725899
          ],
          [
            0.125,
            0.917387822,
            0.917387822
          ],
          [
            0.15625,
            0.945619588,
            0.945619588
          ],
          [
            0.1875,
            0.968154911,
            0.968154911
          ],
          [
            0.21875,
            0.98478814,
            0.98478814
          ],
          [
            0.25,
            0.995375608,
            0.995375608
          ],
          [
            0.28125,
            0.999836203,
            0.999836203
          ],
          [
            0.3125,
            0.998151185,
            0.998151185
          ],
          [
            0.34375,
            0.990363227,
            0.990363227
          ],
          [
            0.375,
            0.976574709,
            0.976574709
          ],
          [
            0.40625,
            0.956945269,
            0.956945269
          ],
          [
            0.4375,
            0.931688648,
            0.931688648
          ],
          [
            0.46875,
            0.901068838,
            0.901068838
          ],
          [
            0.5,
            0.865395561,
            0.865395561
          ],
          [
            0.53125,
            0.820880546,
            0.820880546
          ],
          [
            0.5625,
            0.774508472,
            0.774508472
          ],
          [
            0.59375,
            0.726736146,
            0.726736146
          ],
          [
            0.625,
            0.678007945,
            0.678007945
          ],
          [
            0.65625,
            0.628751763,
            0.628751763
          ],
          [
            0.6875,
            0.579375448,
            0.579375448
          ],
          [
            0.71875,
            0.530263762,
            0.530263762
          ],
          [
            0.75,
            0.481775914,
            0.481775914
          ],
          [
            0.78125,
            0.434243684,
            0.434243684
          ],
          [
            0.8125,
            0.387970225,
            0.387970225
          ],
          [
            0.84375,
            0.343229596,
            0.343229596
          ],
          [
            0.875,
            0.300267182,
            0.300267182
          ],
          [
            0.90625,
            0.259301199,
            0.259301199
          ],
          [
            0.9375,
            0.220525627,
            0.220525627
          ],
          [
            0.96875,
            0.184115123,
            0.184115123
          ],
          [
            1,
            0.150232812,
            0.150232812
          ]
        ]
      }
    },
    blues: {
      name: "Blues",
      numColors: 256,
      gamma: 1,
      segmentedData: {
        red: [
          [
            0,
            0.9686274528503418,
            0.9686274528503418
          ],
          [
            0.125,
            0.8705882430076599,
            0.8705882430076599
          ],
          [
            0.25,
            0.7764706015586853,
            0.7764706015586853
          ],
          [
            0.375,
            0.6196078658103943,
            0.6196078658103943
          ],
          [
            0.5,
            0.41960784792900085,
            0.41960784792900085
          ],
          [
            0.625,
            0.25882354378700256,
            0.25882354378700256
          ],
          [
            0.75,
            0.12941177189350128,
            0.12941177189350128
          ],
          [
            0.875,
            0.0313725508749485,
            0.0313725508749485
          ],
          [
            1,
            0.0313725508749485,
            0.0313725508749485
          ]
        ],
        green: [
          [
            0,
            0.9843137264251709,
            0.9843137264251709
          ],
          [
            0.125,
            0.9215686321258545,
            0.9215686321258545
          ],
          [
            0.25,
            0.8588235378265381,
            0.8588235378265381
          ],
          [
            0.375,
            0.7921568751335144,
            0.7921568751335144
          ],
          [
            0.5,
            0.6823529601097107,
            0.6823529601097107
          ],
          [
            0.625,
            0.572549045085907,
            0.572549045085907
          ],
          [
            0.75,
            0.4431372582912445,
            0.4431372582912445
          ],
          [
            0.875,
            0.3176470696926117,
            0.3176470696926117
          ],
          [
            1,
            0.1882352977991104,
            0.1882352977991104
          ]
        ],
        blue: [
          [
            0,
            1,
            1
          ],
          [
            0.125,
            0.9686274528503418,
            0.9686274528503418
          ],
          [
            0.25,
            0.9372549057006836,
            0.9372549057006836
          ],
          [
            0.375,
            0.8823529481887817,
            0.8823529481887817
          ],
          [
            0.5,
            0.8392156958580017,
            0.8392156958580017
          ],
          [
            0.625,
            0.7764706015586853,
            0.7764706015586853
          ],
          [
            0.75,
            0.7098039388656616,
            0.7098039388656616
          ],
          [
            0.875,
            0.6117647290229797,
            0.6117647290229797
          ],
          [
            1,
            0.41960784792900085,
            0.41960784792900085
          ]
        ]
      }
    }
  }, Gi = {
    MINIMUM_SLAB_THICKNESS: 0.05,
    MAXIMUM_RAY_DISTANCE: 1e6
  };
  Object.freeze(Gi);
  const Vl = 1e-3;
  function vb(t) {
    const e = Object.getOwnPropertyNames(t);
    for (const n of e) {
      const r = t[n];
      r && typeof r == "object" && vb(r);
    }
    return Object.freeze(t);
  }
  const IW = {
    axial: {
      viewPlaneNormal: [
        0,
        0,
        -1
      ],
      viewUp: [
        0,
        -1,
        0
      ]
    },
    sagittal: {
      viewPlaneNormal: [
        1,
        0,
        0
      ],
      viewUp: [
        0,
        0,
        1
      ]
    },
    coronal: {
      viewPlaneNormal: [
        0,
        -1,
        0
      ],
      viewUp: [
        0,
        0,
        1
      ]
    }
  }, Al = vb(IW), yb = [
    {
      name: "CT-AAA",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "12 -3024 0 143.556 0 166.222 0.686275 214.389 0.696078 419.736 0.833333 3071 0.803922",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "24 -3024 0 0 0 143.556 0.615686 0.356863 0.184314 166.222 0.882353 0.603922 0.290196 214.389 1 1 1 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-AAA2",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "16 -3024 0 129.542 0 145.244 0.166667 157.02 0.5 169.918 0.627451 395.575 0.8125 1578.73 0.8125 3071 0.8125",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "32 -3024 0 0 0 129.542 0.54902 0.25098 0.14902 145.244 0.6 0.627451 0.843137 157.02 0.890196 0.47451 0.6 169.918 0.992157 0.870588 0.392157 395.575 1 0.886275 0.658824 1578.73 1 0.829256 0.957922 3071 0.827451 0.658824 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Bone",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "8 -3024 0 -16.4458 0 641.385 0.715686 3071 0.705882",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "16 -3024 0 0 0 -16.4458 0.729412 0.254902 0.301961 641.385 0.905882 0.815686 0.552941 3071 1 1 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Bones",
      gradientOpacity: "4 0 1 985.12 1",
      specularPower: "1",
      scalarOpacity: "8 -1000 0 152.19 0 278.93 0.190476 952 0.2",
      specular: "0",
      shade: "1",
      ambient: "0.2",
      colorTransfer: "20 -1000 0.3 0.3 1 -488 0.3 1 0.3 463.28 1 0 0 659.15 1 0.912535 0.0374849 953 1 0.3 0.3",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Cardiac",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "12 -3024 0 -77.6875 0 94.9518 0.285714 179.052 0.553571 260.439 0.848214 3071 0.875",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "24 -3024 0 0 0 -77.6875 0.54902 0.25098 0.14902 94.9518 0.882353 0.603922 0.290196 179.052 1 0.937033 0.954531 260.439 0.615686 0 0 3071 0.827451 0.658824 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Cardiac2",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "12 -3024 0 42.8964 0 163.488 0.428571 277.642 0.776786 1587 0.754902 3071 0.754902",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "24 -3024 0 0 0 42.8964 0.54902 0.25098 0.14902 163.488 0.917647 0.639216 0.0588235 277.642 1 0.878431 0.623529 1587 1 1 1 3071 0.827451 0.658824 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Cardiac3",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "14 -3024 0 -86.9767 0 45.3791 0.169643 139.919 0.589286 347.907 0.607143 1224.16 0.607143 3071 0.616071",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "28 -3024 0 0 0 -86.9767 0 0.25098 1 45.3791 1 0 0 139.919 1 0.894893 0.894893 347.907 1 1 0.25098 1224.16 1 1 1 3071 0.827451 0.658824 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Chest-Contrast-Enhanced",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "10 -3024 0 67.0106 0 251.105 0.446429 439.291 0.625 3071 0.616071",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "20 -3024 0 0 0 67.0106 0.54902 0.25098 0.14902 251.105 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Chest-Vessels",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "10 -3024 0 -1278.35 0 22.8277 0.428571 439.291 0.625 3071 0.616071",
      specular: "0",
      shade: "1",
      ambient: "0.2",
      colorTransfer: "20 -3024 0 0 0 -1278.35 0.54902 0.25098 0.14902 22.8277 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Coronary-Arteries",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "12 -2048 0 136.47 0 159.215 0.258929 318.43 0.571429 478.693 0.776786 3661 1",
      specular: "0",
      shade: "0",
      ambient: "0.2",
      colorTransfer: "24 -2048 0 0 0 136.47 0 0 0 159.215 0.159804 0.159804 0.159804 318.43 0.764706 0.764706 0.764706 478.693 1 1 1 3661 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Coronary-Arteries-2",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "14 -2048 0 142.677 0 145.016 0.116071 192.174 0.5625 217.24 0.776786 384.347 0.830357 3661 0.830357",
      specular: "0",
      shade: "1",
      ambient: "0.2",
      colorTransfer: "28 -2048 0 0 0 142.677 0 0 0 145.016 0.615686 0 0.0156863 192.174 0.909804 0.454902 0 217.24 0.972549 0.807843 0.611765 384.347 0.909804 0.909804 1 3661 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Coronary-Arteries-3",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "14 -2048 0 128.643 0 129.982 0.0982143 173.636 0.669643 255.884 0.857143 584.878 0.866071 3661 1",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "28 -2048 0 0 0 128.643 0 0 0 129.982 0.615686 0 0.0156863 173.636 0.909804 0.454902 0 255.884 0.886275 0.886275 0.886275 584.878 0.968627 0.968627 0.968627 3661 1 1 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Cropped-Volume-Bone",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "10 -2048 0 -451 0 -450 1 1050 1 3661 1",
      specular: "0",
      shade: "0",
      ambient: "0.2",
      colorTransfer: "20 -2048 0 0 0 -451 0 0 0 -450 0.0556356 0.0556356 0.0556356 1050 1 1 1 3661 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Fat",
      gradientOpacity: "6 0 1 985.12 1 988 1",
      specularPower: "1",
      scalarOpacity: "14 -1000 0 -100 0 -99 0.15 -60 0.15 -59 0 101.2 0 952 0",
      specular: "0",
      shade: "0",
      ambient: "0.2",
      colorTransfer: "36 -1000 0.3 0.3 1 -497.5 0.3 1 0.3 -99 0 0 1 -76.946 0 1 0 -65.481 0.835431 0.888889 0.0165387 83.89 1 0 0 463.28 1 0 0 659.15 1 0.912535 0.0374849 2952 1 0.300267 0.299886",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Liver-Vasculature",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "14 -2048 0 149.113 0 157.884 0.482143 339.96 0.660714 388.526 0.830357 1197.95 0.839286 3661 0.848214",
      specular: "0",
      shade: "0",
      ambient: "0.2",
      colorTransfer: "28 -2048 0 0 0 149.113 0 0 0 157.884 0.501961 0.25098 0 339.96 0.695386 0.59603 0.36886 388.526 0.854902 0.85098 0.827451 1197.95 1 1 1 3661 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Lung",
      gradientOpacity: "6 0 1 985.12 1 988 1",
      specularPower: "1",
      scalarOpacity: "12 -1000 0 -600 0 -599 0.15 -400 0.15 -399 0 2952 0",
      specular: "0",
      shade: "1",
      ambient: "0.2",
      colorTransfer: "24 -1000 0.3 0.3 1 -600 0 0 1 -530 0.134704 0.781726 0.0724558 -460 0.929244 1 0.109473 -400 0.888889 0.254949 0.0240258 2952 1 0.3 0.3",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-MIP",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "8 -3024 0 -637.62 0 700 1 3071 1",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "16 -3024 0 0 0 -637.62 1 1 1 700 1 1 1 3071 1 1 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Muscle",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "10 -3024 0 -155.407 0 217.641 0.676471 419.736 0.833333 3071 0.803922",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "20 -3024 0 0 0 -155.407 0.54902 0.25098 0.14902 217.641 0.882353 0.603922 0.290196 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "CT-Pulmonary-Arteries",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "14 -2048 0 -568.625 0 -364.081 0.0714286 -244.813 0.401786 18.2775 0.607143 447.798 0.830357 3592.73 0.839286",
      specular: "0",
      shade: "1",
      ambient: "0.2",
      colorTransfer: "28 -2048 0 0 0 -568.625 0 0 0 -364.081 0.396078 0.301961 0.180392 -244.813 0.611765 0.352941 0.0705882 18.2775 0.843137 0.0156863 0.156863 447.798 0.752941 0.752941 0.752941 3592.73 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Soft-Tissue",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "10 -2048 0 -167.01 0 -160 1 240 1 3661 1",
      specular: "0",
      shade: "0",
      ambient: "0.2",
      colorTransfer: "20 -2048 0 0 0 -167.01 0 0 0 -160 0.0556356 0.0556356 0.0556356 240 1 1 1 3661 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "CT-Air",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "10",
      scalarOpacity: "8 -3024 0.705882 -900.0 0.715686 -500.0 0 3071 0",
      specular: "0.2",
      shade: "1",
      ambient: "0.1",
      colorTransfer: "16 -3024 1 1 1 -900.0 0.2 1.0 1.0 -500.0 0.3 0.3 1.0 3071 0 0 0 ",
      diffuse: "0.9",
      interpolation: "1"
    },
    {
      name: "MR-Angio",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "12 -2048 0 151.354 0 158.279 0.4375 190.112 0.580357 200.873 0.732143 3661 0.741071",
      specular: "0",
      shade: "1",
      ambient: "0.2",
      colorTransfer: "24 -2048 0 0 0 151.354 0 0 0 158.279 0.74902 0.376471 0 190.112 1 0.866667 0.733333 200.873 0.937255 0.937255 0.937255 3661 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "MR-Default",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "12 0 0 20 0 40 0.15 120 0.3 220 0.375 1024 0.5",
      specular: "0",
      shade: "1",
      ambient: "0.2",
      colorTransfer: "24 0 0 0 0 20 0.168627 0 0 40 0.403922 0.145098 0.0784314 120 0.780392 0.607843 0.380392 220 0.847059 0.835294 0.788235 1024 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "MR-MIP",
      gradientOpacity: "4 0 1 255 1",
      specularPower: "1",
      scalarOpacity: "8 0 0 98.3725 0 416.637 1 2800 1",
      specular: "0",
      shade: "0",
      ambient: "0.2",
      colorTransfer: "16 0 1 1 1 98.3725 1 1 1 416.637 1 1 1 2800 1 1 1",
      diffuse: "1",
      interpolation: "1"
    },
    {
      name: "MR-T2-Brain",
      gradientOpacity: "4 0 1 160.25 1",
      specularPower: "40",
      scalarOpacity: "10 0 0 36.05 0 218.302 0.171429 412.406 1 641 1",
      specular: "0.5",
      shade: "1",
      ambient: "0.3",
      colorTransfer: "16 0 0 0 0 98.7223 0.956863 0.839216 0.192157 412.406 0 0.592157 0.807843 641 1 1 1",
      diffuse: "0.6",
      interpolation: "1"
    },
    {
      name: "DTI-FA-Brain",
      gradientOpacity: "4 0 1 0.9950 1",
      specularPower: "40",
      scalarOpacity: "16 0 0 0 0 0.3501 0.0158 0.49379 0.7619 0.6419 1 0.9920 1 0.9950 0 0.9950 0",
      specular: "0.5",
      shade: "1",
      ambient: "0.3",
      colorTransfer: "28 0 1 0 0 0 1 0 0 0.24974 0.4941 1 0 0.49949 0 0.9882 1 0.7492 0.51764 0 1 0.9950 1 0 0 0.9950 1 0 0",
      diffuse: "0.9",
      interpolation: "1"
    }
  ], VW = {
    slicer3D: [
      160 / 255,
      164 / 255,
      217 / 255
    ]
  }, xb = Object.freeze(Object.defineProperty({
    __proto__: null,
    BACKGROUND_COLORS: VW,
    CPU_COLORMAPS: Hv,
    EPSILON: Vl,
    MPR_CAMERA_VALUES: Al,
    RENDERING_DEFAULTS: Gi,
    VIEWPORT_PRESETS: yb
  }, Symbol.toStringTag, {
    value: "Module"
  })), p1 = {}, Ch = {
    get: (t) => p1[t],
    set: (t) => {
      const e = t.id;
      p1[e] = t;
    },
    delete: (t) => delete p1[t],
    getAll: () => {
      const e = Object.keys(p1).map((n) => p1[n]);
      return e.sort((n, r) => n.id[0] === "_" && r.id[0] !== "_" ? 1 : n.id[0] !== "_" && r.id[0] === "_" ? -1 : 0), e;
    }
  };
  class NW {
    constructor() {
      this.listeners = {}, this.debouncedListeners = {};
    }
    reset() {
      this.listeners = {}, this.debouncedListeners = {};
    }
    addEventListenerOnce(e, n) {
      const r = (i) => {
        this.removeEventListener(e, r), n.call(this, i);
      };
      this.addEventListener(e, r);
    }
    addEventListener(e, n) {
      this.listeners[e] || (this.listeners[e] = []), this.listeners[e].indexOf(n) === -1 && this.listeners[e].push(n);
    }
    addEventListenerDebounced(e, n, r) {
      this.debouncedListeners[e] = this.debouncedListeners[e] || {};
      const i = this.debouncedListeners[e];
      if (!i[n]) {
        const a = (s) => {
          i[n] && clearTimeout(i[n].timeoutId), i[n].timeoutId = setTimeout(() => {
            n.call(this, s);
          }, r);
        };
        i[n] = {
          original: n,
          handle: a,
          timeoutId: null
        }, this.addEventListener(e, a);
      }
    }
    removeEventListenerDebounced(e, n) {
      if (this.debouncedListeners[e] && this.debouncedListeners[e][n]) {
        const r = this.debouncedListeners[e][n];
        this.removeEventListener(e, r.handle), clearTimeout(r.timeoutId), delete this.debouncedListeners[e][n];
      }
    }
    removeEventListener(e, n) {
      if (!this.listeners[e]) return;
      const r = this.listeners[e], i = r.length;
      for (let a = 0; a < i; a++) if (r[a] === n) {
        r.splice(a, 1);
        return;
      }
    }
    dispatchEvent(e) {
      if (!this.listeners[e.type]) return !e.defaultPrevented;
      const n = this.listeners[e.type].slice(), r = n.length;
      for (let i = 0; i < r; i++) try {
        n[i].call(this, e);
      } catch (a) {
        console.error(`error in event listener of type:  ${e.type}`, a);
      }
      return !e.defaultPrevented;
    }
  }
  const je = new NW();
  var Ja;
  (function(t) {
    t[t.None = 0] = "None", t[t.Capture = 1] = "Capture", t[t.Bubble = 2] = "Bubble";
  })(Ja || (Ja = {}));
  class h5 {
    constructor(e) {
      this._eventListeners = /* @__PURE__ */ new Map(), this._children = /* @__PURE__ */ new Map(), this._target = e;
    }
    get isEmpty() {
      return this._eventListeners.size === 0 && this._children.size === 0;
    }
    addEventListener(e, n, r) {
      const i = e.indexOf(".");
      if (i !== -1) {
        const s = e.substring(0, i);
        let o = this._children.get(s);
        o || (o = new h5(this._target), this._children.set(s, o)), e = e.substring(i + 1), o.addEventListener(e, n, r);
      } else this._addEventListener(e, n, r);
    }
    removeEventListener(e, n, r) {
      const i = e.indexOf(".");
      if (i !== -1) {
        const s = e.substring(0, i), o = this._children.get(s);
        if (!o) return;
        e = e.substring(i + 1), o.removeEventListener(e, n, r), o.isEmpty && this._children.delete(s);
      } else this._removeEventListener(e, n, r);
    }
    reset() {
      Array.from(this._children.entries()).forEach(([e, n]) => {
        if (n.reset(), n.isEmpty) this._children.delete(e);
        else throw new Error("Child is not empty and cannot be removed");
      }), this._unregisterAllEvents();
    }
    _addEventListener(e, n, r) {
      let i = this._eventListeners.get(e);
      i || (i = /* @__PURE__ */ new Map(), this._eventListeners.set(e, i));
      const s = (r == null ? void 0 : r.capture) ?? false ? Ja.Capture : Ja.Bubble, o = i.get(n) ?? Ja.None;
      if (o & s) {
        console.warn("A listener is already registered for this phase");
        return;
      }
      i.set(n, o | s), this._target.addEventListener(e, n, r);
    }
    _removeEventListener(e, n, r) {
      const a = (r == null ? void 0 : r.capture) ?? false ? Ja.Capture : Ja.Bubble, s = this._eventListeners.get(e);
      if (!s) return;
      (n ? [
        n
      ] : Array.from(s.keys())).forEach((l) => {
        const c = s.get(l) ?? Ja.None;
        if (!!!(c & a)) return;
        this._target.removeEventListener(e, l, r);
        const u = c ^ a;
        u === Ja.None ? s.delete(l) : s.set(l, u);
      }), s.size || this._eventListeners.delete(e);
    }
    _unregisterAllListeners(e, n) {
      Array.from(n.entries()).forEach(([r, i]) => {
        const a = Ja.Capture;
        for (let s = a; i; s <<= 1) {
          if (!(i & s)) continue;
          const o = s === Ja.Capture;
          this.removeEventListener(e, r, {
            capture: o
          }), i ^= s;
        }
      });
    }
    _unregisterAllEvents() {
      Array.from(this._eventListeners.entries()).forEach(([e, n]) => this._unregisterAllListeners(e, n));
    }
  }
  class LW {
    constructor() {
      this._targetsEventListeners = /* @__PURE__ */ new Map();
    }
    addEventListener(e, n, r, i) {
      let a = this._targetsEventListeners.get(e);
      a || (a = new h5(e), this._targetsEventListeners.set(e, a)), a.addEventListener(n, r, i);
    }
    removeEventListener(e, n, r, i) {
      const a = this._targetsEventListeners.get(e);
      a && (a.removeEventListener(n, r, i), a.isEmpty && this._targetsEventListeners.delete(e));
    }
    reset() {
      Array.from(this._targetsEventListeners.entries()).forEach(([e, n]) => {
        n.reset(), this._targetsEventListeners.delete(e);
      });
    }
  }
  const UW = Object.freeze(Object.defineProperty({
    __proto__: null,
    MultiTargetEventListenerManager: LW,
    TargetEventListeners: h5
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function sh(t) {
    if (!t) return;
    const e = t.getSize();
    for (let n = 0; n < e; n++) {
      const r = [];
      t.getNodeValue(n, r), r[1] = 1 - r[1], r[2] = 1 - r[2], r[3] = 1 - r[3], t.setNodeValue(n, r);
    }
  }
  var d4, CC;
  function FW() {
    return CC || (CC = 1, d4 = function t(e, n) {
      if (e === n) return true;
      if (e && n && typeof e == "object" && typeof n == "object") {
        if (e.constructor !== n.constructor) return false;
        var r, i, a;
        if (Array.isArray(e)) {
          if (r = e.length, r != n.length) return false;
          for (i = r; i-- !== 0; ) if (!t(e[i], n[i])) return false;
          return true;
        }
        if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
        if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
        if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
        if (a = Object.keys(e), r = a.length, r !== Object.keys(n).length) return false;
        for (i = r; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, a[i])) return false;
        for (i = r; i-- !== 0; ) {
          var s = a[i];
          if (!t(e[s], n[s])) return false;
        }
        return true;
      }
      return e !== e && n !== n;
    }), d4;
  }
  var BW = FW();
  const wb = t0(BW);
  var g4, TC;
  function Cb() {
    if (TC) return g4;
    TC = 1;
    var t = Object.prototype.toString;
    return g4 = function(n) {
      var r = t.call(n), i = r === "[object Arguments]";
      return i || (i = r !== "[object Array]" && n !== null && typeof n == "object" && typeof n.length == "number" && n.length >= 0 && t.call(n.callee) === "[object Function]"), i;
    }, g4;
  }
  var p4, SC;
  function _W() {
    if (SC) return p4;
    SC = 1;
    var t;
    if (!Object.keys) {
      var e = Object.prototype.hasOwnProperty, n = Object.prototype.toString, r = Cb(), i = Object.prototype.propertyIsEnumerable, a = !i.call({
        toString: null
      }, "toString"), s = i.call(function() {
      }, "prototype"), o = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ], l = function(h) {
        var g = h.constructor;
        return g && g.prototype === h;
      }, c = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      }, f = (function() {
        if (typeof window > "u") return false;
        for (var h in window) try {
          if (!c["$" + h] && e.call(window, h) && window[h] !== null && typeof window[h] == "object") try {
            l(window[h]);
          } catch {
            return true;
          }
        } catch {
          return true;
        }
        return false;
      })(), u = function(h) {
        if (typeof window > "u" || !f) return l(h);
        try {
          return l(h);
        } catch {
          return false;
        }
      };
      t = function(g) {
        var v = g !== null && typeof g == "object", m = n.call(g) === "[object Function]", y = r(g), w = v && n.call(g) === "[object String]", C = [];
        if (!v && !m && !y) throw new TypeError("Object.keys called on a non-object");
        var T = s && m;
        if (w && g.length > 0 && !e.call(g, 0)) for (var S = 0; S < g.length; ++S) C.push(String(S));
        if (y && g.length > 0) for (var E = 0; E < g.length; ++E) C.push(String(E));
        else for (var b in g) !(T && b === "prototype") && e.call(g, b) && C.push(String(b));
        if (a) for (var D = u(g), R = 0; R < o.length; ++R) !(D && o[R] === "constructor") && e.call(g, o[R]) && C.push(o[R]);
        return C;
      };
    }
    return p4 = t, p4;
  }
  var m4, AC;
  function kW() {
    if (AC) return m4;
    AC = 1;
    var t = Array.prototype.slice, e = Cb(), n = Object.keys, r = n ? function(s) {
      return n(s);
    } : _W(), i = Object.keys;
    return r.shim = function() {
      if (Object.keys) {
        var s = (function() {
          var o = Object.keys(arguments);
          return o && o.length === arguments.length;
        })(1, 2);
        s || (Object.keys = function(l) {
          return e(l) ? i(t.call(l)) : i(l);
        });
      } else Object.keys = r;
      return Object.keys || r;
    }, m4 = r, m4;
  }
  var v4, EC;
  function Tb() {
    if (EC) return v4;
    EC = 1;
    var t = Object.defineProperty || false;
    if (t) try {
      t({}, "a", {
        value: 1
      });
    } catch {
      t = false;
    }
    return v4 = t, v4;
  }
  var y4, bC;
  function PW() {
    return bC || (bC = 1, y4 = SyntaxError), y4;
  }
  var x4, DC;
  function GW() {
    return DC || (DC = 1, x4 = TypeError), x4;
  }
  var w4, MC;
  function zW() {
    return MC || (MC = 1, w4 = Object.getOwnPropertyDescriptor), w4;
  }
  var C4, RC;
  function WW() {
    if (RC) return C4;
    RC = 1;
    var t = zW();
    if (t) try {
      t([], "length");
    } catch {
      t = null;
    }
    return C4 = t, C4;
  }
  var T4, OC;
  function HW() {
    if (OC) return T4;
    OC = 1;
    var t = Tb(), e = PW(), n = GW(), r = WW();
    return T4 = function(a, s, o) {
      if (!a || typeof a != "object" && typeof a != "function") throw new n("`obj` must be an object or a function`");
      if (typeof s != "string" && typeof s != "symbol") throw new n("`property` must be a string or a symbol`");
      if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new n("`nonEnumerable`, if provided, must be a boolean or null");
      if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new n("`nonWritable`, if provided, must be a boolean or null");
      if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new n("`nonConfigurable`, if provided, must be a boolean or null");
      if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new n("`loose`, if provided, must be a boolean");
      var l = arguments.length > 3 ? arguments[3] : null, c = arguments.length > 4 ? arguments[4] : null, f = arguments.length > 5 ? arguments[5] : null, u = arguments.length > 6 ? arguments[6] : false, h = !!r && r(a, s);
      if (t) t(a, s, {
        configurable: f === null && h ? h.configurable : !f,
        enumerable: l === null && h ? h.enumerable : !l,
        value: o,
        writable: c === null && h ? h.writable : !c
      });
      else if (u || !l && !c && !f) a[s] = o;
      else throw new e("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }, T4;
  }
  var S4, IC;
  function jW() {
    if (IC) return S4;
    IC = 1;
    var t = Tb(), e = function() {
      return !!t;
    };
    return e.hasArrayLengthDefineBug = function() {
      if (!t) return null;
      try {
        return t([], "length", {
          value: 1
        }).length !== 1;
      } catch {
        return true;
      }
    }, S4 = e, S4;
  }
  var A4, VC;
  function Sb() {
    if (VC) return A4;
    VC = 1;
    var t = kW(), e = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", n = Object.prototype.toString, r = Array.prototype.concat, i = HW(), a = function(c) {
      return typeof c == "function" && n.call(c) === "[object Function]";
    }, s = jW()(), o = function(c, f, u, h) {
      if (f in c) {
        if (h === true) {
          if (c[f] === u) return;
        } else if (!a(h) || !h()) return;
      }
      s ? i(c, f, u, true) : i(c, f, u);
    }, l = function(c, f) {
      var u = arguments.length > 2 ? arguments[2] : {}, h = t(f);
      e && (h = r.call(h, Object.getOwnPropertySymbols(f)));
      for (var g = 0; g < h.length; g += 1) o(c, h[g], f[h[g]], u[h[g]]);
    };
    return l.supportsDescriptors = !!s, A4 = l, A4;
  }
  var m1 = {
    exports: {}
  }, NC;
  function Ab() {
    return NC || (NC = 1, typeof self < "u" ? m1.exports = self : typeof window < "u" ? m1.exports = window : m1.exports = Function("return this")()), m1.exports;
  }
  var E4, LC;
  function Eb() {
    if (LC) return E4;
    LC = 1;
    var t = Ab();
    return E4 = function() {
      return typeof ci != "object" || !ci || ci.Math !== Math || ci.Array !== Array ? t : ci;
    }, E4;
  }
  var b4, UC;
  function KW() {
    if (UC) return b4;
    UC = 1;
    var t = Sb(), e = Eb();
    return b4 = function() {
      var r = e();
      if (t.supportsDescriptors) {
        var i = Object.getOwnPropertyDescriptor(r, "globalThis");
        (!i || i.configurable && (i.enumerable || !i.writable || globalThis !== r)) && Object.defineProperty(r, "globalThis", {
          configurable: true,
          enumerable: false,
          value: r,
          writable: true
        });
      } else (typeof globalThis != "object" || globalThis !== r) && (r.globalThis = r);
      return r;
    }, b4;
  }
  var D4, FC;
  function YW() {
    if (FC) return D4;
    FC = 1;
    var t = Sb(), e = Ab(), n = Eb(), r = KW(), i = n(), a = function() {
      return i;
    };
    return t(a, {
      getPolyfill: n,
      implementation: e,
      shim: r
    }), D4 = a, D4;
  }
  var qW = YW();
  const XW = t0(qW), rs = XW(), bb = {
    vtkObject: () => null
  };
  function ss(t) {
    if (t == null || t.isA) return t;
    if (!t.vtkClass) return rs.console && rs.console.error && rs.console.error("Invalid VTK object"), null;
    const e = bb[t.vtkClass];
    if (!e) return rs.console && rs.console.error && rs.console.error(`No vtk class found for Object of type ${t.vtkClass}`), null;
    const n = {
      ...t
    };
    Object.keys(n).forEach((i) => {
      n[i] && typeof n[i] == "object" && n[i].vtkClass && (n[i] = ss(n[i]));
    });
    const r = e(n);
    return r && r.modified && r.modified(), r;
  }
  function ZW(t, e) {
    bb[t] = e;
  }
  ss.register = ZW;
  class M4 extends Array {
    push() {
      for (let e = 0; e < arguments.length; e++) this.includes(arguments[e]) || super.push(arguments[e]);
      return this.length;
    }
  }
  let jv = 0;
  const Db = Symbol("void");
  function QW() {
    return jv;
  }
  const Mb = {};
  function bc() {
  }
  const JW = [
    "log",
    "debug",
    "info",
    "warn",
    "error",
    "time",
    "timeEnd",
    "group",
    "groupEnd"
  ];
  JW.forEach((t) => {
    Mb[t] = bc;
  });
  rs.console = console.hasOwnProperty("log") ? console : Mb;
  const Nl = {
    debug: bc,
    error: rs.console.error || bc,
    info: rs.console.info || bc,
    log: rs.console.log || bc,
    warn: rs.console.warn || bc
  };
  function Rb(t, e) {
    Nl[t] && (Nl[t] = e || bc);
  }
  function Ob() {
    Nl.log(...arguments);
  }
  function Ib() {
    Nl.info(...arguments);
  }
  function ap() {
    Nl.debug(...arguments);
  }
  function Jt() {
    Nl.error(...arguments);
  }
  function d8() {
    Nl.warn(...arguments);
  }
  const BC = {};
  function Vb(t) {
    BC[t] || (Nl.error(t), BC[t] = true);
  }
  const Ei = /* @__PURE__ */ Object.create(null);
  Ei.Float32Array = Float32Array;
  Ei.Float64Array = Float64Array;
  Ei.Uint8Array = Uint8Array;
  Ei.Int8Array = Int8Array;
  Ei.Uint16Array = Uint16Array;
  Ei.Int16Array = Int16Array;
  Ei.Uint32Array = Uint32Array;
  Ei.Int32Array = Int32Array;
  Ei.Uint8ClampedArray = Uint8ClampedArray;
  try {
    Ei.BigInt64Array = BigInt64Array, Ei.BigUint64Array = BigUint64Array;
  } catch {
  }
  function qu(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    return new (Ei[t] || Float64Array)(...n);
  }
  function d5(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    return (Ei[t] || Float64Array).from(...n);
  }
  function g5(t) {
    return t.charAt(0).toUpperCase() + t.slice(1);
  }
  function gr(t) {
    return g5(t[0] === "_" ? t.slice(1) : t);
  }
  function Nb(t) {
    return t.charAt(0).toLowerCase() + t.slice(1);
  }
  function Lb(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
    const r = [
      "TB",
      "GB",
      "MB",
      "KB"
    ];
    let i = Number(t), a = "B";
    for (; i > n; ) i /= n, a = r.pop();
    return `${i.toFixed(e)} ${a}`;
  }
  function Ub(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
    const n = [];
    let r = t;
    for (; r > 1e3; ) n.push(`000${r % 1e3}`.slice(-3)), r = Math.floor(r / 1e3);
    return r > 0 && n.push(r), n.reverse(), n.join(e);
  }
  function Fb(t) {
    Object.keys(t).forEach((e) => {
      Array.isArray(t[e]) && (t[e] = [].concat(t[e]));
    });
  }
  function $W(t) {
    return Object.values(Ei).some((e) => t instanceof e);
  }
  function eH(t, e) {
    if (t === e) return true;
    if (Array.isArray(t) && Array.isArray(e)) {
      if (t.length !== e.length) return false;
      for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return false;
      return true;
    }
    return false;
  }
  function tH(t, e) {
    return Object.keys(t).find((n) => t[n] === e);
  }
  function Bb(t) {
    return t && t.isA ? t.getState() : t;
  }
  function g8(t) {
    setTimeout(t, 0);
  }
  function _b(t, e) {
    const n = performance.now();
    t.finally(() => {
      const r = performance.now() - n;
      e(r);
    });
  }
  function _n() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Fb(e);
    const n = [];
    if (Number.isInteger(e.mtime) || (e.mtime = ++jv), !("classHierarchy" in e)) e.classHierarchy = new M4("vtkObject");
    else if (!(e.classHierarchy instanceof M4)) {
      const a = new M4();
      for (let s = 0; s < e.classHierarchy.length; s++) a.push(e.classHierarchy[s]);
      e.classHierarchy = a;
    }
    function r(a) {
      n[a] = null;
    }
    function i(a) {
      function s() {
        r(a);
      }
      return Object.freeze({
        unsubscribe: s
      });
    }
    return t.isDeleted = () => !!e.deleted, t.modified = (a) => {
      if (e.deleted) {
        Jt("instance deleted - cannot call any method");
        return;
      }
      a && a < t.getMTime() || (e.mtime = ++jv, n.forEach((s) => s && s(t)));
    }, t.onModified = (a) => {
      if (e.deleted) return Jt("instance deleted - cannot call any method"), null;
      const s = n.length;
      return n.push(a), i(s);
    }, t.getMTime = () => e.mtime, t.isA = (a) => {
      let s = e.classHierarchy.length;
      for (; s--; ) if (e.classHierarchy[s] === a) return true;
      return false;
    }, t.getClassName = function() {
      let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.classHierarchy[e.classHierarchy.length - 1 - a];
    }, t.set = function() {
      let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, l = false;
      return Object.keys(a).forEach((c) => {
        const f = o ? null : t[`set${g5(c)}`];
        f && Array.isArray(a[c]) && f.length > 1 ? l = f(...a[c]) || l : f ? l = f(a[c]) || l : ([
          "mtime"
        ].indexOf(c) === -1 && !s && d8(`Warning: Set value to model directly ${c}, ${a[c]}`), l = e[c] !== a[c] || l, e[c] = a[c]);
      }), l;
    }, t.get = function() {
      for (var a = arguments.length, s = new Array(a), o = 0; o < a; o++) s[o] = arguments[o];
      if (!s.length) return e;
      const l = {};
      return s.forEach((c) => {
        l[c] = e[c];
      }), l;
    }, t.getReferenceByName = (a) => e[a], t.delete = () => {
      Object.keys(e).forEach((a) => delete e[a]), n.forEach((a, s) => r(s)), e.deleted = true;
    }, t.getState = () => {
      if (e.deleted) return null;
      const a = {
        ...e,
        vtkClass: t.getClassName()
      };
      Object.keys(a).forEach((o) => {
        a[o] === null || a[o] === void 0 || o[0] === "_" ? delete a[o] : a[o].isA ? a[o] = a[o].getState() : Array.isArray(a[o]) ? a[o] = a[o].map(Bb) : $W(a[o]) && (a[o] = Array.from(a[o]));
      });
      const s = {};
      return Object.keys(a).sort().forEach((o) => {
        s[o] = a[o];
      }), s.mtime && delete s.mtime, s;
    }, t.shallowCopy = function(a) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (a.getClassName() !== t.getClassName()) throw new Error(`Cannot ShallowCopy ${a.getClassName()} into ${t.getClassName()}`);
      const o = a.get(), l = Object.keys(e).sort();
      Object.keys(o).sort().forEach((f) => {
        const u = l.indexOf(f);
        u === -1 ? s && ap(`add ${f} in shallowCopy`) : l.splice(u, 1), e[f] = o[f];
      }), l.length && s && ap(`Untouched keys: ${l.join(", ")}`), t.modified();
    }, t.toJSON = function() {
      return t.getState();
    }, t;
  }
  const nH = {
    object(t, e, n) {
      return function() {
        return {
          ...e[n.name]
        };
      };
    }
  };
  function Wi(t, e, n) {
    n.forEach((r) => {
      if (typeof r == "object") {
        const i = nH[r.type];
        i ? t[`get${gr(r.name)}`] = i(t, e, r) : t[`get${gr(r.name)}`] = () => e[r.name];
      } else t[`get${gr(r)}`] = () => e[r];
    });
  }
  const rH = {
    enum(t, e, n) {
      const r = `_on${gr(n.name)}Changed`;
      return (i) => {
        var _a3;
        if (typeof i == "string") {
          if (n.enum[i] !== void 0) return e[n.name] !== n.enum[i] ? (e[n.name] = n.enum[i], t.modified(), true) : false;
          throw Jt(`Set Enum with invalid argument ${n}, ${i}`), new RangeError("Set Enum with invalid string argument");
        }
        if (typeof i == "number") {
          if (e[n.name] !== i) {
            if (Object.keys(n.enum).map((a) => n.enum[a]).indexOf(i) !== -1) {
              const a = e[n.name];
              return e[n.name] = i, (_a3 = e[r]) == null ? void 0 : _a3.call(e, t, e, i, a), t.modified(), true;
            }
            throw Jt(`Set Enum outside numeric range ${n}, ${i}`), new RangeError("Set Enum outside numeric range");
          }
          return false;
        }
        throw Jt(`Set Enum with invalid argument (String/Number) ${n}, ${i}`), new TypeError("Set Enum with invalid argument (String/Number)");
      };
    },
    object(t, e, n) {
      const r = `_on${gr(n.name)}Changed`;
      return (i) => {
        var _a3;
        if (!wb(e[n.name], i)) {
          const a = e[n.name];
          return e[n.name] = i, (_a3 = e[r]) == null ? void 0 : _a3.call(e, t, e, i, a), t.modified(), true;
        }
        return false;
      };
    }
  };
  function _C(t) {
    if (typeof t == "object") {
      const e = rH[t.type];
      if (e) return (n, r) => e(n, r, t);
      throw Jt(`No setter for field ${t}`), new TypeError("No setter for field");
    }
    return function(n, r) {
      const i = `_on${gr(t)}Changed`;
      return function(s) {
        var _a3;
        if (r.deleted) return Jt("instance deleted - cannot call any method"), false;
        if (r[t] !== s) {
          const o = r[t.name];
          return r[t] = s, (_a3 = r[i]) == null ? void 0 : _a3.call(r, n, r, s, o), n.modified(), true;
        }
        return false;
      };
    };
  }
  function Zh(t, e, n) {
    n.forEach((r) => {
      typeof r == "object" ? t[`set${gr(r.name)}`] = _C(r)(t, e) : t[`set${gr(r)}`] = _C(r)(t, e);
    });
  }
  function pr(t, e, n) {
    Wi(t, e, n), Zh(t, e, n);
  }
  function Xu(t, e, n) {
    n.forEach((r) => {
      t[`get${gr(r)}`] = () => e[r] ? Array.from(e[r]) : e[r], t[`get${gr(r)}ByReference`] = () => e[r];
    });
  }
  function p8(t, e, n, r) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
    n.forEach((a) => {
      if (e[a] && r && e[a].length !== r) throw new RangeError(`Invalid initial number of values for array (${a})`);
      const s = `_on${gr(a)}Changed`;
      t[`set${gr(a)}`] = function() {
        var _a3;
        if (e.deleted) return Jt("instance deleted - cannot call any method"), false;
        for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++) l[c] = arguments[c];
        let f = l, u, h = false;
        if (f.length === 1 && (f[0] == null || f[0].length >= 0) && (f = f[0], h = true), f == null) u = e[a] !== f;
        else {
          if (r && f.length !== r) if (f.length < r && i !== void 0) for (f = Array.from(f), h = false; f.length < r; ) f.push(i);
          else throw new RangeError(`Invalid number of values for array setter (${a})`);
          u = e[a] == null || e[a].length !== f.length;
          for (let g = 0; !u && g < f.length; ++g) u = e[a][g] !== f[g];
          u && h && (f = Array.from(f));
        }
        if (u) {
          const g = e[a.name];
          e[a] = f, (_a3 = e[s]) == null ? void 0 : _a3.call(e, t, e, f, g), t.modified();
        }
        return u;
      }, t[`set${gr(a)}From`] = (o) => {
        const l = e[a];
        o.forEach((c, f) => {
          l[f] = c;
        });
      };
    });
  }
  function m8(t, e, n, r) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
    Xu(t, e, n), p8(t, e, n, r, i);
  }
  function Qh(t, e, n) {
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      e[i] !== void 0 && (e[`_${i}`] = e[i], delete e[i]);
    }
  }
  function v8(t, e, n, r) {
    e.inputData ? e.inputData = e.inputData.map(ss) : e.inputData = [], e.inputConnection ? e.inputConnection = e.inputConnection.map(ss) : e.inputConnection = [], e.output ? e.output = e.output.map(ss) : e.output = [], e.inputArrayToProcess ? e.inputArrayToProcess = e.inputArrayToProcess.map(ss) : e.inputArrayToProcess = [], e.numberOfInputs = n;
    function i(g) {
      let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (e.deleted) {
        Jt("instance deleted - cannot call any method");
        return;
      }
      if (v >= e.numberOfInputs) {
        Jt(`algorithm ${t.getClassName()} only has ${e.numberOfInputs} input ports. To add more input ports, use addInputData()`);
        return;
      }
      (e.inputData[v] !== g || e.inputConnection[v]) && (e.inputData[v] = g, e.inputConnection[v] = null, t.modified && t.modified());
    }
    function a() {
      let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.inputConnection[g] && (e.inputData[g] = e.inputConnection[g]()), e.inputData[g];
    }
    function s(g) {
      let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (e.deleted) {
        Jt("instance deleted - cannot call any method");
        return;
      }
      if (v >= e.numberOfInputs) {
        let m = `algorithm ${t.getClassName()} only has `;
        m += `${e.numberOfInputs}`, m += " input ports. To add more input ports, use addInputConnection()", Jt(m);
        return;
      }
      e.inputData[v] = null, e.inputConnection[v] = g;
    }
    function o() {
      let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.inputConnection[g];
    }
    function l() {
      let g = e.numberOfInputs;
      for (; g && !e.inputData[g - 1] && !e.inputConnection[g - 1]; ) g--;
      return g === e.numberOfInputs && e.numberOfInputs++, g;
    }
    function c(g) {
      if (e.deleted) {
        Jt("instance deleted - cannot call any method");
        return;
      }
      s(g, l());
    }
    function f(g) {
      if (e.deleted) {
        Jt("instance deleted - cannot call any method");
        return;
      }
      i(g, l());
    }
    function u() {
      let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.deleted ? (Jt("instance deleted - cannot call any method"), null) : (t.shouldUpdate() && t.update(), e.output[g]);
    }
    t.shouldUpdate = () => {
      var _a3, _b3;
      const g = t.getMTime();
      let v = 1 / 0, m = r;
      for (; m--; ) {
        if (!e.output[m] || e.output[m].isDeleted()) return true;
        const y = e.output[m].getMTime();
        if (y < g) return true;
        y < v && (v = y);
      }
      for (m = e.numberOfInputs; m--; ) if (((_a3 = e.inputConnection[m]) == null ? void 0 : _a3.filter.shouldUpdate()) || ((_b3 = t.getInputData(m)) == null ? void 0 : _b3.getMTime()) > v) return true;
      return false;
    };
    function h() {
      let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      const v = () => u(g);
      return v.filter = t, v;
    }
    if (e.numberOfInputs) {
      let g = e.numberOfInputs;
      for (; g--; ) e.inputData.push(null), e.inputConnection.push(null);
      t.setInputData = i, t.setInputConnection = s, t.addInputData = f, t.addInputConnection = c, t.getInputData = a, t.getInputConnection = o;
    }
    r && (t.getOutputData = u, t.getOutputPort = h), t.update = () => {
      const g = [];
      if (e.numberOfInputs) {
        let v = 0;
        for (; v < e.numberOfInputs; ) g[v] = t.getInputData(v), v++;
      }
      t.shouldUpdate() && t.requestData && t.requestData(g, e.output);
    }, t.getNumberOfInputPorts = () => e.numberOfInputs, t.getNumberOfOutputPorts = () => r || e.output.length, t.getInputArrayToProcess = (g) => {
      const v = e.inputArrayToProcess[g], m = e.inputData[g];
      return v && m ? m[`get${v.fieldAssociation}`]().getArray(v.arrayName) : null;
    }, t.setInputArrayToProcess = function(g, v, m) {
      let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "Scalars";
      for (; e.inputArrayToProcess.length < g; ) e.inputArrayToProcess.push(null);
      e.inputArrayToProcess[g] = {
        arrayName: v,
        fieldAssociation: m,
        attributeType: y
      };
    };
  }
  const y8 = Symbol("Event abort");
  function kb(t, e, n) {
    const r = [], i = t.delete;
    let a = 1;
    function s(c) {
      for (let f = 0; f < r.length; ++f) {
        const [u] = r[f];
        if (u === c) {
          r.splice(f, 1);
          return;
        }
      }
    }
    function o(c) {
      function f() {
        s(c);
      }
      return Object.freeze({
        unsubscribe: f
      });
    }
    function l() {
      if (e.deleted) {
        Jt("instance deleted - cannot call any method");
        return;
      }
      const c = r.slice();
      for (let f = 0; f < c.length; ++f) {
        const [, u, h] = c[f];
        if (u) {
          if (h < 0) setTimeout(() => u.apply(t, arguments), 1 - h);
          else if (u.apply(t, arguments) === y8) break;
        }
      }
    }
    t[`invoke${gr(n)}`] = l, t[`on${gr(n)}`] = function(c) {
      let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!c.apply) return console.error(`Invalid callback for event ${n}`), null;
      if (e.deleted) return Jt("instance deleted - cannot call any method"), null;
      const u = a++;
      return r.push([
        u,
        c,
        f
      ]), r.sort((h, g) => g[2] - h[2]), o(u);
    }, t.delete = () => {
      i(), r.forEach((c) => {
        let [f] = c;
        return s(f);
      });
    };
  }
  function pn(t, e) {
    const n = function() {
      let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const i = {}, a = {};
      return t(a, i, r), Object.freeze(a);
    };
    return e && ss.register(e, n), n;
  }
  function x8() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return function() {
      for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++) i[a] = arguments[a];
      return e.filter((s) => !!s).map((s) => s(...i));
    };
  }
  function w8(t) {
    return t && t.isA && t.isA("vtkObject");
  }
  function sp(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
    if (w8(t)) {
      if (r.indexOf(t) >= 0) return n;
      r.push(t);
      const i = e(t);
      i !== void 0 && n.push(i);
      const a = t.get();
      Object.keys(a).forEach((s) => {
        const o = a[s];
        Array.isArray(o) ? o.forEach((l) => {
          sp(l, e, n, r);
        }) : sp(o, e, n, r);
      });
    }
    return n;
  }
  function Pb(t, e, n) {
    var r = this;
    let i;
    const a = function() {
      for (var s = arguments.length, o = new Array(s), l = 0; l < s; l++) o[l] = arguments[l];
      const c = r, f = () => {
        i = null, n || t.apply(c, o);
      }, u = n && !i;
      clearTimeout(i), i = setTimeout(f, e), u && t.apply(c, o);
    };
    return a.cancel = () => clearTimeout(i), a;
  }
  function Gb(t, e) {
    let n = false, r = null;
    function i() {
      n = false, r !== null && (a(...r), r = null);
    }
    function a() {
      for (var s = arguments.length, o = new Array(s), l = 0; l < s; l++) o[l] = arguments[l];
      if (n) {
        r = o;
        return;
      }
      n = true, t(...o), setTimeout(i, e);
    }
    return a;
  }
  function C8(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    e.keystore = Object.assign(e.keystore || {}, n), t.setKey = (r, i) => {
      e.keystore[r] = i;
    }, t.getKey = (r) => e.keystore[r], t.getAllKeys = () => Object.keys(e.keystore), t.deleteKey = (r) => delete e.keystore[r], t.clearKeystore = () => t.getAllKeys().forEach((r) => delete e.keystore[r]);
  }
  let iH = 1;
  const b2 = "__root__";
  function zb(t, e) {
    C8(t, e);
    const n = t.delete;
    e.proxyId = `${iH++}`, e.ui = JSON.parse(JSON.stringify(e.ui || [])), Wi(t, e, [
      "proxyId",
      "proxyGroup",
      "proxyName"
    ]), pr(t, e, [
      "proxyManager"
    ]);
    const r = {}, i = {};
    function a(c, f) {
      i[f] || (i[f] = []);
      const u = i[f];
      for (let h = 0; h < c.length; h++) u.push(c[h].name), r[c[h].name] = c[h], c[h].children && c[h].children.length && a(c[h].children, c[h].name);
    }
    a(e.ui, b2), t.updateUI = (c) => {
      e.ui = JSON.parse(JSON.stringify(c || [])), Object.keys(r).forEach((f) => delete r[f]), Object.keys(i).forEach((f) => delete i[f]), a(e.ui, b2), t.modified();
    };
    function s() {
      let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : b2;
      return i[c];
    }
    t.updateProxyProperty = (c, f) => {
      const u = r[c];
      u ? Object.assign(u, f) : r[c] = {
        ...f
      };
    }, t.activate = () => {
      if (e.proxyManager) {
        const c = `setActive${gr(t.getProxyGroup().slice(0, -1))}`;
        e.proxyManager[c] && e.proxyManager[c](t);
      }
    }, e.propertyLinkSubscribers = {}, t.registerPropertyLinkForGC = (c, f) => {
      f in e.propertyLinkSubscribers || (e.propertyLinkSubscribers[f] = []), e.propertyLinkSubscribers[f].push(c);
    }, t.gcPropertyLinks = (c) => {
      const f = e.propertyLinkSubscribers[c] || [];
      for (; f.length; ) f.pop().unbind(t);
    }, e.propertyLinkMap = {}, t.getPropertyLink = function(c) {
      let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e.propertyLinkMap[c]) return e.propertyLinkMap[c];
      let u = null;
      const h = [];
      let g = 0, v = false;
      function m(S) {
        let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (v) return null;
        const b = [];
        let D = null;
        for (g = h.length; g--; ) {
          const I = h[g];
          I.instance === S ? D = I : b.push(I);
        }
        if (!D) return null;
        const R = D.instance[`get${gr(D.propertyName)}`]();
        if (!eH(R, u) || E) {
          for (u = R, v = true; b.length; ) {
            const I = b.pop();
            I.instance.set({
              [I.propertyName]: u
            });
          }
          v = false;
        }
        return e.propertyLinkMap[c].persistent && (e.propertyLinkMap[c].value = R), R;
      }
      function y(S, E) {
        const b = [];
        for (g = h.length; g--; ) {
          const D = h[g];
          D.instance === S && (D.propertyName === E || E === void 0) && (D.subscription.unsubscribe(), b.push(g));
        }
        for (; b.length; ) h.splice(b.pop(), 1);
      }
      function w(S, E) {
        let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const D = S.onModified(m), R = h[0];
        return h.push({
          instance: S,
          propertyName: E,
          subscription: D
        }), b && (e.propertyLinkMap[c].persistent && e.propertyLinkMap[c].value !== void 0 ? S.set({
          [E]: e.propertyLinkMap[c].value
        }) : R && m(R.instance, true)), {
          unsubscribe: () => y(S, E)
        };
      }
      function C() {
        for (; h.length; ) h.pop().subscription.unsubscribe();
      }
      const T = {
        bind: w,
        unbind: y,
        unsubscribe: C,
        persistent: f
      };
      return e.propertyLinkMap[c] = T, T;
    };
    function o() {
      let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : b2;
      const f = [], u = e.proxyId, h = s(c) || [];
      for (let g = 0; g < h.length; g++) {
        const v = h[g], m = t[`get${gr(v)}`], y = m ? m() : void 0, w = {
          id: u,
          name: v,
          value: y
        }, C = o(v);
        C.length && (w.children = C), f.push(w);
      }
      return f;
    }
    t.listPropertyNames = () => o().map((c) => c.name), t.getPropertyByName = (c) => o().find((f) => f.name === c), t.getPropertyDomainByName = (c) => (r[c] || {}).domain, t.getProxySection = () => ({
      id: e.proxyId,
      name: e.proxyGroup,
      ui: e.ui,
      properties: o()
    }), t.delete = () => {
      const c = Object.keys(e.propertyLinkMap);
      let f = c.length;
      for (; f--; ) e.propertyLinkMap[c[f]].unsubscribe();
      Object.keys(e.propertyLinkSubscribers).forEach(t.gcPropertyLinks), n();
    }, t.getState = () => null;
    function l() {
      if (e.links) for (let c = 0; c < e.links.length; c++) {
        const { link: f, property: u, persistent: h, updateOnBind: g, type: v } = e.links[c];
        if (v === "application") {
          const m = e.proxyManager.getPropertyLink(f, h);
          t.registerPropertyLinkForGC(m, "application"), m.bind(t, u, g);
        }
      }
    }
    g8(l);
  }
  function Wb(t, e, n) {
    const r = t.delete, i = [], a = Object.keys(n);
    let s = a.length;
    for (; s--; ) {
      const o = a[s], { modelKey: l, property: c, modified: f = true } = n[o], u = gr(c), h = gr(o);
      t[`get${h}`] = e[l][`get${u}`], t[`set${h}`] = e[l][`set${u}`], f && i.push(e[l].onModified(t.modified));
    }
    t.delete = () => {
      for (; i.length; ) i.pop().unsubscribe();
      r();
    };
  }
  function Hb(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    e.this = t;
    function i(o) {
      const l = Object.keys(o);
      let c = l.length;
      for (; c--; ) {
        const f = l[c];
        e[f].set(o[f]);
      }
    }
    const a = Object.keys(r);
    let s = a.length;
    for (; s--; ) {
      const o = a[s];
      e[o] = r[o];
      const l = n[o];
      t[`set${gr(o)}`] = (c) => {
        if (c !== e[o]) {
          e[o] = c;
          const f = l[c];
          i(f), t.modified();
        }
      };
    }
    a.length && Wi(t, e, a);
  }
  const kC = 10, PC = 40, GC = 800;
  function jb(t) {
    let e = 0, n = 0, r = 0, i = 0;
    return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = e * kC, i = n * kC, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (t.deltaMode === 1 ? (r *= PC, i *= PC) : (r *= GC, i *= GC)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
      spinX: e,
      spinY: n || e,
      pixelX: r,
      pixelY: i || r
    };
  }
  var H = {
    algo: v8,
    capitalize: g5,
    chain: x8,
    debounce: Pb,
    enumToString: tH,
    event: kb,
    EVENT_ABORT: y8,
    formatBytesToProperUnit: Lb,
    formatNumbersWithThousandSeparator: Ub,
    get: Wi,
    getArray: Xu,
    getCurrentGlobalMTime: QW,
    getStateArrayMapFunc: Bb,
    isVtkObject: w8,
    keystore: C8,
    measurePromiseExecution: _b,
    moveToProtected: Qh,
    newInstance: pn,
    newTypedArray: qu,
    newTypedArrayFrom: d5,
    normalizeWheel: jb,
    obj: _n,
    proxy: zb,
    proxyPropertyMapping: Wb,
    proxyPropertyState: Hb,
    safeArrays: Fb,
    set: Zh,
    setArray: p8,
    setGet: pr,
    setGetArray: m8,
    setImmediate: g8,
    setLoggerFunction: Rb,
    throttle: Gb,
    traverseInstanceTree: sp,
    TYPED_ARRAYS: Ei,
    uncapitalize: Nb,
    VOID: Db,
    vtkDebugMacro: ap,
    vtkErrorMacro: Jt,
    vtkInfoMacro: Ib,
    vtkLogMacro: Ob,
    vtkOnceErrorMacro: Vb,
    vtkWarningMacro: d8
  }, di = Object.freeze({
    __proto__: null,
    VOID: Db,
    setLoggerFunction: Rb,
    vtkLogMacro: Ob,
    vtkInfoMacro: Ib,
    vtkDebugMacro: ap,
    vtkErrorMacro: Jt,
    vtkWarningMacro: d8,
    vtkOnceErrorMacro: Vb,
    TYPED_ARRAYS: Ei,
    newTypedArray: qu,
    newTypedArrayFrom: d5,
    capitalize: g5,
    _capitalize: gr,
    uncapitalize: Nb,
    formatBytesToProperUnit: Lb,
    formatNumbersWithThousandSeparator: Ub,
    setImmediateVTK: g8,
    measurePromiseExecution: _b,
    obj: _n,
    get: Wi,
    set: Zh,
    setGet: pr,
    getArray: Xu,
    setArray: p8,
    setGetArray: m8,
    moveToProtected: Qh,
    algo: v8,
    EVENT_ABORT: y8,
    event: kb,
    newInstance: pn,
    chain: x8,
    isVtkObject: w8,
    traverseInstanceTree: sp,
    debounce: Pb,
    throttle: Gb,
    keystore: C8,
    proxy: zb,
    proxyPropertyMapping: Wb,
    proxyPropertyState: Hb,
    normalizeWheel: jb,
    default: H
  }), Sg = {
    exports: {}
  }, aH = Sg.exports, zC;
  function sH() {
    return zC || (zC = 1, (function(t) {
      (function(e, n, r) {
        function i(l) {
          var c = this, f = o();
          c.next = function() {
            var u = 2091639 * c.s0 + c.c * 23283064365386963e-26;
            return c.s0 = c.s1, c.s1 = c.s2, c.s2 = u - (c.c = u | 0);
          }, c.c = 1, c.s0 = f(" "), c.s1 = f(" "), c.s2 = f(" "), c.s0 -= f(l), c.s0 < 0 && (c.s0 += 1), c.s1 -= f(l), c.s1 < 0 && (c.s1 += 1), c.s2 -= f(l), c.s2 < 0 && (c.s2 += 1), f = null;
        }
        function a(l, c) {
          return c.c = l.c, c.s0 = l.s0, c.s1 = l.s1, c.s2 = l.s2, c;
        }
        function s(l, c) {
          var f = new i(l), u = c && c.state, h = f.next;
          return h.int32 = function() {
            return f.next() * 4294967296 | 0;
          }, h.double = function() {
            return h() + (h() * 2097152 | 0) * 11102230246251565e-32;
          }, h.quick = h, u && (typeof u == "object" && a(u, f), h.state = function() {
            return a(f, {});
          }), h;
        }
        function o() {
          var l = 4022871197, c = function(f) {
            f = String(f);
            for (var u = 0; u < f.length; u++) {
              l += f.charCodeAt(u);
              var h = 0.02519603282416938 * l;
              l = h >>> 0, h -= l, h *= l, l = h >>> 0, h -= l, l += h * 4294967296;
            }
            return (l >>> 0) * 23283064365386963e-26;
          };
          return c;
        }
        n && n.exports ? n.exports = s : this.alea = s;
      })(aH, t);
    })(Sg)), Sg.exports;
  }
  var Ag = {
    exports: {}
  }, oH = Ag.exports, WC;
  function lH() {
    return WC || (WC = 1, (function(t) {
      (function(e, n, r) {
        function i(o) {
          var l = this, c = "";
          l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.next = function() {
            var u = l.x ^ l.x << 11;
            return l.x = l.y, l.y = l.z, l.z = l.w, l.w ^= l.w >>> 19 ^ u ^ u >>> 8;
          }, o === (o | 0) ? l.x = o : c += o;
          for (var f = 0; f < c.length + 64; f++) l.x ^= c.charCodeAt(f) | 0, l.next();
        }
        function a(o, l) {
          return l.x = o.x, l.y = o.y, l.z = o.z, l.w = o.w, l;
        }
        function s(o, l) {
          var c = new i(o), f = l && l.state, u = function() {
            return (c.next() >>> 0) / 4294967296;
          };
          return u.double = function() {
            do
              var h = c.next() >>> 11, g = (c.next() >>> 0) / 4294967296, v = (h + g) / (1 << 21);
            while (v === 0);
            return v;
          }, u.int32 = c.next, u.quick = u, f && (typeof f == "object" && a(f, c), u.state = function() {
            return a(c, {});
          }), u;
        }
        n && n.exports ? n.exports = s : this.xor128 = s;
      })(oH, t);
    })(Ag)), Ag.exports;
  }
  var Eg = {
    exports: {}
  }, cH = Eg.exports, HC;
  function uH() {
    return HC || (HC = 1, (function(t) {
      (function(e, n, r) {
        function i(o) {
          var l = this, c = "";
          l.next = function() {
            var u = l.x ^ l.x >>> 2;
            return l.x = l.y, l.y = l.z, l.z = l.w, l.w = l.v, (l.d = l.d + 362437 | 0) + (l.v = l.v ^ l.v << 4 ^ (u ^ u << 1)) | 0;
          }, l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.v = 0, o === (o | 0) ? l.x = o : c += o;
          for (var f = 0; f < c.length + 64; f++) l.x ^= c.charCodeAt(f) | 0, f == c.length && (l.d = l.x << 10 ^ l.x >>> 4), l.next();
        }
        function a(o, l) {
          return l.x = o.x, l.y = o.y, l.z = o.z, l.w = o.w, l.v = o.v, l.d = o.d, l;
        }
        function s(o, l) {
          var c = new i(o), f = l && l.state, u = function() {
            return (c.next() >>> 0) / 4294967296;
          };
          return u.double = function() {
            do
              var h = c.next() >>> 11, g = (c.next() >>> 0) / 4294967296, v = (h + g) / (1 << 21);
            while (v === 0);
            return v;
          }, u.int32 = c.next, u.quick = u, f && (typeof f == "object" && a(f, c), u.state = function() {
            return a(c, {});
          }), u;
        }
        n && n.exports ? n.exports = s : this.xorwow = s;
      })(cH, t);
    })(Eg)), Eg.exports;
  }
  var bg = {
    exports: {}
  }, fH = bg.exports, jC;
  function hH() {
    return jC || (jC = 1, (function(t) {
      (function(e, n, r) {
        function i(o) {
          var l = this;
          l.next = function() {
            var f = l.x, u = l.i, h, g;
            return h = f[u], h ^= h >>> 7, g = h ^ h << 24, h = f[u + 1 & 7], g ^= h ^ h >>> 10, h = f[u + 3 & 7], g ^= h ^ h >>> 3, h = f[u + 4 & 7], g ^= h ^ h << 7, h = f[u + 7 & 7], h = h ^ h << 13, g ^= h ^ h << 9, f[u] = g, l.i = u + 1 & 7, g;
          };
          function c(f, u) {
            var h, g = [];
            if (u === (u | 0)) g[0] = u;
            else for (u = "" + u, h = 0; h < u.length; ++h) g[h & 7] = g[h & 7] << 15 ^ u.charCodeAt(h) + g[h + 1 & 7] << 13;
            for (; g.length < 8; ) g.push(0);
            for (h = 0; h < 8 && g[h] === 0; ++h) ;
            for (h == 8 ? g[7] = -1 : g[h], f.x = g, f.i = 0, h = 256; h > 0; --h) f.next();
          }
          c(l, o);
        }
        function a(o, l) {
          return l.x = o.x.slice(), l.i = o.i, l;
        }
        function s(o, l) {
          o == null && (o = +/* @__PURE__ */ new Date());
          var c = new i(o), f = l && l.state, u = function() {
            return (c.next() >>> 0) / 4294967296;
          };
          return u.double = function() {
            do
              var h = c.next() >>> 11, g = (c.next() >>> 0) / 4294967296, v = (h + g) / (1 << 21);
            while (v === 0);
            return v;
          }, u.int32 = c.next, u.quick = u, f && (f.x && a(f, c), u.state = function() {
            return a(c, {});
          }), u;
        }
        n && n.exports ? n.exports = s : this.xorshift7 = s;
      })(fH, t);
    })(bg)), bg.exports;
  }
  var Dg = {
    exports: {}
  }, dH = Dg.exports, KC;
  function gH() {
    return KC || (KC = 1, (function(t) {
      (function(e, n, r) {
        function i(o) {
          var l = this;
          l.next = function() {
            var f = l.w, u = l.X, h = l.i, g, v;
            return l.w = f = f + 1640531527 | 0, v = u[h + 34 & 127], g = u[h = h + 1 & 127], v ^= v << 13, g ^= g << 17, v ^= v >>> 15, g ^= g >>> 12, v = u[h] = v ^ g, l.i = h, v + (f ^ f >>> 16) | 0;
          };
          function c(f, u) {
            var h, g, v, m, y, w = [], C = 128;
            for (u === (u | 0) ? (g = u, u = null) : (u = u + "\0", g = 0, C = Math.max(C, u.length)), v = 0, m = -32; m < C; ++m) u && (g ^= u.charCodeAt((m + 32) % u.length)), m === 0 && (y = g), g ^= g << 10, g ^= g >>> 15, g ^= g << 4, g ^= g >>> 13, m >= 0 && (y = y + 1640531527 | 0, h = w[m & 127] ^= g + y, v = h == 0 ? v + 1 : 0);
            for (v >= 128 && (w[(u && u.length || 0) & 127] = -1), v = 127, m = 512; m > 0; --m) g = w[v + 34 & 127], h = w[v = v + 1 & 127], g ^= g << 13, h ^= h << 17, g ^= g >>> 15, h ^= h >>> 12, w[v] = g ^ h;
            f.w = y, f.X = w, f.i = v;
          }
          c(l, o);
        }
        function a(o, l) {
          return l.i = o.i, l.w = o.w, l.X = o.X.slice(), l;
        }
        function s(o, l) {
          o == null && (o = +/* @__PURE__ */ new Date());
          var c = new i(o), f = l && l.state, u = function() {
            return (c.next() >>> 0) / 4294967296;
          };
          return u.double = function() {
            do
              var h = c.next() >>> 11, g = (c.next() >>> 0) / 4294967296, v = (h + g) / (1 << 21);
            while (v === 0);
            return v;
          }, u.int32 = c.next, u.quick = u, f && (f.X && a(f, c), u.state = function() {
            return a(c, {});
          }), u;
        }
        n && n.exports ? n.exports = s : this.xor4096 = s;
      })(dH, t);
    })(Dg)), Dg.exports;
  }
  var Mg = {
    exports: {}
  }, pH = Mg.exports, YC;
  function mH() {
    return YC || (YC = 1, (function(t) {
      (function(e, n, r) {
        function i(o) {
          var l = this, c = "";
          l.next = function() {
            var u = l.b, h = l.c, g = l.d, v = l.a;
            return u = u << 25 ^ u >>> 7 ^ h, h = h - g | 0, g = g << 24 ^ g >>> 8 ^ v, v = v - u | 0, l.b = u = u << 20 ^ u >>> 12 ^ h, l.c = h = h - g | 0, l.d = g << 16 ^ h >>> 16 ^ v, l.a = v - u | 0;
          }, l.a = 0, l.b = 0, l.c = -1640531527, l.d = 1367130551, o === Math.floor(o) ? (l.a = o / 4294967296 | 0, l.b = o | 0) : c += o;
          for (var f = 0; f < c.length + 20; f++) l.b ^= c.charCodeAt(f) | 0, l.next();
        }
        function a(o, l) {
          return l.a = o.a, l.b = o.b, l.c = o.c, l.d = o.d, l;
        }
        function s(o, l) {
          var c = new i(o), f = l && l.state, u = function() {
            return (c.next() >>> 0) / 4294967296;
          };
          return u.double = function() {
            do
              var h = c.next() >>> 11, g = (c.next() >>> 0) / 4294967296, v = (h + g) / (1 << 21);
            while (v === 0);
            return v;
          }, u.int32 = c.next, u.quick = u, f && (typeof f == "object" && a(f, c), u.state = function() {
            return a(c, {});
          }), u;
        }
        n && n.exports ? n.exports = s : this.tychei = s;
      })(pH, t);
    })(Mg)), Mg.exports;
  }
  var Rg = {
    exports: {}
  };
  const vH = {}, yH = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: vH
  }, Symbol.toStringTag, {
    value: "Module"
  })), xH = EF(yH);
  var wH = Rg.exports, qC;
  function CH() {
    return qC || (qC = 1, (function(t) {
      (function(e, n, r) {
        var i = 256, a = 6, s = 52, o = "random", l = r.pow(i, a), c = r.pow(2, s), f = c * 2, u = i - 1, h;
        function g(S, E, b) {
          var D = [];
          E = E == true ? {
            entropy: true
          } : E || {};
          var R = w(y(E.entropy ? [
            S,
            T(n)
          ] : S ?? C(), 3), D), I = new v(D), O = function() {
            for (var L = I.g(a), N = l, F = 0; L < c; ) L = (L + F) * i, N *= i, F = I.g(1);
            for (; L >= f; ) L /= 2, N /= 2, F >>>= 1;
            return (L + F) / N;
          };
          return O.int32 = function() {
            return I.g(4) | 0;
          }, O.quick = function() {
            return I.g(4) / 4294967296;
          }, O.double = O, w(T(I.S), n), (E.pass || b || function(L, N, F, V) {
            return V && (V.S && m(V, I), L.state = function() {
              return m(I, {});
            }), F ? (r[o] = L, N) : L;
          })(O, R, "global" in E ? E.global : this == r, E.state);
        }
        function v(S) {
          var E, b = S.length, D = this, R = 0, I = D.i = D.j = 0, O = D.S = [];
          for (b || (S = [
            b++
          ]); R < i; ) O[R] = R++;
          for (R = 0; R < i; R++) O[R] = O[I = u & I + S[R % b] + (E = O[R])], O[I] = E;
          (D.g = function(L) {
            for (var N, F = 0, V = D.i, k = D.j, _ = D.S; L--; ) N = _[V = u & V + 1], F = F * i + _[u & (_[V] = _[k = u & k + N]) + (_[k] = N)];
            return D.i = V, D.j = k, F;
          })(i);
        }
        function m(S, E) {
          return E.i = S.i, E.j = S.j, E.S = S.S.slice(), E;
        }
        function y(S, E) {
          var b = [], D = typeof S, R;
          if (E && D == "object") for (R in S) try {
            b.push(y(S[R], E - 1));
          } catch {
          }
          return b.length ? b : D == "string" ? S : S + "\0";
        }
        function w(S, E) {
          for (var b = S + "", D, R = 0; R < b.length; ) E[u & R] = u & (D ^= E[u & R] * 19) + b.charCodeAt(R++);
          return T(E);
        }
        function C() {
          try {
            var S;
            return h && (S = h.randomBytes) ? S = S(i) : (S = new Uint8Array(i), (e.crypto || e.msCrypto).getRandomValues(S)), T(S);
          } catch {
            var E = e.navigator, b = E && E.plugins;
            return [
              +/* @__PURE__ */ new Date(),
              e,
              b,
              e.screen,
              T(n)
            ];
          }
        }
        function T(S) {
          return String.fromCharCode.apply(0, S);
        }
        if (w(r.random(), n), t.exports) {
          t.exports = g;
          try {
            h = xH;
          } catch {
          }
        } else r["seed" + o] = g;
      })(typeof self < "u" ? self : wH, [], Math);
    })(Rg)), Rg.exports;
  }
  var R4, XC;
  function TH() {
    if (XC) return R4;
    XC = 1;
    var t = sH(), e = lH(), n = uH(), r = hH(), i = gH(), a = mH(), s = CH();
    return s.alea = t, s.xor128 = e, s.xorwow = n, s.xorshift7 = r, s.xor4096 = i, s.tychei = a, R4 = s, R4;
  }
  var SH = TH();
  const AH = t0(SH), T8 = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ], EH = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ], S8 = 1e-6, A8 = 1e-12, { vtkErrorMacro: Kb, vtkWarningMacro: Wc } = H;
  let Yb = 0;
  const ZC = 20;
  function Jh(t) {
    return () => Kb(`vtkMath::${t} - NOT IMPLEMENTED`);
  }
  function oh(t, e, n, r) {
    let i;
    for (let a = 0; a < e; a++) i = t[n * e + a], t[n * e + a] = t[r * e + a], t[r * e + a] = i;
  }
  function P1(t, e, n, r) {
    let i;
    for (let a = 0; a < e; a++) i = t[a * e + n], t[a * e + n] = t[a * e + r], t[a * e + r] = i;
  }
  function Wn() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
    const e = Array(t);
    for (let n = 0; n < t; ++n) e[n] = 0;
    return e;
  }
  const bH = () => Math.PI;
  function rr(t) {
    return t / 180 * Math.PI;
  }
  function op(t) {
    return t * 180 / Math.PI;
  }
  const { round: G1, floor: E8, ceil: DH, min: MH, max: RH } = Math;
  function OH(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = 1 / 0;
    for (let i = e, a = t.length; i < a; i += n) t[i] < r && (r = t[i]);
    return r;
  }
  function IH(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = -1 / 0;
    for (let i = e, a = t.length; i < a; i += n) r < t[i] && (r = t[i]);
    return r;
  }
  function VH(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = 1 / 0, i = -1 / 0;
    for (let a = e, s = t.length; a < s; a += n) t[a] < r && (r = t[a]), i < t[a] && (i = t[a]);
    return [
      r,
      i
    ];
  }
  const NH = Jh("ceilLog2"), LH = Jh("factorial");
  function Na(t) {
    let e = 1;
    for (; e < t; ) e *= 2;
    return e;
  }
  function z1(t) {
    return t === Na(t);
  }
  function UH(t, e) {
    let n = 1;
    for (let r = 1; r <= e; ++r) n *= (t - r + 1) / r;
    return Math.floor(n);
  }
  function FH(t, e) {
    if (t < e) return 0;
    const n = Wn(e);
    for (let r = 0; r < e; ++r) n[r] = r;
    return n;
  }
  function BH(t, e, n) {
    let r = 0;
    for (let i = e - 1; i >= 0; --i) if (n[i] < t - e + i) {
      let a = n[i] + 1;
      for (; i < e; ) n[i++] = a++;
      r = 1;
      break;
    }
    return r;
  }
  function _H(t) {
    AH(`${t}`, {
      global: true
    }), Yb = t;
  }
  function kH() {
    return Yb;
  }
  function PH() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1) - t;
    return t + n * Math.random();
  }
  const GH = Jh("gaussian");
  function lp(t, e, n) {
    return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n;
  }
  function xo(t, e, n) {
    return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n;
  }
  function qb(t, e) {
    return t[0] *= e, t[1] *= e, t[2] *= e, t;
  }
  function Xb(t, e) {
    return t[0] *= e, t[1] *= e, t;
  }
  function Kv(t, e, n, r) {
    return r[0] = t[0] + e[0] * n, r[1] = t[1] + e[1] * n, r[2] = t[2] + e[2] * n, r;
  }
  function zH(t, e, n, r) {
    return r[0] = t[0] + e[0] * n, r[1] = t[1] + e[1] * n, r;
  }
  function Ht(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
  }
  function WH(t, e, n) {
    n[0] = t[0] * e[0], n[1] = t[0] * e[1], n[2] = t[0] * e[2], n[3] = t[1] * e[0], n[4] = t[1] * e[1], n[5] = t[1] * e[2], n[6] = t[2] * e[0], n[7] = t[2] * e[1], n[8] = t[2] * e[2];
  }
  function Ns(t, e, n) {
    const r = t[1] * e[2] - t[2] * e[1], i = t[2] * e[0] - t[0] * e[2], a = t[0] * e[1] - t[1] * e[0];
    return n[0] = r, n[1] = i, n[2] = a, n;
  }
  function El(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    switch (e) {
      case 1:
        return Math.abs(t);
      case 2:
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
      case 3:
        return Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
      default: {
        let n = 0;
        for (let r = 0; r < e; r++) n += t[r] * t[r];
        return Math.sqrt(n);
      }
    }
  }
  function Hc(t) {
    const e = El(t);
    return e !== 0 && (t[0] /= e, t[1] /= e, t[2] /= e), e;
  }
  function HH(t, e, n, r) {
    const i = t[0] * t[0], a = t[1] * t[1], s = t[2] * t[2], o = Math.sqrt(i + a + s);
    let l, c, f;
    i > a && i > s ? (l = 0, c = 1, f = 2) : a > s ? (l = 1, c = 2, f = 0) : (l = 2, c = 0, f = 1);
    const u = t[l] / o, h = t[c] / o, g = t[f] / o, v = Math.sqrt(u * u + g * g);
    if (r !== 0) {
      const m = Math.sin(r), y = Math.cos(r);
      e && (e[l] = (g * y - u * h * m) / v, e[c] = m * v, e[f] = (-(u * y) - h * g * m) / v), n && (n[l] = (-(g * m) - u * h * y) / v, n[c] = y * v, n[f] = (u * m - h * g * y) / v);
    } else e && (e[l] = g / v, e[c] = 0, e[f] = -u / v), n && (n[l] = -u * h / v, n[c] = v, n[f] = -h * g / v);
  }
  function jH(t, e, n) {
    const r = Ht(e, e);
    if (r === 0) return n[0] = 0, n[1] = 0, n[2] = 0, false;
    const i = Ht(t, e) / r;
    for (let a = 0; a < 3; a++) n[a] = e[a];
    return qb(n, i), true;
  }
  function Yv(t, e) {
    return t[0] * e[0] + t[1] * e[1];
  }
  function KH(t, e, n) {
    const r = Yv(e, e);
    if (r === 0) return n[0] = 0, n[1] = 0, false;
    const i = Yv(t, e) / r;
    for (let a = 0; a < 2; a++) n[a] = e[a];
    return Xb(n, i), true;
  }
  function bs(t, e) {
    return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]) + (t[2] - e[2]) * (t[2] - e[2]);
  }
  function YH(t, e) {
    const n = [
      0,
      0,
      0
    ];
    return Ns(t, e, n), Math.atan2(El(n), Ht(t, e));
  }
  function qH(t, e, n) {
    const r = Math.abs(t - n);
    return 1 / Math.sqrt(2 * Math.PI * e) * Math.exp(-(r ** 2) / (2 * e));
  }
  function XH(t, e, n) {
    const r = Math.abs(t - n);
    return Math.exp(-(r ** 2) / (2 * e));
  }
  function ZH(t, e, n) {
    n[0] = t[0] * e[0], n[1] = t[0] * e[1], n[2] = t[1] * e[0], n[3] = t[1] * e[1];
  }
  function Zb(t) {
    return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
  }
  function Qb(t) {
    const e = Zb(t);
    return e !== 0 && (t[0] /= e, t[1] /= e), e;
  }
  function ir() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return e.length === 2 ? e[0][0] * e[1][1] - e[1][0] * e[0][1] : e.length === 4 ? e[0] * e[3] - e[1] * e[2] : Number.NaN;
  }
  function QH(t, e) {
    let n, r, i;
    const a = [
      0,
      0,
      0
    ];
    for (let s = 0; s < 3; s++) i = Math.abs(t[s * 3]), (r = Math.abs(t[s * 3 + 1])) > i && (i = r), (r = Math.abs(t[s * 3 + 2])) > i && (i = r), a[s] = 1 / i;
    i = a[0] * Math.abs(t[0]), n = 0, (r = a[1] * Math.abs(t[3])) >= i && (i = r, n = 1), (r = a[2] * Math.abs(t[6])) >= i && (n = 2), n !== 0 && (oh(t, 3, n, 0), a[n] = a[0]), e[0] = n, t[3] /= t[0], t[6] /= t[0], t[4] -= t[3] * t[1], t[7] -= t[6] * t[1], i = a[1] * Math.abs(t[4]), n = 1, (r = a[2] * Math.abs(t[7])) >= i && (n = 2, oh(t, 3, 1, 2), a[2] = a[1]), e[1] = n, t[7] /= t[4], t[5] -= t[3] * t[2], t[8] -= t[6] * t[2] + t[7] * t[5], e[2] = 2;
  }
  function JH(t, e, n) {
    let r = n[e[0]];
    n[e[0]] = n[0], n[0] = r, r = n[e[1]], n[e[1]] = n[1], n[1] = r - t[3] * n[0], r = n[e[2]], n[e[2]] = n[2], n[2] = r - t[6] * n[0] - t[7] * n[1], n[2] /= t[8], n[1] = (n[1] - t[5] * n[2]) / t[4], n[0] = (n[0] - t[1] * n[1] - t[2] * n[2]) / t[0];
  }
  function $H(t, e, n) {
    const r = t[0], i = t[1], a = t[2], s = t[3], o = t[4], l = t[5], c = t[6], f = t[7], u = t[8], h = +ir(o, f, l, u), g = -ir(s, c, l, u), v = +ir(s, c, o, f), m = -ir(i, f, a, u), y = +ir(r, c, a, u), w = -ir(r, c, i, f), C = +ir(i, o, a, l), T = -ir(r, s, a, l), S = +ir(r, s, i, o), E = r * h + i * g + a * v, b = h * e[0] + m * e[1] + C * e[2], D = g * e[0] + y * e[1] + T * e[2], R = v * e[0] + w * e[1] + S * e[2];
    n[0] = b / E, n[1] = D / E, n[2] = R / E;
  }
  function Og(t, e, n) {
    const r = t[0] * e[0] + t[1] * e[1] + t[2] * e[2], i = t[3] * e[0] + t[4] * e[1] + t[5] * e[2], a = t[6] * e[0] + t[7] * e[1] + t[8] * e[2];
    n[0] = r, n[1] = i, n[2] = a;
  }
  function qv(t, e, n) {
    const r = [
      ...t
    ], i = [
      ...e
    ];
    for (let a = 0; a < 3; a++) n[a] = r[0] * i[a] + r[1] * i[a + 3] + r[2] * i[a + 6], n[a + 3] = r[3] * i[a] + r[4] * i[a + 3] + r[5] * i[a + 6], n[a + 6] = r[6] * i[a] + r[7] * i[a + 3] + r[8] * i[a + 6];
  }
  function ej(t, e, n, r, i, a, s) {
    r !== i && Kb("Number of columns of A must match number of rows of B.");
    const o = [
      ...t
    ], l = [
      ...e
    ];
    for (let c = 0; c < n; c++) for (let f = 0; f < a; f++) {
      s[c * a + f] = 0;
      for (let u = 0; u < r; u++) s[c * a + f] += o[c * r + u] * l[f + a * u];
    }
  }
  function vu(t, e) {
    let n;
    n = t[3], e[3] = t[1], e[1] = n, n = t[6], e[6] = t[2], e[2] = n, n = t[7], e[7] = t[5], e[5] = n, e[0] = t[0], e[4] = t[4], e[8] = t[8];
  }
  function tj(t, e) {
    const n = t[0], r = t[1], i = t[2], a = t[3], s = t[4], o = t[5], l = t[6], c = t[7], f = t[8], u = +ir(s, c, o, f), h = -ir(a, l, o, f), g = +ir(a, l, s, c), v = -ir(r, c, i, f), m = +ir(n, l, i, f), y = -ir(n, l, r, c), w = +ir(r, s, i, o), C = -ir(n, a, i, o), T = +ir(n, a, r, s), S = n * u + r * h + i * g;
    S === 0 && Wc("Matrix has 0 determinant"), e[0] = u / S, e[3] = h / S, e[6] = g / S, e[1] = v / S, e[4] = m / S, e[7] = y / S, e[2] = w / S, e[5] = C / S, e[8] = T / S;
  }
  function p5(t) {
    return t[0] * t[4] * t[8] + t[3] * t[7] * t[2] + t[6] * t[1] * t[5] - t[0] * t[7] * t[5] - t[3] * t[1] * t[8] - t[6] * t[4] * t[2];
  }
  function Jb(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S8;
    if (t.length !== e.length) return false;
    function r(i, a) {
      return Math.abs(i - e[a]) <= n;
    }
    return t.every(r);
  }
  const $h = Jb;
  function $b(t) {
    for (let e = 0; e < 3; e++) t[e * 3] = t[e * 3 + 1] = t[e * 3 + 2] = 0, t[e * 3 + e] = 1;
  }
  function eD(t, e) {
    for (let n = 0; n < t; n++) {
      for (let r = 0; r < t; r++) e[n * t + r] = 0;
      e[n * t + n] = 1;
    }
    return e;
  }
  function nj(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : S8;
    return $h(t, T8, e);
  }
  function rj(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : S8;
    return $h(t, EH, e);
  }
  function tD(t, e) {
    const n = t[0] * t[0], r = t[0] * t[1], i = t[0] * t[2], a = t[0] * t[3], s = t[1] * t[1], o = t[2] * t[2], l = t[3] * t[3], c = t[1] * t[2], f = t[1] * t[3], u = t[2] * t[3], h = s + o + l;
    let g = 1 / (n + h);
    const v = (n - h) * g;
    g *= 2, e[0] = s * g + v, e[3] = (c + a) * g, e[6] = (f - i) * g, e[1] = (c - a) * g, e[4] = o * g + v, e[7] = (u + r) * g, e[2] = (f + i) * g, e[5] = (u - r) * g, e[8] = l * g + v;
  }
  function Ig(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!`${t}`.includes("e")) return +`${Math.round(`${t}e+${e}`)}e-${e}`;
    const n = `${t}`.split("e");
    let r = "";
    return +n[1] + e > 0 && (r = "+"), +`${Math.round(`${+n[0]}e${r}${+n[1] + e}`)}e-${e}`;
  }
  function Xv(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
      0,
      0,
      0
    ], n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    return e[0] = Ig(t[0], n), e[1] = Ig(t[1], n), e[2] = Ig(t[2], n), e;
  }
  function ed(t, e, n, r) {
    let i, a, s, o, l, c, f, u, h, g, v, m, y, w, C, T;
    const S = Wn(e), E = Wn(e), b = (R, I, O) => {
      w = R[I], y = R[O], R[I] = w - m * (y + w * g), R[O] = y + m * (w - y * g);
    };
    for (eD(e, r), l = 0; l < e; l++) S[l] = n[l] = t[l + l * e], E[l] = 0;
    for (i = 0; i < ZC; i++) {
      for (v = 0, l = 0; l < e - 1; l++) for (o = l + 1; o < e; o++) v += Math.abs(t[l * e + o]);
      if (v === 0) break;
      for (i < 3 ? f = 0.2 * v / (e * e) : f = 0, l = 0; l < e - 1; l++) for (o = l + 1; o < e; o++) if (w = 100 * Math.abs(t[l * e + o]), i > 3 && Math.abs(n[l]) + w === Math.abs(n[l]) && Math.abs(n[o]) + w === Math.abs(n[o])) t[l * e + o] = 0;
      else if (Math.abs(t[l * e + o]) > f) {
        for (y = n[o] - n[l], Math.abs(y) + w === Math.abs(y) ? h = t[l * e + o] / y : (u = 0.5 * y / t[l * e + o], h = 1 / (Math.abs(u) + Math.sqrt(1 + u * u)), u < 0 && (h = -h)), C = 1 / Math.sqrt(1 + h * h), m = h * C, g = m / (1 + C), y = h * t[l * e + o], E[l] -= y, E[o] += y, n[l] -= y, n[o] += y, t[l * e + o] = 0, a = 0; a <= l - 1; a++) b(t, a * e + l, a * e + o);
        for (a = l + 1; a <= o - 1; a++) b(t, l * e + a, a * e + o);
        for (a = o + 1; a < e; a++) b(t, l * e + a, o * e + a);
        for (a = 0; a < e; a++) b(r, a * e + l, a * e + o);
      }
      for (l = 0; l < e; l++) S[l] += E[l], n[l] = S[l], E[l] = 0;
    }
    if (i >= ZC) return Wc("vtkMath::Jacobi: Error extracting eigenfunctions"), 0;
    for (a = 0; a < e - 1; a++) {
      for (s = a, T = n[s], i = a + 1; i < e; i++) (n[i] >= T || Math.abs(n[i] - T) < A8) && (s = i, T = n[s]);
      s !== a && (n[s] = n[a], n[a] = T, P1(r, e, a, s));
    }
    const D = (e >> 1) + (e & 1);
    for (c = 0, i = 0; i < e * e; i++) r[i] >= 0 && c++;
    if (c < D) for (i = 0; i < e; i++) r[i * e + a] *= -1;
    return 1;
  }
  function nD(t, e) {
    const n = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    n[0] = t[0] + t[4] + t[8], n[5] = t[0] - t[4] - t[8], n[10] = -t[0] + t[4] - t[8], n[15] = -t[0] - t[4] + t[8], n[1] = n[4] = t[7] - t[5], n[2] = n[8] = t[2] - t[6], n[3] = n[12] = t[3] - t[1], n[6] = n[9] = t[3] + t[1], n[7] = n[13] = t[2] + t[6], n[11] = n[14] = t[7] + t[5];
    const r = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], i = [
      0,
      0,
      0,
      0
    ], a = [
      ...n
    ];
    ed(a, 4, i, r), e[0] = r[0], e[1] = r[4], e[2] = r[8], e[3] = r[12];
  }
  function ij(t, e, n) {
    const r = t[0] * e[0], i = t[0] * e[1], a = t[0] * e[2], s = t[0] * e[3], o = t[1] * e[0], l = t[1] * e[1], c = t[1] * e[2], f = t[1] * e[3], u = t[2] * e[0], h = t[2] * e[1], g = t[2] * e[2], v = t[2] * e[3], m = t[3] * e[0], y = t[3] * e[1], w = t[3] * e[2], C = t[3] * e[3];
    n[0] = r - l - g - C, n[1] = i + o + v - w, n[2] = a - f + u + y, n[3] = s + c - h + m;
  }
  function rD(t, e) {
    for (let h = 0; h < 9; h++) e[h] = t[h];
    const n = Wn(3), r = Wn(3);
    let i;
    for (let h = 0; h < 3; h++) {
      const g = Math.abs(e[h * 3]), v = Math.abs(e[h * 3 + 1]), m = Math.abs(e[h * 3 + 2]);
      i = v > g ? v : g, i = m > i ? m : i, n[h] = 1, i !== 0 && (n[h] /= i);
    }
    const a = Math.abs(e[0]) * n[0], s = Math.abs(e[3]) * n[1], o = Math.abs(e[6]) * n[2];
    r[0] = 0, i = a, s >= i && (i = s, r[0] = 1), o >= i && (r[0] = 2), r[0] !== 0 && (P1(e, 3, r[0], 0), n[r[0]] = n[0]);
    const l = Math.abs(e[4]) * n[1], c = Math.abs(e[7]) * n[2];
    r[1] = 1, i = l, c >= i && (r[1] = 2, P1(e, 3, 1, 2)), r[2] = 2;
    let f = 0;
    if (p5(e) < 0) {
      f = 1;
      for (let h = 0; h < 9; h++) e[h] = -e[h];
    }
    const u = Wn(4);
    if (nD(e, u), tD(u, e), f) for (let h = 0; h < 9; h++) e[h] = -e[h];
    r[1] !== 1 && P1(e, 3, r[1], 1), r[0] !== 0 && P1(e, 3, r[0], 0);
  }
  function iD(t, e, n) {
    let r, i, a, s, o, l;
    const c = [
      ...t
    ];
    if (ed(c, 3, e, n), e[0] === e[1] && e[0] === e[2]) {
      $b(n);
      return;
    }
    for (vu(n, n), r = 0; r < 3; r++) if (e[(r + 1) % 3] === e[(r + 2) % 3]) {
      for (l = Math.abs(n[r * 3]), s = 0, i = 1; i < 3; i++) l < (o = Math.abs(n[r * 3 + i])) && (l = o, s = i);
      s !== r && (o = e[s], e[s] = e[r], e[r] = o, oh(n, 3, r, s)), n[s * 3 + s] < 0 && (n[s * 3] = -n[s * 3], n[s * 3 + 1] = -n[s * 3 + 1], n[s * 3 + 2] = -n[s * 3 + 2]), i = (s + 1) % 3, a = (s + 2) % 3, n[i * 3] = 0, n[i * 3 + 1] = 0, n[i * 3 + 2] = 0, n[i * 3 + i] = 1;
      const f = Ns([
        n[s * 3],
        n[s * 3 + 1],
        n[s * 3 + 2]
      ], [
        n[i * 3],
        n[i * 3 + 1],
        n[i * 3 + 2]
      ], []);
      Hc(f);
      const u = Ns(f, [
        n[s * 3],
        n[s * 3 + 1],
        n[s * 3 + 2]
      ], []);
      for (let h = 0; h < 3; h++) n[a * 3 + h] = f[h], n[i * 3 + h] = u[h];
      vu(n, n);
      return;
    }
    for (l = Math.abs(n[0]), s = 0, r = 1; r < 3; r++) l < (o = Math.abs(n[r * 3])) && (l = o, s = r);
    if (s !== 0) {
      const f = e[s];
      e[s] = e[0], e[0] = f, oh(n, 3, s, 0);
    }
    if (Math.abs(n[4]) < Math.abs(n[7])) {
      const f = e[2];
      e[2] = e[1], e[1] = f, oh(n, 3, 1, 2);
    }
    for (r = 0; r < 2; r++) n[r * 3 + r] < 0 && (n[r * 3] = -n[r * 3], n[r * 3 + 1] = -n[r * 3 + 1], n[r * 3 + 2] = -n[r * 3 + 2]);
    p5(n) < 0 && (n[6] = -n[6], n[7] = -n[7], n[8] = -n[8]), vu(n, n);
  }
  function aj(t, e, n, r) {
    let i;
    const a = [
      ...t
    ], s = p5(a);
    if (s < 0) for (i = 0; i < 9; i++) a[i] = -a[i];
    rD(a, e), vu(a, a), qv(a, e, r), iD(r, n, r), qv(e, r, e), vu(r, r), s < 0 && (n[0] = -n[0], n[1] = -n[1], n[2] = -n[2]);
  }
  function b8(t, e, n) {
    let r, i, a, s, o = 0, l, c, f;
    const u = Wn(n);
    for (r = 0; r < n; r++) {
      for (s = 0, i = 0; i < n; i++) (f = Math.abs(t[r * n + i])) > s && (s = f);
      if (s === 0) return Wc("Unable to factor linear system"), 0;
      u[r] = 1 / s;
    }
    for (i = 0; i < n; i++) {
      for (r = 0; r < i; r++) {
        for (l = t[r * n + i], a = 0; a < r; a++) l -= t[r * n + a] * t[a * n + i];
        t[r * n + i] = l;
      }
      for (s = 0, r = i; r < n; r++) {
        for (l = t[r * n + i], a = 0; a < i; a++) l -= t[r * n + a] * t[a * n + i];
        t[r * n + i] = l, (c = u[r] * Math.abs(l)) >= s && (s = c, o = r);
      }
      if (i !== o) {
        for (a = 0; a < n; a++) c = t[o * n + a], t[o * n + a] = t[i * n + a], t[i * n + a] = c;
        u[o] = u[i];
      }
      if (e[i] = o, Math.abs(t[i * n + i]) <= A8) return Wc("Unable to factor linear system"), 0;
      if (i !== n - 1) for (c = 1 / t[i * n + i], r = i + 1; r < n; r++) t[r * n + i] *= c;
    }
    return 1;
  }
  function D8(t, e, n, r) {
    let i, a, s, o, l;
    for (s = -1, i = 0; i < r; i++) {
      if (o = e[i], l = n[o], n[o] = n[i], s >= 0) for (a = s; a <= i - 1; a++) l -= t[i * r + a] * n[a];
      else l !== 0 && (s = i);
      n[i] = l;
    }
    for (i = r - 1; i >= 0; i--) {
      for (l = n[i], a = i + 1; a < r; a++) l -= t[i * r + a] * n[a];
      n[i] = l / t[i * r + i];
    }
  }
  function aD(t, e, n) {
    if (n === 2) {
      const i = Wn(2), a = ir(t[0], t[1], t[2], t[3]);
      return a === 0 ? 0 : (i[0] = (t[3] * e[0] - t[1] * e[1]) / a, i[1] = (-(t[2] * e[0]) + t[0] * e[1]) / a, e[0] = i[0], e[1] = i[1], 1);
    }
    if (n === 1) return t[0] === 0 ? 0 : (e[0] /= t[0], 1);
    const r = Wn(n);
    return b8(t, r, n) === 0 ? 0 : (D8(t, r, e, n), 1);
  }
  function sD(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    const a = r || Wn(n), s = i || Wn(n);
    if (b8(t, a, n) === 0) return null;
    for (let o = 0; o < n; o++) {
      for (let l = 0; l < n; l++) s[l] = 0;
      s[o] = 1, D8(t, a, s, n);
      for (let l = 0; l < n; l++) e[l * n + o] = s[l];
    }
    return e;
  }
  function sj(t, e) {
    let n = +Number.MAX_VALUE, r = -Number.MAX_VALUE;
    for (let i = 0; i < e; i++) for (let a = i; a < e; a++) Math.abs(t[i * e + a]) > r && (r = Math.abs(t[i * e + a]));
    for (let i = 0; i < e; i++) Math.abs(t[i * e + i]) < n && (n = Math.abs(t[i * e + i]));
    return n === 0 ? Number.MAX_VALUE : r / n;
  }
  function oj(t, e, n) {
    return ed(t, 3, e, n);
  }
  function Zv(t, e, n, r) {
    if (t < n) return Wc("Insufficient number of samples. Underdetermined."), 0;
    let i, a, s;
    const o = Wn(n * n), l = Wn(n), c = Wn(n * n);
    for (s = 0; s < t; s++) for (i = 0; i < n; i++) for (a = i; a < n; a++) o[i * n + a] += e[s * n + i] * e[s * n + a];
    for (i = 0; i < n; i++) for (a = 0; a < i; a++) o[i * n + a] = o[a * n + i];
    for (ed(o, n, l, c), i = 0; i < n; i++) r[i] = c[i * n + n - 1];
    return 1;
  }
  function lj(t, e, n, r, i, a) {
    let s = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true;
    if (t < n || t < i) return Wc("Insufficient number of samples. Underdetermined."), 0;
    const o = Wn(i);
    let l = 1, c, f = 0, u, h, g, v = 0;
    if (s) {
      for (h = 0; h < i; h++) o[h] = 1;
      for (u = 0; u < t; u++) for (h = 0; h < i; h++) Math.abs(r[u * i + h]) > A8 && (l = 0, o[h] = 0);
      if (l && i === 1) return Wc("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"), Zv(t, e, n, a);
      if (l) v = 1;
      else for (h = 0; h < i; h++) o[h] && (v = 1);
    }
    v && (c = Wn(n), f = Zv(t, e, n, c));
    const m = Wn(n * n), y = Wn(n * n), w = Wn(n * i);
    for (g = 0; g < t; g++) for (u = 0; u < n; u++) {
      for (h = u; h < n; h++) m[u * n + h] += e[g * n + u] * e[g * n + h];
      for (h = 0; h < i; h++) w[u * i + h] += e[g * n + u] * r[g * i + h];
    }
    for (u = 0; u < n; u++) for (h = 0; h < u; h++) m[u * n + h] = m[h * n + u];
    const C = sD(m, y, n);
    if (C) for (u = 0; u < n; u++) for (h = 0; h < i; h++) for (a[u * i + h] = 0, g = 0; g < n; g++) a[u * i + h] += y[u * n + g] * w[g * i + h];
    if (v) {
      for (h = 0; h < i; h++) if (o[h]) for (u = 0; u < n; u++) a[u * i + h] = c[u * i];
    }
    return v ? f && C : C;
  }
  function cj(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
      0,
      0.5,
      1
    ];
    switch (t.length) {
      case 3:
        return e[0] = parseInt(t[0], 16) * 17 / 255, e[1] = parseInt(t[1], 16) * 17 / 255, e[2] = parseInt(t[2], 16) * 17 / 255, e;
      case 4:
        return e[0] = parseInt(t[1], 16) * 17 / 255, e[1] = parseInt(t[2], 16) * 17 / 255, e[2] = parseInt(t[3], 16) * 17 / 255, e;
      case 6:
        return e[0] = parseInt(t.substr(0, 2), 16) / 255, e[1] = parseInt(t.substr(2, 2), 16) / 255, e[2] = parseInt(t.substr(4, 2), 16) / 255, e;
      case 7:
        return e[0] = parseInt(t.substr(1, 2), 16) / 255, e[1] = parseInt(t.substr(3, 2), 16) / 255, e[2] = parseInt(t.substr(5, 2), 16) / 255, e;
      case 9:
        return e[0] = parseInt(t.substr(1, 2), 16) / 255, e[1] = parseInt(t.substr(3, 2), 16) / 255, e[2] = parseInt(t.substr(5, 2), 16) / 255, e[3] = parseInt(t.substr(7, 2), 16) / 255, e;
      default:
        return e;
    }
  }
  function W1(t, e) {
    let n, r;
    const [i, a, s] = t, o = 1 / 3, l = 1 / 6, c = 2 / 3;
    let f = i, u = i;
    a > f ? f = a : a < u && (u = a), s > f ? f = s : s < u && (u = s);
    const h = f;
    h > 0 ? r = (f - u) / f : r = 0, r > 0 ? (i === f ? n = l * (a - s) / (f - u) : a === f ? n = o + l * (s - i) / (f - u) : n = c + l * (i - a) / (f - u), n < 0 && (n += 1)) : n = 0, e[0] = n, e[1] = r, e[2] = h;
  }
  function Dc(t, e) {
    const [n, r, i] = t, a = 1 / 3, s = 1 / 6, o = 2 / 3, l = 5 / 6;
    let c, f, u;
    n > s && n <= a ? (f = 1, c = (a - n) / s, u = 0) : n > a && n <= 0.5 ? (f = 1, u = (n - a) / s, c = 0) : n > 0.5 && n <= o ? (u = 1, f = (o - n) / s, c = 0) : n > o && n <= l ? (u = 1, c = (n - o) / s, f = 0) : n > l && n <= 1 ? (c = 1, u = (1 - n) / s, f = 0) : (c = 1, f = n / s, u = 0), c = r * c + (1 - r), f = r * f + (1 - r), u = r * u + (1 - r), c *= i, f *= i, u *= i, e[0] = c, e[1] = f, e[2] = u;
  }
  function oD(t, e) {
    const [n, r, i] = t;
    let a = (n + 16) / 116, s = r / 500 + a, o = a - i / 200;
    a ** 3 > 8856e-6 ? a **= 3 : a = (a - 16 / 116) / 7.787, s ** 3 > 8856e-6 ? s **= 3 : s = (s - 16 / 116) / 7.787, o ** 3 > 8856e-6 ? o **= 3 : o = (o - 16 / 116) / 7.787;
    const l = 0.9505, c = 1, f = 1.089;
    e[0] = l * s, e[1] = c * a, e[2] = f * o;
  }
  function lD(t, e) {
    const [n, r, i] = t, a = 0.9505, s = 1, o = 1.089;
    let l = n / a, c = r / s, f = i / o;
    l > 8856e-6 ? l **= 1 / 3 : l = 7.787 * l + 16 / 116, c > 8856e-6 ? c **= 1 / 3 : c = 7.787 * c + 16 / 116, f > 8856e-6 ? f **= 1 / 3 : f = 7.787 * f + 16 / 116, e[0] = 116 * c - 16, e[1] = 500 * (l - c), e[2] = 200 * (c - f);
  }
  function cD(t, e) {
    const [n, r, i] = t;
    let a = n * 3.2406 + r * -1.5372 + i * -0.4986, s = n * -0.9689 + r * 1.8758 + i * 0.0415, o = n * 0.0557 + r * -0.204 + i * 1.057;
    a > 31308e-7 ? a = 1.055 * a ** (1 / 2.4) - 0.055 : a *= 12.92, s > 31308e-7 ? s = 1.055 * s ** (1 / 2.4) - 0.055 : s *= 12.92, o > 31308e-7 ? o = 1.055 * o ** (1 / 2.4) - 0.055 : o *= 12.92;
    let l = a;
    l < s && (l = s), l < o && (l = o), l > 1 && (a /= l, s /= l, o /= l), a < 0 && (a = 0), s < 0 && (s = 0), o < 0 && (o = 0), e[0] = a, e[1] = s, e[2] = o;
  }
  function uD(t, e) {
    let [n, r, i] = t;
    n > 0.04045 ? n = ((n + 0.055) / 1.055) ** 2.4 : n /= 12.92, r > 0.04045 ? r = ((r + 0.055) / 1.055) ** 2.4 : r /= 12.92, i > 0.04045 ? i = ((i + 0.055) / 1.055) ** 2.4 : i /= 12.92, e[0] = n * 0.4124 + r * 0.3576 + i * 0.1805, e[1] = n * 0.2126 + r * 0.7152 + i * 0.0722, e[2] = n * 0.0193 + r * 0.1192 + i * 0.9505;
  }
  function Vc(t, e) {
    const n = [
      0,
      0,
      0
    ];
    uD(t, n), lD(n, e);
  }
  function cp(t, e) {
    const n = [
      0,
      0,
      0
    ];
    oD(t, n), cD(n, e);
  }
  function Zu(t) {
    return t[0] = 1, t[1] = -1, t[2] = 1, t[3] = -1, t[4] = 1, t[5] = -1, t;
  }
  function Vg(t) {
    return !(t[1] - t[0] < 0);
  }
  function uj(t, e, n) {
    return n[0] = Math.min(t[0], e[0]), n[1] = Math.max(t[0], e[0]), n[2] = Math.min(t[1], e[1]), n[3] = Math.max(t[1], e[1]), n[4] = Math.min(t[2], e[2]), n[5] = Math.max(t[2], e[2]), n;
  }
  function os(t, e, n) {
    return t < e ? e : t > n ? n : t;
  }
  function Qv(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [
      0,
      0,
      0
    ];
    return r[0] = os(t[0], e[0], n[0]), r[1] = os(t[1], e[1], n[1]), r[2] = os(t[2], e[2], n[2]), r;
  }
  function fj(t, e) {
    let n = 0;
    return e[0] !== e[1] && (t < e[0] ? n = e[0] : t > e[1] ? n = e[1] : n = t, n = (n - e[0]) / (e[1] - e[0])), n;
  }
  const hj = Jh("GetScalarTypeFittingRange"), dj = Jh("GetAdjustedScalarRange");
  function gj(t, e) {
    if (!t || !e) return 0;
    for (let n = 0; n < 6; n += 2) if (t[n] < e[n] || t[n] > e[n + 1] || t[n + 1] < e[n] || t[n + 1] > e[n + 1]) return 0;
    return 1;
  }
  function pj(t, e, n) {
    if (!t || !e) return 0;
    for (let r = 0; r < 6; r += 2) if (t[r] + n[r / 2] < e[r] || t[r] - n[r / 2] > e[r + 1] || t[r + 1] + n[r / 2] < e[r] || t[r + 1] - n[r / 2] > e[r + 1]) return 0;
    return 1;
  }
  function mj(t, e, n) {
    if (!t || !e || !n) return 0;
    for (let r = 0; r < 3; r++) if (t[r] + n[r] < e[2 * r] || t[r] - n[r] > e[2 * r + 1]) return 0;
    return 1;
  }
  function vj(t, e, n, r) {
    const i = Wn(3), a = Wn(3), s = Wn(3), o = Wn(3), l = Wn(3), c = Wn(3);
    for (let S = 0; S < 3; ++S) i[S] = t[S] - e[S], a[S] = e[S] - n[S], s[S] = n[S] - t[S], o[S] = -i[S], l[S] = -a[S], c[S] = -s[S];
    const f = El(o), u = El(l), h = El(s), g = Wn(3);
    Ns(i, a, g);
    const v = El(g), m = f * u * h / (2 * v), y = 2 * v * v, w = u * u * Ht(i, c) / y, C = h * h * Ht(o, a) / y, T = f * f * Ht(s, l) / y;
    for (let S = 0; S < 3; ++S) r[S] = w * t[S] + C * e[S] + T * n[S];
    return m;
  }
  const yj = 1 / 0, xj = -1 / 0, fD = (t) => !Number.isFinite(t), { isFinite: wj, isNaN: Jv } = Number, up = Jv;
  function Ll() {
    return [].concat([
      Number.MAX_VALUE,
      -Number.MAX_VALUE,
      Number.MAX_VALUE,
      -Number.MAX_VALUE,
      Number.MAX_VALUE,
      -Number.MAX_VALUE
    ]);
  }
  function Cj(t) {
    let e = -1, n = -1;
    for (let r = 0; r < t.length; r++) {
      const i = Math.abs(t[r]);
      i > e && (n = r, e = i);
    }
    return n;
  }
  function hD(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    const n = new Array(e), r = new Array(e);
    for (let a = 0; a < e; ++a) n[a] = a, r[a] = a;
    for (let a = e - 1; a > 0; a--) {
      let s = -1 / 0, o = 0, l = 0;
      for (let c = 0; c <= a; ++c) {
        const f = n[c];
        for (let u = 0; u <= a; ++u) {
          const h = r[u], g = Math.abs(t[f + e * h]);
          g > s && (s = g, o = c, l = u);
        }
      }
      [n[a], n[o]] = [
        n[o],
        n[a]
      ], [r[a], r[l]] = [
        r[l],
        r[a]
      ];
    }
    const i = new Array(e * e).fill(0);
    for (let a = 0; a < e; ++a) {
      const s = n[a] + e * r[a];
      i[s] = t[s] < 0 ? -1 : 1;
    }
    return i;
  }
  function dD(t) {
    const e = Math.floor(t * 255);
    return e > 15 ? e.toString(16) : `0${e.toString(16)}`;
  }
  function Tj(t) {
    return `${arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#"}${t.map(dD).join("")}`;
  }
  function D2(t) {
    return Math.round(t * 255);
  }
  function Sj(t) {
    return t.length === 3 ? `rgb(${t.map(D2).join(", ")})` : `rgba(${D2(t[0] || 0)}, ${D2(t[1] || 0)}, ${D2(t[2] || 0)}, ${t[3] || 0})`;
  }
  var La = {
    Pi: bH,
    radiansFromDegrees: rr,
    degreesFromRadians: op,
    round: G1,
    floor: E8,
    ceil: DH,
    ceilLog2: NH,
    min: MH,
    max: RH,
    arrayMin: OH,
    arrayMax: IH,
    arrayRange: VH,
    isPowerOfTwo: z1,
    nearestPowerOfTwo: Na,
    factorial: LH,
    binomial: UH,
    beginCombination: FH,
    nextCombination: BH,
    randomSeed: _H,
    getSeed: kH,
    random: PH,
    gaussian: GH,
    add: lp,
    subtract: xo,
    multiplyScalar: qb,
    multiplyScalar2D: Xb,
    multiplyAccumulate: Kv,
    multiplyAccumulate2D: zH,
    dot: Ht,
    outer: WH,
    cross: Ns,
    norm: El,
    normalize: Hc,
    perpendiculars: HH,
    projectVector: jH,
    projectVector2D: KH,
    distance2BetweenPoints: bs,
    angleBetweenVectors: YH,
    gaussianAmplitude: qH,
    gaussianWeight: XH,
    dot2D: Yv,
    outer2D: ZH,
    norm2D: Zb,
    normalize2D: Qb,
    determinant2x2: ir,
    LUFactor3x3: QH,
    LUSolve3x3: JH,
    linearSolve3x3: $H,
    multiply3x3_vect3: Og,
    multiply3x3_mat3: qv,
    multiplyMatrix: ej,
    transpose3x3: vu,
    invert3x3: tj,
    identity3x3: $b,
    identity: eD,
    isIdentity: nj,
    isIdentity3x3: rj,
    determinant3x3: p5,
    quaternionToMatrix3x3: tD,
    areEquals: Jb,
    areMatricesEqual: $h,
    roundNumber: Ig,
    roundVector: Xv,
    matrix3x3ToQuaternion: nD,
    multiplyQuaternion: ij,
    orthogonalize3x3: rD,
    diagonalize3x3: iD,
    singularValueDecomposition3x3: aj,
    solveLinearSystem: aD,
    invertMatrix: sD,
    luFactorLinearSystem: b8,
    luSolveLinearSystem: D8,
    estimateMatrixCondition: sj,
    jacobi: oj,
    jacobiN: ed,
    solveHomogeneousLeastSquares: Zv,
    solveLeastSquares: lj,
    hex2float: cj,
    rgb2hsv: W1,
    hsv2rgb: Dc,
    lab2xyz: oD,
    xyz2lab: lD,
    xyz2rgb: cD,
    rgb2xyz: uD,
    rgb2lab: Vc,
    lab2rgb: cp,
    uninitializeBounds: Zu,
    areBoundsInitialized: Vg,
    computeBoundsFromPoints: uj,
    clampValue: os,
    clampVector: Qv,
    clampAndNormalizeValue: fj,
    getScalarTypeFittingRange: hj,
    getAdjustedScalarRange: dj,
    extentIsWithinOtherExtent: gj,
    boundsIsWithinOtherBounds: pj,
    pointIsWithinBounds: mj,
    solve3PointCircle: vj,
    inf: yj,
    negInf: xj,
    isInf: fD,
    isNan: Jv,
    isNaN: Jv,
    isFinite: wj,
    createUninitializedBounds: Ll,
    getMajorAxisIndex: Cj,
    getSparseOrthogonalMatrix: hD,
    floatToHex2: dD,
    floatRGB2HexCode: Tj,
    float2CssRGBA: Sj
  };
  const Aj = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  }, zt = {
    VOID: "",
    CHAR: "Int8Array",
    SIGNED_CHAR: "Int8Array",
    UNSIGNED_CHAR: "Uint8Array",
    UNSIGNED_CHAR_CLAMPED: "Uint8ClampedArray",
    SHORT: "Int16Array",
    UNSIGNED_SHORT: "Uint16Array",
    INT: "Int32Array",
    UNSIGNED_INT: "Uint32Array",
    FLOAT: "Float32Array",
    DOUBLE: "Float64Array"
  }, Ej = zt.FLOAT;
  var gD = {
    DefaultDataType: Ej,
    DataTypeByteSize: Aj,
    VtkDataTypes: zt
  };
  const { vtkErrorMacro: bj } = di, { DefaultDataType: Dj } = gD, Mj = 1e-6;
  function $v(t, e, n) {
    const r = t.length;
    let i = Number.MAX_VALUE, a = -Number.MAX_VALUE, s, o;
    for (o = e; o < r; o += n) if (!Number.isNaN(t[o])) {
      i = t[o], a = i;
      break;
    }
    for (; o < r; o += n) s = t[o], s < i ? i = s : s > a && (a = s);
    return {
      min: i,
      max: a
    };
  }
  function Rj() {
    let t = Number.MAX_VALUE, e = -Number.MAX_VALUE, n = 0, r = 0;
    return {
      add(i) {
        t > i && (t = i), e < i && (e = i), n++, r += i;
      },
      get() {
        return {
          min: t,
          max: e,
          count: n,
          sum: r,
          mean: r / n
        };
      },
      getRange() {
        return {
          min: t,
          max: e
        };
      }
    };
  }
  function pD(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (e < 0 && n > 1) {
      const i = t.length / n, a = new Float64Array(i);
      for (let s = 0, o = 0; s < i; ++s) {
        for (let l = o + n; o < l; ++o) a[s] += t[o] * t[o];
        a[s] **= 0.5;
      }
      return $v(a, 0, 1);
    }
    return $v(t, e < 0 ? 0 : e, n);
  }
  function QC(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const n = t || [];
    for (; n.length <= e; ) n.push(null);
    return n;
  }
  function M8(t) {
    return Object.prototype.toString.call(t).slice(8, -1);
  }
  function Oj(t) {
    const e = t.getNumberOfComponents();
    let n = 0;
    const r = new Array(e);
    for (let i = 0; i < t.getNumberOfTuples(); ++i) {
      t.getTuple(i, r);
      const a = El(r, e);
      a > n && (n = a);
    }
    return n;
  }
  const Ij = {
    computeRange: pD,
    createRangeHelper: Rj,
    fastComputeRange: $v,
    getDataType: M8,
    getMaxNorm: Oj
  };
  function Vj(t, e) {
    e.classHierarchy.push("vtkDataArray");
    function n(r) {
      if (r < 0) return false;
      const i = t.getNumberOfComponents(), a = e.values.length / (i > 0 ? i : 1);
      if (r === a) return true;
      if (r > a) {
        const s = e.values;
        return e.values = qu(e.dataType, (r + a) * i), e.values.set(s), true;
      }
      return e.size > r * i && (e.size = r * i, t.dataChange()), true;
    }
    t.dataChange = () => {
      e.ranges = null, t.modified();
    }, t.resize = (r) => {
      n(r);
      const i = r * t.getNumberOfComponents();
      return e.size !== i ? (e.size = i, t.dataChange(), true) : false;
    }, t.initialize = () => {
      t.resize(0);
    }, t.getElementComponentSize = () => e.values.BYTES_PER_ELEMENT, t.getComponent = function(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return e.values[r * e.numberOfComponents + i];
    }, t.setComponent = (r, i, a) => {
      a !== e.values[r * e.numberOfComponents + i] && (e.values[r * e.numberOfComponents + i] = a, t.dataChange());
    }, t.getValue = (r) => {
      const i = r / e.numberOfComponents, a = r % e.numberOfComponents;
      return t.getComponent(i, a);
    }, t.setValue = (r, i) => {
      const a = r / e.numberOfComponents, s = r % e.numberOfComponents;
      t.setComponent(a, s, i);
    }, t.getData = () => e.size === e.values.length ? e.values : e.values.subarray(0, e.size), t.getRange = function() {
      let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1, i = r;
      i < 0 && (i = e.numberOfComponents === 1 ? 0 : e.numberOfComponents);
      let a = null;
      return e.ranges || (e.ranges = QC(e.ranges, e.numberOfComponents)), a = e.ranges[i], a ? (e.rangeTuple[0] = a.min, e.rangeTuple[1] = a.max, e.rangeTuple) : (a = pD(t.getData(), r, e.numberOfComponents), e.ranges[i] = a, e.rangeTuple[0] = a.min, e.rangeTuple[1] = a.max, e.rangeTuple);
    }, t.setRange = (r, i) => {
      e.ranges || (e.ranges = QC(e.ranges, e.numberOfComponents));
      const a = {
        min: r.min,
        max: r.max
      };
      return e.ranges[i] = a, e.rangeTuple[0] = a.min, e.rangeTuple[1] = a.max, e.rangeTuple;
    }, t.setTuple = (r, i) => {
      const a = r * e.numberOfComponents;
      for (let s = 0; s < e.numberOfComponents; s++) e.values[a + s] = i[s];
    }, t.setTuples = (r, i) => {
      let a = r * e.numberOfComponents;
      const s = Math.min(i.length, e.size - a);
      for (let o = 0; o < s; ) e.values[a++] = i[o++];
    }, t.insertTuple = (r, i) => (e.size <= r * e.numberOfComponents && (e.size = (r + 1) * e.numberOfComponents, n(r + 1)), t.setTuple(r, i), r), t.insertTuples = (r, i) => {
      const a = r + i.length / e.numberOfComponents;
      return e.size < a * e.numberOfComponents && (e.size = a * e.numberOfComponents, n(a)), t.setTuples(r, i), a;
    }, t.insertNextTuple = (r) => {
      const i = e.size / e.numberOfComponents;
      return t.insertTuple(i, r);
    }, t.insertNextTuples = (r) => {
      const i = e.size / e.numberOfComponents;
      return t.insertTuples(i, r);
    }, t.findTuple = function(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Mj;
      for (let a = 0; a < e.size; a += e.numberOfComponents) if (Math.abs(r[0] - e.values[a]) <= i) {
        let s = true;
        for (let o = 1; o < e.numberOfComponents; ++o) if (Math.abs(r[o] - e.values[a + o]) > i) {
          s = false;
          break;
        }
        if (s) return a / e.numberOfComponents;
      }
      return -1;
    }, t.getTuple = function(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      const a = e.numberOfComponents || 1, s = r * a;
      switch (a) {
        case 4:
          i[3] = e.values[s + 3];
        case 3:
          i[2] = e.values[s + 2];
        case 2:
          i[1] = e.values[s + 1];
        case 1:
          i[0] = e.values[s];
          break;
        default:
          for (let o = a - 1; o >= 0; --o) i[o] = e.values[s + o];
      }
      return i;
    }, t.getTuples = (r, i) => {
      const a = (r ?? 0) * e.numberOfComponents, s = (i ?? t.getNumberOfTuples()) * e.numberOfComponents, o = t.getData().subarray(a, s);
      return o.length > 0 ? o : null;
    }, t.getTupleLocation = function() {
      return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1) * e.numberOfComponents;
    }, t.getNumberOfComponents = () => e.numberOfComponents, t.getNumberOfValues = () => e.size, t.getNumberOfTuples = () => e.size / e.numberOfComponents, t.getDataType = () => e.dataType, t.newClone = () => vD({
      empty: true,
      name: e.name,
      dataType: e.dataType,
      numberOfComponents: e.numberOfComponents
    }), t.getName = () => (e.name || (t.modified(), e.name = `vtkDataArray${t.getMTime()}`), e.name), t.setData = (r, i) => {
      e.values = r, e.size = r.length, e.dataType = M8(r), i && (e.numberOfComponents = i), e.size % e.numberOfComponents !== 0 && (e.numberOfComponents = 1), t.dataChange();
    }, t.getState = () => {
      if (e.deleted) return null;
      const r = {
        ...e,
        vtkClass: t.getClassName()
      };
      r.values = Array.from(r.values), delete r.buffer, Object.keys(r).forEach((a) => {
        r[a] || delete r[a];
      });
      const i = {};
      return Object.keys(r).sort().forEach((a) => {
        i[a] = r[a];
      }), i.mtime && delete i.mtime, i;
    }, t.deepCopy = (r) => {
      const i = t.getDataType(), a = e.values;
      t.shallowCopy(r), (a == null ? void 0 : a.length) >= r.getNumberOfValues() && i === r.getDataType() ? (a.set(r.getData()), e.values = a, t.dataChange()) : t.setData(r.getData().slice());
    }, t.interpolateTuple = (r, i, a, s, o, l) => {
      const c = e.numberOfComponents || 1;
      (c !== i.getNumberOfComponents() || c !== s.getNumberOfComponents()) && bj("numberOfComponents must match");
      const f = i.getTuple(a), u = s.getTuple(o), h = [];
      switch (h.length = c, c) {
        case 4:
          h[3] = f[3] + (u[3] - f[3]) * l;
        case 3:
          h[2] = f[2] + (u[2] - f[2]) * l;
        case 2:
          h[1] = f[1] + (u[1] - f[1]) * l;
        case 1:
          h[0] = f[0] + (u[0] - f[0]) * l;
          break;
        default:
          for (let g = 0; g < c; g++) h[g] = f[g] + (u[g] - f[g]) * l;
      }
      return t.insertTuple(r, h);
    };
  }
  const Nj = {
    name: "",
    numberOfComponents: 1,
    dataType: Dj,
    rangeTuple: [
      0,
      0
    ]
  };
  function mD(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (Object.assign(e, Nj, n), !e.empty && !e.values && !e.size) throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
    if (e.values ? Array.isArray(e.values) && (e.values = d5(e.dataType, e.values)) : e.values = qu(e.dataType, e.size), e.values && (e.size = e.size ?? e.values.length, e.dataType = M8(e.values)), _n(t, e), Zh(t, e, [
      "name",
      "numberOfComponents"
    ]), e.size % e.numberOfComponents !== 0) throw new RangeError("model.size is not a multiple of model.numberOfComponents");
    Vj(t, e);
  }
  const vD = pn(mD, "vtkDataArray");
  var Tt = {
    newInstance: vD,
    extend: mD,
    ...Ij,
    ...gD
  };
  const Lj = {
    MAGNITUDE: 0,
    COMPONENT: 1,
    RGBCOLORS: 2
  }, e6 = {
    LUMINANCE: 1,
    LUMINANCE_ALPHA: 2,
    RGB: 3,
    RGBA: 4
  };
  var R8 = {
    VectorMode: Lj,
    ScalarMappingTarget: e6
  };
  const Uj = {
    DEFAULT: 0,
    MAP_SCALARS: 1,
    DIRECT_SCALARS: 2
  }, Fj = {
    DEFAULT: 0,
    USE_POINT_DATA: 1,
    USE_CELL_DATA: 2,
    USE_POINT_FIELD_DATA: 3,
    USE_CELL_FIELD_DATA: 4,
    USE_FIELD_DATA: 5
  }, Bj = {
    BY_ID: 0,
    BY_NAME: 1
  };
  var m5 = {
    ColorMode: Uj,
    GetArray: Bj,
    ScalarMode: Fj
  };
  const { ScalarMappingTarget: JC, VectorMode: As } = R8, { VtkDataTypes: ol } = Tt, { ColorMode: M2 } = m5, { vtkErrorMacro: $C } = H;
  function _j(t) {
    return t;
  }
  function eT(t) {
    return Math.floor(t * 255 + 0.5);
  }
  function kj(t, e) {
    e.classHierarchy.push("vtkScalarsToColors"), t.setVectorModeToMagnitude = () => t.setVectorMode(As.MAGNITUDE), t.setVectorModeToComponent = () => t.setVectorMode(As.COMPONENT), t.setVectorModeToRGBColors = () => t.setVectorMode(As.RGBCOLORS), t.build = () => {
    }, t.isOpaque = () => true, t.setAnnotations = (n, r) => {
      if (!(n && !r || !n && r)) {
        if (n && r && n.length !== r.length) {
          $C("Values and annotations do not have the same number of tuples so ignoring");
          return;
        }
        if (e.annotationArray = [], r && n) {
          const i = r.length;
          for (let a = 0; a < i; a++) e.annotationArray.push({
            value: n[a],
            annotation: String(r[a])
          });
        }
        t.updateAnnotatedValueMap(), t.modified();
      }
    }, t.setAnnotation = (n, r) => {
      let i = t.checkForAnnotatedValue(n), a = false;
      return i >= 0 ? e.annotationArray[i].annotation !== r && (e.annotationArray[i].annotation = r, a = true) : (e.annotationArray.push({
        value: n,
        annotation: r
      }), i = e.annotationArray.length - 1, a = true), a && (t.updateAnnotatedValueMap(), t.modified()), i;
    }, t.getNumberOfAnnotatedValues = () => e.annotationArray.length, t.getAnnotatedValue = (n) => n < 0 || n >= e.annotationArray.length ? null : e.annotationArray[n].value, t.getAnnotation = (n) => e.annotationArray[n] === void 0 ? null : e.annotationArray[n].annotation, t.getAnnotatedValueIndex = (n) => e.annotationArray.length ? t.checkForAnnotatedValue(n) : -1, t.removeAnnotation = (n) => {
      const r = t.checkForAnnotatedValue(n), i = r >= 0;
      return i && (e.annotationArray.splice(r, 1), t.updateAnnotatedValueMap(), t.modified()), i;
    }, t.resetAnnotations = () => {
      e.annotationArray = [], e.annotatedValueMap = [], t.modified();
    }, t.getAnnotationColor = (n, r) => {
      if (e.indexedLookup) {
        const i = t.getAnnotatedValueIndex(n);
        t.getIndexedColor(i, r);
      } else t.getColor(parseFloat(n), r), r[3] = 1;
    }, t.checkForAnnotatedValue = (n) => t.getAnnotatedValueIndexInternal(n), t.getAnnotatedValueIndexInternal = (n) => {
      if (e.annotatedValueMap[n] !== void 0) {
        const r = e.annotationArray.length;
        return e.annotatedValueMap[n] % r;
      }
      return -1;
    }, t.getIndexedColor = (n, r) => {
      r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0;
    }, t.updateAnnotatedValueMap = () => {
      e.annotatedValueMap = [];
      const n = e.annotationArray.length;
      for (let r = 0; r < n; r++) e.annotatedValueMap[e.annotationArray[r].value] = r;
    }, t.mapScalars = (n, r, i) => {
      const a = n.getNumberOfComponents();
      let s = null;
      if (r === M2.DEFAULT && (n.getDataType() === ol.UNSIGNED_CHAR || n.getDataType() === ol.UNSIGNED_CHAR_CLAMPED) || r === M2.DIRECT_SCALARS && n) s = t.convertToRGBA(n, a, n.getNumberOfTuples());
      else {
        const o = {
          type: "vtkDataArray",
          name: "temp",
          numberOfComponents: 4,
          dataType: ol.UNSIGNED_CHAR
        }, l = H.newTypedArray(o.dataType, 4 * n.getNumberOfTuples());
        o.values = l, o.size = l.length, s = Tt.newInstance(o);
        let c = i;
        c < 0 && a > 1 ? t.mapVectorsThroughTable(n, s, JC.RGBA, -1, -1) : (c < 0 && (c = 0), c >= a && (c = a - 1), t.mapScalarsThroughTable(n, s, JC.RGBA, c));
      }
      return s;
    }, t.mapVectorsToMagnitude = (n, r, i) => {
      const a = n.getNumberOfTuples(), s = n.getNumberOfComponents(), o = r.getData(), l = n.getData();
      for (let c = 0; c < a; c++) {
        let f = 0;
        for (let u = 0; u < i; u++) f += l[c * s + u] * l[c * s + u];
        o[c] = Math.sqrt(f);
      }
    }, t.mapVectorsThroughTable = (n, r, i, a, s) => {
      let o = t.getVectorMode(), l = s, c = a;
      const f = n.getNumberOfComponents();
      o === As.COMPONENT ? (c === -1 && (c = t.getVectorComponent()), c < 0 && (c = 0), c >= f && (c = f - 1)) : (l === -1 && (l = t.getVectorSize()), l <= 0 ? (c = 0, l = f) : (c < 0 && (c = 0), c >= f && (c = f - 1), c + l > f && (l = f - c)), o === As.MAGNITUDE && (f === 1 || l === 1) && (o = As.COMPONENT));
      let u = 0;
      switch (c > 0 && (u = c), o) {
        case As.COMPONENT: {
          t.mapScalarsThroughTable(n, r, i, u);
          break;
        }
        case As.RGBCOLORS:
          break;
        case As.MAGNITUDE:
        default: {
          const h = Tt.newInstance({
            numberOfComponents: 1,
            values: new Float32Array(n.getNumberOfTuples())
          });
          t.mapVectorsToMagnitude(n, h, l), t.mapScalarsThroughTable(h, r, i, 0);
          break;
        }
      }
    }, t.luminanceToRGBA = (n, r, i, a) => {
      const s = a(i), o = r.getData(), l = n.getData(), c = o.length, f = 0, u = 1;
      let h = 0;
      for (let g = f; g < c; g += u) {
        const v = a(o[g]);
        l[h * 4] = v, l[h * 4 + 1] = v, l[h * 4 + 2] = v, l[h * 4 + 3] = s, h++;
      }
    }, t.luminanceAlphaToRGBA = (n, r, i, a) => {
      const s = r.getData(), o = n.getData(), l = s.length, c = 0, f = 2;
      let u = 0;
      for (let h = c; h < l; h += f) {
        const g = a(s[h]);
        o[u] = g, o[u + 1] = g, o[u + 2] = g, o[u + 3] = a(s[h + 1]) * i, u += 4;
      }
    }, t.rGBToRGBA = (n, r, i, a) => {
      const s = eT(i), o = r.getData(), l = n.getData(), c = o.length, f = 0, u = 3;
      let h = 0;
      for (let g = f; g < c; g += u) l[h * 4] = a(o[g]), l[h * 4 + 1] = a(o[g + 1]), l[h * 4 + 2] = a(o[g + 2]), l[h * 4 + 3] = s, h++;
    }, t.rGBAToRGBA = (n, r, i, a) => {
      const s = r.getData(), o = n.getData(), l = s.length, c = 0, f = 4;
      let u = 0;
      for (let h = c; h < l; h += f) o[u * 4] = a(s[h]), o[u * 4 + 1] = a(s[h + 1]), o[u * 4 + 2] = a(s[h + 2]), o[u * 4 + 3] = a(s[h + 3]) * i, u++;
    }, t.convertToRGBA = (n, r, i) => {
      let { alpha: a } = e;
      if (r === 4 && a >= 1 && n.getDataType() === ol.UNSIGNED_CHAR) return n;
      const s = Tt.newInstance({
        numberOfComponents: 4,
        empty: true,
        size: 4 * i,
        dataType: ol.UNSIGNED_CHAR
      });
      if (i <= 0) return s;
      a = a > 0 ? a : 0, a = a < 1 ? a : 1;
      let o = _j;
      switch ((n.getDataType() === ol.FLOAT || n.getDataType() === ol.DOUBLE) && (o = eT), r) {
        case 1:
          t.luminanceToRGBA(s, n, a, o);
          break;
        case 2:
          t.luminanceAlphaToRGBA(s, n, o);
          break;
        case 3:
          t.rGBToRGBA(s, n, a, o);
          break;
        case 4:
          t.rGBAToRGBA(s, n, a, o);
          break;
        default:
          return $C("Cannot convert colors"), null;
      }
      return s;
    }, t.usingLogScale = () => false, t.getNumberOfAvailableColors = () => 256 * 256 * 256, t.setRange = (n, r) => t.setMappingRange(n, r), t.getRange = () => t.getMappingRange(), t.areScalarsOpaque = (n, r, i) => {
      if (!n) return t.isOpaque();
      const a = n.getNumberOfComponents();
      return r === M2.DEFAULT && n.getDataType() === ol.UNSIGNED_CHAR || r === M2.DIRECT_SCALARS ? a === 3 || a === 1 ? e.alpha >= 1 : n.getRange(a - 1)[0] === 255 : true;
    };
  }
  const Pj = {
    alpha: 1,
    vectorComponent: 0,
    vectorSize: -1,
    vectorMode: As.COMPONENT,
    mappingRange: null,
    annotationArray: null,
    annotatedValueMap: null,
    indexedLookup: false
  };
  function yD(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Pj, n), H.obj(t, e), e.mappingRange = [
      0,
      255
    ], e.annotationArray = [], e.annotatedValueMap = [], H.setGet(t, e, [
      "vectorSize",
      "vectorComponent",
      "vectorMode",
      "alpha",
      "indexedLookup"
    ]), H.setArray(t, e, [
      "mappingRange"
    ], 2), H.getArray(t, e, [
      "mappingRange"
    ]), kj(t, e);
  }
  const Gj = H.newInstance(yD, "vtkScalarsToColors");
  var v5 = {
    newInstance: Gj,
    extend: yD,
    ...R8
  };
  const zj = {
    RGB: 0,
    HSV: 1,
    LAB: 2,
    DIVERGING: 3
  }, Wj = {
    LINEAR: 0,
    LOG10: 1
  };
  var xD = {
    ColorSpace: zj,
    Scale: Wj
  };
  const { ColorSpace: Qa, Scale: wD } = xD, { ScalarMappingTarget: R2 } = v5, { vtkDebugMacro: Hj, vtkErrorMacro: to, vtkWarningMacro: jj } = H;
  function tT(t, e) {
    const n = t[0], r = t[1], i = t[2], a = Math.sqrt(n * n + r * r + i * i), s = a > 1e-3 ? Math.acos(n / a) : 0, o = s > 1e-3 ? Math.atan2(i, r) : 0;
    e[0] = a, e[1] = s, e[2] = o;
  }
  function Kj(t, e) {
    const n = t[0], r = t[1], i = t[2];
    e[0] = n * Math.cos(r), e[1] = n * Math.sin(r) * Math.cos(i), e[2] = n * Math.sin(r) * Math.sin(i);
  }
  function nT(t, e) {
    if (t[0] >= e - 0.1) return t[2];
    const n = t[1] * Math.sqrt(e * e - t[0] * t[0]) / (t[0] * Math.sin(t[1]));
    return t[2] > -0.3 * Math.PI ? t[2] + n : t[2] - n;
  }
  function Yj(t, e) {
    let n = t - e;
    for (n < 0 && (n = -n); n >= 2 * Math.PI; ) n -= 2 * Math.PI;
    return n > Math.PI && (n = 2 * Math.PI - n), n;
  }
  function rT(t, e, n, r) {
    const i = [], a = [];
    Vc(e, i), Vc(n, a);
    const s = [], o = [];
    tT(i, s), tT(a, o);
    let l = t;
    if (s[1] > 0.05 && o[1] > 0.05 && Yj(s[2], o[2]) > 0.33 * Math.PI) {
      let u = Math.max(s[0], o[0]);
      u = Math.max(88, u), t < 0.5 ? (o[0] = u, o[1] = 0, o[2] = 0, l *= 2) : (s[0] = u, s[1] = 0, s[2] = 0, l = 2 * l - 1);
    }
    s[1] < 0.05 && o[1] > 0.05 ? s[2] = nT(o, s[0]) : o[1] < 0.05 && s[1] > 0.05 && (o[2] = nT(s, o[0]));
    const c = [];
    c[0] = (1 - l) * s[0] + l * o[0], c[1] = (1 - l) * s[1] + l * o[1], c[2] = (1 - l) * s[2] + l * o[2];
    const f = [];
    Kj(c, f), cp(f, r);
  }
  function qj(t, e) {
    e.classHierarchy.push("vtkColorTransferFunction"), t.getSize = () => e.nodes.length, t.addRGBPoint = (n, r, i, a) => t.addRGBPointLong(n, r, i, a, 0.5, 0), t.addRGBPointLong = function(n, r, i, a) {
      let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5, o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
      if (s < 0 || s > 1) return to("Midpoint outside range [0.0, 1.0]"), -1;
      if (o < 0 || o > 1) return to("Sharpness outside range [0.0, 1.0]"), -1;
      e.allowDuplicateScalars || t.removePoint(n);
      const l = {
        x: n,
        r,
        g: i,
        b: a,
        midpoint: s,
        sharpness: o
      };
      e.nodes.push(l), t.sortAndUpdateRange();
      let c = 0;
      for (; c < e.nodes.length && e.nodes[c].x !== n; c++) ;
      return c < e.nodes.length ? c : -1;
    }, t.addHSVPoint = (n, r, i, a) => t.addHSVPointLong(n, r, i, a, 0.5, 0), t.addHSVPointLong = function(n, r, i, a) {
      let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5, o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
      const l = [];
      return Dc([
        r,
        i,
        a
      ], l), t.addRGBPoint(n, l[0], l[1], l[2], s, o);
    }, t.setNodes = (n) => {
      if (e.nodes !== n) {
        const r = JSON.stringify(e.nodes);
        e.nodes = n;
        const i = JSON.stringify(e.nodes);
        if (t.sortAndUpdateRange() || r !== i) return t.modified(), true;
      }
      return false;
    }, t.sortAndUpdateRange = () => {
      const n = JSON.stringify(e.nodes);
      e.nodes.sort((a, s) => a.x - s.x);
      const r = JSON.stringify(e.nodes), i = t.updateRange();
      return !i && n !== r ? (t.modified(), true) : i;
    }, t.updateRange = () => {
      const n = [
        2
      ];
      n[0] = e.mappingRange[0], n[1] = e.mappingRange[1];
      const r = e.nodes.length;
      return r ? (e.mappingRange[0] = e.nodes[0].x, e.mappingRange[1] = e.nodes[r - 1].x) : (e.mappingRange[0] = 0, e.mappingRange[1] = 0), n[0] === e.mappingRange[0] && n[1] === e.mappingRange[1] ? false : (t.modified(), true);
    }, t.removePoint = (n) => {
      let r = 0;
      for (; r < e.nodes.length && e.nodes[r].x !== n; r++) ;
      const i = r;
      if (r >= e.nodes.length) return -1;
      let a = false;
      return e.nodes.splice(r, 1), (r === 0 || r === e.nodes.length) && (a = t.updateRange()), a || t.modified(), i;
    }, t.movePoint = (n, r) => {
      if (n !== r) {
        t.removePoint(r);
        for (let i = 0; i < e.nodes.length; i++) if (e.nodes[i].x === n) {
          e.nodes[i].x = r, t.sortAndUpdateRange();
          break;
        }
      }
    }, t.removeAllPoints = () => {
      e.nodes = [], t.sortAndUpdateRange();
    }, t.addRGBSegment = (n, r, i, a, s, o, l, c) => {
      t.sortAndUpdateRange();
      for (let f = 0; f < e.nodes.length; ) e.nodes[f].x >= n && e.nodes[f].x <= s ? e.nodes.splice(f, 1) : f++;
      t.addRGBPointLong(n, r, i, a, 0.5, 0), t.addRGBPointLong(s, o, l, c, 0.5, 0), t.modified();
    }, t.addHSVSegment = (n, r, i, a, s, o, l, c) => {
      const f = [
        r,
        i,
        a
      ], u = [
        o,
        l,
        c
      ], h = [], g = [];
      Dc(f, h), Dc(u, g), t.addRGBSegment(n, h[0], h[1], h[2], s, g[0], g[1], g[2]);
    }, t.mapValue = (n) => {
      const r = [];
      return t.getColor(n, r), [
        Math.floor(255 * r[0] + 0.5),
        Math.floor(255 * r[1] + 0.5),
        Math.floor(255 * r[2] + 0.5),
        255
      ];
    }, t.getColor = (n, r) => {
      if (e.indexedLookup) {
        const i = t.getSize(), a = t.getAnnotatedValueIndexInternal(n);
        if (a < 0 || i === 0) {
          const s = t.getNanColorByReference();
          r[0] = s[0], r[1] = s[1], r[2] = s[2];
        } else {
          const s = [];
          t.getNodeValue(a % i, s), r[0] = s[1], r[1] = s[2], r[2] = s[3];
        }
        return;
      }
      t.getTable(n, n, 1, r);
    }, t.getRedValue = (n) => {
      const r = [];
      return t.getColor(n, r), r[0];
    }, t.getGreenValue = (n) => {
      const r = [];
      return t.getColor(n, r), r[1];
    }, t.getBlueValue = (n) => {
      const r = [];
      return t.getColor(n, r), r[2];
    }, t.getTable = (n, r, i, a) => {
      const s = Number(n), o = Number(r);
      if (up(s) || up(o)) {
        for (let I = 0; I < i; I++) a[I * 3 + 0] = e.nanColor[0], a[I * 3 + 1] = e.nanColor[1], a[I * 3 + 2] = e.nanColor[2];
        return;
      }
      let l = 0;
      const c = e.nodes.length;
      let f = 0, u = 0, h = 0;
      c !== 0 && (f = e.nodes[c - 1].r, u = e.nodes[c - 1].g, h = e.nodes[c - 1].b);
      let g = 0, v = 0, m = 0;
      const y = [
        0,
        0,
        0
      ], w = [
        0,
        0,
        0
      ];
      let C = 0, T = 0;
      const S = [];
      let E = e.scale === wD.LOG10;
      E && (E = e.mappingRange[0] > 0);
      let b = 0, D = 0, R = 0;
      E && (b = Math.log10(s), D = Math.log10(o));
      for (let I = 0; I < i; I++) {
        const O = 3 * I;
        if (i > 1 ? E ? (R = b + I / (i - 1) * (D - b), g = 10 ** R) : g = s + I / (i - 1) * (o - s) : E ? (R = 0.5 * (b + D), g = 10 ** R) : g = 0.5 * (s + o), e.discretize) {
          const L = e.mappingRange;
          if (g >= L[0] && g <= L[1]) {
            const N = e.numberOfValues, F = L[1] - L[0];
            if (N <= 1) g = L[0] + F / 2;
            else {
              const V = (g - L[0]) / F, k = E8(N * V);
              g = L[0] + k / (N - 1) * F;
            }
          }
        }
        for (; l < c && g > e.nodes[l].x; ) l++, l < c && (v = e.nodes[l - 1].x, m = e.nodes[l].x, E && (v = Math.log10(v), m = Math.log10(m)), y[0] = e.nodes[l - 1].r, w[0] = e.nodes[l].r, y[1] = e.nodes[l - 1].g, w[1] = e.nodes[l].g, y[2] = e.nodes[l - 1].b, w[2] = e.nodes[l].b, C = e.nodes[l - 1].midpoint, T = e.nodes[l - 1].sharpness, C < 1e-5 && (C = 1e-5), C > 0.99999 && (C = 0.99999));
        if (g > e.mappingRange[1]) a[O] = 0, a[O + 1] = 0, a[O + 2] = 0, e.clamping && (t.getUseAboveRangeColor() ? (a[O] = e.aboveRangeColor[0], a[O + 1] = e.aboveRangeColor[1], a[O + 2] = e.aboveRangeColor[2]) : (a[O] = f, a[O + 1] = u, a[O + 2] = h));
        else if (g < e.mappingRange[0] || fD(g) && g < 0) a[O] = 0, a[O + 1] = 0, a[O + 2] = 0, e.clamping && (t.getUseBelowRangeColor() ? (a[O] = e.belowRangeColor[0], a[O + 1] = e.belowRangeColor[1], a[O + 2] = e.belowRangeColor[2]) : c > 0 && (a[O] = e.nodes[0].r, a[O + 1] = e.nodes[0].g, a[O + 2] = e.nodes[0].b));
        else if (l === 0 && (Math.abs(g - s) < 1e-6 || e.discretize)) c > 0 ? (a[O] = e.nodes[0].r, a[O + 1] = e.nodes[0].g, a[O + 2] = e.nodes[0].b) : (a[O] = 0, a[O + 1] = 0, a[O + 2] = 0);
        else {
          let L = 0;
          if (E ? L = (R - v) / (m - v) : L = (g - v) / (m - v), L < C ? L = 0.5 * L / C : L = 0.5 + 0.5 * (L - C) / (1 - C), T > 0.99) if (L < 0.5) {
            a[O] = y[0], a[O + 1] = y[1], a[O + 2] = y[2];
            continue;
          } else {
            a[O] = w[0], a[O + 1] = w[1], a[O + 2] = w[2];
            continue;
          }
          if (T < 0.01) {
            if (e.colorSpace === Qa.RGB) a[O] = (1 - L) * y[0] + L * w[0], a[O + 1] = (1 - L) * y[1] + L * w[1], a[O + 2] = (1 - L) * y[2] + L * w[2];
            else if (e.colorSpace === Qa.HSV) {
              const B = [], Y = [];
              W1(y, B), W1(w, Y), e.hSVWrap && (B[0] - Y[0] > 0.5 || Y[0] - B[0] > 0.5) && (B[0] > Y[0] ? B[0] -= 1 : Y[0] -= 1);
              const X = [];
              X[0] = (1 - L) * B[0] + L * Y[0], X[0] < 0 && (X[0] += 1), X[1] = (1 - L) * B[1] + L * Y[1], X[2] = (1 - L) * B[2] + L * Y[2], Dc(X, S), a[O] = S[0], a[O + 1] = S[1], a[O + 2] = S[2];
            } else if (e.colorSpace === Qa.LAB) {
              const B = [], Y = [];
              Vc(y, B), Vc(w, Y);
              const X = [];
              X[0] = (1 - L) * B[0] + L * Y[0], X[1] = (1 - L) * B[1] + L * Y[1], X[2] = (1 - L) * B[2] + L * Y[2], cp(X, S), a[O] = S[0], a[O + 1] = S[1], a[O + 2] = S[2];
            } else e.colorSpace === Qa.DIVERGING ? (rT(L, y, w, S), a[O] = S[0], a[O + 1] = S[1], a[O + 2] = S[2]) : to("ColorSpace set to invalid value.", e.colorSpace);
            continue;
          }
          L < 0.5 ? L = 0.5 * (L * 2) ** (1 + 10 * T) : L > 0.5 && (L = 1 - 0.5 * ((1 - L) * 2) ** (1 + 10 * T));
          const N = L * L, F = N * L, V = 2 * F - 3 * N + 1, k = -2 * F + 3 * N, _ = F - 2 * N + L, K = F - N;
          let Z, j;
          if (e.colorSpace === Qa.RGB) for (let B = 0; B < 3; B++) Z = w[B] - y[B], j = (1 - T) * Z, a[O + B] = V * y[B] + k * w[B] + _ * j + K * j;
          else if (e.colorSpace === Qa.HSV) {
            const B = [], Y = [];
            W1(y, B), W1(w, Y), e.hSVWrap && (B[0] - Y[0] > 0.5 || Y[0] - B[0] > 0.5) && (B[0] > Y[0] ? B[0] -= 1 : Y[0] -= 1);
            const X = [];
            for (let ie = 0; ie < 3; ie++) Z = Y[ie] - B[ie], j = (1 - T) * Z, X[ie] = V * B[ie] + k * Y[ie] + _ * j + K * j, ie === 0 && X[ie] < 0 && (X[ie] += 1);
            Dc(X, S), a[O] = S[0], a[O + 1] = S[1], a[O + 2] = S[2];
          } else if (e.colorSpace === Qa.LAB) {
            const B = [], Y = [];
            Vc(y, B), Vc(w, Y);
            const X = [];
            for (let ie = 0; ie < 3; ie++) Z = Y[ie] - B[ie], j = (1 - T) * Z, X[ie] = V * B[ie] + k * Y[ie] + _ * j + K * j;
            cp(X, S), a[O] = S[0], a[O + 1] = S[1], a[O + 2] = S[2];
          } else e.colorSpace === Qa.DIVERGING ? (rT(L, y, w, S), a[O] = S[0], a[O + 1] = S[1], a[O + 2] = S[2]) : to("ColorSpace set to invalid value.");
          for (let B = 0; B < 3; B++) a[O + B] = a[O + B] < 0 ? 0 : a[O + B], a[O + B] = a[O + B] > 1 ? 1 : a[O + B];
        }
      }
    }, t.getUint8Table = function(n, r, i) {
      let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (t.getMTime() <= e.buildTime && e.tableSize === i && e.tableWithAlpha !== a) return e.table;
      if (e.nodes.length === 0) return to("Attempting to lookup a value with no points in the function"), e.table;
      const s = a ? 4 : 3;
      (e.tableSize !== i || e.tableWithAlpha !== a) && (e.table = new Uint8Array(i * s), e.tableSize = i, e.tableWithAlpha = a);
      const o = [];
      t.getTable(n, r, i, o);
      for (let l = 0; l < i; l++) e.table[l * s + 0] = Math.floor(o[l * 3 + 0] * 255 + 0.5), e.table[l * s + 1] = Math.floor(o[l * 3 + 1] * 255 + 0.5), e.table[l * s + 2] = Math.floor(o[l * 3 + 2] * 255 + 0.5), a && (e.table[l * s + 3] = 255);
      return e.buildTime.modified(), e.table;
    }, t.buildFunctionFromArray = (n) => {
      t.removeAllPoints();
      const r = n.getNumberOfComponents();
      for (let i = 0; i < n.getNumberOfTuples(); i++) switch (r) {
        case 3: {
          e.nodes.push({
            x: i,
            r: n.getComponent(i, 0),
            g: n.getComponent(i, 1),
            b: n.getComponent(i, 2),
            midpoint: 0.5,
            sharpness: 0
          });
          break;
        }
        case 4: {
          e.nodes.push({
            x: n.getComponent(i, 0),
            r: n.getComponent(i, 1),
            g: n.getComponent(i, 2),
            b: n.getComponent(i, 3),
            midpoint: 0.5,
            sharpness: 0
          });
          break;
        }
        case 5: {
          e.nodes.push({
            x: i,
            r: n.getComponent(i, 0),
            g: n.getComponent(i, 1),
            b: n.getComponent(i, 2),
            midpoint: n.getComponent(i, 4),
            sharpness: n.getComponent(i, 5)
          });
          break;
        }
        case 6: {
          e.nodes.push({
            x: n.getComponent(i, 0),
            r: n.getComponent(i, 1),
            g: n.getComponent(i, 2),
            b: n.getComponent(i, 3),
            midpoint: n.getComponent(i, 4),
            sharpness: n.getComponent(i, 5)
          });
          break;
        }
      }
      t.sortAndUpdateRange();
    }, t.buildFunctionFromTable = (n, r, i, a) => {
      let s = 0;
      t.removeAllPoints(), i > 1 && (s = (r - n) / (i - 1));
      for (let o = 0; o < i; o++) {
        const l = {
          x: n + s * o,
          r: a[o * 3],
          g: a[o * 3 + 1],
          b: a[o * 3 + 2],
          sharpness: 0,
          midpoint: 0.5
        };
        e.nodes.push(l);
      }
      t.sortAndUpdateRange();
    }, t.getNodeValue = (n, r) => n < 0 || n >= e.nodes.length ? (to("Index out of range!"), -1) : (r[0] = e.nodes[n].x, r[1] = e.nodes[n].r, r[2] = e.nodes[n].g, r[3] = e.nodes[n].b, r[4] = e.nodes[n].midpoint, r[5] = e.nodes[n].sharpness, 1), t.setNodeValue = (n, r) => {
      if (n < 0 || n >= e.nodes.length) return to("Index out of range!"), -1;
      const i = e.nodes[n].x;
      return e.nodes[n].x = r[0], e.nodes[n].r = r[1], e.nodes[n].g = r[2], e.nodes[n].b = r[3], e.nodes[n].midpoint = r[4], e.nodes[n].sharpness = r[5], i !== r[0] ? t.sortAndUpdateRange() : t.modified(), 1;
    }, t.getNumberOfAvailableColors = () => e.indexedLookup && t.getSize() ? t.getSize() : e.tableSize ? e.tableSize : 16777216, t.getIndexedColor = (n, r) => {
      const i = t.getSize();
      if (i > 0 && n >= 0) {
        const s = [];
        t.getNodeValue(n % i, s);
        for (let o = 0; o < 3; ++o) r[o] = s[o + 1];
        r[3] = 1;
        return;
      }
      const a = t.getNanColorByReference();
      r[0] = a[0], r[1] = a[1], r[2] = a[2], r[3] = 1;
    }, t.fillFromDataPointer = (n, r) => {
      if (!(n <= 0 || !r)) {
        t.removeAllPoints();
        for (let i = 0; i < n; i++) t.addRGBPoint(r[i * 4], r[i * 4 + 1], r[i * 4 + 2], r[i * 4 + 3]);
      }
    }, t.setMappingRange = (n, r) => {
      const i = [
        n,
        r
      ], a = t.getRange();
      if (a[1] === i[1] && a[0] === i[0]) return;
      if (i[1] === i[0]) {
        to("attempt to set zero width color range");
        return;
      }
      const s = (i[1] - i[0]) / (a[1] - a[0]), o = i[0] - a[0] * s;
      for (let l = 0; l < e.nodes.length; ++l) e.nodes[l].x = e.nodes[l].x * s + o;
      e.mappingRange[0] = i[0], e.mappingRange[1] = i[1], t.modified();
    }, t.adjustRange = (n) => {
      const r = t.getRange(), i = [];
      r[0] < n[0] ? (t.getColor(n[0], i), t.addRGBPoint(n[0], i[0], i[1], i[2])) : (t.getColor(r[0], i), t.addRGBPoint(n[0], i[0], i[1], i[2])), r[1] > n[1] ? (t.getColor(n[1], i), t.addRGBPoint(n[1], i[0], i[1], i[2])) : (t.getColor(r[1], i), t.addRGBPoint(n[1], i[0], i[1], i[2])), t.sortAndUpdateRange();
      for (let a = 0; a < e.nodes.length; ) e.nodes[a].x >= n[0] && e.nodes[a].x <= n[1] ? e.nodes.splice(a, 1) : ++a;
      return 1;
    }, t.estimateMinNumberOfSamples = (n, r) => {
      const i = t.findMinimumXDistance();
      return Math.ceil((r - n) / i);
    }, t.findMinimumXDistance = () => {
      if (e.nodes.length < 2) return -1;
      let n = Number.MAX_VALUE;
      for (let r = 0; r < e.nodes.length - 1; r++) {
        const i = e.nodes[r + 1].x - e.nodes[r].x;
        i < n && (n = i);
      }
      return n;
    }, t.mapScalarsThroughTable = (n, r, i, a) => {
      if (t.getSize() === 0) {
        Hj("Transfer Function Has No Points!");
        return;
      }
      e.indexedLookup ? t.mapDataIndexed(n, r, i, a) : t.mapData(n, r, i, a);
    }, t.mapData = (n, r, i, a) => {
      if (t.getSize() === 0) {
        jj("Transfer Function Has No Points!");
        return;
      }
      const s = Math.floor(t.getAlpha() * 255 + 0.5), o = n.getNumberOfTuples(), l = n.getNumberOfComponents(), c = r.getData(), f = n.getData(), u = [];
      if (i === R2.RGBA) for (let h = 0; h < o; h++) {
        const g = f[h * l + a];
        t.getColor(g, u), c[h * 4] = Math.floor(u[0] * 255 + 0.5), c[h * 4 + 1] = Math.floor(u[1] * 255 + 0.5), c[h * 4 + 2] = Math.floor(u[2] * 255 + 0.5), c[h * 4 + 3] = s;
      }
      if (i === R2.RGB) for (let h = 0; h < o; h++) {
        const g = f[h * l + a];
        t.getColor(g, u), c[h * 3] = Math.floor(u[0] * 255 + 0.5), c[h * 3 + 1] = Math.floor(u[1] * 255 + 0.5), c[h * 3 + 2] = Math.floor(u[2] * 255 + 0.5);
      }
      if (i === R2.LUMINANCE) for (let h = 0; h < o; h++) {
        const g = f[h * l + a];
        t.getColor(g, u), c[h] = Math.floor(u[0] * 76.5 + u[1] * 150.45 + u[2] * 28.05 + 0.5);
      }
      if (i === R2.LUMINANCE_ALPHA) for (let h = 0; h < o; h++) {
        const g = f[h * l + a];
        t.getColor(g, u), c[h * 2] = Math.floor(u[0] * 76.5 + u[1] * 150.45 + u[2] * 28.05 + 0.5), c[h * 2 + 1] = s;
      }
    }, t.applyColorMap = (n) => {
      const r = JSON.stringify(e.colorSpace);
      n.ColorSpace && (e.colorSpace = Qa[n.ColorSpace.toUpperCase()], e.colorSpace === void 0 && (to(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`), e.colorSpace = Qa.RGB));
      let i = r !== JSON.stringify(e.colorSpace);
      const a = i || JSON.stringify(e.nanColor);
      if (n.NanColor) for (e.nanColor = [].concat(n.NanColor); e.nanColor.length < 4; ) e.nanColor.push(1);
      i = i || a !== JSON.stringify(e.nanColor);
      const s = i || JSON.stringify(e.nodes);
      if (n.RGBPoints) {
        const c = n.RGBPoints.length;
        e.nodes = [];
        const f = 0.5, u = 0;
        for (let h = 0; h < c; h += 4) e.nodes.push({
          x: n.RGBPoints[h],
          r: n.RGBPoints[h + 1],
          g: n.RGBPoints[h + 2],
          b: n.RGBPoints[h + 3],
          midpoint: f,
          sharpness: u
        });
      }
      const o = t.sortAndUpdateRange(), l = !o && (i || s !== JSON.stringify(e.nodes));
      return l && t.modified(), o || l;
    };
  }
  const Xj = {
    clamping: true,
    colorSpace: Qa.RGB,
    hSVWrap: true,
    scale: wD.LINEAR,
    nanColor: null,
    belowRangeColor: null,
    aboveRangeColor: null,
    useAboveRangeColor: false,
    useBelowRangeColor: false,
    allowDuplicateScalars: false,
    table: null,
    tableSize: 0,
    buildTime: null,
    nodes: null,
    discretize: false,
    numberOfValues: 256
  };
  function CD(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Xj, n), v5.extend(t, e, n), e.table = [], e.nodes = [], e.nanColor = [
      0.5,
      0,
      0,
      1
    ], e.belowRangeColor = [
      0,
      0,
      0,
      1
    ], e.aboveRangeColor = [
      1,
      1,
      1,
      1
    ], e.buildTime = {}, H.obj(e.buildTime), H.get(t, e, [
      "buildTime",
      "mappingRange"
    ]), H.setGet(t, e, [
      "useAboveRangeColor",
      "useBelowRangeColor",
      "colorSpace",
      "discretize",
      "numberOfValues"
    ]), H.setArray(t, e, [
      "nanColor",
      "belowRangeColor",
      "aboveRangeColor"
    ], 4), H.getArray(t, e, [
      "nanColor",
      "belowRangeColor",
      "aboveRangeColor"
    ]), qj(t, e);
  }
  const Zj = H.newInstance(CD, "vtkColorTransferFunction");
  var Ul = {
    newInstance: Zj,
    extend: CD,
    ...xD
  };
  function O8(t, e) {
    const n = Math.abs(e - t) + 1, r = (t + e + 1) / 2;
    return {
      windowWidth: n,
      windowCenter: r
    };
  }
  function lh(t, e) {
    const n = e - 0.5 - (t - 1) / 2, r = e - 0.5 + (t - 1) / 2;
    return {
      lower: n,
      upper: r
    };
  }
  const Qj = Object.freeze(Object.defineProperty({
    __proto__: null,
    toLowHighRange: lh,
    toWindowLevel: O8
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function I8(t, e = 1024) {
    const { windowWidth: n, windowCenter: r } = O8(t.lower, t.upper), i = (l, c, f) => c - f / 4 * Math.log((1 - l) / l), s = [
      ...Array(e + 2).keys()
    ].map((l) => l / (e + 2)).slice(1, -1).reduce((l, c) => {
      const f = i(c, r, n);
      return l.concat(f, c, c, c, 0.5, 0);
    }, []), o = Ul.newInstance();
    return o.buildFunctionFromArray(Tt.newInstance({
      values: s,
      numberOfComponents: 6
    })), o;
  }
  function TD(t) {
    let e = [];
    const [n, r] = t.getRange();
    t.getTable(n, r, 1024, e), e = e.filter((g, v) => v % 3 === 0);
    const i = [
      ...Array(1024).keys()
    ].map((g, v) => n + (r - n) / 1023 * v), a = e[256], s = Math.log((1 - a) / a), o = i[256], l = e[256 * 3], c = Math.log((1 - l) / l), f = i[256 * 3], u = Math.round(4 * (f - o) / (s - c)), h = Math.round(o + u * s / 4);
    return [
      Math.round(h - u / 2),
      Math.round(h + u / 2)
    ];
  }
  function SD(t) {
    const e = Ul.newInstance();
    let n = 0, r = 1024;
    return t && t.lower !== void 0 && t.upper !== void 0 && (n = t.lower, r = t.upper), e.addRGBPoint(n, 0, 0, 0), e.addRGBPoint(r, 1, 1, 1), e;
  }
  function Jj(t, e) {
    const n = t.getSize();
    for (let r = 0; r < n; r++) {
      const i = [];
      t.getNodeValue(r, i), i[1] = i[1] * e, i[2] = i[2] * e, i[3] = i[3] * e, t.setNodeValue(r, i);
    }
  }
  function qe(t = je, e, n = null) {
    if (!e) throw new Error("Event type was not defined");
    const r = new CustomEvent(e, {
      detail: n,
      cancelable: true
    });
    return t.dispatchEvent(r);
  }
  function gi() {
    var _a3;
    return ((_a3 = crypto.randomUUID) == null ? void 0 : _a3.call(crypto)) || ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (t) => (t ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16));
  }
  function V8(t) {
    let e = t[0], n = t[0], r;
    const i = t.length;
    for (let a = 1; a < i; a++) r = t[a], e = Math.min(e, r), n = Math.max(n, r);
    return {
      min: e,
      max: n
    };
  }
  const $j = Symbol("LastRuntimeId"), eK = {}, tK = 4294967295, nK = "-";
  function AD(t, e, n) {
    return rK(t !== null && typeof t == "object" ? t : eK, $j, (typeof n == "number" && n > 0 ? n : tK) >>> 0).join(typeof e == "string" ? e : nK);
  }
  function rK(t, e, n) {
    let r = t[e];
    r instanceof Array || (r = [
      0
    ], Object.defineProperty(t, e, {
      value: r
    }));
    for (let i = true, a = 0; i && a < r.length; ++a) {
      let s = r[a] | 0;
      s < n ? (i = false, s = s + 1) : (s = 0, a + 1 === r.length && r.push(0)), r[a] = s;
    }
    return r;
  }
  function va(t) {
    const e = t.indexOf(":");
    return t.substring(e + 1);
  }
  const iT = {}, iK = {
    add: (t, e) => {
      const n = va(t);
      iT[n] = e;
    },
    get: (t, e) => {
      if (t === "calibratedPixelSpacing") {
        const n = va(e);
        return iT[n];
      }
    }
  };
  function t6(t, e, n) {
    return Math.max(e, Math.min(n, t));
  }
  function ED(t, e, n) {
    return Math.abs(t - e) <= n;
  }
  function aK(t, e, n = 1e-5) {
    if (t.length !== e.length) return false;
    for (let r = 0; r < t.length; r++) if (!ED(t[r], e[r], n)) return false;
    return true;
  }
  function aT(t) {
    return typeof t == "number";
  }
  function sT(t) {
    return "length" in t && typeof t[0] == "number";
  }
  function zr(t, e, n = 1e-5) {
    return typeof t != typeof e || t === null || e === null ? false : aT(t) && aT(e) ? ED(t, e, n) : sT(t) && sT(e) ? aK(t, e, n) : false;
  }
  const bD = (t) => typeof t == "number" ? -t : (t == null ? void 0 : t.map) ? t.map(bD) : !t, n6 = (t) => typeof t == "number" ? Math.abs(t) : (t == null ? void 0 : t.map) ? t.map(n6) : t, DD = (t, e, n = void 0) => zr(t, bD(e), n), sK = (t, e, n = void 0) => zr(n6(t), n6(e), n);
  function oK(t, e, n = 1e-5) {
    return Math.abs(t[0] + e[0]) < n && Math.abs(t[1] + e[1]) < n && Math.abs(t[2] + e[2]) < n;
  }
  function O4(t, e, n, r) {
    return new (n || (n = Promise))((function(i, a) {
      function s(c) {
        try {
          l(r.next(c));
        } catch (f) {
          a(f);
        }
      }
      function o(c) {
        try {
          l(r.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        var f;
        c.done ? i(c.value) : (f = c.value, f instanceof n ? f : new n((function(u) {
          u(f);
        }))).then(s, o);
      }
      l((r = r.apply(t, [])).next());
    }));
  }
  const lK = [
    "geforce 320m",
    "geforce 8600",
    "geforce 8600m gt",
    "geforce 8800 gs",
    "geforce 8800 gt",
    "geforce 9400",
    "geforce 9400m g",
    "geforce 9400m",
    "geforce 9600m gt",
    "geforce 9600m",
    "geforce fx go5200",
    "geforce gt 120",
    "geforce gt 130",
    "geforce gt 330m",
    "geforce gtx 285",
    "google swiftshader",
    "intel g41",
    "intel g45",
    "intel gma 4500mhd",
    "intel gma x3100",
    "intel hd 3000",
    "intel q45",
    "legacy",
    "mali-2",
    "mali-3",
    "mali-4",
    "quadro fx 1500",
    "quadro fx 4",
    "quadro fx 5",
    "radeon hd 2400",
    "radeon hd 2600",
    "radeon hd 4670",
    "radeon hd 4850",
    "radeon hd 4870",
    "radeon hd 5670",
    "radeon hd 5750",
    "radeon hd 6290",
    "radeon hd 6300",
    "radeon hd 6310",
    "radeon hd 6320",
    "radeon hd 6490m",
    "radeon hd 6630m",
    "radeon hd 6750m",
    "radeon hd 6770m",
    "radeon hd 6970m",
    "sgx 543",
    "sgx543"
  ];
  function oT(t) {
    return t = t.toLowerCase().replace(/.*angle ?\((.+)\)(?: on vulkan [0-9.]+)?$/i, "$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, "").replace(/(?:vulkan|opengl) \d+\.\d+(?:\.\d+)?(?: \((.*)\))?/, "$1");
  }
  const MD = typeof window > "u", Es = (() => {
    if (MD) return;
    const { userAgent: t, platform: e, maxTouchPoints: n } = window.navigator, r = /(iphone|ipod|ipad)/i.test(t), i = e === "iPad" || e === "MacIntel" && n > 0 && !window.MSStream;
    return {
      isIpad: i,
      isMobile: /android/i.test(t) || r || i,
      isSafari12: /Version\/12.+Safari/.test(t),
      isFirefox: /Firefox/.test(t)
    };
  })();
  function cK(t, e, n) {
    if (!n) return [
      e
    ];
    const r = (function(c) {
      const f = `
    precision highp float;
    attribute vec3 aPosition;
    varying float vvv;
    void main() {
      vvv = 0.31622776601683794;
      gl_Position = vec4(aPosition, 1.0);
    }
  `, u = `
    precision highp float;
    varying float vvv;
    void main() {
      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;
      enc = fract(enc);
      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
      gl_FragColor = enc;
    }
  `, h = c.createShader(35633), g = c.createShader(35632), v = c.createProgram();
      if (!(g && h && v)) return;
      c.shaderSource(h, f), c.shaderSource(g, u), c.compileShader(h), c.compileShader(g), c.attachShader(v, h), c.attachShader(v, g), c.linkProgram(v), c.detachShader(v, h), c.detachShader(v, g), c.deleteShader(h), c.deleteShader(g), c.useProgram(v);
      const m = c.createBuffer();
      c.bindBuffer(34962, m), c.bufferData(34962, new Float32Array([
        -1,
        -1,
        0,
        3,
        -1,
        0,
        -1,
        3,
        0
      ]), 35044);
      const y = c.getAttribLocation(v, "aPosition");
      c.vertexAttribPointer(y, 3, 5126, false, 0, 0), c.enableVertexAttribArray(y), c.clearColor(1, 1, 1, 1), c.clear(16384), c.viewport(0, 0, 1, 1), c.drawArrays(4, 0, 3);
      const w = new Uint8Array(4);
      return c.readPixels(0, 0, 1, 1, 6408, 5121, w), c.deleteProgram(v), c.deleteBuffer(m), w.join("");
    })(t), i = "801621810", a = "8016218135", s = "80162181161", o = (Es == null ? void 0 : Es.isIpad) ? [
      [
        "a7",
        s,
        12
      ],
      [
        "a8",
        a,
        15
      ],
      [
        "a8x",
        a,
        15
      ],
      [
        "a9",
        a,
        15
      ],
      [
        "a9x",
        a,
        15
      ],
      [
        "a10",
        a,
        15
      ],
      [
        "a10x",
        a,
        15
      ],
      [
        "a12",
        i,
        15
      ],
      [
        "a12x",
        i,
        15
      ],
      [
        "a12z",
        i,
        15
      ],
      [
        "a14",
        i,
        15
      ],
      [
        "a15",
        i,
        15
      ],
      [
        "m1",
        i,
        15
      ],
      [
        "m2",
        i,
        15
      ]
    ] : [
      [
        "a7",
        s,
        12
      ],
      [
        "a8",
        a,
        12
      ],
      [
        "a9",
        a,
        15
      ],
      [
        "a10",
        a,
        15
      ],
      [
        "a11",
        i,
        15
      ],
      [
        "a12",
        i,
        15
      ],
      [
        "a13",
        i,
        15
      ],
      [
        "a14",
        i,
        15
      ],
      [
        "a15",
        i,
        15
      ],
      [
        "a16",
        i,
        15
      ],
      [
        "a17",
        i,
        15
      ]
    ];
    let l;
    return r === "80162181255" ? l = o.filter((([, , c]) => c >= 14)) : (l = o.filter((([, c]) => c === r)), l.length || (l = o)), l.map((([c]) => `apple ${c} gpu`));
  }
  class lT extends Error {
    constructor(e) {
      super(e), Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  const I4 = [], cT = [];
  function uK(t, e) {
    if (t === e) return 0;
    const n = t;
    t.length > e.length && (t = e, e = n);
    let r = t.length, i = e.length;
    for (; r > 0 && t.charCodeAt(~-r) === e.charCodeAt(~-i); ) r--, i--;
    let a, s = 0;
    for (; s < r && t.charCodeAt(s) === e.charCodeAt(s); ) s++;
    if (r -= s, i -= s, r === 0) return i;
    let o, l, c = 0, f = 0, u = 0;
    for (; f < r; ) cT[f] = t.charCodeAt(s + f), I4[f] = ++f;
    for (; u < i; ) for (a = e.charCodeAt(s + u), o = u++, c = u, f = 0; f < r; f++) l = a === cT[f] ? o : o + 1, o = I4[f], c = I4[f] = o > c ? l > c ? c + 1 : l : l > o ? o + 1 : l;
    return c;
  }
  function fK(t) {
    return t != null;
  }
  const hK = ({ mobileTiers: t = [
    0,
    15,
    30,
    60
  ], desktopTiers: e = [
    0,
    15,
    30,
    60
  ], override: n = {}, glContext: r, failIfMajorPerformanceCaveat: i = false, benchmarksURL: a = "https://unpkg.com/detect-gpu@5.0.70/dist/benchmarks" } = {}) => O4(void 0, void 0, void 0, (function* () {
    const s = {};
    if (MD) return {
      tier: 0,
      type: "SSR"
    };
    const { isIpad: o = !!(Es == null ? void 0 : Es.isIpad), isMobile: l = !!(Es == null ? void 0 : Es.isMobile), screenSize: c = window.screen, loadBenchmarks: f = ((E) => O4(void 0, void 0, void 0, (function* () {
      const b = yield fetch(`${a}/${E}`).then(((D) => D.json()));
      if (parseInt(b.shift().split(".")[0], 10) < 4) throw new lT("Detect GPU benchmark data is out of date. Please update to version 4x");
      return b;
    }))) } = n;
    let { renderer: u } = n;
    const h = (E, b, D, R, I) => ({
      device: I,
      fps: R,
      gpu: D,
      isMobile: l,
      tier: E,
      type: b
    });
    let g, v = "";
    if (u) u = oT(u), g = [
      u
    ];
    else {
      const E = r || (function(D, R = false) {
        const I = {
          alpha: false,
          antialias: false,
          depth: false,
          failIfMajorPerformanceCaveat: R,
          powerPreference: "high-performance",
          stencil: false
        };
        D && delete I.powerPreference;
        const O = window.document.createElement("canvas"), L = O.getContext("webgl", I) || O.getContext("experimental-webgl", I);
        return L ?? void 0;
      })(Es == null ? void 0 : Es.isSafari12, i);
      if (!E) return h(0, "WEBGL_UNSUPPORTED");
      const b = (Es == null ? void 0 : Es.isFirefox) ? null : E.getExtension("WEBGL_debug_renderer_info");
      if (u = b ? E.getParameter(b.UNMASKED_RENDERER_WEBGL) : E.getParameter(E.RENDERER), !u) return h(1, "FALLBACK");
      v = u, u = oT(u), g = (function(D, R, I) {
        return R === "apple gpu" ? cK(D, R, I) : [
          R
        ];
      })(E, u, l);
    }
    const m = (yield Promise.all(g.map((function(E) {
      var b;
      return O4(this, void 0, void 0, (function* () {
        const D = ((ie) => {
          const oe = l ? [
            "adreno",
            "apple",
            "mali-t",
            "mali",
            "nvidia",
            "powervr",
            "samsung"
          ] : [
            "intel",
            "apple",
            "amd",
            "radeon",
            "nvidia",
            "geforce",
            "adreno"
          ];
          for (const he of oe) if (ie.includes(he)) return he;
        })(E);
        if (!D) return;
        const R = `${l ? "m" : "d"}-${D}${o ? "-ipad" : ""}.json`, I = s[R] = (b = s[R]) !== null && b !== void 0 ? b : f(R);
        let O;
        try {
          O = yield I;
        } catch (ie) {
          if (ie instanceof lT) throw ie;
          return;
        }
        const L = (function(ie) {
          var oe;
          const he = (ie = ie.replace(/\([^)]+\)/, "")).match(/\d+/) || ie.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
          return (oe = he == null ? void 0 : he.join("").replace(/\W|amd/g, "")) !== null && oe !== void 0 ? oe : "";
        })(E);
        let N = O.filter((([, ie]) => ie === L));
        N.length || (N = O.filter((([ie]) => ie.includes(E))));
        const F = N.length;
        if (F === 0) return;
        const V = E.split(/[.,()\[\]/\s]/g).sort().filter(((ie, oe, he) => oe === 0 || ie !== he[oe - 1])).join(" ");
        let k, [_, , , , K] = F > 1 ? N.map(((ie) => [
          ie,
          uK(V, ie[2])
        ])).sort((([, ie], [, oe]) => ie - oe))[0][0] : N[0], Z = Number.MAX_VALUE;
        const { devicePixelRatio: j } = window, B = c.width * j * c.height * j;
        for (const ie of K) {
          const [oe, he] = ie, Le = oe * he, Je = Math.abs(B - Le);
          Je < Z && (Z = Je, k = ie);
        }
        if (!k) return;
        const [, , Y, X] = k;
        return [
          Z,
          Y,
          _,
          X
        ];
      }));
    })))).filter(fK).sort((([E = Number.MAX_VALUE, b], [D = Number.MAX_VALUE, R]) => E === D ? b - R : E - D));
    if (!m.length) {
      const E = lK.find(((b) => u.includes(b)));
      return E ? h(0, "BLOCKLISTED", E) : h(1, "FALLBACK", `${u} (${v})`);
    }
    const [, y, w, C] = m[0];
    if (y === -1) return h(0, "BLOCKLISTED", w, y, C);
    const T = l ? t : e;
    let S = 0;
    for (let E = 0; E < T.length; E++) y >= T[E] && (S = E);
    return h(S, "BENCHMARK", w, y, C);
  }));
  function _a(t) {
    return Ch.get(t);
  }
  function Pl() {
    return Ch.getAll();
  }
  const RD = Symbol("Comlink.proxy"), dK = Symbol("Comlink.endpoint"), OD = Symbol("Comlink.releaseProxy"), V4 = Symbol("Comlink.finalizer"), Ng = Symbol("Comlink.thrown"), ID = (t) => typeof t == "object" && t !== null || typeof t == "function", gK = {
    canHandle: (t) => ID(t) && t[RD],
    serialize(t) {
      const { port1: e, port2: n } = new MessageChannel();
      return ND(t, e), [
        n,
        [
          n
        ]
      ];
    },
    deserialize(t) {
      return t.start(), r6(t);
    }
  }, pK = {
    canHandle: (t) => ID(t) && Ng in t,
    serialize({ value: t }) {
      let e;
      return t instanceof Error ? e = {
        isError: true,
        value: {
          message: t.message,
          name: t.name,
          stack: t.stack
        }
      } : e = {
        isError: false,
        value: t
      }, [
        e,
        []
      ];
    },
    deserialize(t) {
      throw t.isError ? Object.assign(new Error(t.value.message), t.value) : t.value;
    }
  }, VD = /* @__PURE__ */ new Map([
    [
      "proxy",
      gK
    ],
    [
      "throw",
      pK
    ]
  ]);
  function mK(t, e) {
    for (const n of t) if (e === n || n === "*" || n instanceof RegExp && n.test(e)) return true;
    return false;
  }
  function ND(t, e = globalThis, n = [
    "*"
  ]) {
    e.addEventListener("message", function r(i) {
      if (!i || !i.data) return;
      if (!mK(n, i.origin)) {
        console.warn(`Invalid origin '${i.origin}' for comlink proxy`);
        return;
      }
      const { id: a, type: s, path: o } = Object.assign({
        path: []
      }, i.data), l = (i.data.argumentList || []).map(Mc);
      let c;
      try {
        const f = o.slice(0, -1).reduce((h, g) => h[g], t), u = o.reduce((h, g) => h[g], t);
        switch (s) {
          case "GET":
            c = u;
            break;
          case "SET":
            f[o.slice(-1)[0]] = Mc(i.data.value), c = true;
            break;
          case "APPLY":
            c = u.apply(f, l);
            break;
          case "CONSTRUCT":
            {
              const h = new u(...l);
              c = BD(h);
            }
            break;
          case "ENDPOINT":
            {
              const { port1: h, port2: g } = new MessageChannel();
              ND(t, g), c = CK(h, [
                h
              ]);
            }
            break;
          case "RELEASE":
            c = void 0;
            break;
          default:
            return;
        }
      } catch (f) {
        c = {
          value: f,
          [Ng]: 0
        };
      }
      Promise.resolve(c).catch((f) => ({
        value: f,
        [Ng]: 0
      })).then((f) => {
        const [u, h] = dp(f);
        e.postMessage(Object.assign(Object.assign({}, u), {
          id: a
        }), h), s === "RELEASE" && (e.removeEventListener("message", r), LD(e), V4 in t && typeof t[V4] == "function" && t[V4]());
      }).catch((f) => {
        const [u, h] = dp({
          value: new TypeError("Unserializable return value"),
          [Ng]: 0
        });
        e.postMessage(Object.assign(Object.assign({}, u), {
          id: a
        }), h);
      });
    }), e.start && e.start();
  }
  function vK(t) {
    return t.constructor.name === "MessagePort";
  }
  function LD(t) {
    vK(t) && t.close();
  }
  function r6(t, e) {
    const n = /* @__PURE__ */ new Map();
    return t.addEventListener("message", function(i) {
      const { data: a } = i;
      if (!a || !a.id) return;
      const s = n.get(a.id);
      if (s) try {
        s(a);
      } finally {
        n.delete(a.id);
      }
    }), i6(t, n, [], e);
  }
  function O2(t) {
    if (t) throw new Error("Proxy has been released and is not useable");
  }
  function UD(t) {
    return lu(t, /* @__PURE__ */ new Map(), {
      type: "RELEASE"
    }).then(() => {
      LD(t);
    });
  }
  const fp = /* @__PURE__ */ new WeakMap(), hp = "FinalizationRegistry" in globalThis && new FinalizationRegistry((t) => {
    const e = (fp.get(t) || 0) - 1;
    fp.set(t, e), e === 0 && UD(t);
  });
  function yK(t, e) {
    const n = (fp.get(e) || 0) + 1;
    fp.set(e, n), hp && hp.register(t, e, t);
  }
  function xK(t) {
    hp && hp.unregister(t);
  }
  function i6(t, e, n = [], r = function() {
  }) {
    let i = false;
    const a = new Proxy(r, {
      get(s, o) {
        if (O2(i), o === OD) return () => {
          xK(a), UD(t), e.clear(), i = true;
        };
        if (o === "then") {
          if (n.length === 0) return {
            then: () => a
          };
          const l = lu(t, e, {
            type: "GET",
            path: n.map((c) => c.toString())
          }).then(Mc);
          return l.then.bind(l);
        }
        return i6(t, e, [
          ...n,
          o
        ]);
      },
      set(s, o, l) {
        O2(i);
        const [c, f] = dp(l);
        return lu(t, e, {
          type: "SET",
          path: [
            ...n,
            o
          ].map((u) => u.toString()),
          value: c
        }, f).then(Mc);
      },
      apply(s, o, l) {
        O2(i);
        const c = n[n.length - 1];
        if (c === dK) return lu(t, e, {
          type: "ENDPOINT"
        }).then(Mc);
        if (c === "bind") return i6(t, e, n.slice(0, -1));
        const [f, u] = uT(l);
        return lu(t, e, {
          type: "APPLY",
          path: n.map((h) => h.toString()),
          argumentList: f
        }, u).then(Mc);
      },
      construct(s, o) {
        O2(i);
        const [l, c] = uT(o);
        return lu(t, e, {
          type: "CONSTRUCT",
          path: n.map((f) => f.toString()),
          argumentList: l
        }, c).then(Mc);
      }
    });
    return yK(a, t), a;
  }
  function wK(t) {
    return Array.prototype.concat.apply([], t);
  }
  function uT(t) {
    const e = t.map(dp);
    return [
      e.map((n) => n[0]),
      wK(e.map((n) => n[1]))
    ];
  }
  const FD = /* @__PURE__ */ new WeakMap();
  function CK(t, e) {
    return FD.set(t, e), t;
  }
  function BD(t) {
    return Object.assign(t, {
      [RD]: true
    });
  }
  function dp(t) {
    for (const [e, n] of VD) if (n.canHandle(t)) {
      const [r, i] = n.serialize(t);
      return [
        {
          type: "HANDLER",
          name: e,
          value: r
        },
        i
      ];
    }
    return [
      {
        type: "RAW",
        value: t
      },
      FD.get(t) || []
    ];
  }
  function Mc(t) {
    switch (t.type) {
      case "HANDLER":
        return VD.get(t.name).deserialize(t.value);
      case "RAW":
        return t.value;
    }
  }
  function lu(t, e, n, r) {
    return new Promise((i) => {
      const a = TK();
      e.set(a, i), t.start && t.start(), t.postMessage(Object.assign({
        id: a
      }, n), r);
    });
  }
  function TK() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
  }
  class _D {
    constructor(e) {
      this.numRequests = {
        interaction: 0,
        thumbnail: 0,
        prefetch: 0,
        compute: 0
      }, this.id = e || gi(), this.requestPool = {
        interaction: {
          0: []
        },
        thumbnail: {
          0: []
        },
        prefetch: {
          0: []
        },
        compute: {
          0: []
        }
      }, this.grabDelay = 5, this.awake = false, this.numRequests = {
        interaction: 0,
        thumbnail: 0,
        prefetch: 0,
        compute: 0
      }, this.maxNumRequests = {
        interaction: 6,
        thumbnail: 6,
        prefetch: 5,
        compute: 1e3
      };
    }
    setMaxSimultaneousRequests(e, n) {
      this.maxNumRequests[e] = n;
    }
    getMaxSimultaneousRequests(e) {
      return this.maxNumRequests[e];
    }
    destroy() {
      this.timeoutHandle && window.clearTimeout(this.timeoutHandle);
    }
    addRequest(e, n, r, i = 0) {
      const a = {
        requestFn: e,
        type: n,
        additionalDetails: r
      };
      this.requestPool[n][i] === void 0 && (this.requestPool[n][i] = []), this.requestPool[n][i].push(a), this.startGrabbing();
    }
    filterRequests(e) {
      Object.keys(this.requestPool).forEach((n) => {
        const r = this.requestPool[n];
        Object.keys(r).forEach((i) => {
          r[i] = r[i].filter((a) => e(a));
        });
      });
    }
    clearRequestStack(e) {
      if (!this.requestPool[e]) throw new Error(`No category for the type ${e} found`);
      this.requestPool[e] = {
        0: []
      };
    }
    sendRequests(e) {
      const n = this.maxNumRequests[e] - this.numRequests[e];
      let r = 0;
      for (let i = 0; i < n; i++) {
        const a = this.getNextRequest(e);
        if (a === null) return false;
        if (a) {
          this.numRequests[e]++, this.awake = true;
          let s;
          try {
            s = a.requestFn();
          } catch (o) {
            console.warn("sendRequest failed", o);
          }
          (s == null ? void 0 : s.finally) ? s.finally(() => {
            this.numRequests[e]--, this.startAgain();
          }) : (this.numRequests[e]--, r++);
        }
      }
      return r && this.startAgain(), true;
    }
    getNextRequest(e) {
      const n = this.getSortedPriorityGroups(e);
      for (const r of n) if (this.requestPool[e][r].length) return this.requestPool[e][r].shift();
      return null;
    }
    startGrabbing() {
      const e = this.sendRequests(ar.Interaction), n = this.sendRequests(ar.Thumbnail), r = this.sendRequests(ar.Prefetch), i = this.sendRequests(ar.Compute);
      !e && !n && !r && !i && (this.awake = false);
    }
    startAgain() {
      this.awake && (this.grabDelay !== void 0 ? this.timeoutHandle || (this.timeoutHandle = window.setTimeout(() => {
        this.timeoutHandle = null, this.startGrabbing();
      }, this.grabDelay)) : this.startGrabbing());
    }
    getSortedPriorityGroups(e) {
      return Object.keys(this.requestPool[e]).map(Number).filter((r) => this.requestPool[e][r].length).sort((r, i) => r - i);
    }
    getRequestPool() {
      return this.requestPool;
    }
  }
  class kD {
    constructor() {
      this.workerRegistry = {}, this.workerPoolManager = new _D("webworker");
    }
    registerWorker(e, n, r = {}) {
      var _a3;
      const { maxWorkerInstances: i = 1, overwrite: a = false, autoTerminateOnIdle: s = {
        enabled: false,
        idleTimeThreshold: 3e3
      } } = r;
      if (this.workerRegistry[e] && !a) {
        console.warn(`Worker type '${e}' is already registered...`);
        return;
      }
      a && ((_a3 = this.workerRegistry[e]) == null ? void 0 : _a3.idleCheckIntervalId) && clearInterval(this.workerRegistry[e].idleCheckIntervalId);
      const o = {
        workerFn: null,
        instances: [],
        loadCounters: [],
        lastActiveTime: [],
        nativeWorkers: [],
        autoTerminateOnIdle: s.enabled,
        idleCheckIntervalId: null,
        idleTimeThreshold: s.idleTimeThreshold
      };
      o.loadCounters = Array(i).fill(0), o.lastActiveTime = Array(i).fill(null);
      for (let l = 0; l < i; l++) {
        const c = n();
        o.instances.push(r6(c)), o.nativeWorkers.push(c), o.workerFn = n;
      }
      this.workerRegistry[e] = o;
    }
    getNextWorkerAPI(e) {
      const n = this.workerRegistry[e];
      if (!n) return console.error(`Worker type '${e}' is not registered.`), null;
      const r = n.instances.filter((s) => s !== null);
      let i = 0, a = n.loadCounters[0] || 0;
      for (let s = 1; s < r.length; s++) {
        const o = n.loadCounters[s] || 0;
        o < a && (i = s, a = o);
      }
      if (n.instances[i] === null) {
        const s = n.workerFn();
        n.instances[i] = r6(s), n.nativeWorkers[i] = s;
      }
      return n.loadCounters[i] += 1, {
        api: n.instances[i],
        index: i
      };
    }
    executeTask(e, n, r = {}, { requestType: i = ar.Compute, priority: a = 0, options: s = {}, callbacks: o = [] } = {}) {
      return new Promise((l, c) => {
        const f = async () => {
          const { api: u, index: h } = this.getNextWorkerAPI(e);
          if (!u) {
            const g = new Error(`No available worker instance for '${e}'`);
            console.error(g), c(g);
            return;
          }
          try {
            let g = [];
            o.length && (g = o.map((y) => BD(y)));
            const v = this.workerRegistry[e];
            v.processing = true;
            const m = await u[n](r, ...g);
            v.processing = false, v.lastActiveTime[h] = Date.now(), v.autoTerminateOnIdle && !v.idleCheckIntervalId && v.idleTimeThreshold && (v.idleCheckIntervalId = setInterval(() => {
              this.terminateIdleWorkers(e, v.idleTimeThreshold);
            }, v.idleTimeThreshold)), l(m);
          } catch (g) {
            console.error(`Error executing method '${n}' on worker '${e}':`, g), c(g);
          } finally {
            this.workerRegistry[e].loadCounters[h]--;
          }
        };
        this.workerPoolManager.addRequest(f, i, s, a);
      });
    }
    terminateIdleWorkers(e, n) {
      const r = this.workerRegistry[e];
      if (r.processing) return;
      const i = Date.now();
      r.instances.forEach((a, s) => {
        const o = r.lastActiveTime[s], l = o !== null && r.loadCounters[s] > 0, c = i - o;
        !l && c > n && this.terminateWorkerInstance(e, s);
      });
    }
    terminate(e) {
      const n = this.workerRegistry[e];
      if (!n) {
        console.error(`Worker type '${e}' is not registered.`);
        return;
      }
      n.instances.forEach((r, i) => {
        this.terminateWorkerInstance(e, i);
      });
    }
    terminateWorkerInstance(e, n) {
      const r = this.workerRegistry[e], i = r.instances[n];
      i !== null && (i[OD](), r.nativeWorkers[n].terminate(), r.instances[n] = null, r.lastActiveTime[n] = null);
    }
  }
  let H1 = false, j1 = true, Lg = Ds.TRUE;
  const a6 = {
    gpuTier: void 0,
    detectGPUConfig: {},
    isMobile: false,
    rendering: {
      useCPURendering: false,
      preferSizeOverAccuracy: false,
      useNorm16Texture: false,
      strictZSpacingForVolumeViewport: true
    },
    enableCacheOptimization: true,
    peerImport: (t) => null
  };
  let Ui = {
    ...a6,
    rendering: {
      ...a6.rendering
    }
  }, ch = null;
  function PD() {
    const t = document.createElement("canvas");
    return t.getContext("webgl2") || t.getContext("webgl") || t.getContext("experimental-webgl");
  }
  function SK() {
    const t = PD();
    return t instanceof WebGLRenderingContext || t instanceof WebGL2RenderingContext;
  }
  function AK() {
    try {
      return !!new SharedArrayBuffer(0);
    } catch {
      return false;
    }
  }
  function EK() {
    const t = PD();
    return !!(t && t.getExtension("EXT_texture_norm16"));
  }
  function GD() {
    return /iPad|iPhone|iPod/.test(navigator.platform) ? true : navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);
  }
  async function bK(t = Ui) {
    var _a3, _b3;
    return H1 || (Ui = zi(a6, t), GD() && (Ui.rendering.useNorm16Texture = EK(), Ui.rendering.useNorm16Texture || (((_a3 = t.rendering) == null ? void 0 : _a3.preferSizeOverAccuracy) ? Ui.rendering.preferSizeOverAccuracy = true : console.log("norm16 texture not supported, you can turn on the preferSizeOverAccuracy flag to use native data type, but be aware of the inaccuracy of the rendering in high bits"))), SK() ? (Ui.gpuTier = Ui.gpuTier || await hK(Ui.detectGPUConfig), console.log("CornerstoneRender: Using detect-gpu to get the GPU benchmark:", Ui.gpuTier), ((_b3 = Ui.gpuTier) == null ? void 0 : _b3.tier) < 1 ? (console.log("CornerstoneRender: GPU is not powerful enough, using CPU rendering"), Ui.rendering.useCPURendering = true) : console.log("CornerstoneRender: using GPU rendering")) : (console.log("CornerstoneRender: GPU not detected, using CPU rendering"), Ui.rendering.useCPURendering = true), MK(Lg), H1 = true, ch || (ch = new kD()), H1);
  }
  function DK() {
    return !GD();
  }
  function uh() {
    return Ui.rendering.useCPURendering;
  }
  function MK(t) {
    if (t == Ds.AUTO) {
      Lg = Ds.AUTO, AK() ? (j1 = true, console.log("CornerstoneRender: using SharedArrayBuffer")) : (j1 = false, console.warn(`CornerstoneRender: SharedArray Buffer not allowed, performance may be slower.
        Try ensuring page is cross-origin isolated to enable SharedArrayBuffer.`));
      return;
    }
    if (t == Ds.TRUE || t == true) {
      Lg = Ds.TRUE, j1 = true;
      return;
    }
    if (t == Ds.FALSE || t == false) {
      Lg = Ds.FALSE, j1 = false;
      return;
    }
  }
  function Qu() {
    return j1;
  }
  function RK() {
    return H1;
  }
  function Do() {
    return Ui;
  }
  function Ju() {
    return ch || (ch = new kD()), ch;
  }
  function OK(t) {
    return Ui.peerImport(t);
  }
  function gp(t) {
    if (!Qu()) throw new Error("Your page is NOT cross-origin isolated, see https://developer.mozilla.org/en-US/docs/Web/API/crossOriginIsolated");
    if (window.SharedArrayBuffer === void 0) throw new Error("SharedArrayBuffer is NOT supported in your browser see https://developer.chrome.com/blog/enabling-shared-array-buffer/");
    const e = new SharedArrayBuffer(t);
    return new Uint8Array(e);
  }
  const zD = 2 * 1024 * 1024 * 1024 - 2, IK = zD * 2, VK = 65536;
  function fh(t) {
    if (!Qu()) throw new Error("Your page is NOT cross-origin isolated, see https://developer.mozilla.org/en-US/docs/Web/API/crossOriginIsolated");
    if (window.SharedArrayBuffer === void 0) throw new Error("SharedArrayBuffer is NOT supported in your browser see https://developer.chrome.com/blog/enabling-shared-array-buffer/");
    const e = t * 4;
    if (e < zD) {
      const n = new SharedArrayBuffer(e);
      return new Float32Array(n);
    } else if (e < IK) {
      const n = Math.ceil(e / VK), r = new WebAssembly.Memory({
        initial: n,
        maximum: n,
        shared: true
      });
      return new Float32Array(r.buffer, 0, t);
    }
  }
  function pp(t) {
    if (!window.crossOriginIsolated) throw new Error("Your page is NOT cross-origin isolated, see https://developer.mozilla.org/en-US/docs/Web/API/crossOriginIsolated");
    if (window.SharedArrayBuffer === void 0) throw new Error("SharedArrayBuffer is NOT supported in your browser see https://developer.chrome.com/blog/enabling-shared-array-buffer/");
    const e = new SharedArrayBuffer(t * 2);
    return new Uint16Array(e);
  }
  function WD(t) {
    if (!window.crossOriginIsolated) throw new Error("Your page is NOT cross-origin isolated, see https://developer.mozilla.org/en-US/docs/Web/API/crossOriginIsolated");
    if (window.SharedArrayBuffer === void 0) throw new Error("SharedArrayBuffer is NOT supported in your browser see https://developer.chrome.com/blog/enabling-shared-array-buffer/");
    const e = new SharedArrayBuffer(t * 2);
    return new Int16Array(e);
  }
  var xn = 1e-6, ei = typeof Float32Array < "u" ? Float32Array : Array, NK = Math.PI / 180;
  function LK(t) {
    return t * NK;
  }
  Math.hypot || (Math.hypot = function() {
    for (var t = 0, e = arguments.length; e--; ) t += arguments[e] * arguments[e];
    return Math.sqrt(t);
  });
  function HD() {
    var t = new ei(9);
    return ei != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
  }
  function y5(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
  }
  function UK(t) {
    var e = new ei(9);
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;
  }
  function FK(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
  }
  function jD(t, e, n, r, i, a, s, o, l) {
    var c = new ei(9);
    return c[0] = t, c[1] = e, c[2] = n, c[3] = r, c[4] = i, c[5] = a, c[6] = s, c[7] = o, c[8] = l, c;
  }
  function BK(t, e, n, r, i, a, s, o, l, c) {
    return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = a, t[5] = s, t[6] = o, t[7] = l, t[8] = c, t;
  }
  function Fa(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
  }
  function N8(t, e) {
    if (t === e) {
      var n = e[1], r = e[2], i = e[5];
      t[1] = e[3], t[2] = e[6], t[3] = n, t[5] = e[7], t[6] = r, t[7] = i;
    } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
    return t;
  }
  function td(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], c = e[7], f = e[8], u = f * s - o * c, h = -f * a + o * l, g = c * a - s * l, v = n * u + r * h + i * g;
    return v ? (v = 1 / v, t[0] = u * v, t[1] = (-f * r + i * c) * v, t[2] = (o * r - i * s) * v, t[3] = h * v, t[4] = (f * n - i * l) * v, t[5] = (-o * n + i * a) * v, t[6] = g * v, t[7] = (-c * n + r * l) * v, t[8] = (s * n - r * a) * v, t) : null;
  }
  function _K(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], c = e[7], f = e[8];
    return t[0] = s * f - o * c, t[1] = i * c - r * f, t[2] = r * o - i * s, t[3] = o * l - a * f, t[4] = n * f - i * l, t[5] = i * a - n * o, t[6] = a * c - s * l, t[7] = r * l - n * c, t[8] = n * s - r * a, t;
  }
  function kK(t) {
    var e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], s = t[5], o = t[6], l = t[7], c = t[8];
    return e * (c * a - s * l) + n * (-c * i + s * o) + r * (l * i - a * o);
  }
  function Ou(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], u = e[8], h = n[0], g = n[1], v = n[2], m = n[3], y = n[4], w = n[5], C = n[6], T = n[7], S = n[8];
    return t[0] = h * r + g * s + v * c, t[1] = h * i + g * o + v * f, t[2] = h * a + g * l + v * u, t[3] = m * r + y * s + w * c, t[4] = m * i + y * o + w * f, t[5] = m * a + y * l + w * u, t[6] = C * r + T * s + S * c, t[7] = C * i + T * o + S * f, t[8] = C * a + T * l + S * u, t;
  }
  function PK(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], u = e[8], h = n[0], g = n[1];
    return t[0] = r, t[1] = i, t[2] = a, t[3] = s, t[4] = o, t[5] = l, t[6] = h * r + g * s + c, t[7] = h * i + g * o + f, t[8] = h * a + g * l + u, t;
  }
  function GK(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], u = e[8], h = Math.sin(n), g = Math.cos(n);
    return t[0] = g * r + h * s, t[1] = g * i + h * o, t[2] = g * a + h * l, t[3] = g * s - h * r, t[4] = g * o - h * i, t[5] = g * l - h * a, t[6] = c, t[7] = f, t[8] = u, t;
  }
  function zK(t, e, n) {
    var r = n[0], i = n[1];
    return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
  }
  function WK(t, e) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t;
  }
  function HK(t, e) {
    var n = Math.sin(e), r = Math.cos(e);
    return t[0] = r, t[1] = n, t[2] = 0, t[3] = -n, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
  }
  function jK(t, e) {
    return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
  }
  function KK(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t;
  }
  function YK(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = n + n, o = r + r, l = i + i, c = n * s, f = r * s, u = r * o, h = i * s, g = i * o, v = i * l, m = a * s, y = a * o, w = a * l;
    return t[0] = 1 - u - v, t[3] = f - w, t[6] = h + y, t[1] = f + w, t[4] = 1 - c - v, t[7] = g - m, t[2] = h - y, t[5] = g + m, t[8] = 1 - c - u, t;
  }
  function qK(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], c = e[7], f = e[8], u = e[9], h = e[10], g = e[11], v = e[12], m = e[13], y = e[14], w = e[15], C = n * o - r * s, T = n * l - i * s, S = n * c - a * s, E = r * l - i * o, b = r * c - a * o, D = i * c - a * l, R = f * m - u * v, I = f * y - h * v, O = f * w - g * v, L = u * y - h * m, N = u * w - g * m, F = h * w - g * y, V = C * F - T * N + S * L + E * O - b * I + D * R;
    return V ? (V = 1 / V, t[0] = (o * F - l * N + c * L) * V, t[1] = (l * O - s * F - c * I) * V, t[2] = (s * N - o * O + c * R) * V, t[3] = (i * N - r * F - a * L) * V, t[4] = (n * F - i * O + a * I) * V, t[5] = (r * O - n * N - a * R) * V, t[6] = (m * D - y * b + w * E) * V, t[7] = (y * S - v * D - w * T) * V, t[8] = (v * b - m * S + w * C) * V, t) : null;
  }
  function XK(t, e, n) {
    return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / n, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
  }
  function ZK(t) {
    return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
  }
  function QK(t) {
    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
  }
  function JK(t, e, n) {
    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t;
  }
  function KD(t, e, n) {
    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t;
  }
  function $K(t, e, n) {
    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t;
  }
  function eY(t, e, n, r) {
    return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t;
  }
  function tY(t, e) {
    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8];
  }
  function nY(t, e) {
    var n = t[0], r = t[1], i = t[2], a = t[3], s = t[4], o = t[5], l = t[6], c = t[7], f = t[8], u = e[0], h = e[1], g = e[2], v = e[3], m = e[4], y = e[5], w = e[6], C = e[7], T = e[8];
    return Math.abs(n - u) <= xn * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(r - h) <= xn * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(i - g) <= xn * Math.max(1, Math.abs(i), Math.abs(g)) && Math.abs(a - v) <= xn * Math.max(1, Math.abs(a), Math.abs(v)) && Math.abs(s - m) <= xn * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(o - y) <= xn * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(l - w) <= xn * Math.max(1, Math.abs(l), Math.abs(w)) && Math.abs(c - C) <= xn * Math.max(1, Math.abs(c), Math.abs(C)) && Math.abs(f - T) <= xn * Math.max(1, Math.abs(f), Math.abs(T));
  }
  var rY = Ou, iY = KD;
  const aY = Object.freeze(Object.defineProperty({
    __proto__: null,
    add: JK,
    adjoint: _K,
    clone: UK,
    copy: FK,
    create: HD,
    determinant: kK,
    equals: nY,
    exactEquals: tY,
    frob: QK,
    fromMat2d: KK,
    fromMat4: y5,
    fromQuat: YK,
    fromRotation: HK,
    fromScaling: jK,
    fromTranslation: WK,
    fromValues: jD,
    identity: Fa,
    invert: td,
    mul: rY,
    multiply: Ou,
    multiplyScalar: $K,
    multiplyScalarAndAdd: eY,
    normalFromMat4: qK,
    projection: XK,
    rotate: GK,
    scale: zK,
    set: BK,
    str: ZK,
    sub: iY,
    subtract: KD,
    translate: PK,
    transpose: N8
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function L8() {
    var t = new ei(16);
    return ei != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
  }
  function sY(t) {
    var e = new ei(16);
    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
  }
  function sr(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
  }
  function oY(t, e, n, r, i, a, s, o, l, c, f, u, h, g, v, m) {
    var y = new ei(16);
    return y[0] = t, y[1] = e, y[2] = n, y[3] = r, y[4] = i, y[5] = a, y[6] = s, y[7] = o, y[8] = l, y[9] = c, y[10] = f, y[11] = u, y[12] = h, y[13] = g, y[14] = v, y[15] = m, y;
  }
  function lY(t, e, n, r, i, a, s, o, l, c, f, u, h, g, v, m, y) {
    return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = a, t[5] = s, t[6] = o, t[7] = l, t[8] = c, t[9] = f, t[10] = u, t[11] = h, t[12] = g, t[13] = v, t[14] = m, t[15] = y, t;
  }
  function gt(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }
  function en(t, e) {
    if (t === e) {
      var n = e[1], r = e[2], i = e[3], a = e[6], s = e[7], o = e[11];
      t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = a, t[11] = e[14], t[12] = i, t[13] = s, t[14] = o;
    } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
    return t;
  }
  function Nr(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], c = e[7], f = e[8], u = e[9], h = e[10], g = e[11], v = e[12], m = e[13], y = e[14], w = e[15], C = n * o - r * s, T = n * l - i * s, S = n * c - a * s, E = r * l - i * o, b = r * c - a * o, D = i * c - a * l, R = f * m - u * v, I = f * y - h * v, O = f * w - g * v, L = u * y - h * m, N = u * w - g * m, F = h * w - g * y, V = C * F - T * N + S * L + E * O - b * I + D * R;
    return V ? (V = 1 / V, t[0] = (o * F - l * N + c * L) * V, t[1] = (i * N - r * F - a * L) * V, t[2] = (m * D - y * b + w * E) * V, t[3] = (h * b - u * D - g * E) * V, t[4] = (l * O - s * F - c * I) * V, t[5] = (n * F - i * O + a * I) * V, t[6] = (y * S - v * D - w * T) * V, t[7] = (f * D - h * S + g * T) * V, t[8] = (s * N - o * O + c * R) * V, t[9] = (r * O - n * N - a * R) * V, t[10] = (v * b - m * S + w * C) * V, t[11] = (u * S - f * b - g * C) * V, t[12] = (o * I - s * L - l * R) * V, t[13] = (n * L - r * I + i * R) * V, t[14] = (m * T - v * E - y * C) * V, t[15] = (f * E - u * T + h * C) * V, t) : null;
  }
  function cY(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], c = e[7], f = e[8], u = e[9], h = e[10], g = e[11], v = e[12], m = e[13], y = e[14], w = e[15];
    return t[0] = o * (h * w - g * y) - u * (l * w - c * y) + m * (l * g - c * h), t[1] = -(r * (h * w - g * y) - u * (i * w - a * y) + m * (i * g - a * h)), t[2] = r * (l * w - c * y) - o * (i * w - a * y) + m * (i * c - a * l), t[3] = -(r * (l * g - c * h) - o * (i * g - a * h) + u * (i * c - a * l)), t[4] = -(s * (h * w - g * y) - f * (l * w - c * y) + v * (l * g - c * h)), t[5] = n * (h * w - g * y) - f * (i * w - a * y) + v * (i * g - a * h), t[6] = -(n * (l * w - c * y) - s * (i * w - a * y) + v * (i * c - a * l)), t[7] = n * (l * g - c * h) - s * (i * g - a * h) + f * (i * c - a * l), t[8] = s * (u * w - g * m) - f * (o * w - c * m) + v * (o * g - c * u), t[9] = -(n * (u * w - g * m) - f * (r * w - a * m) + v * (r * g - a * u)), t[10] = n * (o * w - c * m) - s * (r * w - a * m) + v * (r * c - a * o), t[11] = -(n * (o * g - c * u) - s * (r * g - a * u) + f * (r * c - a * o)), t[12] = -(s * (u * y - h * m) - f * (o * y - l * m) + v * (o * h - l * u)), t[13] = n * (u * y - h * m) - f * (r * y - i * m) + v * (r * h - i * u), t[14] = -(n * (o * y - l * m) - s * (r * y - i * m) + v * (r * l - i * o)), t[15] = n * (o * h - l * u) - s * (r * h - i * u) + f * (r * l - i * o), t;
  }
  function uY(t) {
    var e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], s = t[5], o = t[6], l = t[7], c = t[8], f = t[9], u = t[10], h = t[11], g = t[12], v = t[13], m = t[14], y = t[15], w = e * s - n * a, C = e * o - r * a, T = e * l - i * a, S = n * o - r * s, E = n * l - i * s, b = r * l - i * o, D = c * v - f * g, R = c * m - u * g, I = c * y - h * g, O = f * m - u * v, L = f * y - h * v, N = u * y - h * m;
    return w * N - C * L + T * O + S * I - E * R + b * D;
  }
  function tn(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], u = e[8], h = e[9], g = e[10], v = e[11], m = e[12], y = e[13], w = e[14], C = e[15], T = n[0], S = n[1], E = n[2], b = n[3];
    return t[0] = T * r + S * o + E * u + b * m, t[1] = T * i + S * l + E * h + b * y, t[2] = T * a + S * c + E * g + b * w, t[3] = T * s + S * f + E * v + b * C, T = n[4], S = n[5], E = n[6], b = n[7], t[4] = T * r + S * o + E * u + b * m, t[5] = T * i + S * l + E * h + b * y, t[6] = T * a + S * c + E * g + b * w, t[7] = T * s + S * f + E * v + b * C, T = n[8], S = n[9], E = n[10], b = n[11], t[8] = T * r + S * o + E * u + b * m, t[9] = T * i + S * l + E * h + b * y, t[10] = T * a + S * c + E * g + b * w, t[11] = T * s + S * f + E * v + b * C, T = n[12], S = n[13], E = n[14], b = n[15], t[12] = T * r + S * o + E * u + b * m, t[13] = T * i + S * l + E * h + b * y, t[14] = T * a + S * c + E * g + b * w, t[15] = T * s + S * f + E * v + b * C, t;
  }
  function $n(t, e, n) {
    var r = n[0], i = n[1], a = n[2], s, o, l, c, f, u, h, g, v, m, y, w;
    return e === t ? (t[12] = e[0] * r + e[4] * i + e[8] * a + e[12], t[13] = e[1] * r + e[5] * i + e[9] * a + e[13], t[14] = e[2] * r + e[6] * i + e[10] * a + e[14], t[15] = e[3] * r + e[7] * i + e[11] * a + e[15]) : (s = e[0], o = e[1], l = e[2], c = e[3], f = e[4], u = e[5], h = e[6], g = e[7], v = e[8], m = e[9], y = e[10], w = e[11], t[0] = s, t[1] = o, t[2] = l, t[3] = c, t[4] = f, t[5] = u, t[6] = h, t[7] = g, t[8] = v, t[9] = m, t[10] = y, t[11] = w, t[12] = s * r + f * i + v * a + e[12], t[13] = o * r + u * i + m * a + e[13], t[14] = l * r + h * i + y * a + e[14], t[15] = c * r + g * i + w * a + e[15]), t;
  }
  function Fl(t, e, n) {
    var r = n[0], i = n[1], a = n[2];
    return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
  }
  function $a(t, e, n, r) {
    var i = r[0], a = r[1], s = r[2], o = Math.hypot(i, a, s), l, c, f, u, h, g, v, m, y, w, C, T, S, E, b, D, R, I, O, L, N, F, V, k;
    return o < xn ? null : (o = 1 / o, i *= o, a *= o, s *= o, l = Math.sin(n), c = Math.cos(n), f = 1 - c, u = e[0], h = e[1], g = e[2], v = e[3], m = e[4], y = e[5], w = e[6], C = e[7], T = e[8], S = e[9], E = e[10], b = e[11], D = i * i * f + c, R = a * i * f + s * l, I = s * i * f - a * l, O = i * a * f - s * l, L = a * a * f + c, N = s * a * f + i * l, F = i * s * f + a * l, V = a * s * f - i * l, k = s * s * f + c, t[0] = u * D + m * R + T * I, t[1] = h * D + y * R + S * I, t[2] = g * D + w * R + E * I, t[3] = v * D + C * R + b * I, t[4] = u * O + m * L + T * N, t[5] = h * O + y * L + S * N, t[6] = g * O + w * L + E * N, t[7] = v * O + C * L + b * N, t[8] = u * F + m * V + T * k, t[9] = h * F + y * V + S * k, t[10] = g * F + w * V + E * k, t[11] = v * F + C * V + b * k, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);
  }
  function U8(t, e, n) {
    var r = Math.sin(n), i = Math.cos(n), a = e[4], s = e[5], o = e[6], l = e[7], c = e[8], f = e[9], u = e[10], h = e[11];
    return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * i + c * r, t[5] = s * i + f * r, t[6] = o * i + u * r, t[7] = l * i + h * r, t[8] = c * i - a * r, t[9] = f * i - s * r, t[10] = u * i - o * r, t[11] = h * i - l * r, t;
  }
  function F8(t, e, n) {
    var r = Math.sin(n), i = Math.cos(n), a = e[0], s = e[1], o = e[2], l = e[3], c = e[8], f = e[9], u = e[10], h = e[11];
    return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i - c * r, t[1] = s * i - f * r, t[2] = o * i - u * r, t[3] = l * i - h * r, t[8] = a * r + c * i, t[9] = s * r + f * i, t[10] = o * r + u * i, t[11] = l * r + h * i, t;
  }
  function B8(t, e, n) {
    var r = Math.sin(n), i = Math.cos(n), a = e[0], s = e[1], o = e[2], l = e[3], c = e[4], f = e[5], u = e[6], h = e[7];
    return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i + c * r, t[1] = s * i + f * r, t[2] = o * i + u * r, t[3] = l * i + h * r, t[4] = c * i - a * r, t[5] = f * i - s * r, t[6] = u * i - o * r, t[7] = h * i - l * r, t;
  }
  function _8(t, e) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t;
  }
  function k8(t, e) {
    return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }
  function YD(t, e, n) {
    var r = n[0], i = n[1], a = n[2], s = Math.hypot(r, i, a), o, l, c;
    return s < xn ? null : (s = 1 / s, r *= s, i *= s, a *= s, o = Math.sin(e), l = Math.cos(e), c = 1 - l, t[0] = r * r * c + l, t[1] = i * r * c + a * o, t[2] = a * r * c - i * o, t[3] = 0, t[4] = r * i * c - a * o, t[5] = i * i * c + l, t[6] = a * i * c + r * o, t[7] = 0, t[8] = r * a * c + i * o, t[9] = i * a * c - r * o, t[10] = a * a * c + l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
  }
  function fY(t, e) {
    var n = Math.sin(e), r = Math.cos(e);
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = r, t[6] = n, t[7] = 0, t[8] = 0, t[9] = -n, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }
  function hY(t, e) {
    var n = Math.sin(e), r = Math.cos(e);
    return t[0] = r, t[1] = 0, t[2] = -n, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = n, t[9] = 0, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }
  function dY(t, e) {
    var n = Math.sin(e), r = Math.cos(e);
    return t[0] = r, t[1] = n, t[2] = 0, t[3] = 0, t[4] = -n, t[5] = r, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }
  function qD(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = r + r, l = i + i, c = a + a, f = r * o, u = r * l, h = r * c, g = i * l, v = i * c, m = a * c, y = s * o, w = s * l, C = s * c;
    return t[0] = 1 - (g + m), t[1] = u + C, t[2] = h - w, t[3] = 0, t[4] = u - C, t[5] = 1 - (f + m), t[6] = v + y, t[7] = 0, t[8] = h + w, t[9] = v - y, t[10] = 1 - (f + g), t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t;
  }
  function gY(t, e) {
    var n = new ei(3), r = -e[0], i = -e[1], a = -e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], u = r * r + i * i + a * a + s * s;
    return u > 0 ? (n[0] = (o * s + f * r + l * a - c * i) * 2 / u, n[1] = (l * s + f * i + c * r - o * a) * 2 / u, n[2] = (c * s + f * a + o * i - l * r) * 2 / u) : (n[0] = (o * s + f * r + l * a - c * i) * 2, n[1] = (l * s + f * i + c * r - o * a) * 2, n[2] = (c * s + f * a + o * i - l * r) * 2), qD(t, e, n), t;
  }
  function pY(t, e) {
    return t[0] = e[12], t[1] = e[13], t[2] = e[14], t;
  }
  function XD(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[4], s = e[5], o = e[6], l = e[8], c = e[9], f = e[10];
    return t[0] = Math.hypot(n, r, i), t[1] = Math.hypot(a, s, o), t[2] = Math.hypot(l, c, f), t;
  }
  function s6(t, e) {
    var n = new ei(3);
    XD(n, e);
    var r = 1 / n[0], i = 1 / n[1], a = 1 / n[2], s = e[0] * r, o = e[1] * i, l = e[2] * a, c = e[4] * r, f = e[5] * i, u = e[6] * a, h = e[8] * r, g = e[9] * i, v = e[10] * a, m = s + f + v, y = 0;
    return m > 0 ? (y = Math.sqrt(m + 1) * 2, t[3] = 0.25 * y, t[0] = (u - g) / y, t[1] = (h - l) / y, t[2] = (o - c) / y) : s > f && s > v ? (y = Math.sqrt(1 + s - f - v) * 2, t[3] = (u - g) / y, t[0] = 0.25 * y, t[1] = (o + c) / y, t[2] = (h + l) / y) : f > v ? (y = Math.sqrt(1 + f - s - v) * 2, t[3] = (h - l) / y, t[0] = (o + c) / y, t[1] = 0.25 * y, t[2] = (u + g) / y) : (y = Math.sqrt(1 + v - s - f) * 2, t[3] = (o - c) / y, t[0] = (h + l) / y, t[1] = (u + g) / y, t[2] = 0.25 * y), t;
  }
  function ZD(t, e, n, r) {
    var i = e[0], a = e[1], s = e[2], o = e[3], l = i + i, c = a + a, f = s + s, u = i * l, h = i * c, g = i * f, v = a * c, m = a * f, y = s * f, w = o * l, C = o * c, T = o * f, S = r[0], E = r[1], b = r[2];
    return t[0] = (1 - (v + y)) * S, t[1] = (h + T) * S, t[2] = (g - C) * S, t[3] = 0, t[4] = (h - T) * E, t[5] = (1 - (u + y)) * E, t[6] = (m + w) * E, t[7] = 0, t[8] = (g + C) * b, t[9] = (m - w) * b, t[10] = (1 - (u + v)) * b, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t;
  }
  function mY(t, e, n, r, i) {
    var a = e[0], s = e[1], o = e[2], l = e[3], c = a + a, f = s + s, u = o + o, h = a * c, g = a * f, v = a * u, m = s * f, y = s * u, w = o * u, C = l * c, T = l * f, S = l * u, E = r[0], b = r[1], D = r[2], R = i[0], I = i[1], O = i[2], L = (1 - (m + w)) * E, N = (g + S) * E, F = (v - T) * E, V = (g - S) * b, k = (1 - (h + w)) * b, _ = (y + C) * b, K = (v + T) * D, Z = (y - C) * D, j = (1 - (h + m)) * D;
    return t[0] = L, t[1] = N, t[2] = F, t[3] = 0, t[4] = V, t[5] = k, t[6] = _, t[7] = 0, t[8] = K, t[9] = Z, t[10] = j, t[11] = 0, t[12] = n[0] + R - (L * R + V * I + K * O), t[13] = n[1] + I - (N * R + k * I + Z * O), t[14] = n[2] + O - (F * R + _ * I + j * O), t[15] = 1, t;
  }
  function mp(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = n + n, o = r + r, l = i + i, c = n * s, f = r * s, u = r * o, h = i * s, g = i * o, v = i * l, m = a * s, y = a * o, w = a * l;
    return t[0] = 1 - u - v, t[1] = f + w, t[2] = h - y, t[3] = 0, t[4] = f - w, t[5] = 1 - c - v, t[6] = g + m, t[7] = 0, t[8] = h + y, t[9] = g - m, t[10] = 1 - c - u, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
  }
  function vY(t, e, n, r, i, a, s) {
    var o = 1 / (n - e), l = 1 / (i - r), c = 1 / (a - s);
    return t[0] = a * 2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a * 2 * l, t[6] = 0, t[7] = 0, t[8] = (n + e) * o, t[9] = (i + r) * l, t[10] = (s + a) * c, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = s * a * 2 * c, t[15] = 0, t;
  }
  function QD(t, e, n, r, i) {
    var a = 1 / Math.tan(e / 2), s;
    return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, i != null && i !== 1 / 0 ? (s = 1 / (r - i), t[10] = (i + r) * s, t[14] = 2 * i * r * s) : (t[10] = -1, t[14] = -2 * r), t;
  }
  var yY = QD;
  function xY(t, e, n, r, i) {
    var a = 1 / Math.tan(e / 2), s;
    return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, i != null && i !== 1 / 0 ? (s = 1 / (r - i), t[10] = i * s, t[14] = i * r * s) : (t[10] = -1, t[14] = -r), t;
  }
  function wY(t, e, n, r) {
    var i = Math.tan(e.upDegrees * Math.PI / 180), a = Math.tan(e.downDegrees * Math.PI / 180), s = Math.tan(e.leftDegrees * Math.PI / 180), o = Math.tan(e.rightDegrees * Math.PI / 180), l = 2 / (s + o), c = 2 / (i + a);
    return t[0] = l, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = c, t[6] = 0, t[7] = 0, t[8] = -((s - o) * l * 0.5), t[9] = (i - a) * c * 0.5, t[10] = r / (n - r), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = r * n / (n - r), t[15] = 0, t;
  }
  function JD(t, e, n, r, i, a, s) {
    var o = 1 / (e - n), l = 1 / (r - i), c = 1 / (a - s);
    return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (e + n) * o, t[13] = (i + r) * l, t[14] = (s + a) * c, t[15] = 1, t;
  }
  var $D = JD;
  function CY(t, e, n, r, i, a, s) {
    var o = 1 / (e - n), l = 1 / (r - i), c = 1 / (a - s);
    return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = c, t[11] = 0, t[12] = (e + n) * o, t[13] = (i + r) * l, t[14] = a * c, t[15] = 1, t;
  }
  function eM(t, e, n, r) {
    var i, a, s, o, l, c, f, u, h, g, v = e[0], m = e[1], y = e[2], w = r[0], C = r[1], T = r[2], S = n[0], E = n[1], b = n[2];
    return Math.abs(v - S) < xn && Math.abs(m - E) < xn && Math.abs(y - b) < xn ? gt(t) : (f = v - S, u = m - E, h = y - b, g = 1 / Math.hypot(f, u, h), f *= g, u *= g, h *= g, i = C * h - T * u, a = T * f - w * h, s = w * u - C * f, g = Math.hypot(i, a, s), g ? (g = 1 / g, i *= g, a *= g, s *= g) : (i = 0, a = 0, s = 0), o = u * s - h * a, l = h * i - f * s, c = f * a - u * i, g = Math.hypot(o, l, c), g ? (g = 1 / g, o *= g, l *= g, c *= g) : (o = 0, l = 0, c = 0), t[0] = i, t[1] = o, t[2] = f, t[3] = 0, t[4] = a, t[5] = l, t[6] = u, t[7] = 0, t[8] = s, t[9] = c, t[10] = h, t[11] = 0, t[12] = -(i * v + a * m + s * y), t[13] = -(o * v + l * m + c * y), t[14] = -(f * v + u * m + h * y), t[15] = 1, t);
  }
  function TY(t, e, n, r) {
    var i = e[0], a = e[1], s = e[2], o = r[0], l = r[1], c = r[2], f = i - n[0], u = a - n[1], h = s - n[2], g = f * f + u * u + h * h;
    g > 0 && (g = 1 / Math.sqrt(g), f *= g, u *= g, h *= g);
    var v = l * h - c * u, m = c * f - o * h, y = o * u - l * f;
    return g = v * v + m * m + y * y, g > 0 && (g = 1 / Math.sqrt(g), v *= g, m *= g, y *= g), t[0] = v, t[1] = m, t[2] = y, t[3] = 0, t[4] = u * y - h * m, t[5] = h * v - f * y, t[6] = f * m - u * v, t[7] = 0, t[8] = f, t[9] = u, t[10] = h, t[11] = 0, t[12] = i, t[13] = a, t[14] = s, t[15] = 1, t;
  }
  function SY(t) {
    return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
  }
  function AY(t) {
    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
  }
  function EY(t, e, n) {
    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t[9] = e[9] + n[9], t[10] = e[10] + n[10], t[11] = e[11] + n[11], t[12] = e[12] + n[12], t[13] = e[13] + n[13], t[14] = e[14] + n[14], t[15] = e[15] + n[15], t;
  }
  function tM(t, e, n) {
    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t[9] = e[9] - n[9], t[10] = e[10] - n[10], t[11] = e[11] - n[11], t[12] = e[12] - n[12], t[13] = e[13] - n[13], t[14] = e[14] - n[14], t[15] = e[15] - n[15], t;
  }
  function bY(t, e, n) {
    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12] * n, t[13] = e[13] * n, t[14] = e[14] * n, t[15] = e[15] * n, t;
  }
  function DY(t, e, n, r) {
    return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t[9] = e[9] + n[9] * r, t[10] = e[10] + n[10] * r, t[11] = e[11] + n[11] * r, t[12] = e[12] + n[12] * r, t[13] = e[13] + n[13] * r, t[14] = e[14] + n[14] * r, t[15] = e[15] + n[15] * r, t;
  }
  function MY(t, e) {
    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15];
  }
  function RY(t, e) {
    var n = t[0], r = t[1], i = t[2], a = t[3], s = t[4], o = t[5], l = t[6], c = t[7], f = t[8], u = t[9], h = t[10], g = t[11], v = t[12], m = t[13], y = t[14], w = t[15], C = e[0], T = e[1], S = e[2], E = e[3], b = e[4], D = e[5], R = e[6], I = e[7], O = e[8], L = e[9], N = e[10], F = e[11], V = e[12], k = e[13], _ = e[14], K = e[15];
    return Math.abs(n - C) <= xn * Math.max(1, Math.abs(n), Math.abs(C)) && Math.abs(r - T) <= xn * Math.max(1, Math.abs(r), Math.abs(T)) && Math.abs(i - S) <= xn * Math.max(1, Math.abs(i), Math.abs(S)) && Math.abs(a - E) <= xn * Math.max(1, Math.abs(a), Math.abs(E)) && Math.abs(s - b) <= xn * Math.max(1, Math.abs(s), Math.abs(b)) && Math.abs(o - D) <= xn * Math.max(1, Math.abs(o), Math.abs(D)) && Math.abs(l - R) <= xn * Math.max(1, Math.abs(l), Math.abs(R)) && Math.abs(c - I) <= xn * Math.max(1, Math.abs(c), Math.abs(I)) && Math.abs(f - O) <= xn * Math.max(1, Math.abs(f), Math.abs(O)) && Math.abs(u - L) <= xn * Math.max(1, Math.abs(u), Math.abs(L)) && Math.abs(h - N) <= xn * Math.max(1, Math.abs(h), Math.abs(N)) && Math.abs(g - F) <= xn * Math.max(1, Math.abs(g), Math.abs(F)) && Math.abs(v - V) <= xn * Math.max(1, Math.abs(v), Math.abs(V)) && Math.abs(m - k) <= xn * Math.max(1, Math.abs(m), Math.abs(k)) && Math.abs(y - _) <= xn * Math.max(1, Math.abs(y), Math.abs(_)) && Math.abs(w - K) <= xn * Math.max(1, Math.abs(w), Math.abs(K));
  }
  var vp = tn, OY = tM;
  const Th = Object.freeze(Object.defineProperty({
    __proto__: null,
    add: EY,
    adjoint: cY,
    clone: sY,
    copy: sr,
    create: L8,
    determinant: uY,
    equals: RY,
    exactEquals: MY,
    frob: AY,
    fromQuat: mp,
    fromQuat2: gY,
    fromRotation: YD,
    fromRotationTranslation: qD,
    fromRotationTranslationScale: ZD,
    fromRotationTranslationScaleOrigin: mY,
    fromScaling: k8,
    fromTranslation: _8,
    fromValues: oY,
    fromXRotation: fY,
    fromYRotation: hY,
    fromZRotation: dY,
    frustum: vY,
    getRotation: s6,
    getScaling: XD,
    getTranslation: pY,
    identity: gt,
    invert: Nr,
    lookAt: eM,
    mul: vp,
    multiply: tn,
    multiplyScalar: bY,
    multiplyScalarAndAdd: DY,
    ortho: $D,
    orthoNO: JD,
    orthoZO: CY,
    perspective: yY,
    perspectiveFromFieldOfView: wY,
    perspectiveNO: QD,
    perspectiveZO: xY,
    rotate: $a,
    rotateX: U8,
    rotateY: F8,
    rotateZ: B8,
    scale: Fl,
    set: lY,
    str: SY,
    sub: OY,
    subtract: tM,
    targetTo: TY,
    translate: $n,
    transpose: en
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function nM() {
    var t = new ei(3);
    return ei != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
  }
  function yu(t) {
    var e = t[0], n = t[1], r = t[2];
    return Math.hypot(e, n, r);
  }
  function fT(t, e, n) {
    var r = new ei(3);
    return r[0] = t, r[1] = e, r[2] = n, r;
  }
  function Vn(t, e, n, r) {
    return t[0] = e, t[1] = n, t[2] = r, t;
  }
  function K1(t, e, n) {
    return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t;
  }
  function bl(t, e, n) {
    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t;
  }
  function IY(t, e, n) {
    return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t;
  }
  function VY(t, e, n) {
    return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t;
  }
  function so(t, e, n) {
    return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t;
  }
  function rM(t, e) {
    return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t;
  }
  function cs(t, e) {
    var n = e[0], r = e[1], i = e[2], a = n * n + r * r + i * i;
    return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t;
  }
  function Sh(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
  }
  function xu(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = n[0], o = n[1], l = n[2];
    return t[0] = i * l - a * o, t[1] = a * s - r * l, t[2] = r * o - i * s, t;
  }
  function $t(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = n[3] * r + n[7] * i + n[11] * a + n[15];
    return s = s || 1, t[0] = (n[0] * r + n[4] * i + n[8] * a + n[12]) / s, t[1] = (n[1] * r + n[5] * i + n[9] * a + n[13]) / s, t[2] = (n[2] * r + n[6] * i + n[10] * a + n[14]) / s, t;
  }
  function Ug(t, e, n) {
    var r = e[0], i = e[1], a = e[2];
    return t[0] = r * n[0] + i * n[3] + a * n[6], t[1] = r * n[1] + i * n[4] + a * n[7], t[2] = r * n[2] + i * n[5] + a * n[8], t;
  }
  function NY(t) {
    return t[0] = 0, t[1] = 0, t[2] = 0, t;
  }
  function hT(t, e) {
    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
  }
  function dT(t, e) {
    var n = t[0], r = t[1], i = t[2], a = e[0], s = e[1], o = e[2];
    return Math.abs(n - a) <= xn * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - s) <= xn * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - o) <= xn * Math.max(1, Math.abs(i), Math.abs(o));
  }
  var o6 = bl, LY = IY, iM = yu;
  (function() {
    var t = nM();
    return function(e, n, r, i, a, s) {
      var o, l;
      for (n || (n = 3), r || (r = 0), i ? l = Math.min(i * n + r, e.length) : l = e.length, o = r; o < l; o += n) t[0] = e[o], t[1] = e[o + 1], t[2] = e[o + 2], a(t, t, s), e[o] = t[0], e[o + 1] = t[1], e[o + 2] = t[2];
      return e;
    };
  })();
  function UY() {
    var t = new ei(4);
    return ei != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
  }
  function FY(t, e, n, r) {
    var i = new ei(4);
    return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i;
  }
  function gT(t, e, n) {
    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t;
  }
  function BY(t, e) {
    var n = e[0], r = e[1], i = e[2], a = e[3], s = n * n + r * r + i * i + a * a;
    return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = n * s, t[1] = r * s, t[2] = i * s, t[3] = a * s, t;
  }
  function Nc(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3];
    return t[0] = n[0] * r + n[4] * i + n[8] * a + n[12] * s, t[1] = n[1] * r + n[5] * i + n[9] * a + n[13] * s, t[2] = n[2] * r + n[6] * i + n[10] * a + n[14] * s, t[3] = n[3] * r + n[7] * i + n[11] * a + n[15] * s, t;
  }
  (function() {
    var t = UY();
    return function(e, n, r, i, a, s) {
      var o, l;
      for (n || (n = 4), r || (r = 0), i ? l = Math.min(i * n + r, e.length) : l = e.length, o = r; o < l; o += n) t[0] = e[o], t[1] = e[o + 1], t[2] = e[o + 2], t[3] = e[o + 3], a(t, t, s), e[o] = t[0], e[o + 1] = t[1], e[o + 2] = t[2], e[o + 3] = t[3];
      return e;
    };
  })();
  function jc() {
    var t = new ei(4);
    return ei != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
  }
  function P8(t, e, n) {
    n = n * 0.5;
    var r = Math.sin(n);
    return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = Math.cos(n), t;
  }
  function _Y(t, e) {
    var n = Math.acos(e[3]) * 2, r = Math.sin(n / 2);
    return r > xn ? (t[0] = e[0] / r, t[1] = e[1] / r, t[2] = e[2] / r) : (t[0] = 1, t[1] = 0, t[2] = 0), n;
  }
  function pT(t, e, n) {
    var r = e[0], i = e[1], a = e[2], s = e[3], o = n[0], l = n[1], c = n[2], f = n[3];
    return t[0] = r * f + s * o + i * c - a * l, t[1] = i * f + s * l + a * o - r * c, t[2] = a * f + s * c + r * l - i * o, t[3] = s * f - r * o - i * l - a * c, t;
  }
  function Fg(t, e, n, r) {
    var i = e[0], a = e[1], s = e[2], o = e[3], l = n[0], c = n[1], f = n[2], u = n[3], h, g, v, m, y;
    return g = i * l + a * c + s * f + o * u, g < 0 && (g = -g, l = -l, c = -c, f = -f, u = -u), 1 - g > xn ? (h = Math.acos(g), v = Math.sin(h), m = Math.sin((1 - r) * h) / v, y = Math.sin(r * h) / v) : (m = 1 - r, y = r), t[0] = m * i + y * l, t[1] = m * a + y * c, t[2] = m * s + y * f, t[3] = m * o + y * u, t;
  }
  function kY(t, e) {
    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
  }
  function PY(t, e) {
    var n = e[0] + e[4] + e[8], r;
    if (n > 0) r = Math.sqrt(n + 1), t[3] = 0.5 * r, r = 0.5 / r, t[0] = (e[5] - e[7]) * r, t[1] = (e[6] - e[2]) * r, t[2] = (e[1] - e[3]) * r;
    else {
      var i = 0;
      e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
      var a = (i + 1) % 3, s = (i + 2) % 3;
      r = Math.sqrt(e[i * 3 + i] - e[a * 3 + a] - e[s * 3 + s] + 1), t[i] = 0.5 * r, r = 0.5 / r, t[3] = (e[a * 3 + s] - e[s * 3 + a]) * r, t[a] = (e[a * 3 + i] + e[i * 3 + a]) * r, t[s] = (e[s * 3 + i] + e[i * 3 + s]) * r;
    }
    return t;
  }
  var mT = FY, aM = BY;
  (function() {
    var t = nM(), e = fT(1, 0, 0), n = fT(0, 1, 0);
    return function(r, i, a) {
      var s = Sh(i, a);
      return s < -0.999999 ? (xu(t, e, i), iM(t) < 1e-6 && xu(t, n, i), cs(t, t), P8(r, t, Math.PI), r) : s > 0.999999 ? (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r) : (xu(t, i, a), r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = 1 + s, aM(r, r));
    };
  })();
  (function() {
    var t = jc(), e = jc();
    return function(n, r, i, a, s, o) {
      return Fg(t, r, s, o), Fg(e, i, a, o), Fg(n, t, e, 2 * o * (1 - o)), n;
    };
  })();
  (function() {
    var t = HD();
    return function(e, n, r, i) {
      return t[0] = r[0], t[3] = r[1], t[6] = r[2], t[1] = i[0], t[4] = i[1], t[7] = i[2], t[2] = -n[0], t[5] = -n[1], t[8] = -n[2], aM(e, PY(e, t));
    };
  })();
  const l6 = 1e-6, sM = "coincide", oM = "disjoint";
  function GY(t, e, n) {
    return t[0] * (n[0] - e[0]) + t[1] * (n[1] - e[1]) + t[2] * (n[2] - e[2]);
  }
  function lM(t, e, n) {
    const r = n[0] * (t[0] - e[0]) + n[1] * (t[1] - e[1]) + n[2] * (t[2] - e[2]);
    return Math.abs(r);
  }
  function cM(t, e, n, r) {
    const i = [];
    xo(t, e, i);
    const a = Ht(n, i);
    r[0] = t[0] - a * n[0], r[1] = t[1] - a * n[1], r[2] = t[2] - a * n[2];
  }
  function uM(t, e, n) {
    const r = Ht(t, e);
    let i = Ht(e, e);
    return i === 0 && (i = 1), n[0] = t[0] - r * e[0] / i, n[1] = t[1] - r * e[1] / i, n[2] = t[2] - r * e[2] / i, n;
  }
  function fM(t, e, n, r) {
    const i = [];
    xo(t, e, i);
    const a = Ht(n, i), s = Ht(n, n);
    s !== 0 ? (r[0] = t[0] - a * n[0] / s, r[1] = t[1] - a * n[1] / s, r[2] = t[2] - a * n[2] / s) : (r[0] = t[0], r[1] = t[1], r[2] = t[2]);
  }
  function hM(t, e, n, r) {
    const i = {
      intersection: false,
      betweenPoints: false,
      t: Number.MAX_VALUE,
      x: []
    }, a = [], s = [];
    xo(e, t, a), xo(n, t, s);
    const o = Ht(r, s), l = Ht(r, a);
    let c, f;
    return l < 0 ? c = -l : c = l, o < 0 ? f = -o * l6 : f = o * l6, c <= f || (i.t = o / l, i.x[0] = t[0] + i.t * a[0], i.x[1] = t[1] + i.t * a[1], i.x[2] = t[2] + i.t * a[2], i.intersection = true, i.betweenPoints = i.t >= 0 && i.t <= 1), i;
  }
  function dM(t, e, n, r) {
    const i = {
      intersection: false,
      l0: [],
      l1: [],
      error: null
    }, a = [];
    Ns(e, r, a);
    const s = a.map((u) => Math.abs(u));
    if (s[0] + s[1] + s[2] < l6) {
      const u = [];
      return xo(t, n, u), Ht(e, u) === 0 ? i.error = sM : i.error = oM, i;
    }
    let o;
    s[0] > s[1] && s[0] > s[2] ? o = "x" : s[1] > s[2] ? o = "y" : o = "z";
    const l = [], c = -Ht(e, t), f = -Ht(r, n);
    switch (o) {
      case "x":
        l[0] = 0, l[1] = (f * e[2] - c * r[2]) / a[0], l[2] = (c * r[1] - f * e[1]) / a[0];
        break;
      case "y":
        l[0] = (c * r[2] - f * e[2]) / a[1], l[1] = 0, l[2] = (f * e[0] - c * r[0]) / a[1];
        break;
      case "z":
        l[0] = (f * e[1] - c * r[1]) / a[2], l[1] = (c * r[0] - f * e[0]) / a[2], l[2] = 0;
        break;
    }
    return i.l0 = l, lp(l, a, i.l1), i.intersection = true, i;
  }
  const zY = {
    evaluate: GY,
    distanceToPlane: lM,
    projectPoint: cM,
    projectVector: uM,
    generalizedProjectPoint: fM,
    intersectWithLine: hM,
    intersectWithPlane: dM,
    DISJOINT: oM,
    COINCIDE: sM
  };
  function WY(t, e) {
    e.classHierarchy.push("vtkPlane"), t.distanceToPlane = (n) => lM(n, e.origin, e.normal), t.projectPoint = (n, r) => {
      cM(n, e.origin, e.normal, r);
    }, t.projectVector = (n, r) => uM(n, e.normal, r), t.push = (n) => {
      if (n !== 0) for (let r = 0; r < 3; r++) e.origin[r] += n * e.normal[r];
    }, t.generalizedProjectPoint = (n, r) => {
      fM(n, e.origin, e.normal, r);
    }, t.evaluateFunction = (n, r, i) => Array.isArray(n) ? e.normal[0] * (n[0] - e.origin[0]) + e.normal[1] * (n[1] - e.origin[1]) + e.normal[2] * (n[2] - e.origin[2]) : e.normal[0] * (n - e.origin[0]) + e.normal[1] * (r - e.origin[1]) + e.normal[2] * (i - e.origin[2]), t.evaluateGradient = (n) => [
      e.normal[0],
      e.normal[1],
      e.normal[2]
    ], t.intersectWithLine = (n, r) => hM(n, r, e.origin, e.normal), t.intersectWithPlane = (n, r) => dM(n, r, e.origin, e.normal);
  }
  const HY = {
    normal: [
      0,
      0,
      1
    ],
    origin: [
      0,
      0,
      0
    ]
  };
  function gM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, HY, n), H.obj(t, e), H.setGetArray(t, e, [
      "normal",
      "origin"
    ], 3), WY(t, e);
  }
  const jY = H.newInstance(gM, "vtkPlane");
  var Si = {
    newInstance: jY,
    extend: gM,
    ...zY
  };
  const x5 = [
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE
  ];
  function pM(t, e) {
    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5];
  }
  function Eo(t) {
    return (t == null ? void 0 : t.length) >= 6 && t[0] <= t[1] && t[2] <= t[3] && t[4] <= t[5];
  }
  function G8(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
  }
  function z8(t) {
    return G8(t, x5);
  }
  function yp(t, e, n, r) {
    const [i, a, s, o, l, c] = t;
    return t[0] = i < e ? i : e, t[1] = a > e ? a : e, t[2] = s < n ? s : n, t[3] = o > n ? o : n, t[4] = l < r ? l : r, t[5] = c > r ? c : r, t;
  }
  function W8(t, e) {
    if (e.length === 0) return t;
    if (Array.isArray(e[0])) for (let n = 0; n < e.length; ++n) yp(t, ...e[n]);
    else for (let n = 0; n < e.length; n += 3) yp(t, ...e.slice(n, n + 3));
    return t;
  }
  function mM(t, e, n, r, i, a, s) {
    const [o, l, c, f, u, h] = t;
    return s === void 0 ? (t[0] = Math.min(e[0], o), t[1] = Math.max(e[1], l), t[2] = Math.min(e[2], c), t[3] = Math.max(e[3], f), t[4] = Math.min(e[4], u), t[5] = Math.max(e[5], h)) : (t[0] = Math.min(e, o), t[1] = Math.max(n, l), t[2] = Math.min(r, c), t[3] = Math.max(i, f), t[4] = Math.min(a, u), t[5] = Math.max(s, h)), t;
  }
  function vM(t, e, n, r) {
    const [i, a, s, o, l, c] = t;
    return t[0] = e, t[1] = e > a ? e : a, t[2] = n, t[3] = n > o ? n : o, t[4] = r, t[5] = r > c ? r : c, i !== e || s !== n || l !== r;
  }
  function yM(t, e, n, r) {
    const [i, a, s, o, l, c] = t;
    return t[0] = e < i ? e : i, t[1] = e, t[2] = n < s ? n : s, t[3] = n, t[4] = r < l ? r : l, t[5] = r, a !== e || o !== n || c !== r;
  }
  function xM(t, e) {
    return t[0] -= e, t[1] += e, t[2] -= e, t[3] += e, t[4] -= e, t[5] += e, t;
  }
  function H8(t, e, n, r) {
    return Eo(t) ? (e >= 0 ? (t[0] *= e, t[1] *= e) : (t[0] = e * t[1], t[1] = e * t[0]), n >= 0 ? (t[2] *= n, t[3] *= n) : (t[2] = n * t[3], t[3] = n * t[2]), r >= 0 ? (t[4] *= r, t[5] *= r) : (t[4] = r * t[5], t[5] = r * t[4]), true) : false;
  }
  function j8(t) {
    return [
      0.5 * (t[0] + t[1]),
      0.5 * (t[2] + t[3]),
      0.5 * (t[4] + t[5])
    ];
  }
  function KY(t, e, n, r) {
    if (!Eo(t)) return false;
    const i = j8(t);
    return t[0] -= i[0], t[1] -= i[0], t[2] -= i[1], t[3] -= i[1], t[4] -= i[2], t[5] -= i[2], H8(t, e, n, r), t[0] += i[0], t[1] += i[0], t[2] += i[1], t[3] += i[1], t[4] += i[2], t[5] += i[2], true;
  }
  function hh(t, e) {
    return t[e * 2 + 1] - t[e * 2];
  }
  function w5(t) {
    return [
      hh(t, 0),
      hh(t, 1),
      hh(t, 2)
    ];
  }
  function wM(t) {
    return t.slice(0, 2);
  }
  function CM(t) {
    return t.slice(2, 4);
  }
  function TM(t) {
    return t.slice(4, 6);
  }
  function SM(t) {
    const e = w5(t);
    return e[0] > e[1] ? e[0] > e[2] ? e[0] : e[2] : e[1] > e[2] ? e[1] : e[2];
  }
  function AM(t) {
    if (Eo(t)) {
      const e = w5(t);
      return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
    }
    return null;
  }
  function K8(t) {
    return [
      t[0],
      t[2],
      t[4]
    ];
  }
  function Y8(t) {
    return [
      t[1],
      t[3],
      t[5]
    ];
  }
  function I2(t, e) {
    return t <= 0 && e >= 0 || t >= 0 && e <= 0;
  }
  function q8(t, e) {
    let n = 0;
    for (let r = 0; r < 2; r++) for (let i = 2; i < 4; i++) for (let a = 4; a < 6; a++) e[n++] = [
      t[r],
      t[i],
      t[a]
    ];
    return e;
  }
  function EM(t, e, n) {
    return e[0] = t[0], e[1] = t[2], e[2] = t[4], n[0] = t[1], n[1] = t[3], n[2] = t[5], e;
  }
  function bM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    const r = q8(t, []);
    for (let i = 0; i < r.length; ++i) $t(r[i], r[i], e);
    return z8(n), W8(n, r);
  }
  function DM(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return e[0] = 0.5 * (t[1] - t[0]), e[1] = 0.5 * (t[3] - t[2]), e[2] = 0.5 * (t[5] - t[4]), e;
  }
  function MM(t, e, n, r) {
    const i = [].concat(x5), a = t.getData();
    for (let s = 0; s < a.length; s += 3) {
      const o = [
        a[s],
        a[s + 1],
        a[s + 2]
      ], l = Ht(o, e);
      i[0] = Math.min(l, i[0]), i[1] = Math.max(l, i[1]);
      const c = Ht(o, n);
      i[2] = Math.min(c, i[2]), i[3] = Math.max(c, i[3]);
      const f = Ht(o, r);
      i[4] = Math.min(f, i[4]), i[5] = Math.max(f, i[5]);
    }
    return i;
  }
  function RM(t, e, n, r, i) {
    let a = true;
    const s = [];
    let o = 0;
    const l = [], c = [
      0,
      0,
      0
    ], f = 0, u = 1, h = 2;
    for (let g = 0; g < 3; g++) e[g] < t[2 * g] ? (s[g] = u, c[g] = t[2 * g], a = false) : e[g] > t[2 * g + 1] ? (s[g] = f, c[g] = t[2 * g + 1], a = false) : s[g] = h;
    if (a) return r[0] = e[0], r[1] = e[1], r[2] = e[2], i[0] = 0, 1;
    for (let g = 0; g < 3; g++) s[g] !== h && n[g] !== 0 ? l[g] = (c[g] - e[g]) / n[g] : l[g] = -1;
    for (let g = 0; g < 3; g++) l[o] < l[g] && (o = g);
    if (l[o] > 1 || l[o] < 0) return 0;
    i[0] = l[o];
    for (let g = 0; g < 3; g++) if (o !== g) {
      if (r[g] = e[g] + l[o] * n[g], r[g] < t[2 * g] || r[g] > t[2 * g + 1]) return 0;
    } else r[g] = c[g];
    return 1;
  }
  function OM(t, e, n) {
    const r = [];
    let i = 0, a = 1, s = 1;
    for (let o = 4; o <= 5; ++o) {
      r[2] = t[o];
      for (let l = 2; l <= 3; ++l) {
        r[1] = t[l];
        for (let c = 0; c <= 1; ++c) if (r[0] = t[c], i = Si.evaluate(n, e, r), s && (a = i >= 0 ? 1 : -1, s = 0), i === 0 || a > 0 && i < 0 || a < 0 && i > 0) return 1;
      }
    }
    return 0;
  }
  function IM(t, e) {
    if (!(Eo(t) && Eo(e))) return false;
    const n = [
      0,
      0,
      0,
      0,
      0,
      0
    ];
    let r;
    for (let i = 0; i < 3; i++) if (r = false, e[i * 2] >= t[i * 2] && e[i * 2] <= t[i * 2 + 1] ? (r = true, n[i * 2] = e[i * 2]) : t[i * 2] >= e[i * 2] && t[i * 2] <= e[i * 2 + 1] && (r = true, n[i * 2] = t[i * 2]), e[i * 2 + 1] >= t[i * 2] && e[i * 2 + 1] <= t[i * 2 + 1] ? (r = true, n[i * 2 + 1] = e[2 * i + 1]) : t[i * 2 + 1] >= e[i * 2] && t[i * 2 + 1] <= e[i * 2 + 1] && (r = true, n[i * 2 + 1] = t[i * 2 + 1]), !r) return false;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], true;
  }
  function xp(t, e) {
    if (!(Eo(t) && Eo(e))) return false;
    for (let n = 0; n < 3; n++) if (!(e[n * 2] >= t[n * 2] && e[n * 2] <= t[n * 2 + 1]) && !(t[n * 2] >= e[n * 2] && t[n * 2] <= e[n * 2 + 1]) && !(e[n * 2 + 1] >= t[n * 2] && e[n * 2 + 1] <= t[n * 2 + 1]) && !(t[n * 2 + 1] >= e[n * 2] && t[n * 2 + 1] <= e[n * 2 + 1])) return false;
    return true;
  }
  function wp(t, e, n, r) {
    return !(e < t[0] || e > t[1] || n < t[2] || n > t[3] || r < t[4] || r > t[5]);
  }
  function YY(t, e) {
    return !(!xp(t, e) || !wp(t, ...K8(e)) || !wp(t, ...Y8(e)));
  }
  function VM(t, e, n) {
    const r = [
      [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      [
        0,
        1,
        4,
        5,
        2,
        3,
        6,
        7
      ],
      [
        0,
        2,
        4,
        6,
        1,
        3,
        5,
        7
      ]
    ], i = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    let a = 0;
    for (let u = 0; u < 2; u++) for (let h = 2; h < 4; h++) for (let g = 4; g < 6; g++) {
      const v = [
        t[u],
        t[h],
        t[g]
      ];
      i[a++] = Si.evaluate(n, e, v);
    }
    let s = 2;
    for (; s-- && !(I2(i[r[s][0]], i[r[s][4]]) && I2(i[r[s][1]], i[r[s][5]]) && I2(i[r[s][2]], i[r[s][6]]) && I2(i[r[s][3]], i[r[s][7]])); ) ;
    if (s < 0) return false;
    const o = Math.sign(n[s]), l = Math.abs((t[s * 2 + 1] - t[s * 2]) * n[s]);
    let c = o > 0 ? 1 : 0;
    for (let u = 0; u < 4; u++) {
      if (l === 0) continue;
      const h = Math.abs(i[r[s][u]]) / l;
      o > 0 && h < c && (c = h), o < 0 && h > c && (c = h);
    }
    const f = (1 - c) * t[s * 2] + c * t[s * 2 + 1];
    return o > 0 ? t[s * 2] = f : t[s * 2 + 1] = f, true;
  }
  class qY {
    constructor(e) {
      this.bounds = e, this.bounds || (this.bounds = new Float64Array(x5));
    }
    getBounds() {
      return this.bounds;
    }
    equals(e) {
      return pM(this.bounds, e);
    }
    isValid() {
      return Eo(this.bounds);
    }
    setBounds(e) {
      return G8(this.bounds, e);
    }
    reset() {
      return z8(this.bounds);
    }
    addPoint() {
      for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
      return yp(this.bounds, ...n);
    }
    addPoints(e) {
      return W8(this.bounds, e);
    }
    addBounds(e, n, r, i, a, s) {
      return mM(this.bounds, e, n, r, i, a, s);
    }
    setMinPoint(e, n, r) {
      return vM(this.bounds, e, n, r);
    }
    setMaxPoint(e, n, r) {
      return yM(this.bounds, e, n, r);
    }
    inflate(e) {
      return xM(this.bounds, e);
    }
    scale(e, n, r) {
      return H8(this.bounds, e, n, r);
    }
    getCenter() {
      return j8(this.bounds);
    }
    getLength(e) {
      return hh(this.bounds, e);
    }
    getLengths() {
      return w5(this.bounds);
    }
    getMaxLength() {
      return SM(this.bounds);
    }
    getDiagonalLength() {
      return AM(this.bounds);
    }
    getMinPoint() {
      return K8(this.bounds);
    }
    getMaxPoint() {
      return Y8(this.bounds);
    }
    getXRange() {
      return wM(this.bounds);
    }
    getYRange() {
      return CM(this.bounds);
    }
    getZRange() {
      return TM(this.bounds);
    }
    getCorners(e) {
      return q8(this.bounds, e);
    }
    computeCornerPoints(e, n) {
      return EM(this.bounds, e, n);
    }
    computeLocalBounds(e, n, r) {
      return MM(this.bounds, e, n, r);
    }
    transformBounds(e) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return bM(this.bounds, e, n);
    }
    computeScale3(e) {
      return DM(this.bounds, e);
    }
    cutWithPlane(e, n) {
      return VM(this.bounds, e, n);
    }
    intersectBox(e, n, r, i) {
      return RM(this.bounds, e, n, r, i);
    }
    intersectPlane(e, n) {
      return OM(this.bounds, e, n);
    }
    intersect(e) {
      return IM(this.bounds, e);
    }
    intersects(e) {
      return xp(this.bounds, e);
    }
    containsPoint(e, n, r) {
      return wp(this.bounds, e, n, r);
    }
    contains(e) {
      return xp(this.bounds, e);
    }
  }
  function XY(t) {
    const e = t && t.bounds;
    return new qY(e);
  }
  const ZY = {
    equals: pM,
    isValid: Eo,
    setBounds: G8,
    reset: z8,
    addPoint: yp,
    addPoints: W8,
    addBounds: mM,
    setMinPoint: vM,
    setMaxPoint: yM,
    inflate: xM,
    scale: H8,
    scaleAboutCenter: KY,
    getCenter: j8,
    getLength: hh,
    getLengths: w5,
    getMaxLength: SM,
    getDiagonalLength: AM,
    getMinPoint: K8,
    getMaxPoint: Y8,
    getXRange: wM,
    getYRange: CM,
    getZRange: TM,
    getCorners: q8,
    computeCornerPoints: EM,
    computeLocalBounds: MM,
    transformBounds: bM,
    computeScale3: DM,
    cutWithPlane: VM,
    intersectBox: RM,
    intersectPlane: OM,
    intersect: IM,
    intersects: xp,
    containsPoint: wp,
    contains: YY,
    INIT_BOUNDS: x5
  };
  var En = {
    newInstance: XY,
    ...ZY
  };
  const { vtkErrorMacro: vT, vtkWarningMacro: QY } = H;
  function JY(t, e) {
    e.classHierarchy.push("vtkFieldData");
    const n = t.getState;
    e.arrays && (e.arrays = e.arrays.map((r) => ({
      data: ss(r.data)
    }))), t.initialize = () => {
      t.initializeFields(), t.copyAllOn(), t.clearFieldFlags();
    }, t.initializeFields = () => {
      e.arrays = [], e.copyFieldFlags = {}, t.modified();
    }, t.copyStructure = (r) => {
      t.initializeFields(), e.copyFieldFlags = r.getCopyFieldFlags().map((i) => i), e.arrays = r.arrays().map((i) => ({
        array: i
      }));
    }, t.getNumberOfArrays = () => e.arrays.length, t.getNumberOfActiveArrays = () => e.arrays.length, t.addArray = (r) => {
      const i = r.getName(), { array: a, index: s } = t.getArrayWithIndex(i);
      return a != null ? (e.arrays[s] = {
        data: r
      }, s) : (e.arrays = [].concat(e.arrays, {
        data: r
      }), e.arrays.length - 1);
    }, t.removeAllArrays = () => {
      e.arrays = [];
    }, t.removeArray = (r) => {
      const i = e.arrays.findIndex((a) => a.data.getName() === r);
      return t.removeArrayByIndex(i);
    }, t.removeArrayByIndex = (r) => r !== -1 && r < e.arrays.length ? (e.arrays.splice(r, 1), true) : false, t.getArrays = () => e.arrays.map((r) => r.data), t.getArray = (r) => typeof r == "number" ? t.getArrayByIndex(r) : t.getArrayByName(r), t.getArrayByName = (r) => e.arrays.reduce((i, a, s) => a.data.getName() === r ? a.data : i, null), t.getArrayWithIndex = (r) => {
      const i = e.arrays.findIndex((a) => a.data.getName() === r);
      return {
        array: i !== -1 ? e.arrays[i].data : null,
        index: i
      };
    }, t.getArrayByIndex = (r) => r >= 0 && r < e.arrays.length ? e.arrays[r].data : null, t.hasArray = (r) => t.getArrayWithIndex(r).index >= 0, t.getArrayName = (r) => {
      const i = e.arrays[r];
      return i ? i.data.getName() : "";
    }, t.getCopyFieldFlags = () => e.copyFieldFlags, t.getFlag = (r) => e.copyFieldFlags[r], t.passData = function(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      r.getArrays().forEach((s) => {
        const o = t.getFlag(s.getName());
        if (o !== false && !(e.doCopyAllOff && o !== true) && s) {
          let l = t.getArrayByName(s.getName());
          if (l) if (s.getNumberOfComponents() === l.getNumberOfComponents()) if (i > -1 && i < s.getNumberOfTuples()) {
            const c = a > -1 ? a : i;
            l.insertTuple(c, s.getTuple(i));
          } else l.insertTuples(0, s.getTuples());
          else vT("Unhandled case in passData");
          else if (i < 0 || i > s.getNumberOfTuples()) t.addArray(s), r.getAttributes(s).forEach((c) => {
            t.setAttribute(s, c);
          });
          else {
            const c = s.getNumberOfComponents();
            let f = s.getNumberOfValues();
            const u = a > -1 ? a : i;
            f <= u * c && (f = (u + 1) * c), l = Tt.newInstance({
              name: s.getName(),
              dataType: s.getDataType(),
              numberOfComponents: c,
              values: H.newTypedArray(s.getDataType(), f),
              size: 0
            }), l.insertTuple(u, s.getTuple(i)), t.addArray(l), r.getAttributes(s).forEach((h) => {
              t.setAttribute(l, h);
            });
          }
        }
      });
    }, t.interpolateData = function(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
      r.getArrays().forEach((l) => {
        const c = t.getFlag(l.getName());
        if (c !== false && !(e.doCopyAllOff && c !== true) && l) {
          let f = t.getArrayByName(l.getName());
          if (f) if (l.getNumberOfComponents() === f.getNumberOfComponents()) if (i > -1 && i < l.getNumberOfTuples()) {
            const u = s > -1 ? s : i;
            f.interpolateTuple(u, l, i, l, a, o), QY("Unexpected case in interpolateData");
          } else f.insertTuples(l.getTuples());
          else vT("Unhandled case in interpolateData");
          else if (i < 0 || a < 0 || i > l.getNumberOfTuples()) t.addArray(l), r.getAttributes(l).forEach((u) => {
            t.setAttribute(l, u);
          });
          else {
            const u = l.getNumberOfComponents();
            let h = l.getNumberOfValues();
            const g = s > -1 ? s : i;
            h <= g * u && (h = (g + 1) * u), f = Tt.newInstance({
              name: l.getName(),
              dataType: l.getDataType(),
              numberOfComponents: u,
              values: H.newTypedArray(l.getDataType(), h),
              size: 0
            }), f.interpolateTuple(g, l, i, l, a, o), t.addArray(f), r.getAttributes(l).forEach((v) => {
              t.setAttribute(f, v);
            });
          }
        }
      });
    }, t.copyFieldOn = (r) => {
      e.copyFieldFlags[r] = true;
    }, t.copyFieldOff = (r) => {
      e.copyFieldFlags[r] = false;
    }, t.copyAllOn = () => {
      (!e.doCopyAllOn || e.doCopyAllOff) && (e.doCopyAllOn = true, e.doCopyAllOff = false, t.modified());
    }, t.copyAllOff = () => {
      (e.doCopyAllOn || !e.doCopyAllOff) && (e.doCopyAllOn = false, e.doCopyAllOff = true, t.modified());
    }, t.clearFieldFlags = () => {
      e.copyFieldFlags = {};
    }, t.deepCopy = (r) => {
      e.arrays = r.getArrays().map((i) => {
        const a = i.newClone();
        return a.deepCopy(i), {
          data: a
        };
      });
    }, t.copyFlags = (r) => r.getCopyFieldFlags().map((i) => i), t.reset = () => e.arrays.forEach((r) => r.data.reset()), t.getMTime = () => e.arrays.reduce((r, i) => i.data.getMTime() > r ? i.data.getMTime() : r, e.mtime), t.getNumberOfComponents = () => e.arrays.reduce((r, i) => r + i.data.getNumberOfComponents(), 0), t.getNumberOfTuples = () => e.arrays.length > 0 ? e.arrays[0].getNumberOfTuples() : 0, t.getState = () => {
      const r = n();
      return r && (r.arrays = e.arrays.map((i) => ({
        data: i.data.getState()
      }))), r;
    };
  }
  const $Y = {
    arrays: [],
    copyFieldFlags: [],
    doCopyAllOn: true,
    doCopyAllOff: false
  };
  function NM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, $Y, n), H.obj(t, e), JY(t, e);
  }
  const eq = H.newInstance(NM, "vtkFieldData");
  var tq = {
    newInstance: eq,
    extend: NM
  };
  const nq = {
    SCALARS: 0,
    VECTORS: 1,
    NORMALS: 2,
    TCOORDS: 3,
    TENSORS: 4,
    GLOBALIDS: 5,
    PEDIGREEIDS: 6,
    EDGEFLAG: 7,
    NUM_ATTRIBUTES: 8
  }, rq = {
    MAX: 0,
    EXACT: 1,
    NOLIMIT: 2
  }, iq = {
    DUPLICATECELL: 1,
    HIGHCONNECTIVITYCELL: 2,
    LOWCONNECTIVITYCELL: 4,
    REFINEDCELL: 8,
    EXTERIORCELL: 16,
    HIDDENCELL: 32
  }, aq = {
    DUPLICATEPOINT: 1,
    HIDDENPOINT: 2
  }, sq = {
    COPYTUPLE: 0,
    INTERPOLATE: 1,
    PASSDATA: 2,
    ALLCOPY: 3
  }, oq = "vtkGhostType", lq = {
    DEFAULT: 0,
    SINGLE: 1,
    DOUBLE: 2
  };
  var LM = {
    AttributeCopyOperations: sq,
    AttributeLimitTypes: rq,
    AttributeTypes: nq,
    CellGhostTypes: iq,
    DesiredOutputPrecision: lq,
    PointGhostTypes: aq,
    ghostArrayName: oq
  };
  const { AttributeTypes: ll, AttributeCopyOperations: dc } = LM, { vtkWarningMacro: V2 } = H;
  function cq(t, e) {
    const n = [
      "Scalars",
      "Vectors",
      "Normals",
      "TCoords",
      "Tensors",
      "GlobalIds",
      "PedigreeIds"
    ];
    function r(s) {
      let o = n.find((l) => ll[l.toUpperCase()] === s || typeof s != "number" && l.toLowerCase() === s.toLowerCase());
      return typeof o > "u" && (o = null), o;
    }
    e.classHierarchy.push("vtkDataSetAttributes");
    const i = {
      ...t
    };
    t.checkNumberOfComponents = (s) => true, t.setAttribute = (s, o) => {
      const l = r(o);
      if (s && l.toUpperCase() === "PEDIGREEIDS" && !s.isA("vtkDataArray")) return V2(`Cannot set attribute ${l}. The attribute must be a vtkDataArray.`), -1;
      if (s && !t.checkNumberOfComponents(s, l)) return V2(`Cannot set attribute ${l}. Incorrect number of components.`), -1;
      let c = e[`active${l}`];
      if (c >= 0 && c < e.arrays.length) {
        if (e.arrays[c] === s) return c;
        t.removeArrayByIndex(c);
      }
      return s ? (c = t.addArray(s), e[`active${l}`] = c) : e[`active${l}`] = -1, t.modified(), e[`active${l}`];
    }, t.getAttributes = (s) => n.filter((o) => t[`get${o}`]() === s), t.setActiveAttributeByName = (s, o) => t.setActiveAttributeByIndex(t.getArrayWithIndex(s).index, o), t.setActiveAttributeByIndex = (s, o) => {
      const l = r(o);
      if (s >= 0 && s < e.arrays.length) {
        if (l.toUpperCase() !== "PEDIGREEIDS") {
          const c = t.getArrayByIndex(s);
          if (!c.isA("vtkDataArray")) return V2(`Cannot set attribute ${l}. Only vtkDataArray subclasses can be set as active attributes.`), -1;
          if (!t.checkNumberOfComponents(c, l)) return V2(`Cannot set attribute ${l}. Incorrect number of components.`), -1;
        }
        return e[`active${l}`] = s, t.modified(), s;
      }
      return s === -1 && (e[`active${l}`] = s, t.modified()), -1;
    }, t.getActiveAttribute = (s) => {
      const o = r(s);
      return t[`get${o}`]();
    }, t.removeAllArrays = () => {
      n.forEach((s) => {
        e[`active${s}`] = -1;
      }), i.removeAllArrays();
    }, t.removeArrayByIndex = (s) => (s !== -1 && n.forEach((o) => {
      s === e[`active${o}`] ? e[`active${o}`] = -1 : s < e[`active${o}`] && (e[`active${o}`] -= 1);
    }), i.removeArrayByIndex(s)), n.forEach((s) => {
      const o = `active${s}`;
      t[`get${s}`] = () => t.getArrayByIndex(e[o]), t[`set${s}`] = (l) => t.setAttribute(l, s), t[`setActive${s}`] = (l) => t.setActiveAttributeByIndex(t.getArrayWithIndex(l).index, s), t[`copy${s}Off`] = () => {
        const l = s.toUpperCase();
        e.copyAttributeFlags[dc.PASSDATA][ll[l]] = false;
      }, t[`copy${s}On`] = () => {
        const l = s.toUpperCase();
        e.copyAttributeFlags[dc.PASSDATA][ll[l]] = true;
      };
    }), t.initializeAttributeCopyFlags = () => {
      e.copyAttributeFlags = [], Object.keys(dc).filter((s) => s !== "ALLCOPY").forEach((s) => {
        e.copyAttributeFlags[dc[s]] = Object.keys(ll).filter((o) => o !== "NUM_ATTRIBUTES").reduce((o, l) => (o[ll[l]] = true, o), []);
      }), e.copyAttributeFlags[dc.COPYTUPLE][ll.GLOBALIDS] = false, e.copyAttributeFlags[dc.INTERPOLATE][ll.GLOBALIDS] = false, e.copyAttributeFlags[dc.COPYTUPLE][ll.PEDIGREEIDS] = false;
    }, t.initialize = H.chain(t.initialize, t.initializeAttributeCopyFlags), e.dataArrays && Object.keys(e.dataArrays).length && Object.keys(e.dataArrays).forEach((s) => {
      !e.dataArrays[s].ref && e.dataArrays[s].type === "vtkDataArray" && t.addArray(Tt.newInstance(e.dataArrays[s]));
    });
    const a = t.shallowCopy;
    t.shallowCopy = (s, o) => {
      a(s, o), e.arrays = s.getArrays().map((l) => {
        const c = l.newClone();
        return c.shallowCopy(l, o), {
          data: c
        };
      });
    }, t.initializeAttributeCopyFlags();
  }
  const uq = {
    activeScalars: -1,
    activeVectors: -1,
    activeTensors: -1,
    activeNormals: -1,
    activeTCoords: -1,
    activeGlobalIds: -1,
    activePedigreeIds: -1
  };
  function UM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, uq, n), tq.extend(t, e, n), H.setGet(t, e, [
      "activeScalars",
      "activeNormals",
      "activeTCoords",
      "activeVectors",
      "activeTensors",
      "activeGlobalIds",
      "activePedigreeIds"
    ]), e.arrays || (e.arrays = {}), cq(t, e);
  }
  const fq = H.newInstance(UM, "vtkDataSetAttributes");
  var yT = {
    newInstance: fq,
    extend: UM,
    ...LM
  };
  const hq = {
    UNIFORM: 0,
    DATA_OBJECT_FIELD: 0,
    COORDINATE: 1,
    POINT_DATA: 1,
    POINT: 2,
    POINT_FIELD_DATA: 2,
    CELL: 3,
    CELL_FIELD_DATA: 3,
    VERTEX: 4,
    VERTEX_FIELD_DATA: 4,
    EDGE: 5,
    EDGE_FIELD_DATA: 5,
    ROW: 6,
    ROW_DATA: 6
  }, dq = {
    FIELD_ASSOCIATION_POINTS: 0,
    FIELD_ASSOCIATION_CELLS: 1,
    FIELD_ASSOCIATION_NONE: 2,
    FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
    FIELD_ASSOCIATION_VERTICES: 4,
    FIELD_ASSOCIATION_EDGES: 5,
    FIELD_ASSOCIATION_ROWS: 6,
    NUMBER_OF_ASSOCIATIONS: 7
  };
  var gq = {
    FieldDataTypes: hq,
    FieldAssociations: dq
  };
  const c6 = [
    "pointData",
    "cellData",
    "fieldData"
  ];
  function pq(t, e) {
    e.classHierarchy.push("vtkDataSet"), c6.forEach((r) => {
      e[r] ? e[r] = ss(e[r]) : e[r] = yT.newInstance();
    });
    const n = t.shallowCopy;
    t.shallowCopy = function(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      n(r, i), c6.forEach((a) => {
        e[a] = yT.newInstance(), e[a].shallowCopy(r.getReferenceByName(a));
      });
    };
  }
  const mq = {};
  function FM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, mq, n), H.obj(t, e), H.setGet(t, e, c6), pq(t, e);
  }
  const vq = H.newInstance(FM, "vtkDataSet");
  var $u = {
    newInstance: vq,
    extend: FM,
    ...gq
  };
  const es = {
    UNCHANGED: 0,
    SINGLE_POINT: 1,
    X_LINE: 2,
    Y_LINE: 3,
    Z_LINE: 4,
    XY_PLANE: 5,
    YZ_PLANE: 6,
    XZ_PLANE: 7,
    XYZ_GRID: 8,
    EMPTY: 9
  };
  var BM = {
    StructuredType: es
  };
  const { StructuredType: no } = BM;
  function yq(t) {
    let e = 0;
    for (let n = 0; n < 3; ++n) t[n * 2] < t[n * 2 + 1] && e++;
    return t[0] > t[1] || t[2] > t[3] || t[4] > t[5] ? no.EMPTY : e === 3 ? no.XYZ_GRID : e === 2 ? t[0] === t[1] ? no.YZ_PLANE : t[2] === t[3] ? no.XZ_PLANE : no.XY_PLANE : e === 1 ? t[0] < t[1] ? no.X_LINE : t[2] < t[3] ? no.Y_LINE : no.Z_LINE : no.SINGLE_POINT;
  }
  var xq = {
    getDataDescriptionFromExtent: yq,
    ...BM
  };
  const { vtkErrorMacro: gc } = H;
  function wq(t, e) {
    e.classHierarchy.push("vtkImageData"), t.setExtent = function() {
      if (e.deleted) return gc("instance deleted - cannot call any method"), false;
      for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
      const a = r.length === 1 ? r[0] : r;
      if (a.length !== 6) return false;
      const s = e.extent.some((o, l) => o !== a[l]);
      return s && (e.extent = a.slice(), e.dataDescription = xq.getDataDescriptionFromExtent(e.extent), t.modified()), s;
    }, t.setDimensions = function() {
      let n, r, i;
      if (e.deleted) {
        gc("instance deleted - cannot call any method");
        return;
      }
      if (arguments.length === 1) {
        const a = arguments.length <= 0 ? void 0 : arguments[0];
        n = a[0], r = a[1], i = a[2];
      } else if (arguments.length === 3) n = arguments.length <= 0 ? void 0 : arguments[0], r = arguments.length <= 1 ? void 0 : arguments[1], i = arguments.length <= 2 ? void 0 : arguments[2];
      else {
        gc("Bad dimension specification");
        return;
      }
      t.setExtent(0, n - 1, 0, r - 1, 0, i - 1);
    }, t.getDimensions = () => [
      e.extent[1] - e.extent[0] + 1,
      e.extent[3] - e.extent[2] + 1,
      e.extent[5] - e.extent[4] + 1
    ], t.getNumberOfCells = () => {
      const n = t.getDimensions();
      let r = 1;
      for (let i = 0; i < 3; i++) {
        if (n[i] === 0) return 0;
        n[i] > 1 && (r *= n[i] - 1);
      }
      return r;
    }, t.getNumberOfPoints = () => {
      const n = t.getDimensions();
      return n[0] * n[1] * n[2];
    }, t.getPoint = (n) => {
      const r = t.getDimensions();
      if (r[0] === 0 || r[1] === 0 || r[2] === 0) return gc("Requesting a point from an empty image."), null;
      const i = new Float64Array(3);
      switch (e.dataDescription) {
        case es.EMPTY:
          return null;
        case es.SINGLE_POINT:
          break;
        case es.X_LINE:
          i[0] = n;
          break;
        case es.Y_LINE:
          i[1] = n;
          break;
        case es.Z_LINE:
          i[2] = n;
          break;
        case es.XY_PLANE:
          i[0] = n % r[0], i[1] = n / r[0];
          break;
        case es.YZ_PLANE:
          i[1] = n % r[1], i[2] = n / r[1];
          break;
        case es.XZ_PLANE:
          i[0] = n % r[0], i[2] = n / r[0];
          break;
        case es.XYZ_GRID:
          i[0] = n % r[0], i[1] = n / r[0] % r[1], i[2] = n / (r[0] * r[1]);
          break;
        default:
          gc("Invalid dataDescription");
          break;
      }
      const a = [
        0,
        0,
        0
      ];
      return t.indexToWorld(i, a), a;
    }, t.getBounds = () => t.extentToBounds(t.getSpatialExtent()), t.extentToBounds = (n) => En.transformBounds(n, e.indexToWorld), t.getSpatialExtent = () => En.inflate([
      ...e.extent
    ], 0.5), t.computeTransforms = () => {
      _8(e.indexToWorld, e.origin), e.indexToWorld[0] = e.direction[0], e.indexToWorld[1] = e.direction[1], e.indexToWorld[2] = e.direction[2], e.indexToWorld[4] = e.direction[3], e.indexToWorld[5] = e.direction[4], e.indexToWorld[6] = e.direction[5], e.indexToWorld[8] = e.direction[6], e.indexToWorld[9] = e.direction[7], e.indexToWorld[10] = e.direction[8], Fl(e.indexToWorld, e.indexToWorld, e.spacing), Nr(e.worldToIndex, e.indexToWorld);
    }, t.indexToWorld = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return $t(r, n, e.indexToWorld), r;
    }, t.indexToWorldVec3 = t.indexToWorld, t.worldToIndex = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return $t(r, n, e.worldToIndex), r;
    }, t.worldToIndexVec3 = t.worldToIndex, t.indexToWorldBounds = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return En.transformBounds(n, e.indexToWorld, r);
    }, t.worldToIndexBounds = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return En.transformBounds(n, e.worldToIndex, r);
    }, t.onModified(t.computeTransforms), t.computeTransforms(), t.getCenter = () => En.getCenter(t.getBounds()), t.computeHistogram = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      const i = [
        0,
        0,
        0,
        0,
        0,
        0
      ];
      t.worldToIndexBounds(n, i);
      const a = [
        0,
        0,
        0
      ], s = [
        0,
        0,
        0
      ];
      En.computeCornerPoints(i, a, s), Xv(a, a), Xv(s, s);
      const o = t.getDimensions();
      Qv(a, [
        0,
        0,
        0
      ], [
        o[0] - 1,
        o[1] - 1,
        o[2] - 1
      ], a), Qv(s, [
        0,
        0,
        0
      ], [
        o[0] - 1,
        o[1] - 1,
        o[2] - 1
      ], s);
      const l = o[0], c = o[0] * o[1], f = t.getPointData().getScalars().getData();
      let u = -1 / 0, h = 1 / 0, g = 0, v = 0, m = 0;
      for (let T = a[2]; T <= s[2]; T++) for (let S = a[1]; S <= s[1]; S++) {
        let E = a[0] + S * l + T * c;
        for (let b = a[0]; b <= s[0]; b++) {
          if (!r || r([
            b,
            S,
            T
          ], i)) {
            const D = f[E];
            D > u && (u = D), D < h && (h = D), g += D * D, v += D, m += 1;
          }
          ++E;
        }
      }
      const y = m > 0 ? v / m : 0, w = m ? Math.abs(g / m - y * y) : 0, C = Math.sqrt(w);
      return {
        minimum: h,
        maximum: u,
        average: y,
        variance: w,
        sigma: C,
        count: m
      };
    }, t.computeIncrements = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const i = [];
      let a = r;
      for (let s = 0; s < 3; ++s) i[s] = a, a *= n[s * 2 + 1] - n[s * 2] + 1;
      return i;
    }, t.computeOffsetIndex = (n) => {
      let [r, i, a] = n;
      const s = t.getExtent(), o = t.getPointData().getScalars().getNumberOfComponents(), l = t.computeIncrements(s, o);
      return Math.floor((Math.round(r) - s[0]) * l[0] + (Math.round(i) - s[2]) * l[1] + (Math.round(a) - s[4]) * l[2]);
    }, t.getOffsetIndexFromWorld = (n) => {
      const r = t.getExtent(), i = t.worldToIndex(n);
      for (let a = 0; a < 3; ++a) if (i[a] < r[a * 2] || i[a] > r[a * 2 + 1]) return gc(`GetScalarPointer: Pixel ${i} is not in memory. Current extent = ${r}`), NaN;
      return t.computeOffsetIndex(i);
    }, t.getScalarValueFromWorld = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      const i = t.getPointData().getScalars().getNumberOfComponents();
      if (r < 0 || r >= i) return gc(`GetScalarPointer: Scalar Component ${r} is not within bounds. Current Scalar numberOfComponents: ${i}`), NaN;
      const a = t.getOffsetIndexFromWorld(n);
      return Number.isNaN(a) ? a : t.getPointData().getScalars().getComponent(a, r);
    };
  }
  const Cq = {
    direction: null,
    indexToWorld: null,
    worldToIndex: null,
    spacing: [
      1,
      1,
      1
    ],
    origin: [
      0,
      0,
      0
    ],
    extent: [
      0,
      -1,
      0,
      -1,
      0,
      -1
    ],
    dataDescription: es.EMPTY
  };
  function _M(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Cq, n), $u.extend(t, e, n), e.direction ? Array.isArray(e.direction) && (e.direction = new Float64Array(e.direction.slice(0, 9))) : e.direction = Fa(new Float64Array(9)), e.indexToWorld = new Float64Array(16), e.worldToIndex = new Float64Array(16), H.get(t, e, [
      "indexToWorld",
      "worldToIndex"
    ]), H.setGetArray(t, e, [
      "origin",
      "spacing"
    ], 3), H.setGetArray(t, e, [
      "direction"
    ], 9), H.getArray(t, e, [
      "extent"
    ], 6), wq(t, e);
  }
  const Tq = H.newInstance(_M, "vtkImageData");
  var Bl = {
    newInstance: Tq,
    extend: _M
  };
  function Sq(t) {
    return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array;
  }
  const Aq = "WebGL", Cp = /* @__PURE__ */ Object.create(null);
  function kM(t, e) {
    Cp[t] = e;
  }
  function Eq() {
    return Object.keys(Cp);
  }
  function PM(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Cp[t] && Cp[t](e);
  }
  function bq(t, e) {
    e.classHierarchy.push("vtkRenderWindow"), t.addRenderer = (n) => {
      t.hasRenderer(n) || (n.setRenderWindow(t), e.renderers.push(n), t.modified());
    }, t.removeRenderer = (n) => {
      e.renderers = e.renderers.filter((r) => r !== n), t.modified();
    }, t.hasRenderer = (n) => e.renderers.indexOf(n) !== -1, t.newAPISpecificView = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return PM(n || e.defaultViewAPI, r);
    }, t.addView = (n) => {
      t.hasView(n) || (n.setRenderable(t), e._views.push(n), t.modified());
    }, t.removeView = (n) => {
      e._views = e._views.filter((r) => r !== n), t.modified();
    }, t.hasView = (n) => e._views.indexOf(n) !== -1, t.preRender = () => {
      e.renderers.forEach((n) => {
        n.isActiveCameraCreated() || n.resetCamera();
      });
    }, t.render = () => {
      t.preRender(), e.interactor ? e.interactor.render() : e._views.forEach((n) => n.traverseAllPasses());
    }, t.getStatistics = () => {
      const n = {
        propCount: 0,
        invisiblePropCount: 0,
        gpuMemoryMB: 0
      };
      return e._views.forEach((r) => {
        r.getGraphicsMemoryInfo && (n.gpuMemoryMB += r.getGraphicsMemoryInfo() / 1e6);
      }), e.renderers.forEach((r) => {
        const i = r.getViewProps(), a = e._views[0].getViewNodeFor(r);
        i.forEach((s) => {
          if (s.getVisibility()) {
            n.propCount += 1;
            const o = s.getMapper && s.getMapper();
            if (o && o.getPrimitiveCount) {
              const l = a.getViewNodeFor(o);
              if (l) {
                l.getAllocatedGPUMemoryInBytes && (n.gpuMemoryMB += l.getAllocatedGPUMemoryInBytes() / 1e6);
                const c = o.getPrimitiveCount();
                Object.keys(c).forEach((f) => {
                  n[f] || (n[f] = 0), n[f] += c[f];
                });
              }
            }
          } else n.invisiblePropCount += 1;
        });
      }), n.str = Object.keys(n).map((r) => `${r}: ${n[r]}`).join(`
`), n;
    }, t.captureImages = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png", r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return H.setImmediate(t.render), e._views.map((i) => i.captureNextImage ? i.captureNextImage(n, r) : void 0).filter((i) => !!i);
    }, t.addRenderWindow = (n) => e.childRenderWindows.includes(n) ? false : (e.childRenderWindows.push(n), t.modified(), true);
  }
  const Dq = {
    defaultViewAPI: Aq,
    renderers: [],
    views: [],
    interactor: null,
    neverRendered: true,
    numberOfLayers: 1,
    childRenderWindows: []
  };
  function GM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Dq, n), H.obj(t, e), H.setGet(t, e, [
      "interactor",
      "numberOfLayers",
      "_views",
      "defaultViewAPI"
    ]), H.get(t, e, [
      "neverRendered"
    ]), H.getArray(t, e, [
      "renderers",
      "childRenderWindows"
    ]), H.moveToProtected(t, e, [
      "views"
    ]), H.event(t, e, "completion"), bq(t, e);
  }
  const Mq = H.newInstance(GM, "vtkRenderWindow");
  var Rq = {
    newInstance: Mq,
    extend: GM,
    registerViewConstructor: kM,
    listViewAPIs: Eq,
    newAPISpecificView: PM
  };
  const Ah = {
    CLAMP_TO_EDGE: 0,
    REPEAT: 1,
    MIRRORED_REPEAT: 2
  }, dt = {
    NEAREST: 0,
    LINEAR: 1,
    NEAREST_MIPMAP_NEAREST: 2,
    NEAREST_MIPMAP_LINEAR: 3,
    LINEAR_MIPMAP_NEAREST: 4,
    LINEAR_MIPMAP_LINEAR: 5
  };
  var zM = {
    Wrap: Ah,
    Filter: dt
  };
  const WM = new Float32Array(1), Oq = new Int32Array(WM.buffer);
  function Iq(t) {
    WM[0] = t;
    const e = Oq[0];
    let n = e >> 16 & 32768, r = e >> 12 & 2047;
    const i = e >> 23 & 255;
    return i < 103 ? n : i > 142 ? (n |= 31744, n |= (i === 255 ? 0 : 1) && e & 8388607, n) : i < 113 ? (r |= 2048, n |= (r >> 114 - i) + (r >> 113 - i & 1), n) : (n |= i - 112 << 10 | r >> 1, n += r & 1, n);
  }
  function Vq(t) {
    const e = (t & 32768) >> 15, n = (t & 31744) >> 10, r = t & 1023;
    return n === 0 ? (e ? -1 : 1) * 2 ** -14 * (r / 2 ** 10) : n === 31 ? r ? NaN : (e ? -1 : 1) * (1 / 0) : (e ? -1 : 1) * 2 ** (n - 15) * (1 + r / 2 ** 10);
  }
  var yl = {
    fromHalf: Vq,
    toHalf: Iq
  };
  const { vtkErrorMacro: Nq } = H, Lq = [
    "Build",
    "Render"
  ];
  function Uq(t, e) {
    e.classHierarchy.push("vtkViewNode"), t.build = (r) => {
    }, t.render = (r) => {
    }, t.traverse = (r) => {
      const i = r.getTraverseOperation(), a = t[i];
      if (a) {
        a(r);
        return;
      }
      t.apply(r, true);
      for (let s = 0; s < e.children.length; s++) e.children[s].traverse(r);
      t.apply(r, false);
    }, t.apply = (r, i) => {
      const a = t[r.getOperation()];
      a && a(i, r);
    }, t.getViewNodeFor = (r) => {
      if (e.renderable === r) return t;
      for (let i = 0; i < e.children.length; ++i) {
        const s = e.children[i].getViewNodeFor(r);
        if (s) return s;
      }
    }, t.getFirstAncestorOfType = (r) => e._parent ? e._parent.isA(r) ? e._parent : e._parent.getFirstAncestorOfType(r) : null, t.getLastAncestorOfType = (r) => {
      if (!e._parent) return null;
      const i = e._parent.getLastAncestorOfType(r);
      return i || (e._parent.isA(r) ? e._parent : null);
    }, t.addMissingNode = (r) => {
      if (!r) return;
      const i = e._renderableChildMap.get(r);
      if (i !== void 0) return i.setVisited(true), i;
      const a = t.createViewNode(r);
      if (a) return a.setParent(t), a.setVisited(true), e._renderableChildMap.set(r, a), e.children.push(a), a;
    }, t.addMissingNodes = (r) => {
      if (!(!r || !r.length)) for (let i = 0; i < r.length; ++i) {
        const a = r[i];
        t.addMissingNode(a);
      }
    }, t.addMissingChildren = (r) => {
      if (!(!r || !r.length)) for (let i = 0; i < r.length; ++i) {
        const a = r[i];
        if (e.children.indexOf(a) === -1) {
          a.setParent(t), e.children.push(a);
          const o = a.getRenderable();
          o && e._renderableChildMap.set(o, a);
        }
        a.setVisited(true);
      }
    }, t.prepareNodes = () => {
      for (let r = 0; r < e.children.length; ++r) e.children[r].setVisited(false);
    }, t.setVisited = (r) => {
      e.visited = r;
    }, t.removeUnusedNodes = () => {
      let r = 0;
      for (let i = 0; i < e.children.length; ++i) {
        const a = e.children[i];
        if (a.getVisited()) e.children[r++] = a, a.setVisited(false);
        else {
          const o = a.getRenderable();
          o && e._renderableChildMap.delete(o), a.delete();
        }
      }
      e.children.length = r;
    }, t.createViewNode = (r) => {
      if (!e.myFactory) return Nq("Cannot create view nodes without my own factory"), null;
      const i = e.myFactory.createNode(r);
      return i && i.setRenderable(r), i;
    };
    const n = t.delete;
    t.delete = () => {
      for (let r = 0; r < e.children.length; r++) e.children[r].delete();
      n();
    };
  }
  const Fq = {
    renderable: null,
    myFactory: null,
    children: [],
    visited: false
  };
  function HM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Fq, n), H.obj(t, e), H.event(t, e, "event"), e._renderableChildMap = /* @__PURE__ */ new Map(), H.get(t, e, [
      "visited"
    ]), H.setGet(t, e, [
      "_parent",
      "renderable",
      "myFactory"
    ]), H.getArray(t, e, [
      "children"
    ]), H.moveToProtected(t, e, [
      "parent"
    ]), Uq(t, e);
  }
  const Bq = H.newInstance(HM, "vtkViewNode");
  var Rn = {
    newInstance: Bq,
    extend: HM,
    PASS_TYPES: Lq
  };
  function _q(t, e) {
    e.overrides || (e.overrides = {}), e.classHierarchy.push("vtkViewNodeFactory"), t.createNode = (n) => {
      if (n.isDeleted()) return null;
      let r = 0, i = n.getClassName(r++), a = false;
      const s = Object.keys(e.overrides);
      for (; i && !a; ) s.indexOf(i) !== -1 ? a = true : i = n.getClassName(r++);
      if (!a) return null;
      const o = e.overrides[i]();
      return o.setMyFactory(t), o;
    };
  }
  const kq = {};
  function jM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, kq, n), H.obj(t, e), _q(t, e);
  }
  const Pq = H.newInstance(jM, "vtkViewNodeFactory");
  var X8 = {
    newInstance: Pq,
    extend: jM
  };
  const KM = /* @__PURE__ */ Object.create(null);
  function Er(t, e) {
    KM[t] = e;
  }
  function Gq(t, e) {
    e.classHierarchy.push("vtkOpenGLViewNodeFactory");
  }
  const zq = {};
  function YM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, zq, n), e.overrides = KM, X8.extend(t, e, n), Gq(t, e);
  }
  const Wq = H.newInstance(YM, "vtkOpenGLViewNodeFactory");
  var Hq = {
    newInstance: Wq,
    extend: YM
  };
  const { Wrap: lo, Filter: oi } = zM, { VtkDataTypes: yn } = Tt, { vtkDebugMacro: N4, vtkErrorMacro: q0, vtkWarningMacro: xT } = di, { toHalf: jq } = yl;
  function Kq(t, e) {
    e.classHierarchy.push("vtkOpenGLTexture"), t.render = function() {
      let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      if (c ? e._openGLRenderWindow = c : (e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent()), e.context = e._openGLRenderWindow.getContext(), e.renderable.getInterpolate() ? (e.generateMipmap ? t.setMinificationFilter(oi.LINEAR_MIPMAP_LINEAR) : t.setMinificationFilter(oi.LINEAR), t.setMagnificationFilter(oi.LINEAR)) : (t.setMinificationFilter(oi.NEAREST), t.setMagnificationFilter(oi.NEAREST)), e.renderable.getRepeat() && (t.setWrapR(lo.REPEAT), t.setWrapS(lo.REPEAT), t.setWrapT(lo.REPEAT)), e.renderable.getInputData() && e.renderable.setImage(null), !e.handle || e.renderable.getMTime() > e.textureBuildTime.getMTime()) {
        if (e.renderable.getImage() !== null && (e.renderable.getInterpolate() && (e.generateMipmap = true, t.setMinificationFilter(oi.LINEAR_MIPMAP_LINEAR)), e.renderable.getImage() && e.renderable.getImageLoaded() && (t.create2DFromImage(e.renderable.getImage()), t.activate(), t.sendParameters(), e.textureBuildTime.modified())), e.renderable.getCanvas() !== null) {
          e.renderable.getInterpolate() && (e.generateMipmap = true, t.setMinificationFilter(oi.LINEAR_MIPMAP_LINEAR));
          const u = e.renderable.getCanvas();
          t.create2DFromRaw(u.width, u.height, 4, yn.UNSIGNED_CHAR, u, true), t.activate(), t.sendParameters(), e.textureBuildTime.modified();
        }
        if (e.renderable.getJsImageData() !== null) {
          const u = e.renderable.getJsImageData();
          e.renderable.getInterpolate() && (e.generateMipmap = true, t.setMinificationFilter(oi.LINEAR_MIPMAP_LINEAR)), t.create2DFromRaw(u.width, u.height, 4, yn.UNSIGNED_CHAR, u.data, true), t.activate(), t.sendParameters(), e.textureBuildTime.modified();
        }
        const f = e.renderable.getInputData(0);
        if (f && f.getPointData().getScalars()) {
          const u = f.getExtent(), h = f.getPointData().getScalars(), g = [];
          for (let v = 0; v < e.renderable.getNumberOfInputPorts(); ++v) {
            const m = e.renderable.getInputData(v), y = m ? m.getPointData().getScalars().getData() : null;
            y && g.push(y);
          }
          e.renderable.getInterpolate() && h.getNumberOfComponents() === 4 && (e.generateMipmap = true, t.setMinificationFilter(oi.LINEAR_MIPMAP_LINEAR)), g.length % 6 === 0 ? t.createCubeFromRaw(u[1] - u[0] + 1, u[3] - u[2] + 1, h.getNumberOfComponents(), h.getDataType(), g) : t.create2DFromRaw(u[1] - u[0] + 1, u[3] - u[2] + 1, h.getNumberOfComponents(), h.getDataType(), h.getData()), t.activate(), t.sendParameters(), e.textureBuildTime.modified();
        }
      }
      e.handle && t.activate();
    }, t.destroyTexture = () => {
      t.deactivate(), e.context && e.handle && e.context.deleteTexture(e.handle), e.handle = 0, e.numberOfDimensions = 0, e.target = 0, e.components = 0, e.width = 0, e.height = 0, e.depth = 0, t.resetFormatAndType();
    }, t.createTexture = () => {
      e.handle || (e.handle = e.context.createTexture(), e.target && (e.context.bindTexture(e.target, e.handle), e.context.texParameteri(e.target, e.context.TEXTURE_MIN_FILTER, t.getOpenGLFilterMode(e.minificationFilter)), e.context.texParameteri(e.target, e.context.TEXTURE_MAG_FILTER, t.getOpenGLFilterMode(e.magnificationFilter)), e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_S, t.getOpenGLWrapMode(e.wrapS)), e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_T, t.getOpenGLWrapMode(e.wrapT)), e._openGLRenderWindow.getWebgl2() && e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_R, t.getOpenGLWrapMode(e.wrapR)), e.context.bindTexture(e.target, null)));
    }, t.getTextureUnit = () => e._openGLRenderWindow ? e._openGLRenderWindow.getTextureUnitForTexture(t) : -1, t.activate = () => {
      e._openGLRenderWindow.activateTexture(t), t.bind();
    }, t.deactivate = () => {
      e._openGLRenderWindow && e._openGLRenderWindow.deactivateTexture(t);
    }, t.releaseGraphicsResources = (c) => {
      c && e.handle && (c.activateTexture(t), c.deactivateTexture(t), e.context.deleteTexture(e.handle), e.handle = 0, e.numberOfDimensions = 0, e.target = 0, e.internalFormat = 0, e.format = 0, e.openGLDataType = 0, e.components = 0, e.width = 0, e.height = 0, e.depth = 0, e.allocatedGPUMemoryInBytes = 0), e.shaderProgram && (e.shaderProgram.releaseGraphicsResources(c), e.shaderProgram = null);
    }, t.bind = () => {
      e.context.bindTexture(e.target, e.handle), e.autoParameters && t.getMTime() > e.sendParametersTime.getMTime() && t.sendParameters();
    }, t.isBound = () => {
      let c = false;
      if (e.context && e.handle) {
        let f = 0;
        switch (e.target) {
          case e.context.TEXTURE_2D:
            f = e.context.TEXTURE_BINDING_2D;
            break;
          default:
            xT("impossible case");
            break;
        }
        c = e.context.getIntegerv(f) === e.handle;
      }
      return c;
    }, t.sendParameters = () => {
      e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_S, t.getOpenGLWrapMode(e.wrapS)), e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_T, t.getOpenGLWrapMode(e.wrapT)), e._openGLRenderWindow.getWebgl2() && e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_R, t.getOpenGLWrapMode(e.wrapR)), e.context.texParameteri(e.target, e.context.TEXTURE_MIN_FILTER, t.getOpenGLFilterMode(e.minificationFilter)), e.context.texParameteri(e.target, e.context.TEXTURE_MAG_FILTER, t.getOpenGLFilterMode(e.magnificationFilter)), e._openGLRenderWindow.getWebgl2() && (e.context.texParameteri(e.target, e.context.TEXTURE_BASE_LEVEL, e.baseLevel), e.context.texParameteri(e.target, e.context.TEXTURE_MAX_LEVEL, e.maxLevel)), e.sendParametersTime.modified();
    }, t.getInternalFormat = (c, f) => (e._forceInternalFormat || (e.internalFormat = t.getDefaultInternalFormat(c, f)), e.internalFormat || N4(`Unable to find suitable internal format for T=${c} NC= ${f}`), [
      e.context.R32F,
      e.context.RG32F,
      e.context.RGB32F,
      e.context.RGBA32F
    ].includes(e.internalFormat) && !e.context.getExtension("OES_texture_float_linear") && xT("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."), e.internalFormat), t.getDefaultInternalFormat = (c, f) => {
      let u = 0;
      return u = e._openGLRenderWindow.getDefaultTextureInternalFormat(c, f, e.oglNorm16Ext, e.useHalfFloat), u || (u || (N4("Unsupported internal texture type!"), N4(`Unable to find suitable internal format for T=${c} NC= ${f}`)), u);
    }, t.setInternalFormat = (c) => {
      e._forceInternalFormat = true, c !== e.internalFormat && (e.internalFormat = c, t.modified());
    }, t.getFormat = (c, f) => (e.format = t.getDefaultFormat(c, f), e.format), t.getDefaultFormat = (c, f) => {
      if (e._openGLRenderWindow.getWebgl2()) switch (f) {
        case 1:
          return e.context.RED;
        case 2:
          return e.context.RG;
        case 3:
          return e.context.RGB;
        case 4:
          return e.context.RGBA;
        default:
          return e.context.RGB;
      }
      else switch (f) {
        case 1:
          return e.context.LUMINANCE;
        case 2:
          return e.context.LUMINANCE_ALPHA;
        case 3:
          return e.context.RGB;
        case 4:
          return e.context.RGBA;
        default:
          return e.context.RGB;
      }
    }, t.resetFormatAndType = () => {
      e.format = 0, e.internalFormat = 0, e._forceInternalFormat = false, e.openGLDataType = 0;
    }, t.getDefaultDataType = (c) => {
      if (e._openGLRenderWindow.getWebgl2()) switch (c) {
        case yn.UNSIGNED_CHAR:
          return e.context.UNSIGNED_BYTE;
        case (e.oglNorm16Ext && !e.useHalfFloat && yn.SHORT):
          return e.context.SHORT;
        case (e.oglNorm16Ext && !e.useHalfFloat && yn.UNSIGNED_SHORT):
          return e.context.UNSIGNED_SHORT;
        case (e.useHalfFloat && yn.SHORT):
          return e.context.HALF_FLOAT;
        case (e.useHalfFloat && yn.UNSIGNED_SHORT):
          return e.context.HALF_FLOAT;
        case yn.FLOAT:
        case yn.VOID:
        default:
          return e.context.FLOAT;
      }
      switch (c) {
        case yn.UNSIGNED_CHAR:
          return e.context.UNSIGNED_BYTE;
        case yn.FLOAT:
        case yn.VOID:
        default:
          if (e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear")) return e.context.FLOAT;
          {
            const f = e.context.getExtension("OES_texture_half_float");
            if (f && e.context.getExtension("OES_texture_half_float_linear")) return f.HALF_FLOAT_OES;
          }
          return e.context.UNSIGNED_BYTE;
      }
    }, t.getOpenGLDataType = function(c) {
      let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return (!e.openGLDataType || f) && (e.openGLDataType = t.getDefaultDataType(c)), e.openGLDataType;
    }, t.getShiftAndScale = () => {
      let c = 0, f = 1;
      switch (e.openGLDataType) {
        case e.context.BYTE:
          f = 127.5, c = f - 128;
          break;
        case e.context.UNSIGNED_BYTE:
          f = 255, c = 0;
          break;
        case e.context.SHORT:
          f = 32767.5, c = f - 32768;
          break;
        case e.context.UNSIGNED_SHORT:
          f = 65536, c = 0;
          break;
        case e.context.INT:
          f = 21474836475e-1, c = f - 2147483648;
          break;
        case e.context.UNSIGNED_INT:
          f = 4294967295, c = 0;
          break;
        case e.context.FLOAT:
      }
      return {
        shift: c,
        scale: f
      };
    }, t.getOpenGLFilterMode = (c) => {
      switch (c) {
        case oi.NEAREST:
          return e.context.NEAREST;
        case oi.LINEAR:
          return e.context.LINEAR;
        case oi.NEAREST_MIPMAP_NEAREST:
          return e.context.NEAREST_MIPMAP_NEAREST;
        case oi.NEAREST_MIPMAP_LINEAR:
          return e.context.NEAREST_MIPMAP_LINEAR;
        case oi.LINEAR_MIPMAP_NEAREST:
          return e.context.LINEAR_MIPMAP_NEAREST;
        case oi.LINEAR_MIPMAP_LINEAR:
          return e.context.LINEAR_MIPMAP_LINEAR;
        default:
          return e.context.NEAREST;
      }
    }, t.getOpenGLWrapMode = (c) => {
      switch (c) {
        case lo.CLAMP_TO_EDGE:
          return e.context.CLAMP_TO_EDGE;
        case lo.REPEAT:
          return e.context.REPEAT;
        case lo.MIRRORED_REPEAT:
          return e.context.MIRRORED_REPEAT;
        default:
          return e.context.CLAMP_TO_EDGE;
      }
    };
    function n(c, f) {
      let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      const h = [];
      let g = e.width * e.height * e.components;
      if (u && (g *= e.depth), c !== yn.FLOAT && e.openGLDataType === e.context.FLOAT) for (let m = 0; m < f.length; m++) if (f[m]) {
        const y = f[m].length > g ? f[m].subarray(0, g) : f[m];
        h.push(new Float32Array(y));
      } else h.push(null);
      if (c !== yn.UNSIGNED_CHAR && e.openGLDataType === e.context.UNSIGNED_BYTE) for (let m = 0; m < f.length; m++) if (f[m]) {
        const y = f[m].length > g ? f[m].subarray(0, g) : f[m];
        h.push(new Uint8Array(y));
      } else h.push(null);
      let v = false;
      if (e._openGLRenderWindow.getWebgl2()) v = e.openGLDataType === e.context.HALF_FLOAT;
      else {
        const m = e.context.getExtension("OES_texture_half_float");
        v = m && e.openGLDataType === m.HALF_FLOAT_OES;
      }
      if (v) for (let m = 0; m < f.length; m++) if (f[m]) {
        const y = new Uint16Array(g), w = f[m];
        for (let C = 0; C < g; C++) y[C] = jq(w[C]);
        h.push(y);
      } else h.push(null);
      if (h.length === 0) for (let m = 0; m < f.length; m++) h.push(f[m]);
      return h;
    }
    function r(c) {
      if (e._openGLRenderWindow.getWebgl2()) return c;
      const f = [], u = e.width, h = e.height, g = e.components;
      if (c && (!z1(u) || !z1(h))) {
        const v = e.context.getExtension("OES_texture_half_float"), m = Na(u), y = Na(h), w = m * y * e.components;
        for (let C = 0; C < c.length; C++) if (c[C] !== null) {
          let T = null;
          const S = h / y, E = u / m;
          let b = false;
          e.openGLDataType === e.context.FLOAT ? T = new Float32Array(w) : v && e.openGLDataType === v.HALF_FLOAT_OES ? (T = new Uint16Array(w), b = true) : T = new Uint8Array(w);
          for (let D = 0; D < y; D++) {
            const R = D * m * g, I = D * S;
            let O = Math.floor(I), L = Math.ceil(I);
            L >= h && (L = h - 1);
            const N = I - O, F = 1 - N;
            O = O * u * g, L = L * u * g;
            for (let V = 0; V < m; V++) {
              const k = V * g, _ = V * E;
              let K = Math.floor(_), Z = Math.ceil(_);
              Z >= u && (Z = u - 1);
              const j = _ - K;
              K *= g, Z *= g;
              for (let B = 0; B < g; B++) b ? T[R + k + B] = yl.toHalf(yl.fromHalf(c[C][O + K + B]) * F * (1 - j) + yl.fromHalf(c[C][O + Z + B]) * F * j + yl.fromHalf(c[C][L + K + B]) * N * (1 - j) + yl.fromHalf(c[C][L + Z + B]) * N * j) : T[R + k + B] = c[C][O + K + B] * F * (1 - j) + c[C][O + Z + B] * F * j + c[C][L + K + B] * N * (1 - j) + c[C][L + Z + B] * N * j;
            }
          }
          f.push(T), e.width = m, e.height = y;
        } else f.push(null);
      }
      if (f.length === 0) for (let v = 0; v < c.length; v++) f.push(c[v]);
      return f;
    }
    function i(c) {
      var _a3;
      return e._openGLRenderWindow ? e.resizable || ((_a3 = e.renderable) == null ? void 0 : _a3.getResizable()) ? false : e._openGLRenderWindow.getWebgl2() ? !(e._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && e.oglNorm16Ext && (c === yn.UNSIGNED_SHORT || c === yn.SHORT)) : false : false;
    }
    t.create2DFromRaw = function(c, f, u, h, g) {
      let v = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      if (t.getOpenGLDataType(h, true), t.getInternalFormat(h, u), t.getFormat(h, u), !e.internalFormat || !e.format || !e.openGLDataType) return q0("Failed to determine texture parameters."), false;
      e.target = e.context.TEXTURE_2D, e.components = u, e.width = c, e.height = f, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind();
      const y = n(h, [
        g
      ]), w = r(y);
      return e.context.pixelStorei(e.context.UNPACK_FLIP_Y_WEBGL, v), e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), i(h) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), w[0] != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, w[0])) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, w[0]), e.generateMipmap && e.context.generateMipmap(e.target), v && e.context.pixelStorei(e.context.UNPACK_FLIP_Y_WEBGL, false), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * u * e._openGLRenderWindow.getDefaultTextureByteSize(h, e.oglNorm16Ext, e.useHalfFloat), t.deactivate(), true;
    }, t.createCubeFromRaw = (c, f, u, h, g) => {
      if (t.getOpenGLDataType(h), t.getInternalFormat(h, u), t.getFormat(h, u), !e.internalFormat || !e.format || !e.openGLDataType) return q0("Failed to determine texture parameters."), false;
      e.target = e.context.TEXTURE_CUBE_MAP, e.components = u, e.width = c, e.height = f, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), e.maxLevel = g.length / 6 - 1, t.createTexture(), t.bind();
      const v = n(h, g), m = r(v), y = [];
      let w = e.width, C = e.height;
      for (let T = 0; T < m.length; T++) {
        T % 6 === 0 && T !== 0 && (w /= 2, C /= 2), y[T] = qu(h, C * w * e.components);
        for (let S = 0; S < C; ++S) {
          const E = S * w * e.components, b = (C - S - 1) * w * e.components;
          y[T].set(m[T].slice(b, b + w * e.components), E);
        }
      }
      e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), i(h) && e.context.texStorage2D(e.target, 6, e.internalFormat, e.width, e.height);
      for (let T = 0; T < 6; T++) {
        let S = 0, E = e.width, b = e.height;
        for (; E >= 1 && b >= 1; ) {
          let D = null;
          S <= e.maxLevel && (D = y[6 * S + T]), i(h) ? D != null && e.context.texSubImage2D(e.context.TEXTURE_CUBE_MAP_POSITIVE_X + T, S, 0, 0, E, b, e.format, e.openGLDataType, D) : e.context.texImage2D(e.context.TEXTURE_CUBE_MAP_POSITIVE_X + T, S, e.internalFormat, E, b, 0, e.format, e.openGLDataType, D), S++, E /= 2, b /= 2;
        }
      }
      return e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * u * e._openGLRenderWindow.getDefaultTextureByteSize(h, e.oglNorm16Ext, e.useHalfFloat), t.deactivate(), true;
    }, t.createDepthFromRaw = (c, f, u, h) => (t.getOpenGLDataType(u), e.format = e.context.DEPTH_COMPONENT, e._openGLRenderWindow.getWebgl2() ? u === yn.FLOAT ? e.internalFormat = e.context.DEPTH_COMPONENT32F : e.internalFormat = e.context.DEPTH_COMPONENT16 : e.internalFormat = e.context.DEPTH_COMPONENT, !e.internalFormat || !e.format || !e.openGLDataType ? (q0("Failed to determine texture parameters."), false) : (e.target = e.context.TEXTURE_2D, e.components = 1, e.width = c, e.height = f, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind(), e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), i(u) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), h != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, h)) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, h), e.generateMipmap && e.context.generateMipmap(e.target), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * e.components * e._openGLRenderWindow.getDefaultTextureByteSize(u, e.oglNorm16Ext, e.useHalfFloat), t.deactivate(), true)), t.create2DFromImage = (c) => {
      if (t.getOpenGLDataType(yn.UNSIGNED_CHAR), t.getInternalFormat(yn.UNSIGNED_CHAR, 4), t.getFormat(yn.UNSIGNED_CHAR, 4), !e.internalFormat || !e.format || !e.openGLDataType) return q0("Failed to determine texture parameters."), false;
      e.target = e.context.TEXTURE_2D, e.components = 4, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind(), e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1);
      const f = !e._openGLRenderWindow.getWebgl2() && (!z1(c.width) || !z1(c.height)), u = document.createElement("canvas");
      u.width = f ? Na(c.width) : c.width, u.height = f ? Na(c.height) : c.height, e.width = u.width, e.height = u.height;
      const h = u.getContext("2d");
      h.translate(0, u.height), h.scale(1, -1), h.drawImage(c, 0, 0, c.width, c.height, 0, 0, u.width, u.height);
      const g = u;
      return i(yn.UNSIGNED_CHAR) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), g != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, g)) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, g), e.generateMipmap && e.context.generateMipmap(e.target), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * e.components * e._openGLRenderWindow.getDefaultTextureByteSize(yn.UNSIGNED_CHAR, e.oglNorm16Ext, e.useHalfFloat), t.deactivate(), true;
    };
    function a(c, f, u) {
      const h = new Array(u), g = new Array(u);
      for (let v = 0; v < u; ++v) h[v] = c[v], g[v] = f[v] - c[v] || 1;
      return {
        scale: g,
        offset: h
      };
    }
    function s(c, f) {
      for (let u = 0; u < c.length; u++) {
        const h = c[u], g = f[u] + h;
        if (h < -2048 || h > 2048 || g < -2048 || g > 2048) return false;
      }
      return true;
    }
    function o(c, f, u, h) {
      t.getOpenGLDataType(c);
      let g = false;
      if (e._openGLRenderWindow.getWebgl2()) g = e.openGLDataType === e.context.HALF_FLOAT;
      else {
        const m = e.context.getExtension("OES_texture_half_float");
        g = m && e.openGLDataType === m.HALF_FLOAT_OES;
      }
      const v = g && (s(f, u) || h);
      e.useHalfFloat = v;
    }
    function l(c, f) {
      const u = c.getNumberOfComponents(), h = c.getDataType(), g = c.getData(), v = new Array(u), m = new Array(u);
      for (let w = 0; w < u; ++w) {
        const [C, T] = c.getRange(w);
        v[w] = C, m[w] = T;
      }
      const y = a(v, m, u);
      return o(h, y.offset, y.scale, f), e.useHalfFloat || t.getOpenGLDataType(h, true), {
        numComps: u,
        dataType: h,
        data: g,
        scaleOffsets: y
      };
    }
    t.create2DFilterableFromRaw = function(c, f, u, h, g) {
      let v = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      return t.create2DFilterableFromDataArray(c, f, Tt.newInstance({
        numberOfComponents: u,
        dataType: h,
        values: g
      }), v);
    }, t.create2DFilterableFromDataArray = function(c, f, u) {
      let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      const { numComps: g, dataType: v, data: m } = l(u, h);
      t.create2DFromRaw(c, f, g, v, m);
    }, t.create3DFromRaw = (c, f, u, h, g, v) => {
      if (t.getOpenGLDataType(g), t.getInternalFormat(g, h), t.getFormat(g, h), !e.internalFormat || !e.format || !e.openGLDataType) return q0("Failed to determine texture parameters."), false;
      e.target = e.context.TEXTURE_3D, e.components = h, e.width = c, e.height = f, e.depth = u, e.numberOfDimensions = 3, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind();
      const w = n(g, [
        v
      ], true), C = r(w);
      return e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), i(g) ? (e.context.texStorage3D(e.target, 1, e.internalFormat, e.width, e.height, e.depth), C[0] != null && e.context.texSubImage3D(e.target, 0, 0, 0, 0, e.width, e.height, e.depth, e.format, e.openGLDataType, C[0])) : e.context.texImage3D(e.target, 0, e.internalFormat, e.width, e.height, e.depth, 0, e.format, e.openGLDataType, C[0]), e.generateMipmap && e.context.generateMipmap(e.target), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * e.components * e._openGLRenderWindow.getDefaultTextureByteSize(g, e.oglNorm16Ext, e.useHalfFloat), t.deactivate(), true;
    }, t.create3DFilterableFromRaw = function(c, f, u, h, g, v) {
      let m = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
      return t.create3DFilterableFromDataArray(c, f, u, Tt.newInstance({
        numberOfComponents: h,
        dataType: g,
        values: v
      }), m);
    }, t.create3DFilterableFromDataArray = function(c, f, u, h) {
      let g = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      const { numComps: v, dataType: m, data: y, scaleOffsets: w } = l(h, g), C = c * f * u, T = [], S = [];
      for (let B = 0; B < v; ++B) T[B] = 0, S[B] = 1;
      e.volumeInfo = {
        scale: S,
        offset: T,
        dataComputedScale: w.scale,
        dataComputedOffset: w.offset,
        width: c,
        height: f,
        depth: u
      };
      const E = structuredClone(w);
      if (e._openGLRenderWindow.getWebgl2()) {
        if (e.oglNorm16Ext && !e.useHalfFloat && m === yn.SHORT) {
          for (let ie = 0; ie < v; ++ie) e.volumeInfo.scale[ie] = 32767;
          return t.create3DFromRaw(c, f, u, v, m, y);
        }
        if (e.oglNorm16Ext && !e.useHalfFloat && m === yn.UNSIGNED_SHORT) {
          for (let ie = 0; ie < v; ++ie) e.volumeInfo.scale[ie] = 65535;
          return t.create3DFromRaw(c, f, u, v, m, y);
        }
        if (m === yn.FLOAT || e.useHalfFloat && (m === yn.SHORT || m === yn.UNSIGNED_SHORT)) return t.create3DFromRaw(c, f, u, v, m, y);
        if (m === yn.UNSIGNED_CHAR) {
          for (let ie = 0; ie < v; ++ie) e.volumeInfo.scale[ie] = 255;
          return t.create3DFromRaw(c, f, u, v, m, y);
        }
        const B = new Float32Array(C * v);
        e.volumeInfo.offset = E.offset, e.volumeInfo.scale = E.scale;
        let Y = 0;
        const X = E.scale.map((ie) => 1 / ie);
        for (let ie = 0; ie < C; ie++) for (let oe = 0; oe < v; oe++) B[Y] = (y[Y] - E.offset[oe]) * X[oe], Y++;
        return t.create3DFromRaw(c, f, u, v, yn.FLOAT, B);
      }
      let b = (B, Y, X, ie, oe) => {
        B[Y] = X;
      }, D = yn.UNSIGNED_CHAR;
      if (m === yn.UNSIGNED_CHAR) for (let B = 0; B < v; ++B) E.offset[B] = 0, E.scale[B] = 255;
      else e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear") ? (D = yn.FLOAT, b = (B, Y, X, ie, oe) => {
        B[Y] = (X - ie) / oe;
      }) : (D = yn.UNSIGNED_CHAR, b = (B, Y, X, ie, oe) => {
        B[Y] = 255 * (X - ie) / oe;
      });
      if (t.getOpenGLDataType(D), t.getInternalFormat(D, v), t.getFormat(D, v), !e.internalFormat || !e.format || !e.openGLDataType) return q0("Failed to determine texture parameters."), false;
      e.target = e.context.TEXTURE_2D, e.components = v, e.depth = 1, e.numberOfDimensions = 2;
      let R = e.context.getParameter(e.context.MAX_TEXTURE_SIZE);
      R > 4096 && (D === yn.FLOAT || v >= 3) && (R = 4096);
      let I = 1, O = 1;
      C > R * R && (I = Math.ceil(Math.sqrt(C / (R * R))), O = I);
      let L = Math.sqrt(C) / I;
      L = Na(L);
      const N = Math.floor(L * I / c), F = Math.ceil(u / N), V = Na(f * F / O);
      e.width = L, e.height = V, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind(), e.volumeInfo.xreps = N, e.volumeInfo.yreps = F, e.volumeInfo.xstride = I, e.volumeInfo.ystride = O, e.volumeInfo.offset = E.offset, e.volumeInfo.scale = E.scale;
      let k;
      const _ = L * V * v;
      D === yn.FLOAT ? k = new Float32Array(_) : k = new Uint8Array(_);
      let K = 0;
      const Z = Math.floor(c / I), j = Math.floor(f / O);
      for (let B = 0; B < F; B++) {
        const Y = Math.min(N, u - B * N), X = v * (e.width - Y * Math.floor(c / I));
        for (let ie = 0; ie < j; ie++) {
          for (let oe = 0; oe < Y; oe++) {
            const he = v * ((B * N + oe) * c * f + O * ie * c);
            for (let Le = 0; Le < Z; Le++) for (let Je = 0; Je < v; Je++) b(k, K, y[he + I * Le * v + Je], E.offset[Je], E.scale[Je]), K++;
          }
          K += X;
        }
      }
      return e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), i(D) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), k != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, k)) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, k), t.deactivate(), true;
    }, t.setOpenGLRenderWindow = (c) => {
      e._openGLRenderWindow !== c && (t.releaseGraphicsResources(), e._openGLRenderWindow = c, e.context = null, c && (e.context = e._openGLRenderWindow.getContext()));
    }, t.getMaximumTextureSize = (c) => c && c.isCurrent() ? c.getIntegerv(c.MAX_TEXTURE_SIZE) : -1;
  }
  const Yq = {
    _openGLRenderWindow: null,
    _forceInternalFormat: false,
    context: null,
    handle: 0,
    sendParametersTime: null,
    textureBuildTime: null,
    numberOfDimensions: 0,
    target: 0,
    format: 0,
    openGLDataType: 0,
    components: 0,
    width: 0,
    height: 0,
    depth: 0,
    autoParameters: true,
    wrapS: lo.CLAMP_TO_EDGE,
    wrapT: lo.CLAMP_TO_EDGE,
    wrapR: lo.CLAMP_TO_EDGE,
    minificationFilter: oi.NEAREST,
    magnificationFilter: oi.NEAREST,
    minLOD: -1e3,
    maxLOD: 1e3,
    baseLevel: 0,
    maxLevel: 1e3,
    generateMipmap: false,
    useHalfFloat: true,
    oglNorm16Ext: null,
    allocatedGPUMemoryInBytes: 0
  };
  function qM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Yq, n), Rn.extend(t, e, n), e.sendParametersTime = {}, _n(e.sendParametersTime, {
      mtime: 0
    }), e.textureBuildTime = {}, _n(e.textureBuildTime, {
      mtime: 0
    }), Zh(t, e, [
      "format",
      "openGLDataType"
    ]), pr(t, e, [
      "keyMatrixTime",
      "minificationFilter",
      "magnificationFilter",
      "wrapS",
      "wrapT",
      "wrapR",
      "generateMipmap",
      "oglNorm16Ext"
    ]), Wi(t, e, [
      "width",
      "height",
      "volumeInfo",
      "components",
      "handle",
      "target",
      "allocatedGPUMemoryInBytes"
    ]), Qh(t, e, [
      "openGLRenderWindow"
    ]), Kq(t, e);
  }
  const XM = pn(qM, "vtkOpenGLTexture");
  var er = {
    newInstance: XM,
    extend: qM,
    ...zM
  };
  Er("vtkTexture", XM);
  function qq(t, e) {
    e.classHierarchy.push("vtkFramebuffer"), t.getBothMode = () => e.context.FRAMEBUFFER, t.saveCurrentBindingsAndBuffers = (n) => {
      const r = typeof n < "u" ? n : t.getBothMode();
      t.saveCurrentBindings(r), t.saveCurrentBuffers(r);
    }, t.saveCurrentBindings = (n) => {
      if (!e.context) {
        Jt("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
        return;
      }
      const r = e.context;
      e.previousDrawBinding = r.getParameter(e.context.FRAMEBUFFER_BINDING), e.previousActiveFramebuffer = e._openGLRenderWindow.getActiveFramebuffer();
    }, t.saveCurrentBuffers = (n) => {
    }, t.restorePreviousBindingsAndBuffers = (n) => {
      const r = typeof n < "u" ? n : t.getBothMode();
      t.restorePreviousBindings(r), t.restorePreviousBuffers(r);
    }, t.restorePreviousBindings = (n) => {
      if (!e.context) {
        Jt("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
        return;
      }
      const r = e.context;
      r.bindFramebuffer(r.FRAMEBUFFER, e.previousDrawBinding), e._openGLRenderWindow.setActiveFramebuffer(e.previousActiveFramebuffer);
    }, t.restorePreviousBuffers = (n) => {
    }, t.bind = function() {
      let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      r === null && (r = e.context.FRAMEBUFFER), e.context.bindFramebuffer(r, e.glFramebuffer);
      for (let i = 0; i < e.colorBuffers.length; i++) e.colorBuffers[i].bind();
      e._openGLRenderWindow.setActiveFramebuffer(t);
    }, t.create = (n, r) => {
      if (!e.context) {
        Jt("you must set the OpenGLRenderWindow before calling create");
        return;
      }
      e.glFramebuffer = e.context.createFramebuffer(), e.glFramebuffer.width = n, e.glFramebuffer.height = r;
    }, t.setColorBuffer = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      const i = e.context;
      if (!i) {
        Jt("you must set the OpenGLRenderWindow before calling setColorBuffer");
        return;
      }
      let a = i.COLOR_ATTACHMENT0;
      if (r > 0) if (e._openGLRenderWindow.getWebgl2()) a += r;
      else {
        Jt("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
      e.colorBuffers[r] = n, i.framebufferTexture2D(i.FRAMEBUFFER, a, i.TEXTURE_2D, n.getHandle(), 0);
    }, t.removeColorBuffer = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      const r = e.context;
      if (!r) {
        Jt("you must set the OpenGLRenderWindow before calling removeColorBuffer");
        return;
      }
      let i = r.COLOR_ATTACHMENT0;
      if (n > 0) if (e._openGLRenderWindow.getWebgl2()) i += n;
      else {
        Jt("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
      r.framebufferTexture2D(r.FRAMEBUFFER, i, r.TEXTURE_2D, null, 0), e.colorBuffers = e.colorBuffers.splice(n, 1);
    }, t.setDepthBuffer = (n) => {
      if (!e.context) {
        Jt("you must set the OpenGLRenderWindow before calling setDepthBuffer");
        return;
      }
      if (e._openGLRenderWindow.getWebgl2()) {
        const r = e.context;
        r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, n.getHandle(), 0);
      } else Jt("Attaching depth buffer textures to fbo requires WebGL 2");
    }, t.removeDepthBuffer = () => {
      if (!e.context) {
        Jt("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
        return;
      }
      if (e._openGLRenderWindow.getWebgl2()) {
        const n = e.context;
        n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, null, 0);
      } else Jt("Attaching depth buffer textures to framebuffers requires WebGL 2");
    }, t.getGLFramebuffer = () => e.glFramebuffer, t.setOpenGLRenderWindow = (n) => {
      e._openGLRenderWindow !== n && (t.releaseGraphicsResources(), e._openGLRenderWindow = n, e.context = null, n && (e.context = e._openGLRenderWindow.getContext()));
    }, t.releaseGraphicsResources = () => {
      e.glFramebuffer && e.context.deleteFramebuffer(e.glFramebuffer);
    }, t.getSize = () => e.glFramebuffer == null ? null : [
      e.glFramebuffer.width,
      e.glFramebuffer.height
    ], t.populateFramebuffer = () => {
      if (!e.context) {
        Jt("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
        return;
      }
      t.bind();
      const n = e.context, r = er.newInstance();
      r.setOpenGLRenderWindow(e._openGLRenderWindow), r.setMinificationFilter(dt.LINEAR), r.setMagnificationFilter(dt.LINEAR), r.create2DFromRaw(e.glFramebuffer.width, e.glFramebuffer.height, 4, zt.UNSIGNED_CHAR, null), t.setColorBuffer(r), e.depthTexture = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, e.depthTexture), n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_COMPONENT16, e.glFramebuffer.width, e.glFramebuffer.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e.depthTexture);
    }, t.getColorTexture = () => e.colorBuffers[0];
  }
  const Xq = {
    glFramebuffer: null,
    colorBuffers: null,
    depthTexture: null,
    previousDrawBinding: 0,
    previousReadBinding: 0,
    previousDrawBuffer: 0,
    previousReadBuffer: 0,
    previousActiveFramebuffer: null
  };
  function ZM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Xq, n), _n(t, e), e.colorBuffers && Jt("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."), e.colorBuffers = [], Xu(t, e, [
      "colorBuffers"
    ]), qq(t, e);
  }
  const Zq = pn(ZM, "vtkFramebuffer");
  var C5 = {
    newInstance: Zq,
    extend: ZM
  };
  function Qq(t, e) {
    e.classHierarchy.push("vtkRenderPass"), t.getOperation = () => e.currentOperation, t.setCurrentOperation = (n) => {
      e.currentOperation = n, e.currentTraverseOperation = `traverse${H.capitalize(e.currentOperation)}`;
    }, t.getTraverseOperation = () => e.currentTraverseOperation, t.traverse = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      e.deleted || (e._currentParent = r, e.preDelegateOperations.forEach((i) => {
        t.setCurrentOperation(i), n.traverse(t);
      }), e.delegates.forEach((i) => {
        i.traverse(n, t);
      }), e.postDelegateOperations.forEach((i) => {
        t.setCurrentOperation(i), n.traverse(t);
      }));
    };
  }
  const Jq = {
    delegates: [],
    currentOperation: null,
    preDelegateOperations: [],
    postDelegateOperations: [],
    currentParent: null
  };
  function QM(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Jq, n), H.obj(t, e), H.get(t, e, [
      "currentOperation"
    ]), H.setGet(t, e, [
      "delegates",
      "_currentParent",
      "preDelegateOperations",
      "postDelegateOperations"
    ]), H.moveToProtected(t, e, [
      "currentParent"
    ]), Qq(t, e);
  }
  const $q = H.newInstance(QM, "vtkRenderPass");
  var Z8 = {
    newInstance: $q,
    extend: QM
  };
  const wo = {
    ARRAY_BUFFER: 0,
    ELEMENT_ARRAY_BUFFER: 1,
    TEXTURE_BUFFER: 2
  };
  var JM = {
    ObjectType: wo
  };
  const { ObjectType: Bg } = JM, eX = {};
  function tX(t, e) {
    e.classHierarchy.push("vtkOpenGLBufferObject");
    function n(o) {
      switch (o) {
        case Bg.ELEMENT_ARRAY_BUFFER:
          return e.context.ELEMENT_ARRAY_BUFFER;
        case Bg.TEXTURE_BUFFER:
          if ("TEXTURE_BUFFER" in e.context) return e.context.TEXTURE_BUFFER;
        case Bg.ARRAY_BUFFER:
        default:
          return e.context.ARRAY_BUFFER;
      }
    }
    let r = null, i = null, a = true, s = "";
    t.getType = () => r, t.setType = (o) => {
      r = o;
    }, t.getHandle = () => i, t.isReady = () => a === false, t.generateBuffer = (o) => {
      const l = n(o);
      return i === null && (i = e.context.createBuffer(), r = o), n(r) === l;
    }, t.upload = (o, l) => t.generateBuffer(l) ? (e.context.bindBuffer(n(r), i), e.context.bufferData(n(r), o, e.context.STATIC_DRAW), e.allocatedGPUMemoryInBytes = o.length * o.BYTES_PER_ELEMENT, a = false, true) : (s = "Trying to upload array buffer to incompatible buffer.", false), t.bind = () => i ? (e.context.bindBuffer(n(r), i), true) : false, t.release = () => i ? (e.context.bindBuffer(n(r), null), true) : false, t.releaseGraphicsResources = () => {
      i !== null && (e.context.bindBuffer(n(r), null), e.context.deleteBuffer(i), i = null, e.allocatedGPUMemoryInBytes = 0);
    }, t.setOpenGLRenderWindow = (o) => {
      e._openGLRenderWindow !== o && (t.releaseGraphicsResources(), e._openGLRenderWindow = o, e.context = null, o && (e.context = e._openGLRenderWindow.getContext()));
    }, t.getError = () => s;
  }
  const nX = {
    objectType: Bg.ARRAY_BUFFER,
    context: null,
    allocatedGPUMemoryInBytes: 0
  };
  function $M(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, nX, n), H.obj(t, e), H.get(t, e, [
      "_openGLRenderWindow",
      "allocatedGPUMemoryInBytes"
    ]), H.moveToProtected(t, e, [
      "openGLRenderWindow"
    ]), tX(t, e);
  }
  const rX = H.newInstance($M);
  var go = {
    newInstance: rX,
    extend: $M,
    ...eX,
    ...JM
  };
  const eR = {
    FLAT: 0,
    GOURAUD: 1,
    PHONG: 2
  }, fi = {
    POINTS: 0,
    WIREFRAME: 1,
    SURFACE: 2
  }, iX = eR;
  var tR = {
    Shading: eR,
    Representation: fi,
    Interpolation: iX
  };
  const { vtkErrorMacro: wT } = H;
  function aX(t, e) {
    const n = new Float64Array(3);
    rM(n, e);
    const r = new Float64Array(16);
    return ZD(r, jc(), t, n), r;
  }
  function sX(t, e) {
    return t === null || e === null ? false : !(hT(t, [
      0,
      0,
      0
    ]) && hT(e, [
      1,
      1,
      1
    ]));
  }
  function oX(t, e) {
    e.classHierarchy.push("vtkOpenGLCellArrayBufferObject"), t.setType(wo.ARRAY_BUFFER), t.createVBO = function(n, r, i, a) {
      let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      if (!n.getData() || !n.getData().length) return e.elementCount = 0, 0;
      e.blockSize = 3, e.vertexOffset = 0, e.normalOffset = 0, e.tCoordOffset = 0, e.tCoordComponents = 0, e.colorComponents = 0, e.colorOffset = 0, e.customData = [];
      const o = a.points.getData();
      let l = null, c = null, f = null;
      const u = a.colors ? a.colors.getNumberOfComponents() : 0, h = a.tcoords ? a.tcoords.getNumberOfComponents() : 0;
      a.normals && (e.normalOffset = 4 * e.blockSize, e.blockSize += 3, l = a.normals.getData()), a.customAttributes && a.customAttributes.forEach((j) => {
        j && (e.customData.push({
          data: j.getData(),
          offset: 4 * e.blockSize,
          components: j.getNumberOfComponents(),
          name: j.getName()
        }), e.blockSize += j.getNumberOfComponents());
      }), a.tcoords && (e.tCoordOffset = 4 * e.blockSize, e.tCoordComponents = h, e.blockSize += h, c = a.tcoords.getData()), a.colors ? (e.colorComponents = a.colors.getNumberOfComponents(), e.colorOffset = 0, f = a.colors.getData(), e.colorBO || (e.colorBO = go.newInstance()), e.colorBO.setOpenGLRenderWindow(e._openGLRenderWindow)) : e.colorBO = null, e.stride = 4 * e.blockSize;
      let g = 0, v = 0, m = 0, y = 0, w = 0, C = 0, T;
      const S = {
        anythingToPoints(j, B, Y) {
          for (let X = 0; X < j; ++X) T(B[Y + X]);
        },
        linesToWireframe(j, B, Y) {
          for (let X = 0; X < j - 1; ++X) T(B[Y + X]), T(B[Y + X + 1]);
        },
        polysToWireframe(j, B, Y) {
          if (j > 2) for (let X = 0; X < j; ++X) T(B[Y + X]), T(B[Y + (X + 1) % j]);
        },
        stripsToWireframe(j, B, Y) {
          if (j > 2) {
            for (let X = 0; X < j - 1; ++X) T(B[Y + X]), T(B[Y + X + 1]);
            for (let X = 0; X < j - 2; X++) T(B[Y + X]), T(B[Y + X + 2]);
          }
        },
        polysToSurface(j, B, Y) {
          for (let X = 0; X < j - 2; X++) T(B[Y + 0]), T(B[Y + X + 1]), T(B[Y + X + 2]);
        },
        stripsToSurface(j, B, Y) {
          for (let X = 0; X < j - 2; X++) T(B[Y + X]), T(B[Y + X + 1 + X % 2]), T(B[Y + X + 1 + (X + 1) % 2]);
        }
      }, E = {
        anythingToPoints(j, B) {
          return j;
        },
        linesToWireframe(j, B) {
          return j > 1 ? (j - 1) * 2 : 0;
        },
        polysToWireframe(j, B) {
          return j > 2 ? j * 2 : 0;
        },
        stripsToWireframe(j, B) {
          return j > 2 ? j * 4 - 6 : 0;
        },
        polysToSurface(j, B) {
          return j > 2 ? (j - 2) * 3 : 0;
        },
        stripsToSurface(j, B, Y) {
          return j > 2 ? (j - 2) * 3 : 0;
        }
      };
      let b = null, D = null;
      i === fi.POINTS || r === "verts" ? (b = S.anythingToPoints, D = E.anythingToPoints) : i === fi.WIREFRAME || r === "lines" ? (b = S[`${r}ToWireframe`], D = E[`${r}ToWireframe`]) : (b = S[`${r}ToSurface`], D = E[`${r}ToSurface`]);
      const R = n.getData(), I = R.length;
      let O = 0;
      for (let j = 0; j < I; ) O += D(R[j], R), j += R[j] + 1;
      let L = null;
      const N = new Float32Array(O * e.blockSize);
      f && (L = new Uint8Array(O * 4));
      let F = 0, V = 0, k = 0, _ = 0;
      for (let j = 0; j < 3; ++j) {
        const B = a.points.getRange(j), Y = B[1] - B[0];
        k += Y * Y;
        const X = 0.5 * (B[1] + B[0]);
        _ += X * X;
      }
      if (k > 0 && (Math.abs(_) / k > 1e6 || Math.abs(Math.log10(k)) > 3 || k === 0 && _ > 1e6)) {
        const j = new Float64Array(3), B = new Float64Array(3);
        for (let Y = 0; Y < 3; ++Y) {
          const X = a.points.getRange(Y), ie = X[1] - X[0];
          j[Y] = 0.5 * (X[1] + X[0]), B[Y] = ie > 0 ? 1 / ie : 1;
        }
        t.setCoordShiftAndScale(j, B);
      } else e.coordShiftAndScaleEnabled === true && t.setCoordShiftAndScale(null, null);
      if (s) if (!s.points && !s.cells) s.points = new Int32Array(O), s.cells = new Int32Array(O);
      else {
        const j = new Int32Array(O + s.points.length);
        j.set(s.points), s.points = j;
        const B = new Int32Array(O + s.cells.length);
        B.set(s.cells), s.cells = B;
      }
      let Z = a.vertexOffset;
      T = function(B) {
        if (s && (s.points[Z] = B, s.cells[Z] = C + a.cellOffset), ++Z, g = B * 3, e.coordShiftAndScaleEnabled ? (N[F++] = (o[g++] - e.coordShift[0]) * e.coordScale[0], N[F++] = (o[g++] - e.coordShift[1]) * e.coordScale[1], N[F++] = (o[g++] - e.coordShift[2]) * e.coordScale[2]) : (N[F++] = o[g++], N[F++] = o[g++], N[F++] = o[g++]), l !== null && (a.haveCellNormals ? v = (C + a.cellOffset) * 3 : v = B * 3, N[F++] = l[v++], N[F++] = l[v++], N[F++] = l[v++]), e.customData.forEach((Y) => {
          w = B * Y.components;
          for (let X = 0; X < Y.components; ++X) N[F++] = Y.data[w++];
        }), c !== null) {
          m = B * h;
          for (let Y = 0; Y < h; ++Y) N[F++] = c[m++];
        }
        f !== null && (a.haveCellScalars ? y = (C + a.cellOffset) * u : y = B * u, L[V++] = f[y++], L[V++] = f[y++], L[V++] = f[y++], L[V++] = u === 4 ? f[y++] : 255);
      };
      for (let j = 0; j < I; ) b(R[j], R, j + 1), j += R[j] + 1, C++;
      return e.elementCount = O, t.upload(N, wo.ARRAY_BUFFER), e.colorBO && (e.colorBOStride = 4, e.colorBO.upload(L, wo.ARRAY_BUFFER)), C;
    }, t.setCoordShiftAndScale = (n, r) => {
      if (n !== null && (n.constructor !== Float64Array || n.length !== 3)) {
        wT("Wrong type for coordShift, expected vec3 or null");
        return;
      }
      if (r !== null && (r.constructor !== Float64Array || r.length !== 3)) {
        wT("Wrong type for coordScale, expected vec3 or null");
        return;
      }
      (e.coordShift === null || n === null || !dT(n, e.coordShift)) && (e.coordShift = n), (e.coordScale === null || r === null || !dT(r, e.coordScale)) && (e.coordScale = r), e.coordShiftAndScaleEnabled = sX(e.coordShift, e.coordScale), e.coordShiftAndScaleEnabled ? e.inverseShiftAndScaleMatrix = aX(e.coordShift, e.coordScale) : e.inverseShiftAndScaleMatrix = null;
    };
  }
  const lX = {
    elementCount: 0,
    stride: 0,
    colorBOStride: 0,
    vertexOffset: 0,
    normalOffset: 0,
    tCoordOffset: 0,
    tCoordComponents: 0,
    colorOffset: 0,
    colorComponents: 0,
    tcoordBO: null,
    customData: [],
    coordShift: null,
    coordScale: null,
    coordShiftAndScaleEnabled: false,
    inverseShiftAndScaleMatrix: null
  };
  function nR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, lX, n), go.extend(t, e, n), H.setGet(t, e, [
      "colorBO",
      "elementCount",
      "stride",
      "colorBOStride",
      "vertexOffset",
      "normalOffset",
      "tCoordOffset",
      "tCoordComponents",
      "colorOffset",
      "colorComponents",
      "customData"
    ]), H.get(t, e, [
      "coordShift",
      "coordScale",
      "coordShiftAndScaleEnabled",
      "inverseShiftAndScaleMatrix"
    ]), oX(t, e);
  }
  const cX = H.newInstance(nR);
  var uX = {
    newInstance: cX,
    extend: nR
  };
  const { vtkErrorMacro: fX } = H;
  function hX(t, e) {
    e.classHierarchy.push("vtkShader"), t.compile = () => {
      let n = e.context.VERTEX_SHADER;
      if (!e.source || !e.source.length || e.shaderType === "Unknown") return false;
      switch (e.handle !== 0 && (e.context.deleteShader(e.handle), e.handle = 0), e.shaderType) {
        case "Fragment":
          n = e.context.FRAGMENT_SHADER;
          break;
        case "Vertex":
        default:
          n = e.context.VERTEX_SHADER;
          break;
      }
      if (e.handle = e.context.createShader(n), e.context.shaderSource(e.handle, e.source), e.context.compileShader(e.handle), !e.context.getShaderParameter(e.handle, e.context.COMPILE_STATUS)) {
        const i = e.context.getShaderInfoLog(e.handle);
        return fX(`Error compiling shader '${e.source}': ${i}`), e.context.deleteShader(e.handle), e.handle = 0, false;
      }
      return true;
    }, t.cleanup = () => {
      e.shaderType === "Unknown" || e.handle === 0 || (e.context.deleteShader(e.handle), e.handle = 0, e.dirty = true);
    };
  }
  const dX = {
    shaderType: "Unknown",
    source: "",
    error: "",
    handle: 0,
    dirty: false,
    context: null
  };
  function rR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, dX, n), H.obj(t, e), H.setGet(t, e, [
      "shaderType",
      "source",
      "error",
      "handle",
      "context"
    ]), hX(t, e);
  }
  const gX = H.newInstance(rR, "vtkShader");
  var L4 = {
    newInstance: gX,
    extend: rR
  };
  const { vtkErrorMacro: Cs } = H;
  function pX(t, e, n, r) {
    const i = typeof n == "string" ? n : n.join(`
`), a = r === false ? e : new RegExp(e, "g"), s = t.replace(a, i);
    return {
      replace: s !== i,
      result: s
    };
  }
  function mX(t, e) {
    e.classHierarchy.push("vtkShaderProgram"), t.compileShader = () => e.vertexShader.compile() ? e.fragmentShader.compile() ? !t.attachShader(e.vertexShader) || !t.attachShader(e.fragmentShader) ? (Cs(e.error), 0) : t.link() ? (t.setCompiled(true), 1) : (Cs(`Links failed: ${e.error}`), 0) : (Cs(e.fragmentShader.getSource().split(`
`).map((n, r) => `${r}: ${n}`).join(`
`)), Cs(e.fragmentShader.getError()), 0) : (Cs(e.vertexShader.getSource().split(`
`).map((n, r) => `${r}: ${n}`).join(`
`)), Cs(e.vertexShader.getError()), 0), t.cleanup = () => {
      e.shaderType === "Unknown" || e.handle === 0 || (t.release(), e.vertexShaderHandle !== 0 && (e.context.detachShader(e.handle, e.vertexShaderHandle), e.vertexShaderHandle = 0), e.fragmentShaderHandle !== 0 && (e.context.detachShader(e.handle, e.fragmentShaderHandle), e.fragmentShaderHandle = 0), e.context.deleteProgram(e.handle), e.handle = 0, t.setCompiled(false));
    }, t.bind = () => !e.linked && !t.link() ? false : (e.context.useProgram(e.handle), t.setBound(true), true), t.isBound = () => !!e.bound, t.release = () => {
      e.context.useProgram(null), t.setBound(false);
    }, t.setContext = (n) => {
      e.vertexShader.setContext(n), e.fragmentShader.setContext(n), e.geometryShader.setContext(n);
    }, t.link = () => {
      if (e.linked) return true;
      if (e.handle === 0) return e.error = "Program has not been initialized, and/or does not have shaders.", false;
      if (e.uniformLocs = {}, e.context.linkProgram(e.handle), !e.context.getProgramParameter(e.handle, e.context.LINK_STATUS)) {
        const r = e.context.getProgramInfoLog(e.handle);
        return Cs(`Error linking shader ${r}`), e.handle = 0, false;
      }
      return t.setLinked(true), e.attributeLocs = {}, true;
    }, t.setUniformMatrix = (n, r) => {
      const i = t.findUniform(n);
      if (i === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      const a = new Float32Array(r);
      return e.context.uniformMatrix4fv(i, false, a), true;
    }, t.setUniformMatrix3x3 = (n, r) => {
      const i = t.findUniform(n);
      if (i === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      const a = new Float32Array(r);
      return e.context.uniformMatrix3fv(i, false, a), true;
    }, t.setUniformf = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform1f(i, r), true);
    }, t.setUniformfv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform1fv(i, r), true);
    }, t.setUniformi = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform1i(i, r), true);
    }, t.setUniformiv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform1iv(i, r), true);
    }, t.setUniform2f = (n, r, i) => {
      const a = t.findUniform(n);
      if (a === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      if (i === void 0) throw new RangeError("Invalid number of values for array");
      return e.context.uniform2f(a, r, i), true;
    }, t.setUniform2fv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform2fv(i, r), true);
    }, t.setUniform2i = (n, r, i) => {
      const a = t.findUniform(n);
      if (a === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      if (i === void 0) throw new RangeError("Invalid number of values for array");
      return e.context.uniform2i(a, r, i), true;
    }, t.setUniform2iv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform2iv(i, r), true);
    }, t.setUniform3f = (n, r, i, a) => {
      const s = t.findUniform(n);
      if (s === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      if (a === void 0) throw new RangeError("Invalid number of values for array");
      return e.context.uniform3f(s, r, i, a), true;
    }, t.setUniform3fArray = (n, r) => {
      const i = t.findUniform(n);
      if (i === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      if (!Array.isArray(r) || r.length !== 3) throw new RangeError("Invalid number of values for array");
      return e.context.uniform3f(i, r[0], r[1], r[2]), true;
    }, t.setUniform3fv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform3fv(i, r), true);
    }, t.setUniform3i = function(n) {
      const r = t.findUniform(n);
      if (r === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) a[s - 1] = arguments[s];
      let o = a;
      if (o.length === 1 && Array.isArray(o[0]) && (o = o[0]), o.length !== 3) throw new RangeError("Invalid number of values for array");
      return e.context.uniform3i(r, o[0], o[1], o[2]), true;
    }, t.setUniform3iv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform3iv(i, r), true);
    }, t.setUniform4f = function(n) {
      const r = t.findUniform(n);
      if (r === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) a[s - 1] = arguments[s];
      let o = a;
      if (o.length === 1 && Array.isArray(o[0]) && (o = o[0]), o.length !== 4) throw new RangeError("Invalid number of values for array");
      return e.context.uniform4f(r, o[0], o[1], o[2], o[3]), true;
    }, t.setUniform4fv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform4fv(i, r), true);
    }, t.setUniform4i = function(n) {
      const r = t.findUniform(n);
      if (r === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, false;
      for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) a[s - 1] = arguments[s];
      let o = a;
      if (o.length === 1 && Array.isArray(o[0]) && (o = o[0]), o.length !== 4) throw new RangeError("Invalid number of values for array");
      return e.context.uniform4i(r, o[0], o[1], o[2], o[3]), true;
    }, t.setUniform4iv = (n, r) => {
      const i = t.findUniform(n);
      return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, false) : (e.context.uniform4iv(i, r), true);
    }, t.findUniform = (n) => {
      if (!n || !e.linked) return -1;
      let r = e.uniformLocs[n];
      return r !== void 0 ? r : (r = e.context.getUniformLocation(e.handle, n), r === null ? (e.error = `Uniform ${n} not found in current shader program.`, e.uniformLocs[n] = -1, -1) : (e.uniformLocs[n] = r, r));
    }, t.isUniformUsed = (n) => {
      if (!n) return false;
      let r = e.uniformLocs[n];
      return r !== void 0 ? r !== null : e.linked ? (r = e.context.getUniformLocation(e.handle, n), e.uniformLocs[n] = r, r !== null) : (Cs("attempt to find uniform when the shader program is not linked"), false);
    }, t.isAttributeUsed = (n) => {
      if (!n) return false;
      if (n in e.attributeLocs) return true;
      if (!e.linked) return Cs("attempt to find uniform when the shader program is not linked"), false;
      const r = e.context.getAttribLocation(e.handle, n);
      return r === -1 ? false : (e.attributeLocs[n] = r, true);
    }, t.attachShader = (n) => {
      if (n.getHandle() === 0) return e.error = "Shader object was not initialized, cannot attach it.", false;
      if (n.getShaderType() === "Unknown") return e.error = "Shader object is of type Unknown and cannot be used.", false;
      if (e.handle === 0) {
        const r = e.context.createProgram();
        if (r === 0) return e.error = "Could not create shader program.", false;
        e.handle = r, e.linked = false;
      }
      return n.getShaderType() === "Vertex" && (e.vertexShaderHandle !== 0 && e.context.detachShader(e.handle, e.vertexShaderHandle), e.vertexShaderHandle = n.getHandle()), n.getShaderType() === "Fragment" && (e.fragmentShaderHandle !== 0 && e.context.detachShader(e.handle, e.fragmentShaderHandle), e.fragmentShaderHandle = n.getHandle()), e.context.attachShader(e.handle, n.getHandle()), t.setLinked(false), true;
    }, t.detachShader = (n) => {
      if (n.getHandle() === 0) return e.error = "shader object was not initialized, cannot attach it.", false;
      if (n.getShaderType() === "Unknown") return e.error = "Shader object is of type Unknown and cannot be used.", false;
      switch (e.handle === 0 && (e.error = "This shader program has not been initialized yet."), n.getShaderType()) {
        case "Vertex":
          return e.vertexShaderHandle !== n.getHandle() ? (e.error = "The supplied shader was not attached to this program.", false) : (e.context.detachShader(e.handle, n.getHandle()), e.vertexShaderHandle = 0, e.linked = false, true);
        case "Fragment":
          return e.fragmentShaderHandle !== n.getHandle() ? (e.error = "The supplied shader was not attached to this program.", false) : (e.context.detachShader(e.handle, n.getHandle()), e.fragmentShaderHandle = 0, e.linked = false, true);
        default:
          return false;
      }
    }, t.setContext = (n) => {
      e.context = n, e.vertexShader.setContext(n), e.fragmentShader.setContext(n), e.geometryShader.setContext(n);
    }, t.setLastCameraMTime = (n) => {
      e.lastCameraMTime = n;
    };
  }
  const vX = {
    vertexShaderHandle: 0,
    fragmentShaderHandle: 0,
    geometryShaderHandle: 0,
    vertexShader: null,
    fragmentShader: null,
    geometryShader: null,
    linked: false,
    bound: false,
    compiled: false,
    error: "",
    handle: 0,
    numberOfOutputs: 0,
    attributesLocs: null,
    uniformLocs: null,
    md5Hash: 0,
    context: null,
    lastCameraMTime: null
  };
  function iR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, vX, n), e.attributesLocs = {}, e.uniformLocs = {}, e.vertexShader = L4.newInstance(), e.vertexShader.setShaderType("Vertex"), e.fragmentShader = L4.newInstance(), e.fragmentShader.setShaderType("Fragment"), e.geometryShader = L4.newInstance(), e.geometryShader.setShaderType("Geometry"), H.obj(t, e), H.get(t, e, [
      "lastCameraMTime"
    ]), H.setGet(t, e, [
      "error",
      "handle",
      "compiled",
      "bound",
      "md5Hash",
      "vertexShader",
      "fragmentShader",
      "geometryShader",
      "linked"
    ]), mX(t, e);
  }
  const yX = H.newInstance(iR, "vtkShaderProgram");
  var se = {
    newInstance: yX,
    extend: iR,
    substitute: pX
  };
  function xX(t, e) {
    e.classHierarchy.push("vtkOpenGLVertexArrayObject"), t.exposedMethod = () => {
    }, t.initialize = () => {
      e.instancingExtension = null, e._openGLRenderWindow.getWebgl2() || (e.instancingExtension = e.context.getExtension("ANGLE_instanced_arrays")), !e.forceEmulation && e._openGLRenderWindow && e._openGLRenderWindow.getWebgl2() ? (e.extension = null, e.supported = true, e.handleVAO = e.context.createVertexArray()) : (e.extension = e.context.getExtension("OES_vertex_array_object"), !e.forceEmulation && e.extension ? (e.supported = true, e.handleVAO = e.extension.createVertexArrayOES()) : e.supported = false);
    }, t.isReady = () => e.handleVAO !== 0 || e.supported === false, t.bind = () => {
      if (t.isReady() || t.initialize(), t.isReady() && e.supported) e.extension ? e.extension.bindVertexArrayOES(e.handleVAO) : e.context.bindVertexArray(e.handleVAO);
      else if (t.isReady()) {
        const n = e.context;
        for (let r = 0; r < e.buffers.length; ++r) {
          const i = e.buffers[r];
          e.context.bindBuffer(n.ARRAY_BUFFER, i.buffer);
          for (let a = 0; a < i.attributes.length; ++a) {
            const s = i.attributes[a], o = s.isMatrix ? s.size : 1;
            for (let l = 0; l < o; ++l) n.enableVertexAttribArray(s.index + l), n.vertexAttribPointer(s.index + l, s.size, s.type, s.normalize, s.stride, s.offset + s.stride * l / s.size), s.divisor > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(s.index + l, 1) : n.vertexAttribDivisor(s.index + l, 1));
          }
        }
      }
    }, t.release = () => {
      if (t.isReady() && e.supported) e.extension ? e.extension.bindVertexArrayOES(null) : e.context.bindVertexArray(null);
      else if (t.isReady()) {
        const n = e.context;
        for (let r = 0; r < e.buffers.length; ++r) {
          const i = e.buffers[r];
          e.context.bindBuffer(n.ARRAY_BUFFER, i.buffer);
          for (let a = 0; a < i.attributes.length; ++a) {
            const s = i.attributes[a], o = s.isMatrix ? s.size : 1;
            for (let l = 0; l < o; ++l) n.enableVertexAttribArray(s.index + l), n.vertexAttribPointer(s.index + l, s.size, s.type, s.normalize, s.stride, s.offset + s.stride * l / s.size), s.divisor > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(s.index + l, 0) : n.vertexAttribDivisor(s.index + l, 0)), n.disableVertexAttribArray(s.index + l);
          }
        }
      }
    }, t.shaderProgramChanged = () => {
      t.release(), e.handleVAO && (e.extension ? e.extension.deleteVertexArrayOES(e.handleVAO) : e.context.deleteVertexArray(e.handleVAO)), e.handleVAO = 0, e.handleProgram = 0;
    }, t.releaseGraphicsResources = () => {
      t.shaderProgramChanged(), e.handleVAO && (e.extension ? e.extension.deleteVertexArrayOES(e.handleVAO) : e.context.deleteVertexArray(e.handleVAO)), e.handleVAO = 0, e.supported = true, e.handleProgram = 0;
    }, t.addAttributeArray = (n, r, i, a, s, o, l, c) => t.addAttributeArrayWithDivisor(n, r, i, a, s, o, l, c, 0, false), t.addAttributeArrayWithDivisor = (n, r, i, a, s, o, l, c, f, u) => {
      if (!n || !n.isBound() || r.getHandle() === 0 || r.getType() !== wo.ARRAY_BUFFER || (e.handleProgram === 0 && (e.handleProgram = n.getHandle()), t.isReady() || t.initialize(), !t.isReady() || e.handleProgram !== n.getHandle())) return false;
      const h = e.context, g = {};
      if (g.name = i, g.index = h.getAttribLocation(e.handleProgram, i), g.offset = a, g.stride = s, g.type = o, g.size = l, g.normalize = c, g.isMatrix = u, g.divisor = f, g.Index === -1) return false;
      if (r.bind(), h.enableVertexAttribArray(g.index), h.vertexAttribPointer(g.index, g.size, g.type, g.normalize, g.stride, g.offset), f > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(g.index, 1) : h.vertexAttribDivisor(g.index, 1)), g.buffer = r.getHandle(), !e.supported) {
        let v = false;
        for (let m = 0; m < e.buffers.length; ++m) {
          const y = e.buffers[m];
          if (y.buffer === g.buffer) {
            v = true;
            let w = false;
            for (let C = 0; C < y.attributes.length; ++C) y.attributes[C].name === i && (w = true, y.attributes[C] = g);
            w || y.attributes.push(g);
          }
        }
        v || e.buffers.push({
          buffer: g.buffer,
          attributes: [
            g
          ]
        });
      }
      return true;
    }, t.addAttributeMatrixWithDivisor = (n, r, i, a, s, o, l, c, f) => {
      const u = t.addAttributeArrayWithDivisor(n, r, i, a, s, o, l, c, f, true);
      if (!u) return u;
      const h = e.context, g = h.getAttribLocation(e.handleProgram, i);
      for (let v = 1; v < l; v++) h.enableVertexAttribArray(g + v), h.vertexAttribPointer(g + v, l, o, c, s, a + s * v / l), f > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(g + v, 1) : h.vertexAttribDivisor(g + v, 1));
      return true;
    }, t.removeAttributeArray = (n) => {
      if (!t.isReady() || e.handleProgram === 0) return false;
      if (!e.supported) for (let r = 0; r < e.buffers.length; ++r) {
        const i = e.buffers[r];
        for (let a = 0; a < i.attributes.length; ++a) if (i.attributes[a].name === n) return i.attributes.splice(a, 1), i.attributes.length || e.buffers.splice(r, 1), true;
      }
      return true;
    }, t.setOpenGLRenderWindow = (n) => {
      e._openGLRenderWindow !== n && (t.releaseGraphicsResources(), e._openGLRenderWindow = n, e.context = null, n && (e.context = e._openGLRenderWindow.getContext()));
    };
  }
  const wX = {
    forceEmulation: false,
    handleVAO: 0,
    handleProgram: 0,
    supported: true,
    buffers: null,
    context: null
  };
  function aR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, wX, n), e.buffers = [], H.obj(t, e), H.get(t, e, [
      "supported"
    ]), H.setGet(t, e, [
      "forceEmulation"
    ]), xX(t, e);
  }
  const CX = H.newInstance(aR, "vtkOpenGLVertexArrayObject");
  var Q8 = {
    newInstance: CX,
    extend: aR
  };
  const dl = {
    Start: 0,
    Points: 0,
    Lines: 1,
    Tris: 2,
    TriStrips: 3,
    TrisEdges: 4,
    TriStripsEdges: 5,
    End: 6
  };
  function TX(t, e) {
    e.classHierarchy.push("vtkOpenGLHelper"), t.setOpenGLRenderWindow = (n) => {
      e.context = n.getContext(), e.program.setContext(e.context), e.VAO.setOpenGLRenderWindow(n), e.CABO.setOpenGLRenderWindow(n);
    }, t.releaseGraphicsResources = (n) => {
      e.VAO.releaseGraphicsResources(), e.CABO.releaseGraphicsResources(), e.CABO.setElementCount(0);
    }, t.drawArrays = (n, r, i, a) => {
      if (e.CABO.getElementCount()) {
        const s = t.getOpenGLMode(i), o = t.haveWideLines(n, r), l = e.context, c = l.getParameter(l.DEPTH_WRITEMASK);
        e.pointPicking && l.depthMask(false), s === l.LINES && o ? (t.updateShaders(n, r, a), l.drawArraysInstanced(s, 0, e.CABO.getElementCount(), 2 * Math.ceil(r.getProperty().getLineWidth()))) : (l.lineWidth(r.getProperty().getLineWidth()), t.updateShaders(n, r, a), l.drawArrays(s, 0, e.CABO.getElementCount()), l.lineWidth(1));
        const u = (s === l.POINTS ? 1 : 0) || (s === l.LINES ? 2 : 3);
        return e.pointPicking && l.depthMask(c), e.CABO.getElementCount() / u;
      }
      return 0;
    }, t.getOpenGLMode = (n) => {
      if (e.pointPicking) return e.context.POINTS;
      const r = e.primitiveType;
      return n === fi.POINTS || r === dl.Points ? e.context.POINTS : n === fi.WIREFRAME || r === dl.Lines || r === dl.TrisEdges || r === dl.TriStripsEdges ? e.context.LINES : e.context.TRIANGLES;
    }, t.haveWideLines = (n, r) => r.getProperty().getLineWidth() > 1 ? !(e.CABO.getOpenGLRenderWindow() && e.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= r.getProperty().getLineWidth()) : false, t.getNeedToRebuildShaders = (n, r, i) => !!(i.getNeedToRebuildShaders(t, n, r) || t.getProgram() === 0 || t.getShaderSourceTime().getMTime() < i.getMTime() || t.getShaderSourceTime().getMTime() < r.getMTime()), t.updateShaders = (n, r, i) => {
      if (t.getNeedToRebuildShaders(n, r, i)) {
        const a = {
          Vertex: null,
          Fragment: null,
          Geometry: null
        };
        i.buildShaders(a, n, r);
        const s = e.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex, a.Fragment, a.Geometry);
        s !== t.getProgram() && (t.setProgram(s), t.getVAO().releaseGraphicsResources()), t.getShaderSourceTime().modified();
      } else e.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(t.getProgram());
      t.getVAO().bind(), i.setMapperShaderParameters(t, n, r), i.setPropertyShaderParameters(t, n, r), i.setCameraShaderParameters(t, n, r), i.setLightingShaderParameters(t, n, r), i.invokeShaderCallbacks(t, n, r);
    }, t.setMapperShaderParameters = (n, r, i) => {
      if (t.haveWideLines(n, r)) {
        t.getProgram().setUniform2f("viewportSize", i.usize, i.vsize);
        const a = parseFloat(r.getProperty().getLineWidth()), s = a / 2;
        t.getProgram().setUniformf("lineWidthStepSize", a / Math.ceil(a)), t.getProgram().setUniformf("halfLineWidth", s);
      }
      e.primitiveType === dl.Points || r.getProperty().getRepresentation() === fi.POINTS ? t.getProgram().setUniformf("pointSize", r.getProperty().getPointSize()) : e.pointPicking && t.getProgram().setUniformf("pointSize", t.getPointPickingPrimitiveSize());
    }, t.replaceShaderPositionVC = (n, r, i) => {
      let a = n.Vertex;
      a = se.substitute(a, "//VTK::PositionVC::Dec", [
        "//VTK::PositionVC::Dec",
        "uniform float pointSize;"
      ]).result, a = se.substitute(a, "//VTK::PositionVC::Impl", [
        "//VTK::PositionVC::Impl",
        "  gl_PointSize = pointSize;"
      ], false).result, t.getOpenGLMode(i.getProperty().getRepresentation()) === e.context.LINES && t.haveWideLines(r, i) && (a = se.substitute(a, "//VTK::PositionVC::Dec", [
        "//VTK::PositionVC::Dec",
        "uniform vec2 viewportSize;",
        "uniform float lineWidthStepSize;",
        "uniform float halfLineWidth;"
      ]).result, a = se.substitute(a, "//VTK::PositionVC::Impl", [
        "//VTK::PositionVC::Impl",
        " if (halfLineWidth > 0.0)",
        "   {",
        "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;",
        "   vec4 tmpPos = gl_Position;",
        "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;",
        "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];",
        "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];",
        "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);",
        "   }"
      ]).result), n.Vertex = a;
    }, t.getPointPickingPrimitiveSize = () => e.primitiveType === dl.Points ? 2 : e.primitiveType === dl.Lines ? 4 : 6, t.getAllocatedGPUMemoryInBytes = () => t.getCABO().getAllocatedGPUMemoryInBytes();
  }
  const SX = {
    context: null,
    program: null,
    shaderSourceTime: null,
    VAO: null,
    attributeUpdateTime: null,
    CABO: null,
    primitiveType: 0,
    pointPicking: false
  };
  function sR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, SX, n), H.obj(t, e), e.shaderSourceTime = {}, H.obj(e.shaderSourceTime), e.attributeUpdateTime = {}, H.obj(e.attributeUpdateTime), H.setGet(t, e, [
      "program",
      "shaderSourceTime",
      "VAO",
      "attributeUpdateTime",
      "CABO",
      "primitiveType",
      "pointPicking"
    ]), e.program = se.newInstance(), e.VAO = Q8.newInstance(), e.CABO = uX.newInstance(), TX(t, e);
  }
  const AX = H.newInstance(sR);
  var Bs = {
    newInstance: AX,
    extend: sR,
    primTypes: dl
  };
  const { Representation: Y1, Interpolation: q1 } = tR;
  function CT(t) {
    return () => H.vtkErrorMacro(`vtkProperty::${t} - NOT IMPLEMENTED`);
  }
  function EX(t, e) {
    e.classHierarchy.push("vtkProperty"), t.setColor = (n, r, i) => {
      Array.isArray(n) ? (e.color[0] !== n[0] || e.color[1] !== n[1] || e.color[2] !== n[2]) && (e.color[0] = n[0], e.color[1] = n[1], e.color[2] = n[2], t.modified()) : (e.color[0] !== n || e.color[1] !== r || e.color[2] !== i) && (e.color[0] = n, e.color[1] = r, e.color[2] = i, t.modified()), t.setDiffuseColor(e.color), t.setAmbientColor(e.color), t.setSpecularColor(e.color);
    }, t.computeCompositeColor = CT("ComputeCompositeColor"), t.getColor = () => {
      let n = 0;
      e.ambient + e.diffuse + e.specular > 0 && (n = 1 / (e.ambient + e.diffuse + e.specular));
      for (let r = 0; r < 3; r++) e.color[r] = n * (e.ambient * e.ambientColor[r] + e.diffuse * e.diffuseColor[r] + e.specular * e.specularColor[r]);
      return [].concat(e.color);
    }, t.setSpecularPower = (n) => {
      const r = 1 / Math.max(1, n);
      (e.roughness !== r || e.specularPower !== n) && (e.specularPower = n, e.roughness = r, t.modified());
    }, t.addShaderVariable = CT("AddShaderVariable"), t.setInterpolationToFlat = () => t.setInterpolation(q1.FLAT), t.setInterpolationToGouraud = () => t.setInterpolation(q1.GOURAUD), t.setInterpolationToPhong = () => t.setInterpolation(q1.PHONG), t.getInterpolationAsString = () => H.enumToString(q1, e.interpolation), t.setRepresentationToWireframe = () => t.setRepresentation(Y1.WIREFRAME), t.setRepresentationToSurface = () => t.setRepresentation(Y1.SURFACE), t.setRepresentationToPoints = () => t.setRepresentation(Y1.POINTS), t.getRepresentationAsString = () => H.enumToString(Y1, e.representation);
  }
  const bX = {
    color: [
      1,
      1,
      1
    ],
    ambientColor: [
      1,
      1,
      1
    ],
    diffuseColor: [
      1,
      1,
      1
    ],
    specularColor: [
      1,
      1,
      1
    ],
    edgeColor: [
      0,
      0,
      0
    ],
    ambient: 0,
    diffuse: 1,
    metallic: 0,
    roughness: 0.6,
    normalStrength: 1,
    emission: 1,
    baseIOR: 1.45,
    specular: 0,
    specularPower: 1,
    opacity: 1,
    interpolation: q1.GOURAUD,
    representation: Y1.SURFACE,
    edgeVisibility: false,
    backfaceCulling: false,
    frontfaceCulling: false,
    pointSize: 1,
    lineWidth: 1,
    lighting: true,
    shading: false,
    materialName: null
  };
  function DX(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, bX, n), H.obj(t, e), H.setGet(t, e, [
      "lighting",
      "interpolation",
      "ambient",
      "diffuse",
      "metallic",
      "roughness",
      "normalStrength",
      "emission",
      "baseIOR",
      "specular",
      "specularPower",
      "opacity",
      "edgeVisibility",
      "lineWidth",
      "pointSize",
      "backfaceCulling",
      "frontfaceCulling",
      "representation",
      "diffuseTexture",
      "metallicTexture",
      "roughnessTexture",
      "normalTexture",
      "ambientOcclusionTexture",
      "emissionTexture"
    ]), H.setGetArray(t, e, [
      "ambientColor",
      "specularColor",
      "diffuseColor",
      "edgeColor"
    ], 3), EX(t, e);
  }
  const MX = H.newInstance(DX, "vtkProperty");
  var ef = {
    newInstance: MX,
    ...tR
  };
  const { Representation: RX } = ef, { vtkErrorMacro: TT } = H;
  function OX(t) {
    const e = se.substitute(t.Fragment, "//VTK::RenderPassFragmentShader::Impl", `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
    t.Fragment = e.result;
  }
  const IX = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
  function VX(t, e) {
    e.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"), t.createVertexBuffer = () => {
      const n = new Float32Array([
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1
      ]), r = new Float32Array([
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        1
      ]), i = new Uint16Array([
        4,
        0,
        1,
        3,
        2
      ]), a = Tt.newInstance({
        numberOfComponents: 3,
        values: n
      });
      a.setName("points");
      const s = Tt.newInstance({
        numberOfComponents: 2,
        values: r
      });
      s.setName("tcoords");
      const o = Tt.newInstance({
        numberOfComponents: 1,
        values: i
      });
      e.tris.getCABO().createVBO(o, "polys", RX.SURFACE, {
        points: a,
        tcoords: s,
        cellOffset: 0
      }), e.VBOBuildTime.modified();
    }, t.createFramebuffer = (n) => {
      const r = n.getSize(), i = n.getContext();
      e.framebuffer = C5.newInstance(), e.framebuffer.setOpenGLRenderWindow(n), e.framebuffer.create(...r), e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.bind(), e.translucentRGBATexture = er.newInstance(), e.translucentRGBATexture.setInternalFormat(i.RGBA16F), e.translucentRGBATexture.setFormat(i.RGBA), e.translucentRGBATexture.setOpenGLDataType(i.HALF_FLOAT), e.translucentRGBATexture.setOpenGLRenderWindow(n), e.translucentRGBATexture.create2DFromRaw(r[0], r[1], 4, "Float32Array", null), e.translucentRTexture = er.newInstance(), e.translucentRTexture.setInternalFormat(i.R16F), e.translucentRTexture.setFormat(i.RED), e.translucentRTexture.setOpenGLDataType(i.HALF_FLOAT), e.translucentRTexture.setOpenGLRenderWindow(n), e.translucentRTexture.create2DFromRaw(r[0], r[1], 1, "Float32Array", null), e.translucentZTexture = er.newInstance(), e.translucentZTexture.setOpenGLRenderWindow(n), e.translucentZTexture.createDepthFromRaw(r[0], r[1], "Float32Array", null), e.framebuffer.setColorBuffer(e.translucentRGBATexture, 0), e.framebuffer.setColorBuffer(e.translucentRTexture, 1), e.framebuffer.setDepthBuffer(e.translucentZTexture);
    }, t.createCopyShader = (n) => {
      e.copyShader = n.getShaderCache().readyShaderProgramArray([
        "//VTK::System::Dec",
        "attribute vec4 vertexDC;",
        "attribute vec2 tcoordTC;",
        "varying vec2 tcoord;",
        "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"
      ].join(`
`), IX, "");
    }, t.createVBO = (n) => {
      const r = n.getContext();
      e.tris.setOpenGLRenderWindow(n), t.createVertexBuffer();
      const i = e.copyShader;
      e.tris.getCABO().bind(), e.copyVAO.addAttributeArray(i, e.tris.getCABO(), "vertexDC", e.tris.getCABO().getVertexOffset(), e.tris.getCABO().getStride(), r.FLOAT, 3, r.FALSE) || TT("Error setting vertexDC in copy shader VAO."), e.copyVAO.addAttributeArray(i, e.tris.getCABO(), "tcoordTC", e.tris.getCABO().getTCoordOffset(), e.tris.getCABO().getStride(), r.FLOAT, 2, r.FALSE) || TT("Error setting vertexDC in copy shader VAO.");
    }, t.traverse = (n, r, i) => {
      if (e.deleted) return;
      const a = n.getSize(), s = n.getContext();
      if (e._supported = false, r.getSelector() || !s || !n.getWebgl2() || !s.getExtension("EXT_color_buffer_half_float") && !s.getExtension("EXT_color_buffer_float")) {
        t.setCurrentOperation("translucentPass"), r.traverse(t);
        return;
      }
      if (e._supported = true, e.framebuffer === null) t.createFramebuffer(n);
      else {
        const l = e.framebuffer.getSize();
        l === null || l[0] !== a[0] || l[1] !== a[1] ? (e.framebuffer.releaseGraphicsResources(), e.translucentRGBATexture.releaseGraphicsResources(n), e.translucentRTexture.releaseGraphicsResources(n), e.translucentZTexture.releaseGraphicsResources(n), t.createFramebuffer(n)) : (e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.bind());
      }
      s.drawBuffers([
        s.COLOR_ATTACHMENT0
      ]), s.clearBufferfv(s.COLOR, 0, [
        0,
        0,
        0,
        0
      ]), s.clearBufferfv(s.DEPTH, 0, [
        1
      ]), s.colorMask(false, false, false, false), i.getOpaqueActorCount() > 0 && (i.setCurrentOperation("opaqueZBufferPass"), r.traverse(i)), s.colorMask(true, true, true, true), s.drawBuffers([
        s.COLOR_ATTACHMENT0,
        s.COLOR_ATTACHMENT1
      ]), s.viewport(0, 0, a[0], a[1]), s.scissor(0, 0, a[0], a[1]), s.clearBufferfv(s.COLOR, 0, [
        0,
        0,
        0,
        1
      ]), s.clearBufferfv(s.COLOR, 1, [
        0,
        0,
        0,
        0
      ]), s.enable(s.DEPTH_TEST), s.enable(s.BLEND), s.blendFuncSeparate(s.ONE, s.ONE, s.ZERO, s.ONE_MINUS_SRC_ALPHA), t.setCurrentOperation("translucentPass"), r.traverse(t), s.drawBuffers([
        s.NONE
      ]), e.framebuffer.restorePreviousBindingsAndBuffers(), e.copyShader === null ? t.createCopyShader(n) : n.getShaderCache().readyShaderProgram(e.copyShader), e.copyVAO || (e.copyVAO = Q8.newInstance(), e.copyVAO.setOpenGLRenderWindow(n)), e.copyVAO.bind(), e.VBOBuildTime.getMTime() < t.getMTime() && t.createVBO(n), s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA), s.depthMask(false), s.depthFunc(s.ALWAYS), s.viewport(0, 0, a[0], a[1]), s.scissor(0, 0, a[0], a[1]), e.translucentRGBATexture.activate(), e.copyShader.setUniformi("translucentRGBATexture", e.translucentRGBATexture.getTextureUnit()), e.translucentRTexture.activate(), e.copyShader.setUniformi("translucentRTexture", e.translucentRTexture.getTextureUnit()), s.drawArrays(s.TRIANGLES, 0, e.tris.getCABO().getElementCount()), s.depthMask(true), s.depthFunc(s.LEQUAL), e.translucentRGBATexture.deactivate(), e.translucentRTexture.deactivate();
      const o = r.getTiledSizeAndOrigin();
      s.scissor(o.lowerLeftU, o.lowerLeftV, o.usize, o.vsize), s.viewport(o.lowerLeftU, o.lowerLeftV, o.usize, o.vsize);
    }, t.getShaderReplacement = () => e._supported ? OX : null, t.releaseGraphicsResources = (n) => {
      e.framebuffer && (e.framebuffer.releaseGraphicsResources(n), e.framebuffer = null), e.translucentRGBATexture && (e.translucentRGBATexture.releaseGraphicsResources(n), e.translucentRGBATexture = null), e.translucentRTexture && (e.translucentRTexture.releaseGraphicsResources(n), e.translucentRTexture = null), e.translucentZTexture && (e.translucentZTexture.releaseGraphicsResources(n), e.translucentZTexture = null), e.copyVAO && (e.copyVAO.releaseGraphicsResources(n), e.copyVAO = null), e.copyShader && (e.copyShader.releaseGraphicsResources(n), e.copyShader = null), e.tris && (e.tris.releaseGraphicsResources(n), e.tris = null), t.modified();
    };
  }
  const NX = {
    framebuffer: null,
    copyShader: null,
    tris: null
  };
  function oR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, NX, n), Z8.extend(t, e, n), e.VBOBuildTime = {}, H.obj(e.VBOBuildTime, {
      mtime: 0
    }), e.tris = Bs.newInstance(), H.get(t, e, [
      "framebuffer"
    ]), VX(t, e);
  }
  const LX = H.newInstance(oR, "vtkOpenGLOrderIndependentTranslucentPass");
  var UX = {
    newInstance: LX,
    extend: oR
  };
  function FX(t, e) {
    e.classHierarchy.push("vtkForwardPass"), t.traverse = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (e.deleted) return;
      e._currentParent = r, t.setCurrentOperation("buildPass"), n.traverse(t);
      const i = n.getRenderable().getNumberOfLayers(), a = n.getRenderable().getRenderersByReference();
      for (let s = 0; s < i; s++) for (let o = 0; o < a.length; o++) {
        const l = a[o], c = n.getViewNodeFor(l);
        if (l.getDraw() && l.getLayer() === s) {
          if (e.opaqueActorCount = 0, e.translucentActorCount = 0, e.volumeCount = 0, e.overlayActorCount = 0, t.setCurrentOperation("queryPass"), c.traverse(t), (e.opaqueActorCount > 0 || e.translucentActorCount > 0) && e.volumeCount > 0 || e.depthRequested) {
            const f = n.getFramebufferSize();
            e.framebuffer === null && (e.framebuffer = C5.newInstance()), e.framebuffer.setOpenGLRenderWindow(n), e.framebuffer.saveCurrentBindingsAndBuffers();
            const u = e.framebuffer.getSize();
            (u === null || u[0] !== f[0] || u[1] !== f[1]) && (e.framebuffer.create(f[0], f[1]), e.framebuffer.populateFramebuffer()), e.framebuffer.bind(), t.setCurrentOperation("zBufferPass"), c.traverse(t), e.framebuffer.restorePreviousBindingsAndBuffers(), e.depthRequested = false;
          }
          t.setCurrentOperation("cameraPass"), c.traverse(t), e.opaqueActorCount > 0 && (t.setCurrentOperation("opaquePass"), c.traverse(t)), e.translucentActorCount > 0 && (e.translucentPass || (e.translucentPass = UX.newInstance()), e.translucentPass.traverse(n, c, t)), e.volumeCount > 0 && (t.setCurrentOperation("volumePass"), c.traverse(t)), e.overlayActorCount > 0 && (t.setCurrentOperation("overlayPass"), c.traverse(t));
        }
      }
    }, t.getZBufferTexture = () => e.framebuffer ? e.framebuffer.getColorTexture() : null, t.requestDepth = () => {
      e.depthRequested = true;
    }, t.incrementOpaqueActorCount = () => e.opaqueActorCount++, t.incrementTranslucentActorCount = () => e.translucentActorCount++, t.incrementVolumeCount = () => e.volumeCount++, t.incrementOverlayActorCount = () => e.overlayActorCount++;
  }
  const BX = {
    opaqueActorCount: 0,
    translucentActorCount: 0,
    volumeCount: 0,
    overlayActorCount: 0,
    framebuffer: null,
    depthRequested: false
  };
  function lR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, BX, n), Z8.extend(t, e, n), H.get(t, e, [
      "framebuffer",
      "opaqueActorCount",
      "translucentActorCount",
      "volumeCount"
    ]), FX(t, e);
  }
  const _X = H.newInstance(lR, "vtkForwardPass");
  var kX = {
    newInstance: _X,
    extend: lR
  };
  const Pi = {
    MIN_KNOWN_PASS: 0,
    ACTOR_PASS: 0,
    COMPOSITE_INDEX_PASS: 1,
    ID_LOW24: 2,
    ID_HIGH24: 3,
    MAX_KNOWN_PASS: 3
  };
  var cR = {
    PassTypes: Pi
  };
  const { FieldAssociations: PX } = $u;
  function GX(t, e) {
    e.classHierarchy.push("vtkHardwareSelector"), t.getSourceDataAsync = async (n, r, i, a, s) => {
    }, t.selectAsync = async (n, r, i, a, s) => {
      const o = await t.getSourceDataAsync(n, r, i, a, s);
      return o ? o.generateSelection(r, i, a, s) : [];
    };
  }
  const zX = {
    fieldAssociation: PX.FIELD_ASSOCIATION_CELLS,
    captureZValues: false
  };
  function uR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, zX, n), H.obj(t, e), H.setGet(t, e, [
      "fieldAssociation",
      "captureZValues"
    ]), GX(t, e);
  }
  const WX = H.newInstance(uR, "vtkHardwareSelector");
  var HX = {
    newInstance: WX,
    extend: uR
  };
  const jX = {
    GLOBALIDS: 0,
    PEDIGREEIDS: 1,
    VALUES: 2,
    INDICES: 3,
    FRUSTUM: 4,
    LOCATIONS: 5,
    THRESHOLDS: 6,
    BLOCKS: 7,
    QUERY: 8
  }, KX = {
    CELL: 0,
    POINT: 1,
    FIELD: 2,
    VERTEX: 3,
    EDGE: 4,
    ROW: 5
  };
  var YX = {
    SelectionContent: jX,
    SelectionField: KX
  };
  function qX(t, e) {
    e.classHierarchy.push("vtkSelectionNode"), t.getBounds = () => e.points.getBounds();
  }
  const XX = {
    contentType: -1,
    fieldType: -1,
    properties: null,
    selectionList: []
  };
  function fR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, XX, n), H.obj(t, e), e.properties = {}, H.setGet(t, e, [
      "contentType",
      "fieldType",
      "properties",
      "selectionList"
    ]), qX(t, e);
  }
  const ZX = H.newInstance(fR, "vtkSelectionNode");
  var hR = {
    newInstance: ZX,
    extend: fR,
    ...YX
  };
  const { PassTypes: Or } = cR, { SelectionContent: QX, SelectionField: ST } = hR, { FieldAssociations: dh } = $u, { vtkErrorMacro: dR } = H, xl = 1;
  function gR(t) {
    return `${t.propID} ${t.compositeID}`;
  }
  function pR(t, e, n, r) {
    if (!n) return 0;
    const i = (e * (r[2] - r[0] + 1) + t) * 4;
    return n[i + 3];
  }
  function uo(t, e, n, r) {
    if (!n) return 0;
    const i = (e * (r[2] - r[0] + 1) + t) * 4, a = n[i], s = n[i + 1];
    return (n[i + 2] * 256 + s) * 256 + a;
  }
  function mR(t, e) {
    let n = e;
    return n <<= 24, n |= t, n;
  }
  function JX(t, e, n, r) {
    {
      if (r[0] = e[0], r[1] = e[1], e[0] < t.area[0] || e[0] > t.area[2] || e[1] < t.area[1] || e[1] > t.area[3]) return null;
      const i = [
        e[0] - t.area[0],
        e[1] - t.area[1]
      ], a = uo(i[0], i[1], t.pixBuffer[Or.ACTOR_PASS], t.area);
      if (a <= 0 || a - xl >= t.props.length) return null;
      const s = {};
      s.valid = true, s.propID = a - xl, s.prop = t.props[s.propID];
      let o = uo(i[0], i[1], t.pixBuffer[Or.COMPOSITE_INDEX_PASS], t.area);
      if ((o < 0 || o > 16777215) && (o = 0), s.compositeID = o - xl, t.captureZValues) {
        const f = (i[1] * (t.area[2] - t.area[0] + 1) + i[0]) * 4;
        s.zValue = (256 * t.zBuffer[f] + t.zBuffer[f + 1]) / 65535, s.displayPosition = e;
      }
      if (t.pixBuffer[Or.ID_LOW24] && pR(i[0], i[1], t.pixBuffer[Or.ID_LOW24], t.area) === 0) return s;
      const l = uo(i[0], i[1], t.pixBuffer[Or.ID_LOW24], t.area), c = uo(i[0], i[1], t.pixBuffer[Or.ID_HIGH24], t.area);
      return s.attributeID = mR(l, c), s;
    }
  }
  function vR(t, e, n, r, i) {
    const a = [];
    let s = 0;
    return e.forEach((o, l) => {
      const c = hR.newInstance();
      switch (c.setContentType(QX.INDICES), t) {
        case dh.FIELD_ASSOCIATION_CELLS:
          c.setFieldType(ST.CELL);
          break;
        case dh.FIELD_ASSOCIATION_POINTS:
          c.setFieldType(ST.POINT);
          break;
        default:
          dR("Unknown field association");
      }
      c.getProperties().propID = o.info.propID, c.getProperties().prop = o.info.prop, c.getProperties().compositeID = o.info.compositeID, c.getProperties().attributeID = o.info.attributeID, c.getProperties().pixelCount = o.pixelCount, n && (c.getProperties().displayPosition = [
        o.info.displayPosition[0],
        o.info.displayPosition[1],
        o.info.zValue
      ], c.getProperties().worldPosition = i.displayToWorld(o.info.displayPosition[0], o.info.displayPosition[1], o.info.zValue, r)), c.setSelectionList(o.attributeIDs), a[s] = c, s++;
    }), a;
  }
  function $X(t, e, n, r, i) {
    const a = Math.floor(e), s = Math.floor(n), o = Math.floor(r), l = Math.floor(i), c = /* @__PURE__ */ new Map(), f = [
      0,
      0
    ];
    for (let u = s; u <= l; u++) for (let h = a; h <= o; h++) {
      const v = JX(t, [
        h,
        u
      ], 0, f);
      if (v && v.valid) {
        const m = gR(v);
        if (!c.has(m)) c.set(m, {
          info: v,
          pixelCount: 1,
          attributeIDs: [
            v.attributeID
          ]
        });
        else {
          const y = c.get(m);
          y.pixelCount++, t.captureZValues && v.zValue < y.info.zValue && (y.info = v), y.attributeIDs.indexOf(v.attributeID) === -1 && y.attributeIDs.push(v.attributeID);
        }
      }
    }
    return vR(t.fieldAssociation, c, t.captureZValues, t.renderer, t.openGLRenderWindow);
  }
  function eZ(t, e) {
    e.classHierarchy.push("vtkOpenGLHardwareSelector"), t.releasePixBuffers = () => {
      e.rawPixBuffer = [], e.pixBuffer = [], e.zBuffer = null;
    }, t.beginSelection = () => {
      e._openGLRenderer = e._openGLRenderWindow.getViewNodeFor(e._renderer), e.maxAttributeId = 0;
      const r = e._openGLRenderWindow.getSize();
      if (!e.framebuffer) e.framebuffer = C5.newInstance(), e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.create(r[0], r[1]), e.framebuffer.populateFramebuffer();
      else {
        e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.framebuffer.saveCurrentBindingsAndBuffers();
        const i = e.framebuffer.getSize();
        !i || i[0] !== r[0] || i[1] !== r[1] ? (e.framebuffer.create(r[0], r[1]), e.framebuffer.populateFramebuffer()) : e.framebuffer.bind();
      }
      if (e._openGLRenderer.clear(), e._openGLRenderer.setSelector(t), e.hitProps = {}, e.propPixels = {}, e.props = [], t.releasePixBuffers(), e.fieldAssociation === dh.FIELD_ASSOCIATION_POINTS) {
        const i = e._openGLRenderWindow.getContext(), a = i.isEnabled(i.BLEND);
        i.disable(i.BLEND), e._openGLRenderWindow.traverseAllPasses(), a && i.enable(i.BLEND);
      }
    }, t.endSelection = () => {
      e.hitProps = {}, e._openGLRenderer.setSelector(null), e.framebuffer.restorePreviousBindingsAndBuffers();
    }, t.preCapturePass = () => {
      const r = e._openGLRenderWindow.getContext();
      e.originalBlending = r.isEnabled(r.BLEND), r.disable(r.BLEND);
    }, t.postCapturePass = () => {
      const r = e._openGLRenderWindow.getContext();
      e.originalBlending && r.enable(r.BLEND);
    }, t.select = () => {
      let r = null;
      return t.captureBuffers() && (r = t.generateSelection(e.area[0], e.area[1], e.area[2], e.area[3]), t.releasePixBuffers()), r;
    }, t.getSourceDataAsync = async (r, i, a, s, o) => {
      if (e._renderer = r, i === void 0) {
        const c = e._openGLRenderWindow.getSize();
        t.setArea(0, 0, c[0] - 1, c[1] - 1);
      } else t.setArea(i, a, s, o);
      if (!t.captureBuffers()) return false;
      const l = {
        area: [
          ...e.area
        ],
        pixBuffer: [
          ...e.pixBuffer
        ],
        captureZValues: e.captureZValues,
        zBuffer: e.zBuffer,
        props: [
          ...e.props
        ],
        fieldAssociation: e.fieldAssociation,
        renderer: r,
        openGLRenderWindow: e._openGLRenderWindow
      };
      return l.generateSelection = function() {
        for (var c = arguments.length, f = new Array(c), u = 0; u < c; u++) f[u] = arguments[u];
        return $X(l, ...f);
      }, l;
    }, t.captureBuffers = () => {
      if (!e._renderer || !e._openGLRenderWindow) return dR("Renderer and view must be set before calling Select."), false;
      e._openGLRenderer = e._openGLRenderWindow.getViewNodeFor(e._renderer), e._openGLRenderWindow.getRenderable().preRender(), t.invokeEvent({
        type: "StartEvent"
      }), e.originalBackground = e._renderer.getBackgroundByReference(), e._renderer.setBackground(0, 0, 0, 0);
      const r = e._openGLRenderWindow.getRenderPasses();
      for (t.beginSelection(), e.currentPass = Or.MIN_KNOWN_PASS; e.currentPass <= Or.MAX_KNOWN_PASS; e.currentPass++) t.passRequired(e.currentPass) && (t.preCapturePass(e.currentPass), e.captureZValues && e.currentPass === Or.ACTOR_PASS && typeof r[0].requestDepth == "function" && typeof r[0].getFramebuffer == "function" && r[0].requestDepth(), e._openGLRenderWindow.traverseAllPasses(), t.postCapturePass(e.currentPass), t.savePixelBuffer(e.currentPass), t.processPixelBuffers());
      return t.endSelection(), e._renderer.setBackground(e.originalBackground), t.invokeEvent({
        type: "EndEvent"
      }), true;
    }, t.processPixelBuffers = () => {
      e.props.forEach((r, i) => {
        t.isPropHit(i) && r.processSelectorPixelBuffers(t, e.propPixels[i]);
      });
    }, t.passRequired = (r) => {
      if (r === Or.ID_HIGH24) {
        if (e.fieldAssociation === dh.FIELD_ASSOCIATION_POINTS) return e.maximumPointId > 16777215;
        if (e.fieldAssociation === dh.FIELD_ASSOCIATION_CELLS) return e.maximumCellId > 16777215;
      }
      return true;
    }, t.savePixelBuffer = (r) => {
      if (e.pixBuffer[r] = e._openGLRenderWindow.getPixelData(e.area[0], e.area[1], e.area[2], e.area[3]), !e.rawPixBuffer[r]) {
        const i = (e.area[2] - e.area[0] + 1) * (e.area[3] - e.area[1] + 1) * 4;
        e.rawPixBuffer[r] = new Uint8Array(i), e.rawPixBuffer[r].set(e.pixBuffer[r]);
      }
      if (r === Or.ACTOR_PASS) {
        if (e.captureZValues) {
          const i = e._openGLRenderWindow.getRenderPasses();
          if (typeof i[0].requestDepth == "function" && typeof i[0].getFramebuffer == "function") {
            const a = i[0].getFramebuffer();
            a.saveCurrentBindingsAndBuffers(), a.bind(), e.zBuffer = e._openGLRenderWindow.getPixelData(e.area[0], e.area[1], e.area[2], e.area[3]), a.restorePreviousBindingsAndBuffers();
          }
        }
        t.buildPropHitList(e.rawPixBuffer[r]);
      }
    }, t.buildPropHitList = (r) => {
      let i = 0;
      for (let a = 0; a <= e.area[3] - e.area[1]; a++) for (let s = 0; s <= e.area[2] - e.area[0]; s++) {
        let o = uo(s, a, r, e.area);
        o > 0 && (o--, o in e.hitProps || (e.hitProps[o] = true, e.propPixels[o] = []), e.propPixels[o].push(i * 4)), ++i;
      }
    }, t.renderProp = (r) => {
      e.currentPass === Or.ACTOR_PASS && (t.setPropColorValueFromInt(e.props.length + xl), e.props.push(r));
    }, t.renderCompositeIndex = (r) => {
      e.currentPass === Or.COMPOSITE_INDEX_PASS && t.setPropColorValueFromInt(r + xl);
    }, t.renderAttributeId = (r) => {
      r < 0 || (e.maxAttributeId = r > e.maxAttributeId ? r : e.maxAttributeId);
    }, t.passTypeToString = (r) => H.enumToString(Or, r), t.isPropHit = (r) => !!e.hitProps[r], t.setPropColorValueFromInt = (r) => {
      e.propColorValue[0] = r % 256 / 255, e.propColorValue[1] = Math.floor(r / 256) % 256 / 255, e.propColorValue[2] = Math.floor(r / 65536) % 256 / 255;
    }, t.getPixelInformation = (r, i, a) => {
      const s = i < 0 ? 0 : i;
      if (s === 0) {
        if (a[0] = r[0], a[1] = r[1], r[0] < e.area[0] || r[0] > e.area[2] || r[1] < e.area[1] || r[1] > e.area[3]) return null;
        const f = [
          r[0] - e.area[0],
          r[1] - e.area[1]
        ], u = uo(f[0], f[1], e.pixBuffer[Or.ACTOR_PASS], e.area);
        if (u <= 0 || u - xl >= e.props.length) return null;
        const h = {};
        h.valid = true, h.propID = u - xl, h.prop = e.props[h.propID];
        let g = uo(f[0], f[1], e.pixBuffer[Or.COMPOSITE_INDEX_PASS], e.area);
        if ((g < 0 || g > 16777215) && (g = 0), h.compositeID = g - xl, e.captureZValues) {
          const y = (f[1] * (e.area[2] - e.area[0] + 1) + f[0]) * 4;
          h.zValue = (256 * e.zBuffer[y] + e.zBuffer[y + 1]) / 65535, h.displayPosition = r;
        }
        if (e.pixBuffer[Or.ID_LOW24] && pR(f[0], f[1], e.pixBuffer[Or.ID_LOW24], e.area) === 0) return h;
        const v = uo(f[0], f[1], e.pixBuffer[Or.ID_LOW24], e.area), m = uo(f[0], f[1], e.pixBuffer[Or.ID_HIGH24], e.area);
        return h.attributeID = mR(v, m), h;
      }
      const o = [
        r[0],
        r[1]
      ], l = [
        0,
        0
      ];
      let c = t.getPixelInformation(r, 0, a);
      if (c && c.valid) return c;
      for (let f = 1; f < s; ++f) {
        for (let u = o[1] > f ? o[1] - f : 0; u <= o[1] + f; ++u) if (l[1] = u, o[0] >= f && (l[0] = o[0] - f, c = t.getPixelInformation(l, 0, a), c && c.valid) || (l[0] = o[0] + f, c = t.getPixelInformation(l, 0, a), c && c.valid)) return c;
        for (let u = o[0] >= f ? o[0] - (f - 1) : 0; u <= o[0] + (f - 1); ++u) if (l[0] = u, o[1] >= f && (l[1] = o[1] - f, c = t.getPixelInformation(l, 0, a), c && c.valid) || (l[1] = o[1] + f, c = t.getPixelInformation(l, 0, a), c && c.valid)) return c;
      }
      return a[0] = r[0], a[1] = r[1], null;
    }, t.generateSelection = (r, i, a, s) => {
      const o = Math.floor(r), l = Math.floor(i), c = Math.floor(a), f = Math.floor(s), u = /* @__PURE__ */ new Map(), h = [
        0,
        0
      ];
      for (let g = l; g <= f; g++) for (let v = o; v <= c; v++) {
        const m = [
          v,
          g
        ], y = t.getPixelInformation(m, 0, h);
        if (y && y.valid) {
          const w = gR(y);
          if (!u.has(w)) u.set(w, {
            info: y,
            pixelCount: 1,
            attributeIDs: [
              y.attributeID
            ]
          });
          else {
            const C = u.get(w);
            C.pixelCount++, e.captureZValues && y.zValue < C.info.zValue && (C.info = y), C.attributeIDs.indexOf(y.attributeID) === -1 && C.attributeIDs.push(y.attributeID);
          }
        }
      }
      return vR(e.fieldAssociation, u, e.captureZValues, e._renderer, e._openGLRenderWindow);
    }, t.getRawPixelBuffer = (r) => e.rawPixBuffer[r], t.getPixelBuffer = (r) => e.pixBuffer[r], t.attach = (r, i) => {
      e._openGLRenderWindow = r, e._renderer = i;
    };
    const n = t.setArea;
    t.setArea = function() {
      return n(...arguments) ? (e.area[0] = Math.floor(e.area[0]), e.area[1] = Math.floor(e.area[1]), e.area[2] = Math.floor(e.area[2]), e.area[3] = Math.floor(e.area[3]), true) : false;
    };
  }
  const tZ = {
    area: void 0,
    currentPass: -1,
    propColorValue: null,
    props: null,
    maximumPointId: 0,
    maximumCellId: 0,
    idOffset: 1
  };
  function yR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, tZ, n), HX.extend(t, e, n), e.propColorValue = [
      0,
      0,
      0
    ], e.props = [], e.area || (e.area = [
      0,
      0,
      0,
      0
    ]), H.setGetArray(t, e, [
      "area"
    ], 4), H.setGet(t, e, [
      "_renderer",
      "currentPass",
      "_openGLRenderWindow",
      "maximumPointId",
      "maximumCellId"
    ]), H.setGetArray(t, e, [
      "propColorValue"
    ], 3), H.moveToProtected(t, e, [
      "renderer",
      "openGLRenderWindow"
    ]), H.event(t, e, "event"), eZ(t, e);
  }
  const nZ = H.newInstance(yR, "vtkOpenGLHardwareSelector");
  var J8 = {
    newInstance: nZ,
    extend: yR,
    ...cR
  }, U4 = {
    exports: {}
  }, AT;
  function rZ() {
    return AT || (AT = 1, (function(t, e) {
      (function(n) {
        t.exports = n();
      })(function(n) {
        var r = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f"
        ];
        function i(w, C) {
          var T = w[0], S = w[1], E = w[2], b = w[3];
          T += (S & E | ~S & b) + C[0] - 680876936 | 0, T = (T << 7 | T >>> 25) + S | 0, b += (T & S | ~T & E) + C[1] - 389564586 | 0, b = (b << 12 | b >>> 20) + T | 0, E += (b & T | ~b & S) + C[2] + 606105819 | 0, E = (E << 17 | E >>> 15) + b | 0, S += (E & b | ~E & T) + C[3] - 1044525330 | 0, S = (S << 22 | S >>> 10) + E | 0, T += (S & E | ~S & b) + C[4] - 176418897 | 0, T = (T << 7 | T >>> 25) + S | 0, b += (T & S | ~T & E) + C[5] + 1200080426 | 0, b = (b << 12 | b >>> 20) + T | 0, E += (b & T | ~b & S) + C[6] - 1473231341 | 0, E = (E << 17 | E >>> 15) + b | 0, S += (E & b | ~E & T) + C[7] - 45705983 | 0, S = (S << 22 | S >>> 10) + E | 0, T += (S & E | ~S & b) + C[8] + 1770035416 | 0, T = (T << 7 | T >>> 25) + S | 0, b += (T & S | ~T & E) + C[9] - 1958414417 | 0, b = (b << 12 | b >>> 20) + T | 0, E += (b & T | ~b & S) + C[10] - 42063 | 0, E = (E << 17 | E >>> 15) + b | 0, S += (E & b | ~E & T) + C[11] - 1990404162 | 0, S = (S << 22 | S >>> 10) + E | 0, T += (S & E | ~S & b) + C[12] + 1804603682 | 0, T = (T << 7 | T >>> 25) + S | 0, b += (T & S | ~T & E) + C[13] - 40341101 | 0, b = (b << 12 | b >>> 20) + T | 0, E += (b & T | ~b & S) + C[14] - 1502002290 | 0, E = (E << 17 | E >>> 15) + b | 0, S += (E & b | ~E & T) + C[15] + 1236535329 | 0, S = (S << 22 | S >>> 10) + E | 0, T += (S & b | E & ~b) + C[1] - 165796510 | 0, T = (T << 5 | T >>> 27) + S | 0, b += (T & E | S & ~E) + C[6] - 1069501632 | 0, b = (b << 9 | b >>> 23) + T | 0, E += (b & S | T & ~S) + C[11] + 643717713 | 0, E = (E << 14 | E >>> 18) + b | 0, S += (E & T | b & ~T) + C[0] - 373897302 | 0, S = (S << 20 | S >>> 12) + E | 0, T += (S & b | E & ~b) + C[5] - 701558691 | 0, T = (T << 5 | T >>> 27) + S | 0, b += (T & E | S & ~E) + C[10] + 38016083 | 0, b = (b << 9 | b >>> 23) + T | 0, E += (b & S | T & ~S) + C[15] - 660478335 | 0, E = (E << 14 | E >>> 18) + b | 0, S += (E & T | b & ~T) + C[4] - 405537848 | 0, S = (S << 20 | S >>> 12) + E | 0, T += (S & b | E & ~b) + C[9] + 568446438 | 0, T = (T << 5 | T >>> 27) + S | 0, b += (T & E | S & ~E) + C[14] - 1019803690 | 0, b = (b << 9 | b >>> 23) + T | 0, E += (b & S | T & ~S) + C[3] - 187363961 | 0, E = (E << 14 | E >>> 18) + b | 0, S += (E & T | b & ~T) + C[8] + 1163531501 | 0, S = (S << 20 | S >>> 12) + E | 0, T += (S & b | E & ~b) + C[13] - 1444681467 | 0, T = (T << 5 | T >>> 27) + S | 0, b += (T & E | S & ~E) + C[2] - 51403784 | 0, b = (b << 9 | b >>> 23) + T | 0, E += (b & S | T & ~S) + C[7] + 1735328473 | 0, E = (E << 14 | E >>> 18) + b | 0, S += (E & T | b & ~T) + C[12] - 1926607734 | 0, S = (S << 20 | S >>> 12) + E | 0, T += (S ^ E ^ b) + C[5] - 378558 | 0, T = (T << 4 | T >>> 28) + S | 0, b += (T ^ S ^ E) + C[8] - 2022574463 | 0, b = (b << 11 | b >>> 21) + T | 0, E += (b ^ T ^ S) + C[11] + 1839030562 | 0, E = (E << 16 | E >>> 16) + b | 0, S += (E ^ b ^ T) + C[14] - 35309556 | 0, S = (S << 23 | S >>> 9) + E | 0, T += (S ^ E ^ b) + C[1] - 1530992060 | 0, T = (T << 4 | T >>> 28) + S | 0, b += (T ^ S ^ E) + C[4] + 1272893353 | 0, b = (b << 11 | b >>> 21) + T | 0, E += (b ^ T ^ S) + C[7] - 155497632 | 0, E = (E << 16 | E >>> 16) + b | 0, S += (E ^ b ^ T) + C[10] - 1094730640 | 0, S = (S << 23 | S >>> 9) + E | 0, T += (S ^ E ^ b) + C[13] + 681279174 | 0, T = (T << 4 | T >>> 28) + S | 0, b += (T ^ S ^ E) + C[0] - 358537222 | 0, b = (b << 11 | b >>> 21) + T | 0, E += (b ^ T ^ S) + C[3] - 722521979 | 0, E = (E << 16 | E >>> 16) + b | 0, S += (E ^ b ^ T) + C[6] + 76029189 | 0, S = (S << 23 | S >>> 9) + E | 0, T += (S ^ E ^ b) + C[9] - 640364487 | 0, T = (T << 4 | T >>> 28) + S | 0, b += (T ^ S ^ E) + C[12] - 421815835 | 0, b = (b << 11 | b >>> 21) + T | 0, E += (b ^ T ^ S) + C[15] + 530742520 | 0, E = (E << 16 | E >>> 16) + b | 0, S += (E ^ b ^ T) + C[2] - 995338651 | 0, S = (S << 23 | S >>> 9) + E | 0, T += (E ^ (S | ~b)) + C[0] - 198630844 | 0, T = (T << 6 | T >>> 26) + S | 0, b += (S ^ (T | ~E)) + C[7] + 1126891415 | 0, b = (b << 10 | b >>> 22) + T | 0, E += (T ^ (b | ~S)) + C[14] - 1416354905 | 0, E = (E << 15 | E >>> 17) + b | 0, S += (b ^ (E | ~T)) + C[5] - 57434055 | 0, S = (S << 21 | S >>> 11) + E | 0, T += (E ^ (S | ~b)) + C[12] + 1700485571 | 0, T = (T << 6 | T >>> 26) + S | 0, b += (S ^ (T | ~E)) + C[3] - 1894986606 | 0, b = (b << 10 | b >>> 22) + T | 0, E += (T ^ (b | ~S)) + C[10] - 1051523 | 0, E = (E << 15 | E >>> 17) + b | 0, S += (b ^ (E | ~T)) + C[1] - 2054922799 | 0, S = (S << 21 | S >>> 11) + E | 0, T += (E ^ (S | ~b)) + C[8] + 1873313359 | 0, T = (T << 6 | T >>> 26) + S | 0, b += (S ^ (T | ~E)) + C[15] - 30611744 | 0, b = (b << 10 | b >>> 22) + T | 0, E += (T ^ (b | ~S)) + C[6] - 1560198380 | 0, E = (E << 15 | E >>> 17) + b | 0, S += (b ^ (E | ~T)) + C[13] + 1309151649 | 0, S = (S << 21 | S >>> 11) + E | 0, T += (E ^ (S | ~b)) + C[4] - 145523070 | 0, T = (T << 6 | T >>> 26) + S | 0, b += (S ^ (T | ~E)) + C[11] - 1120210379 | 0, b = (b << 10 | b >>> 22) + T | 0, E += (T ^ (b | ~S)) + C[2] + 718787259 | 0, E = (E << 15 | E >>> 17) + b | 0, S += (b ^ (E | ~T)) + C[9] - 343485551 | 0, S = (S << 21 | S >>> 11) + E | 0, w[0] = T + w[0] | 0, w[1] = S + w[1] | 0, w[2] = E + w[2] | 0, w[3] = b + w[3] | 0;
        }
        function a(w) {
          var C = [], T;
          for (T = 0; T < 64; T += 4) C[T >> 2] = w.charCodeAt(T) + (w.charCodeAt(T + 1) << 8) + (w.charCodeAt(T + 2) << 16) + (w.charCodeAt(T + 3) << 24);
          return C;
        }
        function s(w) {
          var C = [], T;
          for (T = 0; T < 64; T += 4) C[T >> 2] = w[T] + (w[T + 1] << 8) + (w[T + 2] << 16) + (w[T + 3] << 24);
          return C;
        }
        function o(w) {
          var C = w.length, T = [
            1732584193,
            -271733879,
            -1732584194,
            271733878
          ], S, E, b, D, R, I;
          for (S = 64; S <= C; S += 64) i(T, a(w.substring(S - 64, S)));
          for (w = w.substring(S - 64), E = w.length, b = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ], S = 0; S < E; S += 1) b[S >> 2] |= w.charCodeAt(S) << (S % 4 << 3);
          if (b[S >> 2] |= 128 << (S % 4 << 3), S > 55) for (i(T, b), S = 0; S < 16; S += 1) b[S] = 0;
          return D = C * 8, D = D.toString(16).match(/(.*?)(.{0,8})$/), R = parseInt(D[2], 16), I = parseInt(D[1], 16) || 0, b[14] = R, b[15] = I, i(T, b), T;
        }
        function l(w) {
          var C = w.length, T = [
            1732584193,
            -271733879,
            -1732584194,
            271733878
          ], S, E, b, D, R, I;
          for (S = 64; S <= C; S += 64) i(T, s(w.subarray(S - 64, S)));
          for (w = S - 64 < C ? w.subarray(S - 64) : new Uint8Array(0), E = w.length, b = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ], S = 0; S < E; S += 1) b[S >> 2] |= w[S] << (S % 4 << 3);
          if (b[S >> 2] |= 128 << (S % 4 << 3), S > 55) for (i(T, b), S = 0; S < 16; S += 1) b[S] = 0;
          return D = C * 8, D = D.toString(16).match(/(.*?)(.{0,8})$/), R = parseInt(D[2], 16), I = parseInt(D[1], 16) || 0, b[14] = R, b[15] = I, i(T, b), T;
        }
        function c(w) {
          var C = "", T;
          for (T = 0; T < 4; T += 1) C += r[w >> T * 8 + 4 & 15] + r[w >> T * 8 & 15];
          return C;
        }
        function f(w) {
          var C;
          for (C = 0; C < w.length; C += 1) w[C] = c(w[C]);
          return w.join("");
        }
        f(o("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && (function() {
          function w(C, T) {
            return C = C | 0 || 0, C < 0 ? Math.max(C + T, 0) : Math.min(C, T);
          }
          ArrayBuffer.prototype.slice = function(C, T) {
            var S = this.byteLength, E = w(C, S), b = S, D, R, I, O;
            return T !== n && (b = w(T, S)), E > b ? new ArrayBuffer(0) : (D = b - E, R = new ArrayBuffer(D), I = new Uint8Array(R), O = new Uint8Array(this, E, D), I.set(O), R);
          };
        })();
        function u(w) {
          return /[\u0080-\uFFFF]/.test(w) && (w = unescape(encodeURIComponent(w))), w;
        }
        function h(w, C) {
          var T = w.length, S = new ArrayBuffer(T), E = new Uint8Array(S), b;
          for (b = 0; b < T; b += 1) E[b] = w.charCodeAt(b);
          return C ? E : S;
        }
        function g(w) {
          return String.fromCharCode.apply(null, new Uint8Array(w));
        }
        function v(w, C, T) {
          var S = new Uint8Array(w.byteLength + C.byteLength);
          return S.set(new Uint8Array(w)), S.set(new Uint8Array(C), w.byteLength), S;
        }
        function m(w) {
          var C = [], T = w.length, S;
          for (S = 0; S < T - 1; S += 2) C.push(parseInt(w.substr(S, 2), 16));
          return String.fromCharCode.apply(String, C);
        }
        function y() {
          this.reset();
        }
        return y.prototype.append = function(w) {
          return this.appendBinary(u(w)), this;
        }, y.prototype.appendBinary = function(w) {
          this._buff += w, this._length += w.length;
          var C = this._buff.length, T;
          for (T = 64; T <= C; T += 64) i(this._hash, a(this._buff.substring(T - 64, T)));
          return this._buff = this._buff.substring(T - 64), this;
        }, y.prototype.end = function(w) {
          var C = this._buff, T = C.length, S, E = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ], b;
          for (S = 0; S < T; S += 1) E[S >> 2] |= C.charCodeAt(S) << (S % 4 << 3);
          return this._finish(E, T), b = f(this._hash), w && (b = m(b)), this.reset(), b;
        }, y.prototype.reset = function() {
          return this._buff = "", this._length = 0, this._hash = [
            1732584193,
            -271733879,
            -1732584194,
            271733878
          ], this;
        }, y.prototype.getState = function() {
          return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
          };
        }, y.prototype.setState = function(w) {
          return this._buff = w.buff, this._length = w.length, this._hash = w.hash, this;
        }, y.prototype.destroy = function() {
          delete this._hash, delete this._buff, delete this._length;
        }, y.prototype._finish = function(w, C) {
          var T = C, S, E, b;
          if (w[T >> 2] |= 128 << (T % 4 << 3), T > 55) for (i(this._hash, w), T = 0; T < 16; T += 1) w[T] = 0;
          S = this._length * 8, S = S.toString(16).match(/(.*?)(.{0,8})$/), E = parseInt(S[2], 16), b = parseInt(S[1], 16) || 0, w[14] = E, w[15] = b, i(this._hash, w);
        }, y.hash = function(w, C) {
          return y.hashBinary(u(w), C);
        }, y.hashBinary = function(w, C) {
          var T = o(w), S = f(T);
          return C ? m(S) : S;
        }, y.ArrayBuffer = function() {
          this.reset();
        }, y.ArrayBuffer.prototype.append = function(w) {
          var C = v(this._buff.buffer, w), T = C.length, S;
          for (this._length += w.byteLength, S = 64; S <= T; S += 64) i(this._hash, s(C.subarray(S - 64, S)));
          return this._buff = S - 64 < T ? new Uint8Array(C.buffer.slice(S - 64)) : new Uint8Array(0), this;
        }, y.ArrayBuffer.prototype.end = function(w) {
          var C = this._buff, T = C.length, S = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ], E, b;
          for (E = 0; E < T; E += 1) S[E >> 2] |= C[E] << (E % 4 << 3);
          return this._finish(S, T), b = f(this._hash), w && (b = m(b)), this.reset(), b;
        }, y.ArrayBuffer.prototype.reset = function() {
          return this._buff = new Uint8Array(0), this._length = 0, this._hash = [
            1732584193,
            -271733879,
            -1732584194,
            271733878
          ], this;
        }, y.ArrayBuffer.prototype.getState = function() {
          var w = y.prototype.getState.call(this);
          return w.buff = g(w.buff), w;
        }, y.ArrayBuffer.prototype.setState = function(w) {
          return w.buff = h(w.buff, true), y.prototype.setState.call(this, w);
        }, y.ArrayBuffer.prototype.destroy = y.prototype.destroy, y.ArrayBuffer.prototype._finish = y.prototype._finish, y.ArrayBuffer.hash = function(w, C) {
          var T = l(new Uint8Array(w)), S = f(T);
          return C ? m(S) : S;
        }, y;
      });
    })(U4)), U4.exports;
  }
  var iZ = rZ();
  const aZ = t0(iZ), sZ = [
    "lastShaderProgramBound",
    "context",
    "_openGLRenderWindow"
  ];
  function oZ(t, e) {
    e.classHierarchy.push("vtkShaderCache"), t.replaceShaderValues = (n, r, i) => {
      let a = r;
      i.length > 0 && (a = se.substitute(a, "VSOut", "GSOut").result);
      const s = e._openGLRenderWindow.getWebgl2();
      let o = `
`, l = `#version 100
`;
      s ? l = `#version 300 es
#define attribute in
#define textureCube texture
#define texture2D texture
#define textureCubeLod textureLod
#define texture2DLod textureLod
` : (e.context.getExtension("OES_standard_derivatives"), e.context.getExtension("EXT_frag_depth") && (o = `#extension GL_EXT_frag_depth : enable
`), e.context.getExtension("EXT_shader_texture_lod") && (o += `#extension GL_EXT_shader_texture_lod : enable
#define textureCubeLod textureCubeLodEXT
#define texture2DLod texture2DLodEXT`)), a = se.substitute(a, "//VTK::System::Dec", [
        `${l}
`,
        s ? "" : `#extension GL_OES_standard_derivatives : enable
`,
        o,
        "#ifdef GL_FRAGMENT_PRECISION_HIGH",
        "precision highp float;",
        "precision highp int;",
        "#else",
        "precision mediump float;",
        "precision mediump int;",
        "#endif"
      ]).result;
      let c = se.substitute(n, "//VTK::System::Dec", [
        `${l}
`,
        "#ifdef GL_FRAGMENT_PRECISION_HIGH",
        "precision highp float;",
        "precision highp int;",
        "#else",
        "precision mediump float;",
        "precision mediump int;",
        "#endif"
      ]).result;
      if (s) {
        c = se.substitute(c, "varying", "out").result, a = se.substitute(a, "varying", "in").result;
        let u = "", h = 0;
        for (; a.includes(`gl_FragData[${h}]`); ) a = se.substitute(a, `gl_FragData\\[${h}\\]`, `fragOutput${h}`).result, u += `layout(location = ${h}) out vec4 fragOutput${h};
`, h++;
        a = se.substitute(a, "//VTK::Output::Dec", u).result;
      }
      const f = se.substitute(i, "//VTK::System::Dec", l).result;
      return {
        VSSource: c,
        FSSource: a,
        GSSource: f
      };
    }, t.readyShaderProgramArray = (n, r, i) => {
      const a = t.replaceShaderValues(n, r, i), s = t.getShaderProgram(a.VSSource, a.FSSource, a.GSSource);
      return t.readyShaderProgram(s);
    }, t.readyShaderProgram = (n) => !n || !n.getCompiled() && !n.compileShader() || !t.bindShaderProgram(n) ? null : n, t.getShaderProgram = (n, r, i) => {
      const a = `${n}${r}${i}`, s = aZ.hash(a);
      if (!(s in e.shaderPrograms)) {
        const o = se.newInstance();
        return o.setContext(e.context), o.getVertexShader().setSource(n), o.getFragmentShader().setSource(r), i && o.getGeometryShader().setSource(i), o.setMd5Hash(s), e.shaderPrograms[s] = o, o;
      }
      return e.shaderPrograms[s];
    }, t.releaseGraphicsResources = (n) => {
      t.releaseCurrentShaderProgram(), Object.keys(e.shaderPrograms).map((r) => e.shaderPrograms[r]).forEach((r) => r.cleanup()), e.shaderPrograms = {};
    }, t.releaseCurrentShaderProgram = () => {
      e.lastShaderProgramBound && (e.lastShaderProgramBound.cleanup(), e.lastShaderProgramBound = null);
    }, t.bindShaderProgram = (n) => (e.lastShaderProgramBound === n || (e.lastShaderProgramBound && e.lastShaderProgramBound.release(), n.bind(), e.lastShaderProgramBound = n), 1);
  }
  const lZ = {
    lastShaderProgramBound: null,
    shaderPrograms: null,
    context: null
  };
  function xR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, lZ, n), e.shaderPrograms = {}, H.obj(t, e), H.setGet(t, e, sZ), H.moveToProtected(t, e, [
      "openGLRenderWindow"
    ]), oZ(t, e);
  }
  const cZ = H.newInstance(xR, "vtkShaderCache");
  var uZ = {
    newInstance: cZ,
    extend: xR
  };
  const { vtkErrorMacro: fZ } = H;
  function hZ(t, e) {
    e.classHierarchy.push("vtkOpenGLTextureUnitManager"), t.deleteTable = () => {
      for (let n = 0; n < e.numberOfTextureUnits; ++n) e.textureUnits[n] === true && fZ("some texture units  were not properly released");
      e.textureUnits = [], e.numberOfTextureUnits = 0;
    }, t.setContext = (n) => {
      if (e.context !== n) {
        if (e.context !== 0 && t.deleteTable(), e.context = n, e.context) {
          e.numberOfTextureUnits = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);
          for (let r = 0; r < e.numberOfTextureUnits; ++r) e.textureUnits[r] = false;
        }
        t.modified();
      }
    }, t.allocate = () => {
      for (let n = 0; n < e.numberOfTextureUnits; n++) if (!t.isAllocated(n)) return e.textureUnits[n] = true, n;
      return -1;
    }, t.allocateUnit = (n) => t.isAllocated(n) ? -1 : (e.textureUnits[n] = true, n), t.isAllocated = (n) => e.textureUnits[n], t.free = (n) => {
      e.textureUnits[n] = false;
    }, t.freeAll = () => {
      for (let n = 0; n < e.numberOfTextureUnits; ++n) e.textureUnits[n] = false;
    };
  }
  const dZ = {
    context: null,
    numberOfTextureUnits: 0,
    textureUnits: 0
  };
  function wR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, dZ, n), H.obj(t, e), e.textureUnits = [], H.get(t, e, [
      "numberOfTextureUnits"
    ]), H.setGet(t, e, [
      "context"
    ]), hZ(t, e);
  }
  const gZ = H.newInstance(wR, "vtkOpenGLTextureUnitManager");
  var pZ = {
    newInstance: gZ,
    extend: wR
  };
  function mZ(t, e) {
    e.classHierarchy.push("vtkRenderWindowViewNode"), t.getViewNodeFactory = () => null, t.getAspectRatio = () => e.size[0] / e.size[1], t.getAspectRatioForRenderer = (n) => {
      const r = n.getViewportByReference();
      return e.size[0] * (r[2] - r[0]) / ((r[3] - r[1]) * e.size[1]);
    }, t.isInViewport = (n, r, i) => {
      const a = i.getViewportByReference(), s = t.getFramebufferSize();
      return a[0] * s[0] <= n && a[2] * s[0] >= n && a[1] * s[1] <= r && a[3] * s[1] >= r;
    }, t.getViewportSize = (n) => {
      const r = n.getViewportByReference(), i = t.getFramebufferSize();
      return [
        (r[2] - r[0]) * i[0],
        (r[3] - r[1]) * i[1]
      ];
    }, t.getViewportCenter = (n) => {
      const r = t.getViewportSize(n);
      return [
        r[0] * 0.5,
        r[1] * 0.5
      ];
    }, t.displayToNormalizedDisplay = (n, r, i) => {
      const a = t.getFramebufferSize();
      return [
        n / a[0],
        r / a[1],
        i
      ];
    }, t.normalizedDisplayToDisplay = (n, r, i) => {
      const a = t.getFramebufferSize();
      return [
        n * a[0],
        r * a[1],
        i
      ];
    }, t.worldToView = (n, r, i, a) => a.worldToView(n, r, i), t.viewToWorld = (n, r, i, a) => a.viewToWorld(n, r, i), t.worldToDisplay = (n, r, i, a) => {
      const s = a.worldToView(n, r, i), o = t.getViewportSize(a), l = a.viewToProjection(s[0], s[1], s[2], o[0] / o[1]), c = a.projectionToNormalizedDisplay(l[0], l[1], l[2]);
      return t.normalizedDisplayToDisplay(c[0], c[1], c[2]);
    }, t.displayToWorld = (n, r, i, a) => {
      const s = t.displayToNormalizedDisplay(n, r, i), o = a.normalizedDisplayToProjection(s[0], s[1], s[2]), l = t.getViewportSize(a), c = a.projectionToView(o[0], o[1], o[2], l[0] / l[1]);
      return a.viewToWorld(c[0], c[1], c[2]);
    }, t.normalizedDisplayToViewport = (n, r, i, a) => {
      let s = a.getViewportByReference();
      s = t.normalizedDisplayToDisplay(s[0], s[1], 0);
      const o = t.normalizedDisplayToDisplay(n, r, i);
      return [
        o[0] - s[0] - 0.5,
        o[1] - s[1] - 0.5,
        i
      ];
    }, t.viewportToNormalizedViewport = (n, r, i, a) => {
      const s = t.getViewportSize(a);
      return s && s[0] !== 0 && s[1] !== 0 ? [
        n / (s[0] - 1),
        r / (s[1] - 1),
        i
      ] : [
        n,
        r,
        i
      ];
    }, t.normalizedViewportToViewport = (n, r, i, a) => {
      const s = t.getViewportSize(a);
      return [
        n * (s[0] - 1),
        r * (s[1] - 1),
        i
      ];
    }, t.displayToLocalDisplay = (n, r, i) => {
      const a = t.getFramebufferSize();
      return [
        n,
        a[1] - r - 1,
        i
      ];
    }, t.viewportToNormalizedDisplay = (n, r, i, a) => {
      let s = a.getViewportByReference();
      s = t.normalizedDisplayToDisplay(s[0], s[1], 0);
      const o = n + s[0] + 0.5, l = r + s[1] + 0.5;
      return t.displayToNormalizedDisplay(o, l, i);
    }, t.getComputedDevicePixelRatio = () => e.size[0] / t.getContainerSize()[0], t.getContainerSize = () => {
      H.vtkErrorMacro("not implemented");
    }, t.getPixelData = (n, r, i, a) => {
      H.vtkErrorMacro("not implemented");
    }, t.createSelector = () => {
      H.vtkErrorMacro("not implemented");
    };
  }
  const vZ = {
    size: void 0,
    selector: void 0
  };
  function CR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, vZ, n), e.size || (e.size = [
      300,
      300
    ]), H.getArray(t, e, [
      "size"
    ], 2), H.get(t, e, [
      "selector"
    ]), Rn.extend(t, e, n), mZ(t, e);
  }
  const yZ = H.newInstance(CR, "vtkRenderWindowViewNode");
  var xZ = {
    newInstance: yZ,
    extend: CR
  };
  const wZ = "__getUnderlyingContext";
  function CZ() {
    const t = /* @__PURE__ */ new Map(), e = {
      apply(i, a, s) {
        return t.has(s[0]) ? t.get(s[0]) : i.apply(a, s);
      }
    };
    function n(i) {
      return {
        apply(a, s, o) {
          return t.set(i, o[0]), a.apply(s, o);
        }
      };
    }
    const r = /* @__PURE__ */ Object.create(null);
    return r.getParameter = (i, a, s, o) => new Proxy(o.bind(i), e), r.depthMask = (i, a, s, o) => new Proxy(o.bind(i), n(i.DEPTH_WRITEMASK)), {
      get(i, a, s) {
        if (a === wZ) return () => i;
        let o = Reflect.get(i, a, i);
        o instanceof Function && (o = o.bind(i));
        const l = r[a];
        return l ? l(i, a, s, o) : o;
      }
    };
  }
  const { vtkDebugMacro: ET, vtkErrorMacro: bT } = H, TZ = {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%"
  }, SZ = [
    "activateTexture",
    "deactivateTexture",
    "disableCullFace",
    "enableCullFace",
    "get3DContext",
    "getActiveFramebuffer",
    "getContext",
    "getDefaultTextureByteSize",
    "getDefaultTextureInternalFormat",
    "getDefaultToWebgl2",
    "getGLInformations",
    "getGraphicsMemoryInfo",
    "getGraphicsResourceForObject",
    "getHardwareMaximumLineWidth",
    "getPixelData",
    "getShaderCache",
    "getTextureUnitForTexture",
    "getTextureUnitManager",
    "getWebgl2",
    "makeCurrent",
    "releaseGraphicsResources",
    "releaseGraphicsResourcesForObject",
    "restoreContext",
    "setActiveFramebuffer",
    "setContext",
    "setDefaultToWebgl2",
    "setGraphicsResourceForObject"
  ];
  function Ni(t, e, n) {
    const r = t.createFramebuffer(), i = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, i), t.texImage2D(t.TEXTURE_2D, 0, e, 2, 2, 0, e, n, null), t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0);
    const a = t.checkFramebufferStatus(t.FRAMEBUFFER);
    return t.bindFramebuffer(t.FRAMEBUFFER, null), t.bindTexture(t.TEXTURE_2D, null), a === t.FRAMEBUFFER_COMPLETE;
  }
  let Tp = 0;
  const T5 = [];
  function AZ() {
    Tp++, T5.forEach((t) => t(Tp));
  }
  function EZ() {
    Tp--, T5.forEach((t) => t(Tp));
  }
  function bZ(t) {
    T5.push(t);
  }
  function DZ(t) {
    return T5.pop();
  }
  function DT(t) {
    t.preventDefault();
  }
  function MZ(t, e) {
    e.classHierarchy.push("vtkOpenGLRenderWindow");
    let n;
    function r() {
      return n || (n = CZ()), n;
    }
    t.getViewNodeFactory = () => e.myFactory, e.canvas.addEventListener("webglcontextlost", DT, false), e.canvas.addEventListener("webglcontextrestored", t.restoreContext, false);
    const i = [
      0,
      0
    ];
    function a() {
      e.renderable && (e.size[0] !== i[0] || e.size[1] !== i[1]) && (i[0] = e.size[0], i[1] = e.size[1], e.canvas.setAttribute("width", e.size[0]), e.canvas.setAttribute("height", e.size[1])), e.viewStream && e.viewStream.setSize(e.size[0], e.size[1]), e.canvas.style.display = e.useOffScreen ? "none" : "block", e.el && (e.el.style.cursor = e.cursorVisibility ? e.cursor : "none"), e.containerSize = null;
    }
    t.onModified(a), t.buildPass = (u) => {
      if (u) {
        if (!e.renderable) return;
        t.prepareNodes(), t.addMissingNodes(e.renderable.getRenderersByReference()), t.addMissingNodes(e.renderable.getChildRenderWindowsByReference()), t.removeUnusedNodes(), t.initialize(), e.children.forEach((h) => {
          var _a3;
          (_a3 = h.setOpenGLRenderWindow) == null ? void 0 : _a3.call(h, t);
        });
      }
    }, t.initialize = () => {
      if (!e.initialized) {
        if (e.rootOpenGLRenderWindow = t.getLastAncestorOfType("vtkOpenGLRenderWindow"), e.rootOpenGLRenderWindow) e.context2D = t.get2DContext();
        else {
          e.context = t.get3DContext(), t.resizeFromChildRenderWindows(), e.context && AZ(), e.textureUnitManager = pZ.newInstance(), e.textureUnitManager.setContext(e.context), e.shaderCache.setContext(e.context);
          const u = e.context;
          u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA), u.depthFunc(u.LEQUAL), u.enable(u.BLEND);
        }
        e.initialized = true;
      }
    }, t.makeCurrent = () => {
      e.context.makeCurrent();
    }, t.setContainer = (u) => {
      e.el && e.el !== u && (e.canvas.parentNode !== e.el && bT("Error: canvas parent node does not match container"), e.el.removeChild(e.canvas), e.el.contains(e.bgImage) && e.el.removeChild(e.bgImage)), e.el !== u && (e.el = u, e.el && (e.el.appendChild(e.canvas), e.useBackgroundImage && e.el.appendChild(e.bgImage)), t.modified());
    }, t.getContainer = () => e.el, t.getContainerSize = () => {
      if (!e.containerSize && e.el) {
        const { width: u, height: h } = e.el.getBoundingClientRect();
        e.containerSize = [
          u,
          h
        ];
      }
      return e.containerSize || e.size;
    }, t.getFramebufferSize = () => {
      var _a3;
      return ((_a3 = e.activeFramebuffer) == null ? void 0 : _a3.getSize()) || e.size;
    }, t.getPixelData = (u, h, g, v) => {
      const m = new Uint8Array((g - u + 1) * (v - h + 1) * 4);
      return e.context.readPixels(u, h, g - u + 1, v - h + 1, e.context.RGBA, e.context.UNSIGNED_BYTE, m), m;
    }, t.get3DContext = function() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        preserveDrawingBuffer: false,
        depth: true,
        alpha: true,
        powerPreference: "high-performance"
      }, h = null;
      const g = typeof WebGL2RenderingContext < "u";
      return e.webgl2 = false, e.defaultToWebgl2 && g && (h = e.canvas.getContext("webgl2", u), h && (e.webgl2 = true, ET("using webgl2"))), h || (ET("using webgl1"), h = e.canvas.getContext("webgl", u) || e.canvas.getContext("experimental-webgl", u)), new Proxy(h, r());
    }, t.get2DContext = function() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return e.canvas.getContext("2d", u);
    }, t.restoreContext = () => {
      const u = Z8.newInstance();
      u.setCurrentOperation("Release"), u.traverse(t, null);
    }, t.activateTexture = (u) => {
      const h = e._textureResourceIds.get(u);
      if (h !== void 0) {
        e.context.activeTexture(e.context.TEXTURE0 + h);
        return;
      }
      const g = t.getTextureUnitManager().allocate();
      if (g < 0) {
        bT("Hardware does not support the number of textures defined.");
        return;
      }
      e._textureResourceIds.set(u, g), e.context.activeTexture(e.context.TEXTURE0 + g);
    }, t.deactivateTexture = (u) => {
      const h = e._textureResourceIds.get(u);
      h !== void 0 && (t.getTextureUnitManager().free(h), e._textureResourceIds.delete(u));
    }, t.getTextureUnitForTexture = (u) => {
      const h = e._textureResourceIds.get(u);
      return h !== void 0 ? h : -1;
    }, t.getDefaultTextureByteSize = function(u) {
      let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (e.webgl2) switch (u) {
        case zt.CHAR:
        case zt.SIGNED_CHAR:
        case zt.UNSIGNED_CHAR:
          return 1;
        case h:
        case g:
        case zt.UNSIGNED_SHORT:
        case zt.SHORT:
        case zt.VOID:
          return 2;
        default:
          return 4;
      }
      return 1;
    }, t.getDefaultTextureInternalFormat = function(u, h) {
      let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (e.webgl2) switch (u) {
        case zt.UNSIGNED_CHAR:
          switch (h) {
            case 1:
              return e.context.R8;
            case 2:
              return e.context.RG8;
            case 3:
              return e.context.RGB8;
            case 4:
            default:
              return e.context.RGBA8;
          }
        case (g && !v && zt.UNSIGNED_SHORT):
          switch (h) {
            case 1:
              return g.R16_EXT;
            case 2:
              return g.RG16_EXT;
            case 3:
              return g.RGB16_EXT;
            case 4:
            default:
              return g.RGBA16_EXT;
          }
        case (g && !v && zt.SHORT):
          switch (h) {
            case 1:
              return g.R16_SNORM_EXT;
            case 2:
              return g.RG16_SNORM_EXT;
            case 3:
              return g.RGB16_SNORM_EXT;
            case 4:
            default:
              return g.RGBA16_SNORM_EXT;
          }
        case zt.UNSIGNED_SHORT:
        case zt.SHORT:
        case zt.FLOAT:
        default:
          switch (h) {
            case 1:
              return v ? e.context.R16F : e.context.R32F;
            case 2:
              return v ? e.context.RG16F : e.context.RG32F;
            case 3:
              return v ? e.context.RGB16F : e.context.RGB32F;
            case 4:
            default:
              return v ? e.context.RGBA16F : e.context.RGBA32F;
          }
      }
      switch (h) {
        case 1:
          return e.context.LUMINANCE;
        case 2:
          return e.context.LUMINANCE_ALPHA;
        case 3:
          return e.context.RGB;
        case 4:
        default:
          return e.context.RGBA;
      }
    }, t.setBackgroundImage = (u) => {
      e.bgImage.src = u.src;
    }, t.setUseBackgroundImage = (u) => {
      e.useBackgroundImage = u, e.useBackgroundImage && !e.el.contains(e.bgImage) ? e.el.appendChild(e.bgImage) : !e.useBackgroundImage && e.el.contains(e.bgImage) && e.el.removeChild(e.bgImage);
    };
    function s() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.imageFormat;
      const h = document.createElement("canvas"), g = h.getContext("2d");
      h.width = e.canvas.width, h.height = e.canvas.height, g.drawImage(e.canvas, 0, 0);
      const v = e.canvas.getBoundingClientRect();
      e.renderable.getRenderers().forEach((C) => {
        C.getViewProps().forEach((S) => {
          if (S.getContainer) {
            const b = S.getContainer().getElementsByTagName("canvas");
            for (let D = 0; D < b.length; D++) {
              const R = b[D], I = R.getBoundingClientRect(), O = I.x - v.x, L = I.y - v.y;
              g.drawImage(R, O, L);
            }
          }
        });
      });
      const w = h.toDataURL(u);
      h.remove(), t.invokeImageReady(w);
    }
    t.captureNextImage = function() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png", { resetCamera: h = false, size: g = null, scale: v = 1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (e.deleted) return null;
      e.imageFormat = u;
      const m = e.notifyStartCaptureImage;
      return e.notifyStartCaptureImage = true, e._screenshot = {
        size: g || v !== 1 ? g || e.size.map((y) => y * v) : null
      }, new Promise((y, w) => {
        const C = t.onImageReady((T) => {
          if (e._screenshot.size === null) e.notifyStartCaptureImage = m, C.unsubscribe(), e._screenshot.placeHolder && (e.size = e._screenshot.originalSize, t.modified(), e._screenshot.cameras && e._screenshot.cameras.forEach((S) => {
            let { restoreParamsFn: E, arg: b } = S;
            return E(b);
          }), t.traverseAllPasses(), e.el.removeChild(e._screenshot.placeHolder), e._screenshot.placeHolder.remove(), e._screenshot = null), y(T);
          else {
            const S = document.createElement("img");
            if (S.style = TZ, S.src = T, e._screenshot.placeHolder = e.el.appendChild(S), e.canvas.style.display = "none", e._screenshot.originalSize = e.size, e.size = e._screenshot.size, e._screenshot.size = null, t.modified(), h) {
              const E = h !== true;
              e._screenshot.cameras = e.renderable.getRenderers().map((b) => {
                const D = b.getActiveCamera(), R = D.get("focalPoint", "position", "parallelScale");
                return {
                  resetCameraArgs: E ? {
                    renderer: b
                  } : void 0,
                  resetCameraFn: E ? h : b.resetCamera,
                  restoreParamsFn: D.set,
                  arg: JSON.parse(JSON.stringify(R))
                };
              }), e._screenshot.cameras.forEach((b) => {
                let { resetCameraFn: D, resetCameraArgs: R } = b;
                return D(R);
              });
            }
            t.traverseAllPasses();
          }
        });
      });
    };
    let o;
    t.getHardwareMaximumLineWidth = () => {
      if (o != null) return o;
      const u = t.get3DContext(), h = u.getParameter(u.ALIASED_LINE_WIDTH_RANGE);
      return o = h[1], h[1];
    }, t.getGLInformations = () => {
      if (e._glInformation) return e._glInformation;
      const u = t.get3DContext(), h = u.getExtension("OES_texture_float"), g = u.getExtension("OES_texture_half_float"), v = u.getExtension("WEBGL_debug_renderer_info"), m = u.getExtension("WEBGL_draw_buffers"), y = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), w = [
        [
          "Max Vertex Attributes",
          "MAX_VERTEX_ATTRIBS",
          u.getParameter(u.MAX_VERTEX_ATTRIBS)
        ],
        [
          "Max Varying Vectors",
          "MAX_VARYING_VECTORS",
          u.getParameter(u.MAX_VARYING_VECTORS)
        ],
        [
          "Max Vertex Uniform Vectors",
          "MAX_VERTEX_UNIFORM_VECTORS",
          u.getParameter(u.MAX_VERTEX_UNIFORM_VECTORS)
        ],
        [
          "Max Fragment Uniform Vectors",
          "MAX_FRAGMENT_UNIFORM_VECTORS",
          u.getParameter(u.MAX_FRAGMENT_UNIFORM_VECTORS)
        ],
        [
          "Max Fragment Texture Image Units",
          "MAX_TEXTURE_IMAGE_UNITS",
          u.getParameter(u.MAX_TEXTURE_IMAGE_UNITS)
        ],
        [
          "Max Vertex Texture Image Units",
          "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
          u.getParameter(u.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
        ],
        [
          "Max Combined Texture Image Units",
          "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
          u.getParameter(u.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
        ],
        [
          "Max 2D Texture Size",
          "MAX_TEXTURE_SIZE",
          u.getParameter(u.MAX_TEXTURE_SIZE)
        ],
        [
          "Max Cube Texture Size",
          "MAX_CUBE_MAP_TEXTURE_SIZE",
          u.getParameter(u.MAX_CUBE_MAP_TEXTURE_SIZE)
        ],
        [
          "Max Texture Anisotropy",
          "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
          y && u.getParameter(y.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        ],
        [
          "Point Size Range",
          "ALIASED_POINT_SIZE_RANGE",
          u.getParameter(u.ALIASED_POINT_SIZE_RANGE).join(" - ")
        ],
        [
          "Line Width Range",
          "ALIASED_LINE_WIDTH_RANGE",
          u.getParameter(u.ALIASED_LINE_WIDTH_RANGE).join(" - ")
        ],
        [
          "Max Viewport Dimensions",
          "MAX_VIEWPORT_DIMS",
          u.getParameter(u.MAX_VIEWPORT_DIMS).join(" - ")
        ],
        [
          "Max Renderbuffer Size",
          "MAX_RENDERBUFFER_SIZE",
          u.getParameter(u.MAX_RENDERBUFFER_SIZE)
        ],
        [
          "Framebuffer Red Bits",
          "RED_BITS",
          u.getParameter(u.RED_BITS)
        ],
        [
          "Framebuffer Green Bits",
          "GREEN_BITS",
          u.getParameter(u.GREEN_BITS)
        ],
        [
          "Framebuffer Blue Bits",
          "BLUE_BITS",
          u.getParameter(u.BLUE_BITS)
        ],
        [
          "Framebuffer Alpha Bits",
          "ALPHA_BITS",
          u.getParameter(u.ALPHA_BITS)
        ],
        [
          "Framebuffer Depth Bits",
          "DEPTH_BITS",
          u.getParameter(u.DEPTH_BITS)
        ],
        [
          "Framebuffer Stencil Bits",
          "STENCIL_BITS",
          u.getParameter(u.STENCIL_BITS)
        ],
        [
          "Framebuffer Subpixel Bits",
          "SUBPIXEL_BITS",
          u.getParameter(u.SUBPIXEL_BITS)
        ],
        [
          "MSAA Samples",
          "SAMPLES",
          u.getParameter(u.SAMPLES)
        ],
        [
          "MSAA Sample Buffers",
          "SAMPLE_BUFFERS",
          u.getParameter(u.SAMPLE_BUFFERS)
        ],
        [
          "Supported Formats for UByte Render Targets     ",
          "UNSIGNED_BYTE RENDER TARGET FORMATS",
          [
            h && Ni(u, u.RGBA, u.UNSIGNED_BYTE) ? "RGBA" : "",
            h && Ni(u, u.RGB, u.UNSIGNED_BYTE) ? "RGB" : "",
            h && Ni(u, u.LUMINANCE, u.UNSIGNED_BYTE) ? "LUMINANCE" : "",
            h && Ni(u, u.ALPHA, u.UNSIGNED_BYTE) ? "ALPHA" : "",
            h && Ni(u, u.LUMINANCE_ALPHA, u.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""
          ].join(" ")
        ],
        [
          "Supported Formats for Half Float Render Targets",
          "HALF FLOAT RENDER TARGET FORMATS",
          [
            g && Ni(u, u.RGBA, g.HALF_FLOAT_OES) ? "RGBA" : "",
            g && Ni(u, u.RGB, g.HALF_FLOAT_OES) ? "RGB" : "",
            g && Ni(u, u.LUMINANCE, g.HALF_FLOAT_OES) ? "LUMINANCE" : "",
            g && Ni(u, u.ALPHA, g.HALF_FLOAT_OES) ? "ALPHA" : "",
            g && Ni(u, u.LUMINANCE_ALPHA, g.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""
          ].join(" ")
        ],
        [
          "Supported Formats for Full Float Render Targets",
          "FLOAT RENDER TARGET FORMATS",
          [
            h && Ni(u, u.RGBA, u.FLOAT) ? "RGBA" : "",
            h && Ni(u, u.RGB, u.FLOAT) ? "RGB" : "",
            h && Ni(u, u.LUMINANCE, u.FLOAT) ? "LUMINANCE" : "",
            h && Ni(u, u.ALPHA, u.FLOAT) ? "ALPHA" : "",
            h && Ni(u, u.LUMINANCE_ALPHA, u.FLOAT) ? "LUMINANCE_ALPHA" : ""
          ].join(" ")
        ],
        [
          "Max Multiple Render Targets Buffers",
          "MAX_DRAW_BUFFERS_WEBGL",
          m ? u.getParameter(m.MAX_DRAW_BUFFERS_WEBGL) : 0
        ],
        [
          "High Float Precision in Vertex Shader",
          "HIGH_FLOAT VERTEX_SHADER",
          [
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Medium Float Precision in Vertex Shader",
          "MEDIUM_FLOAT VERTEX_SHADER",
          [
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_FLOAT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_FLOAT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_FLOAT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Low Float Precision in Vertex Shader",
          "LOW_FLOAT VERTEX_SHADER",
          [
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_FLOAT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_FLOAT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_FLOAT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "High Float Precision in Fragment Shader",
          "HIGH_FLOAT FRAGMENT_SHADER",
          [
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Medium Float Precision in Fragment Shader",
          "MEDIUM_FLOAT FRAGMENT_SHADER",
          [
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_FLOAT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_FLOAT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_FLOAT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Low Float Precision in Fragment Shader",
          "LOW_FLOAT FRAGMENT_SHADER",
          [
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_FLOAT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_FLOAT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_FLOAT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "High Int Precision in Vertex Shader",
          "HIGH_INT VERTEX_SHADER",
          [
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_INT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_INT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_INT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Medium Int Precision in Vertex Shader",
          "MEDIUM_INT VERTEX_SHADER",
          [
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_INT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_INT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_INT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Low Int Precision in Vertex Shader",
          "LOW_INT VERTEX_SHADER",
          [
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_INT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_INT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_INT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "High Int Precision in Fragment Shader",
          "HIGH_INT FRAGMENT_SHADER",
          [
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_INT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_INT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_INT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Medium Int Precision in Fragment Shader",
          "MEDIUM_INT FRAGMENT_SHADER",
          [
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_INT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_INT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_INT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Low Int Precision in Fragment Shader",
          "LOW_INT FRAGMENT_SHADER",
          [
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_INT).precision,
            " (-2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_INT).rangeMin,
            "</sup> - 2<sup>",
            u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_INT).rangeMax,
            "</sup>)"
          ].join("")
        ],
        [
          "Supported Extensions",
          "EXTENSIONS",
          u.getSupportedExtensions().join("<br/>					    ")
        ],
        [
          "WebGL Renderer",
          "RENDERER",
          u.getParameter(u.RENDERER)
        ],
        [
          "WebGL Vendor",
          "VENDOR",
          u.getParameter(u.VENDOR)
        ],
        [
          "WebGL Version",
          "VERSION",
          u.getParameter(u.VERSION)
        ],
        [
          "Shading Language Version",
          "SHADING_LANGUAGE_VERSION",
          u.getParameter(u.SHADING_LANGUAGE_VERSION)
        ],
        [
          "Unmasked Renderer",
          "UNMASKED_RENDERER",
          v && u.getParameter(v.UNMASKED_RENDERER_WEBGL)
        ],
        [
          "Unmasked Vendor",
          "UNMASKED_VENDOR",
          v && u.getParameter(v.UNMASKED_VENDOR_WEBGL)
        ],
        [
          "WebGL Version",
          "WEBGL_VERSION",
          e.webgl2 ? 2 : 1
        ]
      ], C = {};
      for (; w.length; ) {
        const [T, S, E] = w.pop();
        S && (C[S] = {
          label: T,
          value: E
        });
      }
      return e._glInformation = C, C;
    }, t.traverseAllPasses = () => {
      var _a3;
      if (e.renderPasses) for (let h = 0; h < e.renderPasses.length; ++h) e.renderPasses[h].traverse(t, null);
      e.notifyStartCaptureImage && s(), t.copyParentContent();
      const u = e.renderable.getChildRenderWindowsByReference();
      for (let h = 0; h < u.length; ++h) (_a3 = t.getViewNodeFor(u[h])) == null ? void 0 : _a3.traverseAllPasses();
    }, t.copyParentContent = () => {
      const u = e.rootOpenGLRenderWindow;
      if (!u || !e.context2D) return;
      const h = u.getCanvas(), g = e.canvas;
      e.context2D.drawImage(h, 0, h.height - g.height, g.width, g.height, 0, 0, g.width, g.height);
    }, t.resizeFromChildRenderWindows = () => {
      var _a3;
      const u = e.renderable.getChildRenderWindowsByReference();
      if (u.length > 0) {
        const h = [
          0,
          0
        ];
        for (let g = 0; g < u.length; ++g) {
          const v = (_a3 = t.getViewNodeFor(u[g])) == null ? void 0 : _a3.getSize();
          v && (h[0] = v[0] > h[0] ? v[0] : h[0], h[1] = v[1] > h[1] ? v[1] : h[1]);
        }
        t.setSize(...h);
      }
    }, t.disableCullFace = () => {
      e.cullFaceEnabled && (e.context.disable(e.context.CULL_FACE), e.cullFaceEnabled = false);
    }, t.enableCullFace = () => {
      e.cullFaceEnabled || (e.context.enable(e.context.CULL_FACE), e.cullFaceEnabled = true);
    }, t.setViewStream = (u) => {
      if (e.viewStream === u) return false;
      if (e.subscription && (e.subscription.unsubscribe(), e.subscription = null), e.viewStream = u, e.viewStream) {
        const h = e.renderable.getRenderers()[0];
        h.getBackgroundByReference()[3] = 0, t.setUseBackgroundImage(true), e.subscription = e.viewStream.onImageReady((g) => t.setBackgroundImage(g.image)), e.viewStream.setSize(e.size[0], e.size[1]), e.viewStream.invalidateCache(), e.viewStream.render(), t.modified();
      }
      return true;
    }, t.createSelector = () => {
      const u = J8.newInstance();
      return u.setOpenGLRenderWindow(t), u;
    };
    function l() {
      e.canvas.removeEventListener("webglcontextlost", DT), e.canvas.removeEventListener("webglcontextrestored", t.restoreContext);
    }
    t.delete = H.chain(() => {
      e.context && EZ();
    }, l, t.delete, t.setViewStream), t.setActiveFramebuffer = (u) => {
      e.activeFramebuffer = u;
    };
    const c = t.setSize;
    t.setSize = (u, h) => {
      const g = c(u, h);
      return g && t.invokeWindowResizeEvent({
        width: u,
        height: h
      }), g;
    }, t.getGraphicsResourceForObject = (u) => {
      if (!u) return null;
      const h = e._graphicsResources.get(u), g = e._graphicsResourceHash.get(u);
      return {
        vtkObj: h,
        hash: g
      };
    }, t.setGraphicsResourceForObject = (u, h, g) => {
      u && (e._graphicsResources.set(u, h), e._graphicsResourceHash.set(u, g));
    }, t.getGraphicsMemoryInfo = () => {
      let u = 0;
      return e._graphicsResources.forEach((h, g) => {
        u += h.getAllocatedGPUMemoryInBytes();
      }), u;
    }, t.releaseGraphicsResourcesForObject = (u) => {
      var _a3;
      return u ? ((_a3 = e._graphicsResources.get(u)) == null ? void 0 : _a3.releaseGraphicsResources(t), e._graphicsResources.delete(u) && e._graphicsResourceHash.delete(u)) : false;
    }, t.releaseGraphicsResources = () => {
      e.shaderCache !== null && e.shaderCache.releaseGraphicsResources(t), e._graphicsResources.forEach((u, h) => {
        u.releaseGraphicsResources(t);
      }), e._graphicsResources.clear(), e._graphicsResourceHash.clear(), e.textureUnitManager !== null && e.textureUnitManager.freeAll(), e.renderable.getRenderersByReference().forEach((u) => {
        var _a3;
        (_a3 = t.getViewNodeFor(u)) == null ? void 0 : _a3.releaseGraphicsResources();
      });
    };
    const f = {
      ...t
    };
    SZ.forEach((u) => {
      t[u] = function() {
        return e.rootOpenGLRenderWindow ? e.rootOpenGLRenderWindow[u](...arguments) : f[u](...arguments);
      };
    });
  }
  const RZ = {
    cullFaceEnabled: false,
    shaderCache: null,
    initialized: false,
    context: null,
    context2D: null,
    canvas: null,
    cursorVisibility: true,
    cursor: "pointer",
    textureUnitManager: null,
    textureResourceIds: null,
    containerSize: null,
    renderPasses: [],
    notifyStartCaptureImage: false,
    webgl2: false,
    defaultToWebgl2: true,
    activeFramebuffer: null,
    imageFormat: "image/png",
    useOffScreen: false,
    useBackgroundImage: false
  };
  function TR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, RZ, n), xZ.extend(t, e, n), e.canvas || (e.canvas = document.createElement("canvas"), e.canvas.style.width = "100%"), e.selector || (e.selector = J8.newInstance(), e.selector.setOpenGLRenderWindow(t)), e.bgImage = new Image(), e.bgImage.style.position = "absolute", e.bgImage.style.left = "0", e.bgImage.style.top = "0", e.bgImage.style.width = "100%", e.bgImage.style.height = "100%", e.bgImage.style.zIndex = "-1", e._textureResourceIds = /* @__PURE__ */ new Map(), e._graphicsResources = /* @__PURE__ */ new Map(), e._graphicsResourceHash = /* @__PURE__ */ new Map(), e._glInformation = null, e.myFactory = Hq.newInstance(), e.shaderCache = uZ.newInstance(), e.shaderCache.setOpenGLRenderWindow(t), e.renderPasses[0] = kX.newInstance(), H.get(t, e, [
      "shaderCache",
      "textureUnitManager",
      "webgl2",
      "useBackgroundImage",
      "activeFramebuffer",
      "rootOpenGLRenderWindow"
    ]), H.setGet(t, e, [
      "initialized",
      "context",
      "context2D",
      "canvas",
      "renderPasses",
      "notifyStartCaptureImage",
      "defaultToWebgl2",
      "cursor",
      "useOffScreen"
    ]), H.setGetArray(t, e, [
      "size"
    ], 2), H.event(t, e, "imageReady"), H.event(t, e, "windowResizeEvent"), MZ(t, e);
  }
  const $8 = H.newInstance(TR, "vtkOpenGLRenderWindow");
  kM("WebGL", $8);
  var OZ = {
    newInstance: $8,
    extend: TR,
    pushMonitorGLContextCount: bZ,
    popMonitorGLContextCount: DZ
  };
  Er("vtkRenderWindow", $8);
  function IZ(t, e) {
    e.classHierarchy.push("vtkOpenGLActor"), t.buildPass = (n) => {
      if (n) {
        e._openGLRenderWindow = t.getFirstAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNodes(e.renderable.getTextures()), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes(), e.ogltextures = null, e.activeTextures = null;
        for (let r = 0; r < e.children.length; r++) {
          const i = e.children[r];
          i.isA("vtkOpenGLTexture") ? (e.ogltextures || (e.ogltextures = []), e.ogltextures.push(i)) : e.oglmapper = i;
        }
      }
    }, t.traverseZBufferPass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.oglmapper.traverse(n), t.apply(n, false));
    }, t.traverseOpaqueZBufferPass = (n) => t.traverseOpaquePass(n), t.traverseOpaquePass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.oglmapper.traverse(n), t.apply(n, false));
    }, t.traverseTranslucentPass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.oglmapper.traverse(n), t.apply(n, false));
    }, t.activateTextures = () => {
      if (e.ogltextures) {
        e.activeTextures = [];
        for (let n = 0; n < e.ogltextures.length; n++) {
          const r = e.ogltextures[n];
          r.render(), r.getHandle() && e.activeTextures.push(r);
        }
      }
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
      }
    }, t.zBufferPass = (n, r) => t.opaquePass(n, r), t.opaqueZBufferPass = (n, r) => t.opaquePass(n, r), t.opaquePass = (n, r) => {
      if (n) e.context.depthMask(true), t.activateTextures();
      else if (e.activeTextures) for (let i = 0; i < e.activeTextures.length; i++) e.activeTextures[i].deactivate();
    }, t.translucentPass = (n, r) => {
      if (n) e.context.depthMask(false), t.activateTextures();
      else if (e.activeTextures) for (let i = 0; i < e.activeTextures.length; i++) e.activeTextures[i].deactivate();
    }, t.getKeyMatrices = () => (e.renderable.getMTime() > e.keyMatrixTime.getMTime() && (e.renderable.computeMatrix(), sr(e.keyMatrices.mcwc, e.renderable.getMatrix()), en(e.keyMatrices.mcwc, e.keyMatrices.mcwc), e.renderable.getIsIdentity() ? Fa(e.keyMatrices.normalMatrix) : (y5(e.keyMatrices.normalMatrix, e.keyMatrices.mcwc), td(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), N8(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix)), e.keyMatrixTime.modified()), e.keyMatrices);
  }
  const VZ = {
    context: null,
    keyMatrixTime: null,
    keyMatrices: null,
    activeTextures: null
  };
  function NZ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, VZ, n), Rn.extend(t, e, n), e.keyMatrixTime = {}, _n(e.keyMatrixTime, {
      mtime: 0
    }), e.keyMatrices = {
      normalMatrix: Fa(new Float64Array(9)),
      mcwc: gt(new Float64Array(16))
    }, pr(t, e, [
      "context"
    ]), Wi(t, e, [
      "activeTextures"
    ]), IZ(t, e);
  }
  const SR = pn(NZ);
  var LZ = {
    newInstance: SR
  };
  Er("vtkActor", SR);
  function UZ(t, e) {
    e.classHierarchy.push("vtkOpenGLActor2D"), t.buildPass = (n) => {
      if (n) {
        if (!e.renderable) return;
        e._openGLRenderWindow = t.getFirstAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNodes(e.renderable.getTextures()), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes(), e.ogltextures = null, e.activeTextures = null;
        for (let r = 0; r < e.children.length; r++) {
          const i = e.children[r];
          i.isA("vtkOpenGLTexture") ? (e.ogltextures || (e.ogltextures = []), e.ogltextures.push(i)) : e.oglmapper = i;
        }
      }
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        r.incrementOverlayActorCount();
      }
    }, t.traverseOpaquePass = (n) => {
      !e.oglmapper || !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.oglmapper.traverse(n), t.apply(n, false));
    }, t.traverseTranslucentPass = (n) => {
      !e.oglmapper || !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.oglmapper.traverse(n), t.apply(n, false));
    }, t.traverseOverlayPass = (n) => {
      !e.oglmapper || !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable || (t.apply(n, true), e.oglmapper.traverse(n), t.apply(n, false));
    }, t.activateTextures = () => {
      if (e.ogltextures) {
        e.activeTextures = [];
        for (let n = 0; n < e.ogltextures.length; n++) {
          const r = e.ogltextures[n];
          r.render(), r.getHandle() && e.activeTextures.push(r);
        }
      }
    }, t.opaquePass = (n, r) => {
      if (n) e.context.depthMask(true), t.activateTextures();
      else if (e.activeTextures) for (let i = 0; i < e.activeTextures.length; i++) e.activeTextures[i].deactivate();
    }, t.translucentPass = (n, r) => {
      if (n) e.context.depthMask(false), t.activateTextures();
      else if (e.activeTextures) for (let i = 0; i < e.activeTextures.length; i++) e.activeTextures[i].deactivate();
    }, t.overlayPass = (n, r) => {
      if (n) e.context.depthMask(true), t.activateTextures();
      else if (e.activeTextures) for (let i = 0; i < e.activeTextures.length; i++) e.activeTextures[i].deactivate();
    };
  }
  const FZ = {
    context: null,
    activeTextures: null
  };
  function BZ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, FZ, n), Rn.extend(t, e, n), pr(t, e, [
      "context"
    ]), Wi(t, e, [
      "activeTextures"
    ]), UZ(t, e);
  }
  const AR = pn(BZ);
  var _Z = {
    newInstance: AR
  };
  Er("vtkActor2D", AR);
  function kZ(t, e) {
    e.classHierarchy.push("vtkOpenGLCamera"), t.buildPass = (n) => {
      n && (e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.context = e._openGLRenderWindow.getContext());
    }, t.opaquePass = (n) => {
      if (n) {
        const r = e._openGLRenderer.getTiledSizeAndOrigin();
        e.context.viewport(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize), e.context.scissor(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize);
      }
    }, t.translucentPass = t.opaquePass, t.zBufferPass = t.opaquePass, t.opaqueZBufferPass = t.opaquePass, t.volumePass = t.opaquePass, t.getKeyMatrices = (n) => {
      if (n !== e.lastRenderer || e._openGLRenderWindow.getMTime() > e.keyMatrixTime.getMTime() || t.getMTime() > e.keyMatrixTime.getMTime() || n.getMTime() > e.keyMatrixTime.getMTime() || e.renderable.getMTime() > e.keyMatrixTime.getMTime()) {
        sr(e.keyMatrices.wcvc, e.renderable.getViewMatrix()), y5(e.keyMatrices.normalMatrix, e.keyMatrices.wcvc), td(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), en(e.keyMatrices.wcvc, e.keyMatrices.wcvc);
        const r = e._openGLRenderer.getAspectRatio();
        sr(e.keyMatrices.vcpc, e.renderable.getProjectionMatrix(r, -1, 1)), en(e.keyMatrices.vcpc, e.keyMatrices.vcpc), tn(e.keyMatrices.wcpc, e.keyMatrices.vcpc, e.keyMatrices.wcvc), e.keyMatrixTime.modified(), e.lastRenderer = n;
      }
      return e.keyMatrices;
    };
  }
  const PZ = {
    context: null,
    lastRenderer: null,
    keyMatrixTime: null,
    keyMatrices: null
  };
  function GZ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, PZ, n), Rn.extend(t, e, n), e.keyMatrixTime = {}, _n(e.keyMatrixTime), e.keyMatrices = {
      normalMatrix: new Float64Array(9),
      vcpc: new Float64Array(16),
      wcvc: new Float64Array(16),
      wcpc: new Float64Array(16)
    }, pr(t, e, [
      "context",
      "keyMatrixTime"
    ]), kZ(t, e);
  }
  const ER = pn(GZ);
  var zZ = {
    newInstance: ER
  };
  Er("vtkCamera", ER);
  function WZ(t, e) {
    e.classHierarchy.push("vtkAbstractMapper"), t.update = () => {
      t.getInputData();
    }, t.addClippingPlane = (n) => n.isA("vtkPlane") ? e.clippingPlanes.includes(n) ? false : (e.clippingPlanes.push(n), t.modified(), true) : false, t.getNumberOfClippingPlanes = () => e.clippingPlanes.length, t.removeAllClippingPlanes = () => e.clippingPlanes.length === 0 ? false : (e.clippingPlanes.length = 0, t.modified(), true), t.removeClippingPlane = (n) => {
      const r = e.clippingPlanes.indexOf(n);
      return r === -1 ? false : (e.clippingPlanes.splice(r, 1), t.modified(), true);
    }, t.getClippingPlanes = () => e.clippingPlanes, t.setClippingPlanes = (n) => {
      if (n) if (!Array.isArray(n)) t.addClippingPlane(n);
      else {
        const r = n.length;
        for (let i = 0; i < r && i < 6; i++) t.addClippingPlane(n[i]);
      }
    }, t.getClippingPlaneInDataCoords = (n, r, i) => {
      const a = e.clippingPlanes, s = n;
      if (a) {
        const o = a.length;
        if (r >= 0 && r < o) {
          const l = a[r], c = l.getNormal(), f = l.getOrigin(), u = c[0], h = c[1], g = c[2], v = -(u * f[0] + h * f[1] + g * f[2]);
          i[0] = u * s[0] + h * s[4] + g * s[8] + v * s[12], i[1] = u * s[1] + h * s[5] + g * s[9] + v * s[13], i[2] = u * s[2] + h * s[6] + g * s[10] + v * s[14], i[3] = u * s[3] + h * s[7] + g * s[11] + v * s[15];
          return;
        }
      }
      H.vtkErrorMacro(`Clipping plane index ${r} is out of range.`);
    };
  }
  const HZ = {
    clippingPlanes: []
  };
  function jZ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, HZ, n), H.obj(t, e), H.algo(t, e, 1, 0), e.clippingPlanes || (e.clippingPlanes = []), WZ(t, e);
  }
  var bR = {
    extend: jZ
  };
  function KZ(t, e) {
    t.getBounds = () => (H.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"), Ll()), t.getCenter = () => {
      var _a3;
      const n = t.getBounds();
      return e.center = En.isValid(n) ? En.getCenter(n) : null, (_a3 = e.center) == null ? void 0 : _a3.slice();
    }, t.getLength = () => {
      const n = t.getBounds();
      return En.getDiagonalLength(n);
    };
  }
  const YZ = (t) => ({
    bounds: [
      ...En.INIT_BOUNDS
    ],
    center: [
      0,
      0,
      0
    ],
    viewSpecificProperties: {},
    ...t
  });
  function qZ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, YZ(n)), bR.extend(t, e, n), H.setGet(t, e, [
      "viewSpecificProperties"
    ]), KZ(t, e);
  }
  var ey = {
    extend: qZ
  };
  const { vtkErrorMacro: MT } = H, RT = 0, OT = 1, F4 = 2;
  function XZ(t, e) {
    e.classHierarchy.push("vtkLookupTable"), t.isOpaque = () => {
      if (e.opaqueFlagBuildTime.getMTime() < t.getMTime()) {
        let n = true;
        e.nanColor[3] < 1 && (n = 0), e.useBelowRangeColor && e.belowRangeColor[3] < 1 && (n = 0), e.useAboveRangeColor && e.aboveRangeColor[3] < 1 && (n = 0);
        for (let r = 3; r < e.table.length && n; r += 4) e.table[r] < 255 && (n = false);
        e.opaqueFlag = n, e.opaqueFlagBuildTime.modified();
      }
      return e.opaqueFlag;
    }, t.usingLogScale = () => false, t.getNumberOfAvailableColors = () => e.table.length / 4, t.linearIndexLookup = (n, r) => {
      let i = 0;
      const a = Number(n);
      return a < r.range[0] ? i = r.maxIndex + RT + 1.5 : a > r.range[1] ? i = r.maxIndex + OT + 1.5 : (i = (a + r.shift) * r.scale, i = i < r.maxIndex ? i : r.maxIndex), Math.floor(i);
    }, t.linearLookup = (n, r, i) => {
      let a = 0;
      up(n) ? a = Math.floor(i.maxIndex + 1.5 + F4) : a = t.linearIndexLookup(n, i);
      const s = 4 * a;
      return r.slice(s, s + 4);
    }, t.indexedLookupFunction = (n, r, i) => {
      let a = t.getAnnotatedValueIndexInternal(n);
      a === -1 && (a = e.numberOfColors + F4);
      const s = 4 * a;
      return [
        r[s],
        r[s + 1],
        r[s + 2],
        r[s + 3]
      ];
    }, t.lookupShiftAndScale = (n, r) => {
      r.shift = -n[0], r.scale = Number.MAX_VALUE, n[1] > n[0] && (r.scale = (r.maxIndex + 1) / (n[1] - n[0]));
    }, t.mapScalarsThroughTable = (n, r, i, a) => {
      let s = t.linearLookup;
      e.indexedLookup && (s = t.indexedLookupFunction);
      const o = t.getMappingRange(), l = {
        maxIndex: t.getNumberOfColors() - 1,
        range: o,
        shift: 0,
        scale: 0
      };
      t.lookupShiftAndScale(o, l);
      const c = t.getAlpha(), f = n.getNumberOfTuples(), u = n.getNumberOfComponents(), h = r.getData(), g = n.getData();
      if (c >= 1) {
        if (i === e6.RGBA) for (let v = 0; v < f; v++) {
          const m = s(g[v * u + a], e.table, l);
          h[v * 4] = m[0], h[v * 4 + 1] = m[1], h[v * 4 + 2] = m[2], h[v * 4 + 3] = m[3];
        }
      } else if (i === e6.RGBA) for (let v = 0; v < f; v++) {
        const m = s(g[v * u + a], e.table, l);
        h[v * 4] = m[0], h[v * 4 + 1] = m[1], h[v * 4 + 2] = m[2], h[v * 4 + 3] = Math.floor(m[3] * c + 0.5);
      }
    }, t.forceBuild = () => {
      let n = 0, r = 0, i = 0, a = 0;
      const s = e.numberOfColors - 1;
      s && (n = (e.hueRange[1] - e.hueRange[0]) / s, r = (e.saturationRange[1] - e.saturationRange[0]) / s, i = (e.valueRange[1] - e.valueRange[0]) / s, a = (e.alphaRange[1] - e.alphaRange[0]) / s), e.table.length = 4 * s + 16;
      const o = [], l = [];
      for (let c = 0; c <= s; c++) o[0] = e.hueRange[0] + c * n, o[1] = e.saturationRange[0] + c * r, o[2] = e.valueRange[0] + c * i, Dc(o, l), l[3] = e.alphaRange[0] + c * a, e.table[c * 4] = l[0] * 255 + 0.5, e.table[c * 4 + 1] = l[1] * 255 + 0.5, e.table[c * 4 + 2] = l[2] * 255 + 0.5, e.table[c * 4 + 3] = l[3] * 255 + 0.5;
      t.buildSpecialColors(), e.buildTime.modified();
    }, t.setTable = (n) => {
      if (Array.isArray(n)) {
        const i = n[0].length;
        e.numberOfColors = n.length;
        const a = 4 - i;
        let s = 0;
        for (let o = 0; o < e.numberOfColors; o++) e.table[o * 4] = 255, e.table[o * 4 + 1] = 255, e.table[o * 4 + 2] = 255, e.table[o * 4 + 3] = 255;
        for (let o = 0; o < n.length; o++) {
          const l = n[o];
          for (let c = 0; c < i; c++) e.table[s++] = l[c];
          s += a;
        }
        return t.buildSpecialColors(), e.insertTime.modified(), t.modified(), true;
      }
      if (n.getNumberOfComponents() !== 4) return MT("Expected 4 components for RGBA colors"), false;
      if (n.getDataType() !== zt.UNSIGNED_CHAR) return MT("Expected unsigned char values for RGBA colors"), false;
      e.numberOfColors = n.getNumberOfTuples();
      const r = n.getData();
      e.table.length = r.length;
      for (let i = 0; i < r.length; i++) e.table[i] = r[i];
      return t.buildSpecialColors(), e.insertTime.modified(), t.modified(), true;
    }, t.buildSpecialColors = () => {
      const { numberOfColors: n } = e, r = e.table;
      let i = (n + RT) * 4;
      e.useBelowRangeColor || n === 0 ? (r[i] = e.belowRangeColor[0] * 255 + 0.5, r[i + 1] = e.belowRangeColor[1] * 255 + 0.5, r[i + 2] = e.belowRangeColor[2] * 255 + 0.5, r[i + 3] = e.belowRangeColor[3] * 255 + 0.5) : (r[i] = r[0], r[i + 1] = r[1], r[i + 2] = r[2], r[i + 3] = r[3]), i = (n + OT) * 4, e.useAboveRangeColor || n === 0 ? (r[i] = e.aboveRangeColor[0] * 255 + 0.5, r[i + 1] = e.aboveRangeColor[1] * 255 + 0.5, r[i + 2] = e.aboveRangeColor[2] * 255 + 0.5, r[i + 3] = e.aboveRangeColor[3] * 255 + 0.5) : (r[i] = r[4 * (n - 1) + 0], r[i + 1] = r[4 * (n - 1) + 1], r[i + 2] = r[4 * (n - 1) + 2], r[i + 3] = r[4 * (n - 1) + 3]), i = (n + F4) * 4, r[i] = e.nanColor[0] * 255 + 0.5, r[i + 1] = e.nanColor[1] * 255 + 0.5, r[i + 2] = e.nanColor[2] * 255 + 0.5, r[i + 3] = e.nanColor[3] * 255 + 0.5;
    }, t.build = () => {
      (e.table.length < 1 || t.getMTime() > e.buildTime.getMTime() && e.insertTime.getMTime() <= e.buildTime.getMTime()) && t.forceBuild();
    }, e.table.length > 0 && (t.buildSpecialColors(), e.insertTime.modified());
  }
  const ZZ = {
    numberOfColors: 256,
    hueRange: [
      0,
      0.66667
    ],
    saturationRange: [
      1,
      1
    ],
    valueRange: [
      1,
      1
    ],
    alphaRange: [
      1,
      1
    ],
    nanColor: [
      0.5,
      0,
      0,
      1
    ],
    belowRangeColor: [
      0,
      0,
      0,
      1
    ],
    aboveRangeColor: [
      1,
      1,
      1,
      1
    ],
    useAboveRangeColor: false,
    useBelowRangeColor: false,
    alpha: 1
  };
  function DR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, ZZ, n), v5.extend(t, e, n), e.table || (e.table = []), e.buildTime = {}, H.obj(e.buildTime), e.opaqueFlagBuildTime = {}, H.obj(e.opaqueFlagBuildTime, {
      mtime: 0
    }), e.insertTime = {}, H.obj(e.insertTime, {
      mtime: 0
    }), H.get(t, e, [
      "buildTime"
    ]), H.setGet(t, e, [
      "numberOfColors",
      "useAboveRangeColor",
      "useBelowRangeColor"
    ]), H.setArray(t, e, [
      "alphaRange",
      "hueRange",
      "saturationRange",
      "valueRange"
    ], 2), H.setArray(t, e, [
      "nanColor",
      "belowRangeColor",
      "aboveRangeColor"
    ], 4), H.getArray(t, e, [
      "hueRange",
      "saturationRange",
      "valueRange",
      "alphaRange",
      "nanColor",
      "belowRangeColor",
      "aboveRangeColor"
    ]), XZ(t, e);
  }
  const QZ = H.newInstance(DR, "vtkLookupTable");
  var X1 = {
    newInstance: QZ,
    extend: DR
  };
  let MR = 1, ty = 0;
  const JZ = [
    "VTK_RESOLVE_OFF",
    "VTK_RESOLVE_POLYGON_OFFSET"
  ];
  function $Z() {
    return MR;
  }
  function eQ(t) {
    MR = t;
  }
  function tQ() {
    return ty;
  }
  function S5() {
    ty = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  }
  function nQ() {
    S5(0);
  }
  function rQ() {
    S5(0);
  }
  function iQ() {
    S5(1);
  }
  function aQ() {
    return JZ[ty];
  }
  var u6 = {
    getResolveCoincidentTopologyAsString: aQ,
    getResolveCoincidentTopologyPolygonOffsetFaces: $Z,
    getResolveCoincidentTopology: tQ,
    setResolveCoincidentTopology: S5,
    setResolveCoincidentTopologyPolygonOffsetFaces: eQ,
    setResolveCoincidentTopologyToDefault: nQ,
    setResolveCoincidentTopologyToOff: rQ,
    setResolveCoincidentTopologyToPolygonOffset: iQ
  };
  function RR(t, e, n) {
    n.forEach((r) => {
      t[`get${r.method}`] = () => e[r.key], t[`set${r.method}`] = (i, a) => {
        e[r.key] = {
          factor: i,
          offset: a
        };
      };
    });
  }
  const ny = [
    "Polygon",
    "Line",
    "Point"
  ], sQ = {
    Polygon: {
      factor: 2,
      offset: 0
    },
    Line: {
      factor: 1,
      offset: -1
    },
    Point: {
      factor: 0,
      offset: -2
    }
  }, Rc = {};
  RR(Rc, sQ, ny.map((t) => ({
    key: t,
    method: `ResolveCoincidentTopology${t}OffsetParameters`
  })));
  function oQ(t, e) {
    e.resolveCoincidentTopology === void 0 && (e.resolveCoincidentTopology = false), H.setGet(t, e, [
      "resolveCoincidentTopology"
    ]), e.topologyOffset = {
      Polygon: {
        factor: 0,
        offset: 0
      },
      Line: {
        factor: 0,
        offset: 0
      },
      Point: {
        factor: 0,
        offset: 0
      }
    }, Object.keys(u6).forEach((n) => {
      t[n] = u6[n];
    }), Object.keys(Rc).forEach((n) => {
      t[n] = Rc[n];
    }), RR(t, e.topologyOffset, ny.map((n) => ({
      key: n,
      method: `RelativeCoincidentTopology${n}OffsetParameters`
    }))), t.getCoincidentTopologyPolygonOffsetParameters = () => {
      const n = Rc.getResolveCoincidentTopologyPolygonOffsetParameters(), r = t.getRelativeCoincidentTopologyPolygonOffsetParameters();
      return {
        factor: n.factor + r.factor,
        offset: n.offset + r.offset
      };
    }, t.getCoincidentTopologyLineOffsetParameters = () => {
      const n = Rc.getResolveCoincidentTopologyLineOffsetParameters(), r = t.getRelativeCoincidentTopologyLineOffsetParameters();
      return {
        factor: n.factor + r.factor,
        offset: n.offset + r.offset
      };
    }, t.getCoincidentTopologyPointOffsetParameter = () => {
      const n = Rc.getResolveCoincidentTopologyPointOffsetParameters(), r = t.getRelativeCoincidentTopologyPointOffsetParameters();
      return {
        factor: n.factor + r.factor,
        offset: n.offset + r.offset
      };
    };
  }
  var A5 = {
    implementCoincidentTopologyMethods: oQ,
    staticOffsetAPI: Rc,
    otherStaticMethods: u6,
    CATEGORIES: ny
  };
  const { FieldAssociations: IT } = $u, { staticOffsetAPI: lQ, otherStaticMethods: cQ } = A5, { ColorMode: B4, ScalarMode: pc, GetArray: _4 } = m5, { VectorMode: uQ } = R8, { VtkDataTypes: fQ } = Tt;
  function v1(t) {
    return () => H.vtkErrorMacro(`vtkMapper::${t} - NOT IMPLEMENTED`);
  }
  function hQ(t, e) {
    e.classHierarchy.push("vtkMapper"), t.getBounds = () => {
      const n = t.getInputData();
      return n ? (e.static || t.update(), e.bounds = n.getBounds()) : e.bounds = Ll(), e.bounds;
    }, t.setForceCompileOnly = (n) => {
      e.forceCompileOnly = n;
    }, t.setSelectionWebGLIdsToVTKIds = (n) => {
      e.selectionWebGLIdsToVTKIds = n;
    }, t.createDefaultLookupTable = () => {
      e.lookupTable = X1.newInstance();
    }, t.getColorModeAsString = () => H.enumToString(B4, e.colorMode), t.setColorModeToDefault = () => t.setColorMode(0), t.setColorModeToMapScalars = () => t.setColorMode(1), t.setColorModeToDirectScalars = () => t.setColorMode(2), t.getScalarModeAsString = () => H.enumToString(pc, e.scalarMode), t.setScalarModeToDefault = () => t.setScalarMode(0), t.setScalarModeToUsePointData = () => t.setScalarMode(1), t.setScalarModeToUseCellData = () => t.setScalarMode(2), t.setScalarModeToUsePointFieldData = () => t.setScalarMode(3), t.setScalarModeToUseCellFieldData = () => t.setScalarMode(4), t.setScalarModeToUseFieldData = () => t.setScalarMode(5), t.getAbstractScalars = (n, r, i, a, s) => {
      if (!n || !e.scalarVisibility) return {
        scalars: null,
        cellFLag: false
      };
      let o = null, l = false;
      if (r === pc.DEFAULT) o = n.getPointData().getScalars(), o || (o = n.getCellData().getScalars(), l = true);
      else if (r === pc.USE_POINT_DATA) o = n.getPointData().getScalars();
      else if (r === pc.USE_CELL_DATA) o = n.getCellData().getScalars(), l = true;
      else if (r === pc.USE_POINT_FIELD_DATA) {
        const c = n.getPointData();
        i === _4.BY_ID ? o = c.getArrayByIndex(a) : o = c.getArrayByName(s);
      } else if (r === pc.USE_CELL_FIELD_DATA) {
        const c = n.getCellData();
        l = true, i === _4.BY_ID ? o = c.getArrayByIndex(a) : o = c.getArrayByName(s);
      } else if (r === pc.USE_FIELD_DATA) {
        const c = n.getFieldData();
        i === _4.BY_ID ? o = c.getArrayByIndex(a) : o = c.getArrayByName(s);
      }
      return {
        scalars: o,
        cellFlag: l
      };
    }, t.mapScalars = (n, r) => {
      const i = t.getAbstractScalars(n, e.scalarMode, e.arrayAccessMode, e.arrayId, e.colorByArrayName).scalars;
      if (!i) {
        e.colorCoordinates = null, e.colorTextureMap = null, e.colorMapColors = null;
        return;
      }
      const a = `${t.getMTime()}${i.getMTime()}${r}`;
      if (e.colorBuildString !== a) {
        if (e.useLookupTableScalarRange || t.getLookupTable().setRange(e.scalarRange[0], e.scalarRange[1]), t.canUseTextureMapForColoring(n)) t.mapScalarsToTexture(i, r);
        else {
          e.colorCoordinates = null, e.colorTextureMap = null;
          const s = t.getLookupTable();
          s && (s.build(), e.colorMapColors = s.mapScalars(i, e.colorMode, e.fieldDataTupleId));
        }
        e.colorBuildString = `${t.getMTime()}${i.getMTime()}${r}`;
      }
    }, t.scalarToTextureCoordinate = (n, r, i) => {
      let a = 0.5, s = 1;
      return up(n) || (s = 0.49, a = (n - r) * i, a > 1e3 ? a = 1e3 : a < -1e3 && (a = -1e3)), {
        texCoordS: a,
        texCoordT: s
      };
    }, t.createColorTextureCoordinates = (n, r, i, a, s, o, l, c, f) => {
      const u = (o[1] - o[0]) / c, h = [];
      h[0] = o[0] - u, h[1] = o[1] + u;
      const g = 1 / (h[1] - h[0]), v = r.getData(), m = n.getData();
      let y = 0, w = 0;
      if (s < 0 || s >= a) for (let C = 0; C < i; ++C) {
        let T = 0;
        for (let b = 0; b < a; ++b) T += m[y] * m[y], y++;
        let S = Math.sqrt(T);
        f && (S = X1.applyLogScale(S, l, o));
        const E = t.scalarToTextureCoordinate(S, h[0], g);
        v[w] = E.texCoordS, v[w + 1] = E.texCoordT, w += 2;
      }
      else {
        y += s;
        for (let C = 0; C < i; ++C) {
          let T = m[y];
          f && (T = X1.applyLogScale(T, l, o));
          const S = t.scalarToTextureCoordinate(T, h[0], g);
          v[w] = S.texCoordS, v[w + 1] = S.texCoordT, w += 2, y += a;
        }
      }
    }, t.mapScalarsToTexture = (n, r) => {
      const i = e.lookupTable.getRange(), a = e.lookupTable.usingLogScale();
      a && X1.getLogRange(i, i);
      const s = e.lookupTable.getAlpha();
      if (e.colorMapColors = null, e.colorTextureMap == null || t.getMTime() > e.colorTextureMap.getMTime() || e.lookupTable.getMTime() > e.colorTextureMap.getMTime() || e.lookupTable.getAlpha() !== r) {
        e.lookupTable.setAlpha(r), e.colorTextureMap = null, e.lookupTable.build();
        let o = e.lookupTable.getNumberOfAvailableColors();
        o > 4094 && (o = 4094), o < 64 && (o = 64), o += 2;
        const l = (i[1] - i[0]) / (o - 2), c = new Float64Array(o * 2);
        for (let u = 0; u < o; ++u) c[u] = i[0] + u * l - l / 2, a && (c[u] = 10 ** c[u]);
        for (let u = 0; u < o; ++u) c[u + o] = NaN;
        e.colorTextureMap = Bl.newInstance(), e.colorTextureMap.setExtent(0, o - 1, 0, 1, 0, 0);
        const f = Tt.newInstance({
          numberOfComponents: 1,
          values: c
        });
        e.colorTextureMap.getPointData().setScalars(e.lookupTable.mapScalars(f, e.colorMode, 0)), e.lookupTable.setAlpha(s);
      }
      if (!e.colorCoordinates || t.getMTime() > e.colorCoordinates.getMTime() || t.getInputData(0).getMTime() > e.colorCoordinates.getMTime() || e.lookupTable.getMTime() > e.colorCoordinates.getMTime()) {
        e.colorCoordinates = null;
        const o = n.getNumberOfComponents(), l = n.getNumberOfTuples();
        e.colorCoordinates = Tt.newInstance({
          numberOfComponents: 2,
          values: new Float32Array(l * 2)
        });
        let c = e.lookupTable.getVectorComponent();
        e.lookupTable.getVectorMode() === uQ.MAGNITUDE && n.getNumberOfComponents() > 1 && (c = -1), t.createColorTextureCoordinates(n, e.colorCoordinates, l, o, c, i, e.lookupTable.getRange(), e.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, a);
      }
    }, t.getIsOpaque = () => {
      const n = t.getInputData(), i = t.getAbstractScalars(n, e.scalarMode, e.arrayAccessMode, e.arrayId, e.colorByArrayName).scalars;
      if (!e.scalarVisibility || i == null) return true;
      const a = t.getLookupTable();
      return a ? (a.build(), a.areScalarsOpaque(i, e.colorMode, -1)) : true;
    }, t.canUseTextureMapForColoring = (n) => {
      if (!e.interpolateScalarsBeforeMapping || e.lookupTable && e.lookupTable.getIndexedLookup()) return false;
      const r = t.getAbstractScalars(n, e.scalarMode, e.arrayAccessMode, e.arrayId, e.colorByArrayName), i = r.scalars;
      return !(!i || r.cellFlag || e.colorMode === B4.DEFAULT && i.getDataType() === fQ.UNSIGNED_CHAR || e.colorMode === B4.DIRECT_SCALARS);
    }, t.clearColorArrays = () => {
      e.colorMapColors = null, e.colorCoordinates = null, e.colorTextureMap = null;
    }, t.getLookupTable = () => (e.lookupTable || t.createDefaultLookupTable(), e.lookupTable), t.getMTime = () => {
      let n = e.mtime;
      if (e.lookupTable !== null) {
        const r = e.lookupTable.getMTime();
        n = r > n ? r : n;
      }
      return n;
    }, t.getPrimitiveCount = () => {
      const n = t.getInputData();
      return {
        points: n.getPoints().getNumberOfValues() / 3,
        verts: n.getVerts().getNumberOfValues() - n.getVerts().getNumberOfCells(),
        lines: n.getLines().getNumberOfValues() - 2 * n.getLines().getNumberOfCells(),
        triangles: n.getPolys().getNumberOfValues() - 3 * n.getPolys().getNumberOfCells()
      };
    }, t.acquireInvertibleLookupTable = v1("AcquireInvertibleLookupTable"), t.valueToColor = v1("ValueToColor"), t.colorToValue = v1("ColorToValue"), t.useInvertibleColorFor = v1("UseInvertibleColorFor"), t.clearInvertibleColor = v1("ClearInvertibleColor"), t.processSelectorPixelBuffers = (n, r) => {
      if (!n || !e.selectionWebGLIdsToVTKIds || !e.populateSelectionSettings) return;
      const i = n.getRawPixelBuffer(Pi.ID_LOW24), a = n.getRawPixelBuffer(Pi.ID_HIGH24), s = n.getCurrentPass(), o = n.getFieldAssociation();
      let l = null;
      o === IT.FIELD_ASSOCIATION_POINTS ? l = e.selectionWebGLIdsToVTKIds.points : o === IT.FIELD_ASSOCIATION_CELLS && (l = e.selectionWebGLIdsToVTKIds.cells), l && r.forEach((c) => {
        if (s === Pi.ID_LOW24) {
          let f = 0;
          a && (f += a[c], f *= 256), f += i[c + 2], f *= 256, f += i[c + 1], f *= 256, f += i[c];
          const u = l[f], h = n.getPixelBuffer(Pi.ID_LOW24);
          h[c] = u & 255, h[c + 1] = (u & 65280) >> 8, h[c + 2] = (u & 16711680) >> 16;
        } else if (s === Pi.ID_HIGH24 && a) {
          let f = 0;
          f += a[c], f *= 256, f += i[c], f *= 256, f += i[c + 1], f *= 256, f += i[c + 2];
          const u = l[f], h = n.getPixelBuffer(Pi.ID_HIGH24);
          h[c] = (u & 4278190080) >> 24;
        }
      });
    };
  }
  const dQ = {
    colorMapColors: null,
    static: false,
    lookupTable: null,
    scalarVisibility: true,
    scalarRange: [
      0,
      1
    ],
    useLookupTableScalarRange: false,
    colorMode: 0,
    scalarMode: 0,
    arrayAccessMode: 1,
    renderTime: 0,
    colorByArrayName: null,
    fieldDataTupleId: -1,
    populateSelectionSettings: true,
    selectionWebGLIdsToVTKIds: null,
    interpolateScalarsBeforeMapping: false,
    colorCoordinates: null,
    colorTextureMap: null,
    forceCompileOnly: 0,
    useInvertibleColors: false,
    invertibleScalars: null,
    customShaderAttributes: []
  };
  function OR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, dQ, n), ey.extend(t, e, n), H.get(t, e, [
      "colorCoordinates",
      "colorMapColors",
      "colorTextureMap",
      "selectionWebGLIdsToVTKIds"
    ]), H.setGet(t, e, [
      "colorByArrayName",
      "arrayAccessMode",
      "colorMode",
      "fieldDataTupleId",
      "interpolateScalarsBeforeMapping",
      "lookupTable",
      "populateSelectionSettings",
      "renderTime",
      "scalarMode",
      "scalarVisibility",
      "static",
      "useLookupTableScalarRange",
      "customShaderAttributes"
    ]), H.setGetArray(t, e, [
      "scalarRange"
    ], 2), A5.implementCoincidentTopologyMethods(t, e), hQ(t, e);
  }
  const gQ = H.newInstance(OR, "vtkMapper");
  var Kc = {
    newInstance: gQ,
    extend: OR,
    ...lQ,
    ...cQ,
    ...m5
  };
  const pQ = {
    DISPLAY: 0,
    WORLD: 1
  };
  var IR = {
    CoordinateSystem: pQ
  };
  const { CoordinateSystem: f6 } = IR;
  function VT(t) {
    return () => H.vtkErrorMacro(`vtkProp::${t} - NOT IMPLEMENTED`);
  }
  function mQ(t, e) {
    e.classHierarchy.push("vtkProp"), t.getMTime = () => {
      let n = e.mtime;
      for (let r = 0; r < e.textures.length; ++r) {
        const i = e.textures[r].getMTime();
        i > n && (n = i);
      }
      return n;
    }, t.processSelectorPixelBuffers = (n, r) => {
    }, t.getNestedProps = () => null, t.getActors = () => [], t.getActors2D = () => [], t.getVolumes = () => [], t.pick = VT("pick"), t.hasKey = VT("hasKey"), t.getNestedVisibility = () => e.visibility && (!e._parentProp || e._parentProp.getNestedVisibility()), t.getNestedPickable = () => e.pickable && (!e._parentProp || e._parentProp.getNestedPickable()), t.getNestedDragable = () => e.dragable && (!e._parentProp || e._parentProp.getNestedDragable()), t.getRedrawMTime = () => e.mtime, t.setEstimatedRenderTime = (n) => {
      e.estimatedRenderTime = n, e.savedEstimatedRenderTime = n;
    }, t.restoreEstimatedRenderTime = () => {
      e.estimatedRenderTime = e.savedEstimatedRenderTime;
    }, t.addEstimatedRenderTime = (n) => {
      e.estimatedRenderTime += n;
    }, t.setAllocatedRenderTime = (n) => {
      e.allocatedRenderTime = n, e.savedEstimatedRenderTime = e.estimatedRenderTime, e.estimatedRenderTime = 0;
    }, t.getSupportsSelection = () => false, t.getTextures = () => e.textures, t.hasTexture = (n) => e.textures.indexOf(n) !== -1, t.addTexture = (n) => {
      n && !t.hasTexture(n) && (e.textures = e.textures.concat(n), t.modified());
    }, t.removeTexture = (n) => {
      const r = e.textures.filter((i) => i !== n);
      e.textures.length !== r.length && (e.textures = r, t.modified());
    }, t.removeAllTextures = () => {
      e.textures = [], t.modified();
    }, t.setCoordinateSystemToWorld = () => t.setCoordinateSystem(f6.WORLD), t.setCoordinateSystemToDisplay = () => t.setCoordinateSystem(f6.DISPLAY);
  }
  const vQ = {
    allocatedRenderTime: 10,
    coordinateSystem: f6.WORLD,
    dragable: true,
    estimatedRenderTime: 0,
    paths: null,
    pickable: true,
    renderTimeMultiplier: 1,
    savedEstimatedRenderTime: 0,
    textures: [],
    useBounds: true,
    visibility: true
  };
  function VR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, vQ, n), H.obj(t, e), H.get(t, e, [
      "estimatedRenderTime",
      "allocatedRenderTime"
    ]), H.setGet(t, e, [
      "_parentProp",
      "coordinateSystem",
      "dragable",
      "pickable",
      "renderTimeMultiplier",
      "useBounds",
      "visibility"
    ]), H.moveToProtected(t, e, [
      "parentProp"
    ]), mQ(t, e);
  }
  const yQ = H.newInstance(VR, "vtkProp");
  var nd = {
    newInstance: yQ,
    extend: VR,
    ...IR
  }, ry = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexMC;

// frag position in VC
//VTK::PositionVC::Dec

// optional normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// Texture coordinates
//VTK::TCoord::Dec

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

// Apple Bug
//VTK::PrimID::Dec

// picking support
//VTK::Picking::Dec

void main()
{
  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  //VTK::PrimID::Impl

  //VTK::PositionVC::Impl

  //VTK::Light::Impl

  //VTK::Picking::Impl
}
`, rd = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the polydata mappers fragment shader

uniform int PrimitiveIDOffset;

// VC position of this fragment
//VTK::PositionVC::Dec

// optional color passed in from the vertex shader, vertexColor
//VTK::Color::Dec

// optional surface normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// Depth Peeling Support
//VTK::DepthPeeling::Dec

// clipping plane vars
//VTK::Clip::Dec

// label outline 
//VTK::LabelOutline::Dec

// the output of this shader
//VTK::Output::Dec

// Apple Bug
//VTK::PrimID::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

//VTK::LabelOutlineHelperFunction

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  // Apple Bug
  //VTK::PrimID::Impl

  //VTK::Clip::Impl

  //VTK::Color::Impl

  // Generate the normal if we are not passed in one
  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Light::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;
  function xQ(t, e) {
    t.replaceShaderCoincidentOffset = (n, r, i) => {
      const a = t.getCoincidentParameters(r, i);
      if (a && (a.factor !== 0 || a.offset !== 0)) {
        let s = n.Fragment;
        s = se.substitute(s, "//VTK::Coincident::Dec", [
          "uniform float cfactor;",
          "uniform float coffset;"
        ]).result, e.context.getExtension("EXT_frag_depth") && (a.factor !== 0 ? (s = se.substitute(s, "//VTK::UniformFlow::Impl", [
          "float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));",
          "//VTK::UniformFlow::Impl"
        ], false).result, s = se.substitute(s, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result) : s = se.substitute(s, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result), e._openGLRenderWindow.getWebgl2() && (a.factor !== 0 ? (s = se.substitute(s, "//VTK::UniformFlow::Impl", [
          "float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));",
          "//VTK::UniformFlow::Impl"
        ], false).result, s = se.substitute(s, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result) : s = se.substitute(s, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result), n.Fragment = s;
      }
    };
  }
  function wQ(t, e) {
    t.applyShaderReplacements = (n, r, i) => {
      let a = null;
      if (r && (a = r.ShaderReplacements), a) for (let s = 0; s < a.length; s++) {
        const o = a[s];
        if (i && o.replaceFirst || !i && !o.replaceFirst) {
          const l = o.shaderType, c = n[l], f = se.substitute(c, o.originalValue, o.replacementValue, o.replaceAll);
          n[l] = f.result;
        }
      }
    }, t.buildShaders = (n, r, i) => {
      t.getReplacedShaderTemplate(n, r, i), e.lastRenderPassShaderReplacement = e.currentRenderPass ? e.currentRenderPass.getShaderReplacement() : null, e.lastRenderPassShaderReplacement && e.lastRenderPassShaderReplacement(n);
      const a = e.renderable.getViewSpecificProperties().OpenGL;
      t.applyShaderReplacements(n, a, true), t.replaceShaderValues(n, r, i), t.applyShaderReplacements(n, a);
    }, t.getReplacedShaderTemplate = (n, r, i) => {
      const a = e.renderable.getViewSpecificProperties().OpenGL;
      t.getShaderTemplate(n, r, i);
      let s = n.Vertex;
      if (a) {
        const c = a.VertexShaderCode;
        c !== void 0 && c !== "" && (s = c);
      }
      n.Vertex = s;
      let o = n.Fragment;
      if (a) {
        const c = a.FragmentShaderCode;
        c !== void 0 && c !== "" && (o = c);
      }
      n.Fragment = o;
      let l = n.Geometry;
      if (a) {
        const c = a.GeometryShaderCode;
        c !== void 0 && (l = c);
      }
      n.Geometry = l;
    };
  }
  var Ls = {
    implementReplaceShaderCoincidentOffset: xQ,
    implementBuildShadersWithReplacements: wQ
  };
  const { FieldAssociations: k4 } = $u, { primTypes: kr } = Bs, { Representation: X0, Shading: NT } = ef, { ScalarMode: N2 } = Kc, { Filter: LT, Wrap: UT } = er, { vtkErrorMacro: mc } = di, CQ = {
    type: "StartEvent"
  }, TQ = {
    type: "EndEvent"
  }, { CoordinateSystem: SQ } = nd;
  function AQ(t) {
    const e = t.getSelector();
    return e ? e.getCurrentPass() : Pi.MIN_KNOWN_PASS - 1;
  }
  function EQ(t, e) {
    e.classHierarchy.push("vtkOpenGLPolyDataMapper"), t.buildPass = (r) => {
      r && (e.currentRenderPass = null, e.openGLActor = t.getFirstAncestorOfType("vtkOpenGLActor"), e._openGLRenderer = e.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.openGLCamera = e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()));
    }, t.translucentPass = (r, i) => {
      r && (e.currentRenderPass = i, t.render());
    }, t.zBufferPass = (r) => {
      r && (e.haveSeenDepthRequest = true, e.renderDepth = true, t.render(), e.renderDepth = false);
    }, t.opaqueZBufferPass = (r) => t.zBufferPass(r), t.opaquePass = (r) => {
      r && t.render();
    }, t.render = () => {
      const r = e._openGLRenderWindow.getContext();
      if (e.context !== r) {
        e.context = r;
        for (let s = kr.Start; s < kr.End; s++) e.primitives[s].setOpenGLRenderWindow(e._openGLRenderWindow);
      }
      const i = e.openGLActor.getRenderable(), a = e._openGLRenderer.getRenderable();
      t.renderPiece(a, i);
    }, t.getShaderTemplate = (r, i, a) => {
      r.Vertex = ry, r.Fragment = rd, r.Geometry = "";
    }, t.replaceShaderColor = (r, i, a) => {
      let s = r.Vertex, o = r.Geometry, l = r.Fragment;
      const c = e.lastBoundBO.getReferenceByName("lastLightComplexity");
      let f = [
        "uniform float ambient;",
        "uniform float diffuse;",
        "uniform float specular;",
        "uniform float opacityUniform; // the fragment opacity",
        "uniform vec3 ambientColorUniform;",
        "uniform vec3 diffuseColorUniform;"
      ];
      c && (f = f.concat([
        "uniform vec3 specularColorUniform;",
        "uniform float specularPowerUniform;"
      ]));
      let u = [
        "vec3 ambientColor;",
        "  vec3 diffuseColor;",
        "  float opacity;"
      ];
      c && (u = u.concat([
        "  vec3 specularColor;",
        "  float specularPower;"
      ])), u = u.concat([
        "  ambientColor = ambientColorUniform;",
        "  diffuseColor = diffuseColorUniform;",
        "  opacity = opacityUniform;"
      ]), c && (u = u.concat([
        "  specularColor = specularColorUniform;",
        "  specularPower = specularPowerUniform;"
      ])), e.lastBoundBO.getCABO().getColorComponents() !== 0 && !e.drawingEdges && (f = f.concat([
        "varying vec4 vertexColorVSOutput;"
      ]), s = se.substitute(s, "//VTK::Color::Dec", [
        "attribute vec4 scalarColor;",
        "varying vec4 vertexColorVSOutput;"
      ]).result, s = se.substitute(s, "//VTK::Color::Impl", [
        "vertexColorVSOutput =  scalarColor;"
      ]).result, o = se.substitute(o, "//VTK::Color::Dec", [
        "in vec4 vertexColorVSOutput[];",
        "out vec4 vertexColorGSOutput;"
      ]).result, o = se.substitute(o, "//VTK::Color::Impl", [
        "vertexColorGSOutput = vertexColorVSOutput[i];"
      ]).result), e.lastBoundBO.getCABO().getColorComponents() !== 0 && !e.drawingEdges ? l = se.substitute(l, "//VTK::Color::Impl", u.concat([
        "  diffuseColor = vertexColorVSOutput.rgb;",
        "  ambientColor = vertexColorVSOutput.rgb;",
        "  opacity = opacity*vertexColorVSOutput.a;"
      ])).result : e.renderable.getInterpolateScalarsBeforeMapping() && e.renderable.getColorCoordinates() && !e.drawingEdges ? l = se.substitute(l, "//VTK::Color::Impl", u.concat([
        "  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);",
        "  diffuseColor = texColor.rgb;",
        "  ambientColor = texColor.rgb;",
        "  opacity = opacity*texColor.a;"
      ])).result : (a.getBackfaceProperty() && !e.drawingEdges && (f = f.concat([
        "uniform float opacityUniformBF; // the fragment opacity",
        "uniform float ambientIntensityBF; // the material ambient",
        "uniform float diffuseIntensityBF; // the material diffuse",
        "uniform vec3 ambientColorUniformBF; // ambient material color",
        "uniform vec3 diffuseColorUniformBF; // diffuse material color"
      ]), c ? (f = f.concat([
        "uniform float specularIntensityBF; // the material specular intensity",
        "uniform vec3 specularColorUniformBF; // intensity weighted color",
        "uniform float specularPowerUniformBF;"
      ]), u = u.concat([
        "if (gl_FrontFacing == false) {",
        "  ambientColor = ambientIntensityBF * ambientColorUniformBF;",
        "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;",
        "  specularColor = specularIntensityBF * specularColorUniformBF;",
        "  specularPower = specularPowerUniformBF;",
        "  opacity = opacityUniformBF; }"
      ])) : u = u.concat([
        "if (gl_FrontFacing == false) {",
        "  ambientColor = ambientIntensityBF * ambientColorUniformBF;",
        "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;",
        "  opacity = opacityUniformBF; }"
      ])), e.haveCellScalars && !e.drawingEdges && (f = f.concat([
        "uniform samplerBuffer texture1;"
      ])), l = se.substitute(l, "//VTK::Color::Impl", u).result), l = se.substitute(l, "//VTK::Color::Dec", f).result, r.Vertex = s, r.Geometry = o, r.Fragment = l;
    }, t.replaceShaderLight = (r, i, a) => {
      let s = r.Fragment;
      const o = "", l = e.lastBoundBO.getReferenceByName("lastLightComplexity"), c = e.lastBoundBO.getReferenceByName("lastLightCount");
      let f = [];
      switch (l) {
        case 0:
          s = se.substitute(s, "//VTK::Light::Impl", [
            "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);",
            "  //VTK::Light::Impl"
          ], false).result;
          break;
        case 1:
          s = se.substitute(s, "//VTK::Light::Impl", [
            "  float df = max(0.0, normalVCVSOutput.z);",
            "  float sf = pow(df, specularPower);",
            "  vec3 diffuseL = df * diffuseColor;",
            "  vec3 specularL = sf * specularColor;",
            "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);",
            "  //VTK::Light::Impl"
          ], false).result;
          break;
        case 2:
          for (let u = 0; u < c; ++u) f = f.concat([
            `uniform vec3 lightColor${u};`,
            `uniform vec3 lightDirectionVC${u}; // normalized`,
            `uniform vec3 lightHalfAngleVC${u}; // normalized`
          ]);
          s = se.substitute(s, "//VTK::Light::Dec", f).result, f = [
            "vec3 diffuseL = vec3(0,0,0);",
            "  vec3 specularL = vec3(0,0,0);",
            "  float df;"
          ];
          for (let u = 0; u < c; ++u) f = f.concat([
            `  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${u}));`,
            `  diffuseL += ((df${o}) * lightColor${u});`,
            `  if (dot(normalVCVSOutput, lightDirectionVC${u}) < 0.0)`,
            "    {",
            `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${u},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`,
            `    specularL += (sf${o} * lightColor${u});`,
            "    }"
          ]);
          f = f.concat([
            "  diffuseL = diffuseL * diffuseColor;",
            "  specularL = specularL * specularColor;",
            "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);",
            "  //VTK::Light::Impl"
          ]), s = se.substitute(s, "//VTK::Light::Impl", f, false).result;
          break;
        case 3:
          for (let u = 0; u < c; ++u) f = f.concat([
            `uniform vec3 lightColor${u};`,
            `uniform vec3 lightDirectionVC${u}; // normalized`,
            `uniform vec3 lightHalfAngleVC${u}; // normalized`,
            `uniform vec3 lightPositionVC${u};`,
            `uniform vec3 lightAttenuation${u};`,
            `uniform float lightConeAngle${u};`,
            `uniform float lightExponent${u};`,
            `uniform int lightPositional${u};`
          ]);
          s = se.substitute(s, "//VTK::Light::Dec", f).result, f = [
            "vec3 diffuseL = vec3(0,0,0);",
            "  vec3 specularL = vec3(0,0,0);",
            "  vec3 vertLightDirectionVC;",
            "  float attenuation;",
            "  float df;"
          ];
          for (let u = 0; u < c; ++u) f = f.concat([
            "  attenuation = 1.0;",
            `  if (lightPositional${u} == 0)`,
            "    {",
            `      vertLightDirectionVC = lightDirectionVC${u};`,
            "    }",
            "  else",
            "    {",
            `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${u};`,
            "    float distanceVC = length(vertLightDirectionVC);",
            "    vertLightDirectionVC = normalize(vertLightDirectionVC);",
            "    attenuation = 1.0 /",
            `      (lightAttenuation${u}.x`,
            `       + lightAttenuation${u}.y * distanceVC`,
            `       + lightAttenuation${u}.z * distanceVC * distanceVC);`,
            "    // per OpenGL standard cone angle is 90 or less for a spot light",
            `    if (lightConeAngle${u} <= 90.0)`,
            "      {",
            `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${u});`,
            "      // if inside the cone",
            `      if (coneDot >= cos(radians(lightConeAngle${u})))`,
            "        {",
            `        attenuation = attenuation * pow(coneDot, lightExponent${u});`,
            "        }",
            "      else",
            "        {",
            "        attenuation = 0.0;",
            "        }",
            "      }",
            "    }",
            "    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",
            `    diffuseL += ((df${o}) * lightColor${u});`,
            "    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)",
            "      {",
            `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${u},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`,
            `    specularL += ((sf${o}) * lightColor${u});`,
            "    }"
          ]);
          f = f.concat([
            "  diffuseL = diffuseL * diffuseColor;",
            "  specularL = specularL * specularColor;",
            "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);",
            "  //VTK::Light::Impl"
          ]), s = se.substitute(s, "//VTK::Light::Impl", f, false).result;
          break;
        default:
          mc("bad light complexity");
      }
      r.Fragment = s;
    }, t.replaceShaderNormal = (r, i, a) => {
      if (e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0) {
        let o = r.Vertex, l = r.Geometry, c = r.Fragment;
        e.lastBoundBO.getCABO().getNormalOffset() ? (o = se.substitute(o, "//VTK::Normal::Dec", [
          "attribute vec3 normalMC;",
          "uniform mat3 normalMatrix;",
          "varying vec3 normalVCVSOutput;"
        ]).result, o = se.substitute(o, "//VTK::Normal::Impl", [
          "normalVCVSOutput = normalMatrix * normalMC;"
        ]).result, l = se.substitute(l, "//VTK::Normal::Dec", [
          "in vec3 normalVCVSOutput[];",
          "out vec3 normalVCGSOutput;"
        ]).result, l = se.substitute(l, "//VTK::Normal::Impl", [
          "normalVCGSOutput = normalVCVSOutput[i];"
        ]).result, c = se.substitute(c, "//VTK::Normal::Dec", [
          "varying vec3 normalVCVSOutput;"
        ]).result, c = se.substitute(c, "//VTK::Normal::Impl", [
          "vec3 normalVCVSOutput = normalize(normalVCVSOutput);",
          "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
        ]).result) : e.haveCellNormals ? (c = se.substitute(c, "//VTK::Normal::Dec", [
          "uniform mat3 normalMatrix;",
          "uniform samplerBuffer textureN;"
        ]).result, c = se.substitute(c, "//VTK::Normal::Impl", [
          "vec3 normalVCVSOutput = normalize(normalMatrix *",
          "    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);",
          "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
        ]).result) : e.lastBoundBO.getOpenGLMode(a.getProperty().getRepresentation()) === e.context.LINES ? (c = se.substitute(c, "//VTK::UniformFlow::Impl", [
          "  vec3 fdx = dFdx(vertexVC.xyz);",
          "  vec3 fdy = dFdy(vertexVC.xyz);",
          "  //VTK::UniformFlow::Impl"
        ]).result, c = se.substitute(c, "//VTK::Normal::Impl", [
          "vec3 normalVCVSOutput;",
          "  if (abs(fdx.x) > 0.0)",
          "    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }",
          "  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"
        ]).result) : (c = se.substitute(c, "//VTK::Normal::Dec", [
          "uniform int cameraParallel;"
        ]).result, c = se.substitute(c, "//VTK::UniformFlow::Impl", [
          "  vec3 fdx = dFdx(vertexVC.xyz);",
          "  vec3 fdy = dFdy(vertexVC.xyz);",
          "  //VTK::UniformFlow::Impl"
        ]).result, c = se.substitute(c, "//VTK::Normal::Impl", [
          "  fdx = normalize(fdx);",
          "  fdy = normalize(fdy);",
          "  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));",
          "  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }",
          "  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"
        ]).result), r.Vertex = o, r.Geometry = l, r.Fragment = c;
      }
    }, t.replaceShaderPositionVC = (r, i, a) => {
      e.lastBoundBO.replaceShaderPositionVC(r, i, a);
      let s = r.Vertex, o = r.Geometry, l = r.Fragment;
      e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0 ? (s = se.substitute(s, "//VTK::PositionVC::Dec", [
        "varying vec4 vertexVCVSOutput;"
      ]).result, s = se.substitute(s, "//VTK::PositionVC::Impl", [
        "vertexVCVSOutput = MCVCMatrix * vertexMC;",
        "  gl_Position = MCPCMatrix * vertexMC;"
      ]).result, s = se.substitute(s, "//VTK::Camera::Dec", [
        "uniform mat4 MCPCMatrix;",
        "uniform mat4 MCVCMatrix;"
      ]).result, o = se.substitute(o, "//VTK::PositionVC::Dec", [
        "in vec4 vertexVCVSOutput[];",
        "out vec4 vertexVCGSOutput;"
      ]).result, o = se.substitute(o, "//VTK::PositionVC::Impl", [
        "vertexVCGSOutput = vertexVCVSOutput[i];"
      ]).result, l = se.substitute(l, "//VTK::PositionVC::Dec", [
        "varying vec4 vertexVCVSOutput;"
      ]).result, l = se.substitute(l, "//VTK::PositionVC::Impl", [
        "vec4 vertexVC = vertexVCVSOutput;"
      ]).result) : (s = se.substitute(s, "//VTK::Camera::Dec", [
        "uniform mat4 MCPCMatrix;"
      ]).result, s = se.substitute(s, "//VTK::PositionVC::Impl", [
        "  gl_Position = MCPCMatrix * vertexMC;"
      ]).result), r.Vertex = s, r.Geometry = o, r.Fragment = l;
    }, t.replaceShaderTCoord = (r, i, a) => {
      if (e.lastBoundBO.getCABO().getTCoordOffset()) {
        let s = r.Vertex, o = r.Geometry, l = r.Fragment;
        if (e.drawingEdges) return;
        s = se.substitute(s, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
        const c = e.openGLActor.getActiveTextures();
        let f = 2, u = 2;
        if (c && c.length > 0 && (f = c[0].getComponents(), c[0].getTarget() === e.context.TEXTURE_CUBE_MAP && (u = 3)), e.renderable.getColorTextureMap() && (f = e.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(), u = 2), u === 2) {
          if (s = se.substitute(s, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result, o = se.substitute(o, "//VTK::TCoord::Dec", [
            "in vec2 tcoordVCVSOutput[];",
            "out vec2 tcoordVCGSOutput;"
          ]).result, o = se.substitute(o, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result, l = se.substitute(l, "//VTK::TCoord::Dec", [
            "varying vec2 tcoordVCVSOutput;",
            "uniform sampler2D texture1;"
          ]).result, c && c.length >= 1) switch (f) {
            case 1:
              l = se.substitute(l, "//VTK::TCoord::Impl", [
                "  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
                "  ambientColor = ambientColor*tcolor.r;",
                "  diffuseColor = diffuseColor*tcolor.r;"
              ]).result;
              break;
            case 2:
              l = se.substitute(l, "//VTK::TCoord::Impl", [
                "  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
                "  ambientColor = ambientColor*tcolor.r;",
                "  diffuseColor = diffuseColor*tcolor.r;",
                "  opacity = opacity * tcolor.g;"
              ]).result;
              break;
            default:
              l = se.substitute(l, "//VTK::TCoord::Impl", [
                "  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
                "  ambientColor = ambientColor*tcolor.rgb;",
                "  diffuseColor = diffuseColor*tcolor.rgb;",
                "  opacity = opacity * tcolor.a;"
              ]).result;
          }
        } else switch (s = se.substitute(s, "//VTK::TCoord::Dec", "attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result, o = se.substitute(o, "//VTK::TCoord::Dec", [
          "in vec3 tcoordVCVSOutput[];",
          "out vec3 tcoordVCGSOutput;"
        ]).result, o = se.substitute(o, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result, l = se.substitute(l, "//VTK::TCoord::Dec", [
          "varying vec3 tcoordVCVSOutput;",
          "uniform samplerCube texture1;"
        ]).result, f) {
          case 1:
            l = se.substitute(l, "//VTK::TCoord::Impl", [
              "  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);",
              "  ambientColor = ambientColor*tcolor.r;",
              "  diffuseColor = diffuseColor*tcolor.r;"
            ]).result;
            break;
          case 2:
            l = se.substitute(l, "//VTK::TCoord::Impl", [
              "  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);",
              "  ambientColor = ambientColor*tcolor.r;",
              "  diffuseColor = diffuseColor*tcolor.r;",
              "  opacity = opacity * tcolor.g;"
            ]).result;
            break;
          default:
            l = se.substitute(l, "//VTK::TCoord::Impl", [
              "  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);",
              "  ambientColor = ambientColor*tcolor.rgb;",
              "  diffuseColor = diffuseColor*tcolor.rgb;",
              "  opacity = opacity * tcolor.a;"
            ]).result;
        }
        r.Vertex = s, r.Geometry = o, r.Fragment = l;
      }
    }, t.replaceShaderClip = (r, i, a) => {
      let s = r.Vertex, o = r.Fragment;
      if (e.renderable.getNumberOfClippingPlanes()) {
        const l = e.renderable.getNumberOfClippingPlanes();
        s = se.substitute(s, "//VTK::Clip::Dec", [
          "uniform int numClipPlanes;",
          `uniform vec4 clipPlanes[${l}];`,
          `varying float clipDistancesVSOutput[${l}];`
        ]).result, s = se.substitute(s, "//VTK::Clip::Impl", [
          `for (int planeNum = 0; planeNum < ${l}; planeNum++)`,
          "    {",
          "    if (planeNum >= numClipPlanes)",
          "        {",
          "        break;",
          "        }",
          "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);",
          "    }"
        ]).result, o = se.substitute(o, "//VTK::Clip::Dec", [
          "uniform int numClipPlanes;",
          `varying float clipDistancesVSOutput[${l}];`
        ]).result, o = se.substitute(o, "//VTK::Clip::Impl", [
          `for (int planeNum = 0; planeNum < ${l}; planeNum++)`,
          "    {",
          "    if (planeNum >= numClipPlanes)",
          "        {",
          "        break;",
          "        }",
          "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;",
          "    }"
        ]).result;
      }
      r.Vertex = s, r.Fragment = o;
    }, t.getCoincidentParameters = (r, i) => {
      let a = {
        factor: 0,
        offset: 0
      };
      const s = i.getProperty();
      if (e.renderable.getResolveCoincidentTopology() || s.getEdgeVisibility() && s.getRepresentation() === X0.SURFACE) {
        const l = e.lastBoundBO.getPrimitiveType();
        l === kr.Points || s.getRepresentation() === X0.POINTS ? a = e.renderable.getCoincidentTopologyPointOffsetParameter() : l === kr.Lines || s.getRepresentation() === X0.WIREFRAME ? a = e.renderable.getCoincidentTopologyLineOffsetParameters() : (l === kr.Tris || l === kr.TriStrips) && (a = e.renderable.getCoincidentTopologyPolygonOffsetParameters()), (l === kr.TrisEdges || l === kr.TriStripsEdges) && (a = e.renderable.getCoincidentTopologyPolygonOffsetParameters(), a.factor /= 2, a.offset /= 2);
      }
      const o = e._openGLRenderer.getSelector();
      return o && o.getFieldAssociation() === k4.FIELD_ASSOCIATION_POINTS && (a.offset -= 2), a;
    }, t.replaceShaderPicking = (r, i, a) => {
      let s = r.Fragment, o = r.Vertex;
      if (s = se.substitute(s, "//VTK::Picking::Dec", [
        "uniform int picking;",
        "//VTK::Picking::Dec"
      ]).result, !!e._openGLRenderer.getSelector()) {
        switch ((e.lastSelectionState === Pi.ID_LOW24 || e.lastSelectionState === Pi.ID_HIGH24) && (o = se.substitute(o, "//VTK::Picking::Dec", [
          `flat out int vertexIDVSOutput;
`,
          `uniform int VertexIDOffset;
`
        ]).result, o = se.substitute(o, "//VTK::Picking::Impl", `  vertexIDVSOutput = gl_VertexID + VertexIDOffset;
`).result, s = se.substitute(s, "//VTK::Picking::Dec", `flat in int vertexIDVSOutput;
`).result, s = se.substitute(s, "//VTK::Picking::Impl", [
          "  int idx = vertexIDVSOutput;",
          "//VTK::Picking::Impl"
        ]).result), e.lastSelectionState) {
          case Pi.ID_LOW24:
            s = se.substitute(s, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;
            break;
          case Pi.ID_HIGH24:
            s = se.substitute(s, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);").result;
            break;
          default:
            s = se.substitute(s, "//VTK::Picking::Dec", "uniform vec3 mapperIndex;").result, s = se.substitute(s, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
        }
        r.Fragment = s, r.Vertex = o;
      }
    }, t.replaceShaderValues = (r, i, a) => {
      if (t.replaceShaderColor(r, i, a), t.replaceShaderNormal(r, i, a), t.replaceShaderLight(r, i, a), t.replaceShaderTCoord(r, i, a), t.replaceShaderPicking(r, i, a), t.replaceShaderClip(r, i, a), t.replaceShaderCoincidentOffset(r, i, a), t.replaceShaderPositionVC(r, i, a), e.haveSeenDepthRequest) {
        let s = r.Fragment;
        s = se.substitute(s, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, s = se.substitute(s, "//VTK::ZBuffer::Impl", [
          "if (depthRequest == 1) {",
          "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
          "float rf = floor(iz/256.0)/255.0;",
          "float gf = mod(iz,256.0)/255.0;",
          "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
        ]).result, r.Fragment = s;
      }
    }, t.getNeedToRebuildShaders = (r, i, a) => {
      let s = 0, o = 0;
      const l = r.getPrimitiveType(), c = e.currentInput;
      let f = false;
      const u = c.getPointData().getNormals(), h = c.getCellData().getNormals(), g = a.getProperty().getInterpolation() === NT.FLAT, v = a.getProperty().getRepresentation(), m = r.getOpenGLMode(v, l);
      if ((m === e.context.TRIANGLES || h && !u || !g && u || !g && m === e.context.LINES) && (f = true), a.getProperty().getLighting() && f) {
        s = 0;
        const T = i.getLightsByReference();
        for (let S = 0; S < T.length; ++S) {
          const E = T[S];
          E.getSwitch() > 0 && (o++, s === 0 && (s = 1)), s === 1 && (o > 1 || E.getIntensity() !== 1 || !E.lightTypeIsHeadLight()) && (s = 2), s < 3 && E.getPositional() && (s = 3);
        }
      }
      let y = false;
      const w = e.lastBoundBO.getReferenceByName("lastLightComplexity"), C = e.lastBoundBO.getReferenceByName("lastLightCount");
      return (w !== s || C !== o) && (e.lastBoundBO.set({
        lastLightComplexity: s
      }, true), e.lastBoundBO.set({
        lastLightCount: o
      }, true), y = true), (!e.currentRenderPass && e.lastRenderPassShaderReplacement || e.currentRenderPass && e.currentRenderPass.getShaderReplacement() !== e.lastRenderPassShaderReplacement) && (y = true), e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || r.getShaderSourceTime().getMTime() < e.renderable.getMTime() || r.getShaderSourceTime().getMTime() < e.currentInput.getMTime() || r.getShaderSourceTime().getMTime() < e.selectionStateChanged.getMTime() || y ? (e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, true) : false;
    }, t.invokeShaderCallbacks = (r, i, a) => {
      const s = e.renderable.getViewSpecificProperties().ShadersCallbacks;
      s && s.forEach((o) => {
        o.callback(o.userData, r, i, a);
      });
    }, t.setMapperShaderParameters = (r, i, a) => {
      if (r.getProgram().isUniformUsed("PrimitiveIDOffset") && r.getProgram().setUniformi("PrimitiveIDOffset", e.primitiveIDOffset), r.getProgram().isUniformUsed("VertexIDOffset") && r.getProgram().setUniformi("VertexIDOffset", e.vertexIDOffset), r.getCABO().getElementCount() && (e.VBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime())) {
        const l = e.lastBoundBO.getReferenceByName("lastLightComplexity");
        r.getProgram().isAttributeUsed("vertexMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "vertexMC", r.getCABO().getVertexOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, false) || mc("Error setting vertexMC in shader VAO.")), r.getProgram().isAttributeUsed("normalMC") && r.getCABO().getNormalOffset() && l > 0 ? r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "normalMC", r.getCABO().getNormalOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, false) || mc("Error setting normalMC in shader VAO.") : r.getVAO().removeAttributeArray("normalMC"), e.renderable.getCustomShaderAttributes().forEach((c, f) => {
          r.getProgram().isAttributeUsed(`${c}MC`) && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), `${c}MC`, r.getCABO().getCustomData()[f].offset, r.getCABO().getStride(), e.context.FLOAT, r.getCABO().getCustomData()[f].components, false) || mc(`Error setting ${c}MC in shader VAO.`));
        }), r.getProgram().isAttributeUsed("tcoordMC") && r.getCABO().getTCoordOffset() ? r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "tcoordMC", r.getCABO().getTCoordOffset(), r.getCABO().getStride(), e.context.FLOAT, r.getCABO().getTCoordComponents(), false) || mc("Error setting tcoordMC in shader VAO.") : r.getVAO().removeAttributeArray("tcoordMC"), r.getProgram().isAttributeUsed("scalarColor") && r.getCABO().getColorComponents() ? r.getVAO().addAttributeArray(r.getProgram(), r.getCABO().getColorBO(), "scalarColor", r.getCABO().getColorOffset(), r.getCABO().getColorBOStride(), e.context.UNSIGNED_BYTE, 4, true) || mc("Error setting scalarColor in shader VAO.") : r.getVAO().removeAttributeArray("scalarColor"), r.getAttributeUpdateTime().modified();
      }
      if (e.renderable.getNumberOfClippingPlanes()) {
        const l = e.renderable.getNumberOfClippingPlanes(), c = [], u = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null, h = u ? sr(e.tmpMat4, a.getMatrix()) : a.getMatrix();
        u && (en(h, h), tn(h, h, u), en(h, h));
        for (let g = 0; g < l; g++) {
          const v = [];
          e.renderable.getClippingPlaneInDataCoords(h, g, v);
          for (let m = 0; m < 4; m++) c.push(v[m]);
        }
        r.getProgram().setUniformi("numClipPlanes", l), r.getProgram().setUniform4fv("clipPlanes", c);
      }
      e.internalColorTexture && r.getProgram().isUniformUsed("texture1") && r.getProgram().setUniformi("texture1", e.internalColorTexture.getTextureUnit());
      const s = e.openGLActor.getActiveTextures();
      if (s) for (let l = 0; l < s.length; ++l) {
        const f = s[l].getTextureUnit(), u = `texture${f + 1}`;
        r.getProgram().isUniformUsed(u) && r.getProgram().setUniformi(u, f);
      }
      if (e.haveSeenDepthRequest && r.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), r.getProgram().isUniformUsed("coffset")) {
        const l = t.getCoincidentParameters(i, a);
        r.getProgram().setUniformf("coffset", l.offset), r.getProgram().isUniformUsed("cfactor") && r.getProgram().setUniformf("cfactor", l.factor);
      }
      r.setMapperShaderParameters(i, a, e._openGLRenderer.getTiledSizeAndOrigin());
      const o = e._openGLRenderer.getSelector();
      r.getProgram().setUniform3fArray("mapperIndex", o ? o.getPropColorValue() : [
        0,
        0,
        0
      ]), r.getProgram().setUniformi("picking", o ? o.getCurrentPass() + 1 : 0);
    }, t.setLightingShaderParameters = (r, i, a) => {
      const s = e.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (s < 2) return;
      const o = r.getProgram();
      let l = 0;
      const c = i.getLightsByReference();
      for (let h = 0; h < c.length; ++h) {
        const g = c[h];
        if (g.getSwitch() > 0) {
          const m = g.getColorByReference(), y = g.getIntensity();
          e.lightColor[0] = m[0] * y, e.lightColor[1] = m[1] * y, e.lightColor[2] = m[2] * y;
          const w = g.getDirection(), C = i.getActiveCamera().getViewMatrix(), T = [
            ...w
          ];
          g.lightTypeIsSceneLight() && (T[0] = C[0] * w[0] + C[1] * w[1] + C[2] * w[2], T[1] = C[4] * w[0] + C[5] * w[1] + C[6] * w[2], T[2] = C[8] * w[0] + C[9] * w[1] + C[10] * w[2], Hc(T)), e.lightDirection[0] = T[0], e.lightDirection[1] = T[1], e.lightDirection[2] = T[2], Hc(e.lightDirection), o.setUniform3fArray(`lightColor${l}`, e.lightColor), o.setUniform3fArray(`lightDirectionVC${l}`, e.lightDirection), l++;
        }
      }
      if (s < 3) return;
      const u = i.getActiveCamera().getViewMatrix();
      en(u, u), l = 0;
      for (let h = 0; h < c.length; ++h) {
        const g = c[h];
        if (g.getSwitch() > 0) {
          const m = g.getTransformedPosition(), y = new Float64Array(3);
          $t(y, m, u), o.setUniform3fArray(`lightAttenuation${l}`, g.getAttenuationValuesByReference()), o.setUniformi(`lightPositional${l}`, g.getPositional()), o.setUniformf(`lightExponent${l}`, g.getExponent()), o.setUniformf(`lightConeAngle${l}`, g.getConeAngle()), o.setUniform3fArray(`lightPositionVC${l}`, [
            y[0],
            y[1],
            y[2]
          ]), l++;
        }
      }
    };
    function n(r, i, a) {
      return i.identity(a), r.reduce((s, o, l) => l === 0 ? o ? i.copy(s, o) : i.identity(s) : o ? i.multiply(s, s, o) : s, a);
    }
    t.setCameraShaderParameters = (r, i, a) => {
      const s = r.getProgram(), o = e.openGLCamera.getKeyMatrices(i), l = i.getActiveCamera(), c = e.openGLCamera.getKeyMatrixTime().getMTime(), f = s.getLastCameraMTime(), h = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null, g = a.getIsIdentity(), v = g ? {
        mcwc: null,
        normalMatrix: null
      } : e.openGLActor.getKeyMatrices();
      if (a.getCoordinateSystem() === SQ.DISPLAY) {
        const m = e._openGLRenderer.getTiledSizeAndOrigin();
        gt(e.tmpMat4), e.tmpMat4[0] = 2 / m.usize, e.tmpMat4[12] = -1, e.tmpMat4[5] = 2 / m.vsize, e.tmpMat4[13] = -1, tn(e.tmpMat4, e.tmpMat4, h), s.setUniformMatrix("MCPCMatrix", e.tmpMat4);
      } else s.setUniformMatrix("MCPCMatrix", n([
        o.wcpc,
        v.mcwc,
        h
      ], Th, e.tmpMat4));
      s.isUniformUsed("MCVCMatrix") && s.setUniformMatrix("MCVCMatrix", n([
        o.wcvc,
        v.mcwc,
        h
      ], Th, e.tmpMat4)), s.isUniformUsed("normalMatrix") && s.setUniformMatrix3x3("normalMatrix", n([
        o.normalMatrix,
        v.normalMatrix
      ], aY, e.tmpMat3)), f !== c && (s.isUniformUsed("cameraParallel") && s.setUniformi("cameraParallel", l.getParallelProjection()), s.setLastCameraMTime(c)), g || s.setLastCameraMTime(0);
    }, t.setPropertyShaderParameters = (r, i, a) => {
      const s = r.getProgram();
      let o = a.getProperty(), l = o.getOpacity(), c = e.drawingEdges ? o.getEdgeColorByReference() : o.getAmbientColorByReference(), f = e.drawingEdges ? o.getEdgeColorByReference() : o.getDiffuseColorByReference(), u = e.drawingEdges ? 1 : o.getAmbient(), h = e.drawingEdges ? 0 : o.getDiffuse(), g = e.drawingEdges ? 0 : o.getSpecular();
      const v = o.getSpecularPower();
      s.setUniformf("opacityUniform", l), s.setUniform3fArray("ambientColorUniform", c), s.setUniform3fArray("diffuseColorUniform", f), s.setUniformf("ambient", u), s.setUniformf("diffuse", h);
      const m = e.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (m < 1) return;
      let y = o.getSpecularColorByReference();
      if (s.setUniform3fArray("specularColorUniform", y), s.setUniformf("specularPowerUniform", v), s.setUniformf("specular", g), s.isUniformUsed("ambientIntensityBF")) {
        if (o = a.getBackfaceProperty(), l = o.getOpacity(), c = o.getAmbientColor(), u = o.getAmbient(), f = o.getDiffuseColor(), h = o.getDiffuse(), y = o.getSpecularColor(), g = o.getSpecular(), s.setUniformf("ambientIntensityBF", u), s.setUniformf("diffuseIntensityBF", h), s.setUniformf("opacityUniformBF", l), s.setUniform3fArray("ambientColorUniformBF", c), s.setUniform3fArray("diffuseColorUniformBF", f), m < 1) return;
        s.setUniformf("specularIntensityBF", g), s.setUniform3fArray("specularColorUniformBF", y), s.setUniformf("specularPowerUniformBF", v);
      }
    }, t.updateMaximumPointCellIds = (r, i) => {
      var _a3, _b3, _c3, _d;
      const a = e._openGLRenderer.getSelector();
      if (!a) return;
      if ((_b3 = (_a3 = e.selectionWebGLIdsToVTKIds) == null ? void 0 : _a3.points) == null ? void 0 : _b3.length) {
        const o = e.selectionWebGLIdsToVTKIds.points.length;
        a.setMaximumPointId(o - 1);
      }
      if ((_d = (_c3 = e.selectionWebGLIdsToVTKIds) == null ? void 0 : _c3.cells) == null ? void 0 : _d.length) {
        const o = e.selectionWebGLIdsToVTKIds.cells.length;
        a.setMaximumCellId(o - 1);
      }
      a.getFieldAssociation() === k4.FIELD_ASSOCIATION_POINTS && (e.pointPicking = true);
    }, t.renderPieceStart = (r, i) => {
      e.primitiveIDOffset = 0, e.vertexIDOffset = 0;
      const a = AQ(e._openGLRenderer);
      e.lastSelectionState !== a && (e.selectionStateChanged.modified(), e.lastSelectionState = a), e._openGLRenderer.getSelector() && e._openGLRenderer.getSelector().renderProp(i), t.updateBufferObjects(r, i), e.renderable.getColorTextureMap() && e.internalColorTexture.activate(), e.lastBoundBO = null;
    }, t.renderPieceDraw = (r, i) => {
      const a = i.getProperty().getRepresentation(), s = i.getProperty().getEdgeVisibility() && a === X0.SURFACE, o = e._openGLRenderer.getSelector(), l = o && o.getFieldAssociation() === k4.FIELD_ASSOCIATION_POINTS && (e.lastSelectionState === Pi.ID_LOW24 || e.lastSelectionState === Pi.ID_HIGH24);
      for (let c = kr.Start; c < kr.End; c++) e.primitives[c].setPointPicking(l), e.primitives[c].getCABO().getElementCount() && (e.drawingEdges = s && (c === kr.TrisEdges || c === kr.TriStripsEdges), (!e.drawingEdges || !(e.renderDepth || e.lastSelectionState >= 0)) && (e.lastBoundBO = e.primitives[c], e.primitiveIDOffset += e.primitives[c].drawArrays(r, i, a, t), e.vertexIDOffset += e.primitives[c].getCABO().getElementCount()));
    }, t.renderPieceFinish = (r, i) => {
      e.LastBoundBO && e.LastBoundBO.getVAO().release(), e.renderable.getColorTextureMap() && e.internalColorTexture.deactivate();
    }, t.renderPiece = (r, i) => {
      if (t.invokeEvent(CQ), e.renderable.getStatic() || e.renderable.update(), e.currentInput = e.renderable.getInputData(), t.invokeEvent(TQ), !e.currentInput) {
        mc("No input!");
        return;
      }
      if (!e.currentInput.getPoints || !e.currentInput.getPoints().getNumberOfValues()) return;
      const a = e.context, s = i.getProperty().getBackfaceCulling(), o = i.getProperty().getFrontfaceCulling();
      !s && !o ? e._openGLRenderWindow.disableCullFace() : o ? (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.FRONT)) : (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.BACK)), t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i);
    }, t.computeBounds = (r, i) => {
      if (!t.getInput()) {
        Zu(e.bounds);
        return;
      }
      e.bounds = t.getInput().getBounds();
    }, t.updateBufferObjects = (r, i) => {
      t.getNeedToRebuildBufferObjects(r, i) && t.buildBufferObjects(r, i);
    }, t.getNeedToRebuildBufferObjects = (r, i) => {
      const a = e.VBOBuildTime.getMTime();
      return a < t.getMTime() || a < e.renderable.getMTime() || a < i.getMTime() || a < e.currentInput.getMTime();
    }, t.buildBufferObjects = (r, i) => {
      const a = e.currentInput;
      if (a === null) return;
      e.renderable.mapScalars(a, 1);
      const s = e.renderable.getColorMapColors();
      e.haveCellScalars = false;
      const o = e.renderable.getScalarMode();
      e.renderable.getScalarVisibility() && (o === N2.USE_CELL_DATA || o === N2.USE_CELL_FIELD_DATA || o === N2.USE_FIELD_DATA || !a.getPointData().getScalars()) && o !== N2.USE_POINT_FIELD_DATA && s && (e.haveCellScalars = true);
      let l = i.getProperty().getInterpolation() !== NT.FLAT ? a.getPointData().getNormals() : null;
      l === null && a.getCellData().getNormals() && (e.haveCellNormals = true, l = a.getCellData().getNormals());
      const c = i.getProperty().getRepresentation();
      let f = a.getPointData().getTCoords();
      if (e.openGLActor.getActiveTextures() || (f = null), e.renderable.getColorCoordinates()) {
        f = e.renderable.getColorCoordinates(), e.internalColorTexture || (e.internalColorTexture = er.newInstance({
          resizable: true
        }));
        const h = e.internalColorTexture;
        h.setMinificationFilter(LT.NEAREST), h.setMagnificationFilter(LT.NEAREST), h.setWrapS(UT.CLAMP_TO_EDGE), h.setWrapT(UT.CLAMP_TO_EDGE), h.setOpenGLRenderWindow(e._openGLRenderWindow);
        const g = e.renderable.getColorTextureMap(), v = g.getExtent(), m = g.getPointData().getScalars();
        h.create2DFromRaw(v[1] - v[0] + 1, v[3] - v[2] + 1, m.getNumberOfComponents(), m.getDataType(), m.getData()), h.activate(), h.sendParameters(), h.deactivate();
      }
      const u = `${a.getMTime()}A${c}B${a.getMTime()}C${l ? l.getMTime() : 1}D${s ? s.getMTime() : 1}E${i.getProperty().getEdgeVisibility()}F${f ? f.getMTime() : 1}`;
      if (e.VBOBuildString !== u) {
        const g = {
          points: a.getPoints(),
          normals: l,
          tcoords: f,
          colors: s,
          cellOffset: 0,
          vertexOffset: 0,
          haveCellScalars: e.haveCellScalars,
          haveCellNormals: e.haveCellNormals,
          customAttributes: e.renderable.getCustomShaderAttributes().map((y) => a.getPointData().getArrayByName(y))
        };
        e.renderable.getPopulateSelectionSettings() && (e.selectionWebGLIdsToVTKIds = {
          points: null,
          cells: null
        });
        const v = [
          {
            inRep: "verts",
            cells: a.getVerts()
          },
          {
            inRep: "lines",
            cells: a.getLines()
          },
          {
            inRep: "polys",
            cells: a.getPolys()
          },
          {
            inRep: "strips",
            cells: a.getStrips()
          },
          {
            inRep: "polys",
            cells: a.getPolys()
          },
          {
            inRep: "strips",
            cells: a.getStrips()
          }
        ], m = i.getProperty().getEdgeVisibility() && c === X0.SURFACE;
        for (let y = kr.Start; y < kr.End; y++) y !== kr.TrisEdges && y !== kr.TriStripsEdges ? (g.cellOffset += e.primitives[y].getCABO().createVBO(v[y].cells, v[y].inRep, c, g, e.selectionWebGLIdsToVTKIds), g.vertexOffset += e.primitives[y].getCABO().getElementCount()) : m ? e.primitives[y].getCABO().createVBO(v[y].cells, v[y].inRep, X0.WIREFRAME, {
          ...g,
          tcoords: null,
          colors: null,
          haveCellScalars: false,
          haveCellNormals: false
        }) : e.primitives[y].releaseGraphicsResources();
        e.renderable.getPopulateSelectionSettings() && (e.renderable.setSelectionWebGLIdsToVTKIds(e.selectionWebGLIdsToVTKIds), t.updateMaximumPointCellIds()), e.VBOBuildTime.modified(), e.VBOBuildString = u;
      }
    }, t.getAllocatedGPUMemoryInBytes = () => {
      let r = 0;
      return e.primitives.forEach((i) => {
        r += i.getAllocatedGPUMemoryInBytes();
      }), r;
    };
  }
  const bQ = {
    context: null,
    VBOBuildTime: 0,
    VBOBuildString: null,
    primitives: null,
    primTypes: null,
    shaderRebuildString: null,
    tmpMat4: null,
    ambientColor: [],
    diffuseColor: [],
    specularColor: [],
    lightColor: [],
    lightDirection: [],
    lastHaveSeenDepthRequest: false,
    haveSeenDepthRequest: false,
    lastSelectionState: Pi.MIN_KNOWN_PASS - 1,
    selectionStateChanged: null,
    selectionWebGLIdsToVTKIds: null,
    pointPicking: false
  };
  function NR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, bQ, n), Rn.extend(t, e, n), Ls.implementReplaceShaderCoincidentOffset(t, e, n), Ls.implementBuildShadersWithReplacements(t, e, n), e.primitives = [], e.primTypes = kr, e.tmpMat3 = Fa(new Float64Array(9)), e.tmpMat4 = gt(new Float64Array(16));
    for (let r = kr.Start; r < kr.End; r++) e.primitives[r] = Bs.newInstance(), e.primitives[r].setPrimitiveType(r), e.primitives[r].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
    pr(t, e, [
      "context"
    ]), e.VBOBuildTime = {}, _n(e.VBOBuildTime, {
      mtime: 0
    }), e.selectionStateChanged = {}, _n(e.selectionStateChanged, {
      mtime: 0
    }), EQ(t, e);
  }
  const LR = pn(NR, "vtkOpenGLPolyDataMapper");
  var E5 = {
    newInstance: LR,
    extend: NR
  };
  Er("vtkMapper", LR);
  const { vtkErrorMacro: y1 } = di, { Representation: DQ } = ef, { ObjectType: L2 } = go, { PassTypes: MQ } = J8, RQ = {
    type: "StartEvent"
  }, OQ = {
    type: "EndEvent"
  };
  function IQ(t, e) {
    e.classHierarchy.push("vtkOpenGLGlyph3DMapper");
    const n = {
      ...t
    };
    t.renderPiece = (r, i) => {
      if (t.invokeEvent(RQ), e.renderable.getStatic() || e.renderable.update(), e.currentInput = e.renderable.getInputData(1), t.invokeEvent(OQ), !e.currentInput) {
        y1("No input!");
        return;
      }
      if (!e.currentInput.getPoints || !e.currentInput.getPoints().getNumberOfValues()) return;
      const a = e.context;
      e._openGLRenderWindow.getWebgl2() ? (e.hardwareSupport = true, e.extension = null) : e.extension || (e.extension = e.context.getExtension("ANGLE_instanced_arrays"), e.hardwareSupport = !!e.extension);
      const s = i.getProperty().getBackfaceCulling(), o = i.getProperty().getFrontfaceCulling();
      !s && !o ? e._openGLRenderWindow.disableCullFace() : o ? (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.FRONT)) : (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.BACK)), t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i);
    }, t.multiply4x4WithOffset = (r, i, a, s) => {
      const o = i[0], l = i[1], c = i[2], f = i[3], u = i[4], h = i[5], g = i[6], v = i[7], m = i[8], y = i[9], w = i[10], C = i[11], T = i[12], S = i[13], E = i[14], b = i[15];
      let D = a[s], R = a[s + 1], I = a[s + 2], O = a[s + 3];
      r[0] = D * o + R * u + I * m + O * T, r[1] = D * l + R * h + I * y + O * S, r[2] = D * c + R * g + I * w + O * E, r[3] = D * f + R * v + I * C + O * b, D = a[s + 4], R = a[s + 5], I = a[s + 6], O = a[s + 7], r[4] = D * o + R * u + I * m + O * T, r[5] = D * l + R * h + I * y + O * S, r[6] = D * c + R * g + I * w + O * E, r[7] = D * f + R * v + I * C + O * b, D = a[s + 8], R = a[s + 9], I = a[s + 10], O = a[s + 11], r[8] = D * o + R * u + I * m + O * T, r[9] = D * l + R * h + I * y + O * S, r[10] = D * c + R * g + I * w + O * E, r[11] = D * f + R * v + I * C + O * b, D = a[s + 12], R = a[s + 13], I = a[s + 14], O = a[s + 15], r[12] = D * o + R * u + I * m + O * T, r[13] = D * l + R * h + I * y + O * S, r[14] = D * c + R * g + I * w + O * E, r[15] = D * f + R * v + I * C + O * b;
    }, t.replaceShaderNormal = (r, i, a) => {
      if (e.hardwareSupport && e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0) {
        let o = r.Vertex;
        e.lastBoundBO.getCABO().getNormalOffset() && (o = se.substitute(o, "//VTK::Normal::Dec", [
          "attribute vec3 normalMC;",
          "attribute mat3 gNormal;",
          "uniform mat3 normalMatrix;",
          "varying vec3 normalVCVSOutput;"
        ]).result, o = se.substitute(o, "//VTK::Normal::Impl", [
          "normalVCVSOutput = normalMatrix * gNormal * normalMC;"
        ]).result), r.Vertex = o;
      }
      n.replaceShaderNormal(r, i, a);
    }, t.replaceShaderColor = (r, i, a) => {
      if (e.hardwareSupport && e.renderable.getColorArray()) {
        let s = r.Vertex, o = r.Geometry, l = r.Fragment;
        const c = e.lastBoundBO.getReferenceByName("lastLightComplexity");
        let f = [
          "uniform float ambient;",
          "uniform float diffuse;",
          "uniform float specular;",
          "uniform float opacityUniform; // the fragment opacity"
        ];
        c && (f = f.concat([
          "uniform vec3 specularColorUniform;",
          "uniform float specularPowerUniform;"
        ]));
        let u = [
          "vec3 ambientColor;",
          "  vec3 diffuseColor;",
          "  float opacity;"
        ];
        c && (u = u.concat([
          "  vec3 specularColor;",
          "  float specularPower;"
        ])), u = u.concat([
          "  opacity = opacityUniform;"
        ]), c && (u = u.concat([
          "  specularColor = specularColorUniform;",
          "  specularPower = specularPowerUniform;"
        ])), e.drawingEdges || (f = f.concat([
          "varying vec4 vertexColorVSOutput;"
        ]), s = se.substitute(s, "//VTK::Color::Dec", [
          "attribute vec4 gColor;",
          "varying vec4 vertexColorVSOutput;"
        ]).result, s = se.substitute(s, "//VTK::Color::Impl", [
          "vertexColorVSOutput = gColor;"
        ]).result, o = se.substitute(o, "//VTK::Color::Dec", [
          "in vec4 vertexColorVSOutput[];",
          "out vec4 vertexColorGSOutput;"
        ]).result, o = se.substitute(o, "//VTK::Color::Impl", [
          "vertexColorGSOutput = vertexColorVSOutput[i];"
        ]).result, u = u.concat([
          "  diffuseColor = vertexColorVSOutput.rgb;",
          "  ambientColor = vertexColorVSOutput.rgb;",
          "  opacity = opacity*vertexColorVSOutput.a;"
        ])), l = se.substitute(l, "//VTK::Color::Impl", u).result, l = se.substitute(l, "//VTK::Color::Dec", f).result, r.Vertex = s, r.Geometry = o, r.Fragment = l;
      }
      n.replaceShaderColor(r, i, a);
    }, t.replaceShaderPositionVC = (r, i, a) => {
      if (e.hardwareSupport) {
        let s = r.Vertex;
        e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0 ? (s = se.substitute(s, "//VTK::PositionVC::Impl", [
          "vec4 gVertexMC = gMatrix * vertexMC;",
          "vertexVCVSOutput = MCVCMatrix * gVertexMC;",
          "  gl_Position = MCPCMatrix * gVertexMC;"
        ]).result, s = se.substitute(s, "//VTK::Camera::Dec", [
          "attribute mat4 gMatrix;",
          "uniform mat4 MCPCMatrix;",
          "uniform mat4 MCVCMatrix;"
        ]).result) : (s = se.substitute(s, "//VTK::Camera::Dec", [
          "attribute mat4 gMatrix;",
          "uniform mat4 MCPCMatrix;"
        ]).result, s = se.substitute(s, "//VTK::PositionVC::Impl", [
          "vec4 gVertexMC = gMatrix * vertexMC;",
          "  gl_Position = MCPCMatrix * gVertexMC;"
        ]).result), r.Vertex = s;
      }
      n.replaceShaderPositionVC(r, i, a);
    }, t.replaceShaderPicking = (r, i, a) => {
      if (e.hardwareSupport) {
        let s = r.Fragment, o = r.Vertex;
        o = se.substitute(o, "//VTK::Picking::Dec", [
          "attribute vec3 mapperIndexVS;",
          "varying vec3 mapperIndexVSOutput;"
        ]).result, o = se.substitute(o, "//VTK::Picking::Impl", "  mapperIndexVSOutput = mapperIndexVS;").result, r.Vertex = o, s = se.substitute(s, "//VTK::Picking::Dec", [
          "varying vec3 mapperIndexVSOutput;",
          "uniform vec3 mapperIndex;",
          "uniform int picking;"
        ]).result, s = se.substitute(s, "//VTK::Picking::Impl", [
          "  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);",
          "  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"
        ]).result, r.Fragment = s;
      } else n.replaceShaderPicking(r, i, a);
    }, t.updateGlyphShaderParameters = (r, i, a, s, o, l, c, f) => {
      const u = a.getProgram();
      if (r) {
        const h = e.normalMatrix, g = l, v = c * 9, m = e.tmpMat3, y = h[0], w = h[1], C = h[2], T = h[3], S = h[4], E = h[5], b = h[6], D = h[7], R = h[8], I = g[v], O = g[v + 1], L = g[v + 2], N = g[v + 3], F = g[v + 4], V = g[v + 5], k = g[v + 6], _ = g[v + 7], K = g[v + 8];
        m[0] = I * y + O * T + L * b, m[1] = I * w + O * S + L * D, m[2] = I * C + O * E + L * R, m[3] = N * y + F * T + V * b, m[4] = N * w + F * S + V * D, m[5] = N * C + F * E + V * R, m[6] = k * y + _ * T + K * b, m[7] = k * w + _ * S + K * D, m[8] = k * C + _ * E + K * R, u.setUniformMatrix3x3("normalMatrix", e.tmpMat3);
      }
      if (t.multiply4x4WithOffset(e.tmpMat4, e.mcpcMatrix, o, c * 16), u.setUniformMatrix("MCPCMatrix", e.tmpMat4), i && (t.multiply4x4WithOffset(e.tmpMat4, e.mcvcMatrix, o, c * 16), u.setUniformMatrix("MCVCMatrix", e.tmpMat4)), s) {
        const h = s.getData();
        e.tmpColor[0] = h[c * 4] / 255, e.tmpColor[1] = h[c * 4 + 1] / 255, e.tmpColor[2] = h[c * 4 + 2] / 255, u.setUniform3fArray("ambientColorUniform", e.tmpColor), u.setUniform3fArray("diffuseColorUniform", e.tmpColor);
      }
      f && u.setUniform3fArray("mapperIndex", f.getPropColorValue());
    }, t.renderPieceDraw = (r, i) => {
      const a = i.getProperty().getRepresentation(), s = e.context, o = i.getProperty().getEdgeVisibility() && a === DQ.SURFACE, l = e.openGLCamera.getKeyMatrices(r), c = e.openGLActor.getKeyMatrices();
      Ou(e.normalMatrix, l.normalMatrix, c.normalMatrix), tn(e.mcpcMatrix, l.wcpc, c.mcwc), tn(e.mcvcMatrix, l.wcvc, c.mcwc);
      const f = e.renderable.getMatrixArray(), u = e.renderable.getNormalArray(), h = e.renderable.getColorArray(), g = f.length / 16;
      let v = false;
      e._openGLRenderer.getSelector() && e._openGLRenderer.getSelector().getCurrentPass() === MQ.COMPOSITE_INDEX_PASS && (v = true);
      for (let m = e.primTypes.Start; m < e.primTypes.End; m++) {
        const y = e.primitives[m].getCABO();
        if (y.getElementCount()) {
          e.drawingEdges = o && (m === e.primTypes.TrisEdges || m === e.primTypes.TriStripsEdges), e.lastBoundBO = e.primitives[m], e.primitives[m].updateShaders(r, i, t);
          const w = e.primitives[m].getProgram(), C = e.primitives[m].getOpenGLMode(a), T = w.isUniformUsed("normalMatrix"), S = w.isUniformUsed("MCVCMatrix");
          if (e.hardwareSupport) e.extension ? e.extension.drawArraysInstancedANGLE(C, 0, y.getElementCount(), g) : s.drawArraysInstanced(C, 0, y.getElementCount(), g);
          else for (let E = 0; E < g; ++E) v && e._openGLRenderer.getSelector().renderCompositeIndex(E), t.updateGlyphShaderParameters(T, S, e.primitives[m], h, f, u, E, v ? e._openGLRenderer.getSelector() : null), s.drawArrays(C, 0, y.getElementCount());
        }
      }
    }, t.setMapperShaderParameters = (r, i, a) => {
      if (r.getCABO().getElementCount() && (e.glyphBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime())) {
        r.getProgram().isAttributeUsed("gMatrix") ? r.getVAO().addAttributeMatrixWithDivisor(r.getProgram(), e.matrixBuffer, "gMatrix", 0, 64, e.context.FLOAT, 4, false, 1) || y1("Error setting gMatrix in shader VAO.") : r.getVAO().removeAttributeArray("gMatrix"), r.getProgram().isAttributeUsed("gNormal") ? r.getVAO().addAttributeMatrixWithDivisor(r.getProgram(), e.normalBuffer, "gNormal", 0, 36, e.context.FLOAT, 3, false, 1) || y1("Error setting gNormal in shader VAO.") : r.getVAO().removeAttributeArray("gNormal"), r.getProgram().isAttributeUsed("gColor") ? r.getVAO().addAttributeArrayWithDivisor(r.getProgram(), e.colorBuffer, "gColor", 0, 4, e.context.UNSIGNED_BYTE, 4, true, 1, false) || y1("Error setting gColor in shader VAO.") : r.getVAO().removeAttributeArray("gColor"), r.getProgram().isAttributeUsed("mapperIndexVS") ? r.getVAO().addAttributeArrayWithDivisor(r.getProgram(), e.pickBuffer, "mapperIndexVS", 0, 4, e.context.UNSIGNED_BYTE, 4, true, 1, false) || y1("Error setting mapperIndexVS in shader VAO.") : r.getVAO().removeAttributeArray("mapperIndexVS"), n.setMapperShaderParameters(r, i, a), r.getAttributeUpdateTime().modified();
        return;
      }
      n.setMapperShaderParameters(r, i, a);
    }, t.getNeedToRebuildBufferObjects = (r, i) => (e.renderable.buildArrays(), e.VBOBuildTime.getMTime() < e.renderable.getBuildTime().getMTime() ? true : n.getNeedToRebuildBufferObjects(r, i)), t.getNeedToRebuildShaders = (r, i, a) => !!(n.getNeedToRebuildShaders(r, i, a) || r.getShaderSourceTime().getMTime() < e.renderable.getMTime() || r.getShaderSourceTime().getMTime() < e.currentInput.getMTime()), t.buildBufferObjects = (r, i) => {
      if (e.hardwareSupport) {
        const a = e.renderable.getMatrixArray(), s = e.renderable.getNormalArray(), o = e.renderable.getColorArray();
        if (e.matrixBuffer || (e.matrixBuffer = go.newInstance(), e.matrixBuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.normalBuffer = go.newInstance(), e.normalBuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.colorBuffer = go.newInstance(), e.colorBuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.pickBuffer = go.newInstance(), e.pickBuffer.setOpenGLRenderWindow(e._openGLRenderWindow)), e.renderable.getBuildTime().getMTime() > e.glyphBOBuildTime.getMTime()) {
          e.matrixBuffer.upload(a, L2.ARRAY_BUFFER), e.normalBuffer.upload(s, L2.ARRAY_BUFFER), o ? e.colorBuffer.upload(o.getData(), L2.ARRAY_BUFFER) : e.colorBuffer.releaseGraphicsResources();
          const l = a.length / 16, c = new Uint8Array(4 * l);
          for (let f = 0; f < l; ++f) {
            let u = f + 1;
            const h = f * 4;
            c[h] = u % 256, u -= c[h], u /= 256, c[h + 1] = u % 256, u -= c[h + 1], u /= 256, c[h + 2] = u % 256, c[h + 3] = 255;
          }
          e.pickBuffer.upload(c, L2.ARRAY_BUFFER), e.glyphBOBuildTime.modified();
        }
      }
      return n.buildBufferObjects(r, i);
    };
  }
  const VQ = {
    normalMatrix: null,
    mcpcMatrix: null,
    mcwcMatrix: null
  };
  function NQ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, VQ, n), E5.extend(t, e, n), e.tmpMat3 = Fa(new Float64Array(9)), e.normalMatrix = Fa(new Float64Array(9)), e.mcpcMatrix = gt(new Float64Array(16)), e.mcvcMatrix = gt(new Float64Array(16)), e.tmpColor = [], e.glyphBOBuildTime = {}, _n(e.glyphBOBuildTime, {
      mtime: 0
    }), IQ(t, e);
  }
  const UR = pn(NQ, "vtkOpenGLGlyph3DMapper");
  var LQ = {
    newInstance: UR
  };
  Er("vtkGlyph3DMapper", UR);
  const UQ = {
    NONE: -1,
    I: 0,
    J: 1,
    K: 2,
    X: 3,
    Y: 4,
    Z: 5
  };
  var b5 = {
    SlicingMode: UQ
  };
  const Bc = {
    NEAREST: 0,
    LINEAR: 1
  };
  var FQ = {
    InterpolationType: Bc
  };
  const { vtkErrorMacro: Z0 } = di, { SlicingMode: Xa } = b5;
  function FT(t, e, n) {
    if (e) {
      const r = t.getIndependentComponents();
      return `${e.getMTime()}-${r}-${n}`;
    }
    return "0";
  }
  function BQ(t) {
    const e = t.split(`
`), n = [];
    for (let r = 0; r < e.length; ++r) {
      const i = e[r].trim();
      i.length > 0 && n.push(i);
    }
    return n;
  }
  function _Q(t, e) {
    e.classHierarchy.push("vtkOpenGLImageMapper"), t.buildPass = (n) => {
      if (n) {
        e.currentRenderPass = null, e.openGLImageSlice = t.getFirstAncestorOfType("vtkOpenGLImageSlice"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow);
        const r = e._openGLRenderer.getRenderable();
        e.openGLCamera = e._openGLRenderer.getViewNodeFor(r.getActiveCamera()), e.renderable.isA("vtkImageMapper") && e.renderable.getSliceAtFocalPoint() && e.renderable.setSliceFromCamera(r.getActiveCamera());
      }
    }, t.translucentPass = (n, r) => {
      n && (e.currentRenderPass = r, t.render());
    }, t.zBufferPass = (n) => {
      n && (e.haveSeenDepthRequest = true, e.renderDepth = true, t.render(), e.renderDepth = false);
    }, t.opaqueZBufferPass = (n) => t.zBufferPass(n), t.opaquePass = (n) => {
      n && t.render();
    }, t.getCoincidentParameters = (n, r) => e.renderable.getResolveCoincidentTopology() ? e.renderable.getCoincidentTopologyPolygonOffsetParameters() : null, t.render = () => {
      const n = e.openGLImageSlice.getRenderable(), r = e._openGLRenderer.getRenderable();
      t.renderPiece(r, n);
    }, t.getShaderTemplate = (n, r, i) => {
      n.Vertex = ry, n.Fragment = rd, n.Geometry = "";
    }, t.replaceShaderValues = (n, r, i) => {
      let a = n.Vertex, s = n.Fragment;
      a = se.substitute(a, "//VTK::Camera::Dec", [
        "uniform mat4 MCPCMatrix;"
      ]).result, a = se.substitute(a, "//VTK::PositionVC::Impl", [
        "  gl_Position = MCPCMatrix * vertexMC;"
      ]).result, a = se.substitute(a, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result, a = se.substitute(a, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
      const o = e.openGLTexture.getComponents(), l = i.getProperty().getIndependentComponents();
      let c = [
        "varying vec2 tcoordVCVSOutput;",
        "uniform float cshift0;",
        "uniform float cscale0;",
        "uniform float pwfshift0;",
        "uniform float pwfscale0;",
        "uniform sampler2D texture1;",
        "uniform sampler2D colorTexture1;",
        "uniform sampler2D pwfTexture1;",
        "uniform sampler2D labelOutlineTexture1;",
        "uniform float opacity;",
        "uniform float outlineOpacity;"
      ];
      if (l) {
        for (let u = 1; u < o; u++) c = c.concat([
          `uniform float cshift${u};`,
          `uniform float cscale${u};`,
          `uniform float pwfshift${u};`,
          `uniform float pwfscale${u};`
        ]);
        switch (o) {
          case 1:
            c = c.concat([
              "uniform float mix0;",
              "#define height0 0.5"
            ]);
            break;
          case 2:
            c = c.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "#define height0 0.25",
              "#define height1 0.75"
            ]);
            break;
          case 3:
            c = c.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "uniform float mix2;",
              "#define height0 0.17",
              "#define height1 0.5",
              "#define height2 0.83"
            ]);
            break;
          case 4:
            c = c.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "uniform float mix2;",
              "uniform float mix3;",
              "#define height0 0.125",
              "#define height1 0.375",
              "#define height2 0.625",
              "#define height3 0.875"
            ]);
            break;
          default:
            Z0("Unsupported number of independent coordinates.");
        }
      }
      if (s = se.substitute(s, "//VTK::TCoord::Dec", c).result, i.getProperty().getUseLabelOutline() === true && (s = se.substitute(s, "//VTK::LabelOutline::Dec", [
        "uniform int outlineThickness;",
        "uniform float vpWidth;",
        "uniform float vpHeight;",
        "uniform float vpOffsetX;",
        "uniform float vpOffsetY;",
        "uniform mat4 PCWCMatrix;",
        "uniform mat4 vWCtoIDX;",
        "uniform ivec3 imageDimensions;"
      ]).result, s = se.substitute(s, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result, s = se.substitute(s, "//VTK::LabelOutlineHelperFunction", [
        "#ifdef vtkImageLabelOutlineOn",
        "vec3 fragCoordToIndexSpace(vec4 fragCoord) {",
        "  vec4 pcPos = vec4(",
        "    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,",
        "    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,",
        "    (fragCoord.z - 0.5) * 2.0,",
        "    1.0);",
        "",
        "  vec4 worldCoord = PCWCMatrix * pcPos;",
        "  vec4 vertex = (worldCoord/worldCoord.w);",
        "",
        "  vec3 index = (vWCtoIDX * vertex).xyz;",
        "",
        "  // half voxel fix for labelmapOutline",
        "  return (index + vec3(0.5)) / vec3(imageDimensions);",
        "}",
        "#endif"
      ]).result), l) {
        const u = [
          "r",
          "g",
          "b",
          "a"
        ];
        let h = [
          "vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"
        ];
        for (let g = 0; g < o; g++) h = h.concat([
          `vec3 tcolor${g} = mix${g} * texture2D(colorTexture1, vec2(tvalue.${u[g]} * cscale${g} + cshift${g}, height${g})).rgb;`,
          `float compWeight${g} = mix${g} * texture2D(pwfTexture1, vec2(tvalue.${u[g]} * pwfscale${g} + pwfshift${g}, height${g})).r;`
        ]);
        switch (o) {
          case 1:
            h = h.concat([
              "gl_FragData[0] = vec4(tcolor0.rgb, opacity);"
            ]);
            break;
          case 2:
            h = h.concat([
              "float weightSum = compWeight0 + compWeight1;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"
            ]);
            break;
          case 3:
            h = h.concat([
              "float weightSum = compWeight0 + compWeight1 + compWeight2;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"
            ]);
            break;
          case 4:
            h = h.concat([
              "float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"
            ]);
            break;
          default:
            Z0("Unsupported number of independent coordinates.");
        }
        s = se.substitute(s, "//VTK::TCoord::Impl", h).result;
      } else switch (o) {
        case 1:
          s = se.substitute(s, "//VTK::TCoord::Impl", [
            ...BQ(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); 
                  float centerValue = texture2D(texture1, centerPosIS.xy).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 1.0, 1.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, neighborPosIS.xy).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)
          ]).result;
          break;
        case 2:
          s = se.substitute(s, "//VTK::TCoord::Impl", [
            "vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
            "float intensity = tcolor.r*cscale0 + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"
          ]).result;
          break;
        case 3:
          s = se.substitute(s, "//VTK::TCoord::Impl", [
            "vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"
          ]).result;
          break;
        default:
          s = se.substitute(s, "//VTK::TCoord::Impl", [
            "vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"
          ]).result;
      }
      e.haveSeenDepthRequest && (s = se.substitute(s, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, s = se.substitute(s, "//VTK::ZBuffer::Impl", [
        "if (depthRequest == 1) {",
        "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
        "float rf = floor(iz/256.0)/255.0;",
        "float gf = mod(iz,256.0)/255.0;",
        "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
      ]).result), n.Vertex = a, n.Fragment = s, t.replaceShaderClip(n, r, i), t.replaceShaderCoincidentOffset(n, r, i);
    }, t.replaceShaderClip = (n, r, i) => {
      let a = n.Vertex, s = n.Fragment;
      if (e.renderable.getNumberOfClippingPlanes()) {
        let o = e.renderable.getNumberOfClippingPlanes();
        o > 6 && (Jt("OpenGL has a limit of 6 clipping planes"), o = 6), a = se.substitute(a, "//VTK::Clip::Dec", [
          "uniform int numClipPlanes;",
          "uniform vec4 clipPlanes[6];",
          "varying float clipDistancesVSOutput[6];"
        ]).result, a = se.substitute(a, "//VTK::Clip::Impl", [
          "for (int planeNum = 0; planeNum < 6; planeNum++)",
          "    {",
          "    if (planeNum >= numClipPlanes)",
          "        {",
          "        break;",
          "        }",
          "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);",
          "    }"
        ]).result, s = se.substitute(s, "//VTK::Clip::Dec", [
          "uniform int numClipPlanes;",
          "varying float clipDistancesVSOutput[6];"
        ]).result, s = se.substitute(s, "//VTK::Clip::Impl", [
          "for (int planeNum = 0; planeNum < 6; planeNum++)",
          "    {",
          "    if (planeNum >= numClipPlanes)",
          "        {",
          "        break;",
          "        }",
          "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;",
          "    }"
        ]).result;
      }
      n.Vertex = a, n.Fragment = s;
    }, t.getNeedToRebuildShaders = (n, r, i) => {
      var _a3;
      const a = e.openGLTexture.getComponents(), s = i.getProperty().getIndependentComponents();
      let o = false;
      return (!e.currentRenderPass && e.lastRenderPassShaderReplacement || e.currentRenderPass && e.currentRenderPass.getShaderReplacement() !== e.lastRenderPassShaderReplacement) && (o = true), o || e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || ((_a3 = n.getProgram()) == null ? void 0 : _a3.getHandle()) === 0 || e.lastTextureComponents !== a || e.lastIndependentComponents !== s ? (e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, e.lastTextureComponents = a, e.lastIndependentComponents = s, true) : false;
    }, t.updateShaders = (n, r, i) => {
      if (e.lastBoundBO = n, t.getNeedToRebuildShaders(n, r, i)) {
        const a = {
          Vertex: null,
          Fragment: null,
          Geometry: null
        };
        t.buildShaders(a, r, i);
        const s = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex, a.Fragment, a.Geometry);
        s !== n.getProgram() && (n.setProgram(s), n.getVAO().releaseGraphicsResources()), n.getShaderSourceTime().modified();
      } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());
      n.getVAO().bind(), t.setMapperShaderParameters(n, r, i), t.setCameraShaderParameters(n, r, i), t.setPropertyShaderParameters(n, r, i);
    }, t.setMapperShaderParameters = (n, r, i) => {
      n.getCABO().getElementCount() && (e.VBOBuildTime > n.getAttributeUpdateTime().getMTime() || n.getShaderSourceTime().getMTime() > n.getAttributeUpdateTime().getMTime()) && (n.getProgram().isAttributeUsed("vertexMC") && (n.getVAO().addAttributeArray(n.getProgram(), n.getCABO(), "vertexMC", n.getCABO().getVertexOffset(), n.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || Z0("Error setting vertexMC in shader VAO.")), n.getProgram().isAttributeUsed("tcoordMC") && n.getCABO().getTCoordOffset() && (n.getVAO().addAttributeArray(n.getProgram(), n.getCABO(), "tcoordMC", n.getCABO().getTCoordOffset(), n.getCABO().getStride(), e.context.FLOAT, n.getCABO().getTCoordComponents(), e.context.FALSE) || Z0("Error setting tcoordMC in shader VAO.")), n.getAttributeUpdateTime().modified());
      const a = e.openGLTexture.getTextureUnit();
      n.getProgram().setUniformi("texture1", a);
      const s = e.openGLTexture.getComponents(), o = i.getProperty().getIndependentComponents();
      if (o) for (let g = 0; g < s; g++) n.getProgram().setUniformf(`mix${g}`, i.getProperty().getComponentWeight(g));
      const l = e.openGLTexture.getShiftAndScale();
      for (let g = 0; g < s; g++) {
        let v = i.getProperty().getColorWindow(), m = i.getProperty().getColorLevel();
        const y = o ? g : 0, w = i.getProperty().getRGBTransferFunction(y);
        if (w && i.getProperty().getUseLookupTableScalarRange()) {
          const S = w.getRange();
          v = S[1] - S[0], m = 0.5 * (S[1] + S[0]);
        }
        const C = l.scale / v, T = (l.shift - m) / v + 0.5;
        n.getProgram().setUniformf(`cshift${g}`, T), n.getProgram().setUniformf(`cscale${g}`, C);
      }
      for (let g = 0; g < s; g++) {
        let v = 1, m = 0;
        const y = o ? g : 0, w = i.getProperty().getPiecewiseFunction(y);
        if (w) {
          const C = w.getRange(), T = C[1] - C[0], S = 0.5 * (C[0] + C[1]);
          v = l.scale / T, m = (l.shift - S) / T + 0.5;
        }
        n.getProgram().setUniformf(`pwfshift${g}`, m), n.getProgram().setUniformf(`pwfscale${g}`, v);
      }
      if (e.haveSeenDepthRequest && n.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), n.getProgram().isUniformUsed("coffset")) {
        const g = t.getCoincidentParameters(r, i);
        n.getProgram().setUniformf("coffset", g.offset), n.getProgram().isUniformUsed("cfactor") && n.getProgram().setUniformf("cfactor", g.factor);
      }
      const c = e.colorTexture.getTextureUnit();
      n.getProgram().setUniformi("colorTexture1", c);
      const f = e.pwfTexture.getTextureUnit();
      n.getProgram().setUniformi("pwfTexture1", f);
      const u = e.labelOutlineThicknessTexture.getTextureUnit();
      if (n.getProgram().setUniformi("labelOutlineTexture1", u), e.renderable.getNumberOfClippingPlanes()) {
        let g = e.renderable.getNumberOfClippingPlanes();
        g > 6 && (Jt("OpenGL has a limit of 6 clipping planes"), g = 6);
        const m = n.getCABO().getCoordShiftAndScaleEnabled() ? n.getCABO().getInverseShiftAndScaleMatrix() : null, y = m ? sr(e.imagematinv, i.getMatrix()) : i.getMatrix();
        m && (en(y, y), tn(y, y, m), en(y, y)), en(e.imagemat, e.currentInput.getIndexToWorld()), tn(e.imagematinv, y, e.imagemat);
        const w = [];
        for (let C = 0; C < g; C++) {
          const T = [];
          e.renderable.getClippingPlaneInDataCoords(e.imagematinv, C, T);
          for (let S = 0; S < 4; S++) w.push(T[S]);
        }
        n.getProgram().setUniformi("numClipPlanes", g), n.getProgram().setUniform4fv("clipPlanes", w);
      }
      if (i.getProperty().getUseLabelOutline() === true) {
        const g = i.getProperty().getLabelOutlineOpacity();
        n.getProgram().setUniformf("outlineOpacity", g);
      }
    }, t.setCameraShaderParameters = (n, r, i) => {
      const a = n.getProgram(), s = e.openGLImageSlice.getKeyMatrices(), o = e.currentInput, l = o.getIndexToWorld();
      tn(e.imagemat, s.mcwc, l);
      const c = e.openGLCamera.getKeyMatrices(r);
      if (tn(e.imagemat, c.wcpc, e.imagemat), n.getCABO().getCoordShiftAndScaleEnabled()) {
        const u = n.getCABO().getInverseShiftAndScaleMatrix();
        tn(e.imagemat, e.imagemat, u);
      }
      if (a.setUniformMatrix("MCPCMatrix", e.imagemat), i.getProperty().getUseLabelOutline() === true) {
        const u = o.getWorldToIndex(), h = o.getDimensions();
        a.setUniform3i("imageDimensions", h[0], h[1], 1), a.setUniformMatrix("vWCtoIDX", u);
        const g = e.openGLCamera.getKeyMatrices(r);
        Nr(e.projectionToWorld, g.wcpc), e.openGLCamera.getKeyMatrices(r), a.setUniformMatrix("PCWCMatrix", e.projectionToWorld);
        const v = t.getRenderTargetSize();
        a.setUniformf("vpWidth", v[0]), a.setUniformf("vpHeight", v[1]);
        const m = t.getRenderTargetOffset();
        a.setUniformf("vpOffsetX", m[0] / v[0]), a.setUniformf("vpOffsetY", m[1] / v[1]);
      }
    }, t.setPropertyShaderParameters = (n, r, i) => {
      const a = n.getProgram(), o = i.getProperty().getOpacity();
      a.setUniformf("opacity", o);
    }, t.renderPieceStart = (n, r) => {
      t.updateBufferObjects(n, r), e.lastBoundBO = null;
    }, t.renderPieceDraw = (n, r) => {
      const i = e.context;
      e.openGLTexture.activate(), e.colorTexture.activate(), e.labelOutlineThicknessTexture.activate(), e.pwfTexture.activate(), e.tris.getCABO().getElementCount() && (t.updateShaders(e.tris, n, r), i.drawArrays(i.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release()), e.openGLTexture.deactivate(), e.colorTexture.deactivate(), e.labelOutlineThicknessTexture.deactivate(), e.pwfTexture.deactivate();
    }, t.renderPieceFinish = (n, r) => {
    }, t.renderPiece = (n, r) => {
      if (t.invokeEvent({
        type: "StartEvent"
      }), e.renderable.update(), e.currentInput = e.renderable.getCurrentImage(), t.invokeEvent({
        type: "EndEvent"
      }), !e.currentInput) {
        Z0("No input!");
        return;
      }
      t.renderPieceStart(n, r), t.renderPieceDraw(n, r), t.renderPieceFinish(n, r);
    }, t.computeBounds = (n, r) => {
      if (!t.getInput()) {
        Zu(e.bounds);
        return;
      }
      e.bounds = t.getInput().getBounds();
    }, t.updateBufferObjects = (n, r) => {
      t.getNeedToRebuildBufferObjects(n, r) && t.buildBufferObjects(n, r);
    }, t.getNeedToRebuildBufferObjects = (n, r) => e.VBOBuildTime.getMTime() < t.getMTime() || e.VBOBuildTime.getMTime() < r.getMTime() || e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < r.getProperty().getMTime() || e.VBOBuildTime.getMTime() < e.currentInput.getMTime(), t.buildBufferObjects = (n, r) => {
      var _a3, _b3;
      const i = e.currentInput;
      if (!i) return;
      const a = i.getPointData() && i.getPointData().getScalars();
      if (!a) return;
      const s = a.getDataType(), o = a.getNumberOfComponents(), l = r.getProperty(), c = l.getInterpolationType(), f = l.getIndependentComponents(), u = f ? o : 1, h = f ? 2 * u : 1, g = l.getRGBTransferFunction(), v = FT(l, g, u), m = e._openGLRenderWindow.getGraphicsResourceForObject(g);
      if (!(m == null ? void 0 : m.vtkObj) || (m == null ? void 0 : m.hash) !== v || e.colorTextureString !== v) {
        const N = 1024 * h * 3, F = new Uint8ClampedArray(N);
        if (e.colorTexture || (e.colorTexture = er.newInstance({
          resizable: true
        }), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow)), c === Bc.NEAREST ? (e.colorTexture.setMinificationFilter(dt.NEAREST), e.colorTexture.setMagnificationFilter(dt.NEAREST)) : (e.colorTexture.setMinificationFilter(dt.LINEAR), e.colorTexture.setMagnificationFilter(dt.LINEAR)), g) {
          const V = new Float32Array(3072);
          for (let k = 0; k < u; k++) {
            const _ = l.getRGBTransferFunction(k), K = _.getRange();
            if (_.getTable(K[0], K[1], 1024, V, 1), f) for (let Z = 0; Z < 1024 * 3; Z++) F[k * 1024 * 6 + Z] = 255 * V[Z], F[k * 1024 * 6 + Z + 1024 * 3] = 255 * V[Z];
            else for (let Z = 0; Z < 1024 * 3; Z++) F[k * 1024 * 6 + Z] = 255 * V[Z];
          }
          e.colorTexture.releaseGraphicsResources(e._openGLRenderWindow), e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, h, 3, zt.UNSIGNED_CHAR, F);
        } else {
          for (let V = 0; V < 1024 * 3; ++V) F[V] = 255 * V / (1023 * 3), F[V + 1] = 255 * V / (1023 * 3), F[V + 2] = 255 * V / (1023 * 3);
          e.colorTexture.create2DFromRaw(1024, 1, 3, zt.UNSIGNED_CHAR, F);
        }
        e.colorTextureString = v, g && e._openGLRenderWindow.setGraphicsResourceForObject(g, e.colorTexture, e.colorTextureString);
      } else e.colorTexture = m.vtkObj, e.colorTextureString = m.hash;
      const w = l.getPiecewiseFunction(), C = FT(l, w, u), T = e._openGLRenderWindow.getGraphicsResourceForObject(w);
      if (!(T == null ? void 0 : T.vtkObj) || (T == null ? void 0 : T.hash) !== C || e.pwfTextureString !== C) {
        const N = 1024 * h, F = new Uint8ClampedArray(N);
        if (e.pwfTexture || (e.pwfTexture = er.newInstance({
          resizable: true
        }), e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow)), c === Bc.NEAREST ? (e.pwfTexture.setMinificationFilter(dt.NEAREST), e.pwfTexture.setMagnificationFilter(dt.NEAREST)) : (e.pwfTexture.setMinificationFilter(dt.LINEAR), e.pwfTexture.setMagnificationFilter(dt.LINEAR)), w) {
          const V = new Float32Array(N), k = new Float32Array(1024);
          for (let _ = 0; _ < u; ++_) {
            const K = l.getPiecewiseFunction(_);
            if (K === null) V.fill(1);
            else {
              const Z = K.getRange();
              if (K.getTable(Z[0], Z[1], 1024, k, 1), f) for (let j = 0; j < 1024; j++) V[_ * 1024 * 2 + j] = k[j], V[_ * 1024 * 2 + j + 1024] = k[j];
              else for (let j = 0; j < 1024; j++) V[_ * 1024 * 2 + j] = k[j];
            }
          }
          e.pwfTexture.releaseGraphicsResources(e._openGLRenderWindow), e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, h, 1, zt.FLOAT, V);
        } else F.fill(255), e.pwfTexture.create2DFromRaw(1024, 1, 1, zt.UNSIGNED_CHAR, F);
        e.pwfTextureString = C, w && e._openGLRenderWindow.setGraphicsResourceForObject(w, e.pwfTexture, e.pwfTextureString);
      } else e.pwfTexture = T.vtkObj, e.pwfTextureString = T.hash;
      t.updatelabelOutlineThicknessTexture(r);
      const { ijkMode: E } = e.renderable.getClosestIJKAxis();
      let b = e.renderable.getSlice();
      E !== e.renderable.getSlicingMode() && (b = e.renderable.getSliceAtPosition(b));
      const D = e.renderable.isA("vtkImageArrayMapper") ? e.renderable.getSubSlice() : Math.round(b), R = i.getExtent();
      let I;
      E === Xa.I && (I = D - R[0]), E === Xa.J && (I = D - R[2]), (E === Xa.K || E === Xa.NONE) && (I = D - R[4]);
      const O = `${b}A${i.getMTime()}A${a.getMTime()}B${t.getMTime()}C${e.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;
      if (e.VBOBuildString !== O) {
        const L = i.getDimensions();
        e.openGLTexture || (e.openGLTexture = er.newInstance({
          resizable: true
        }), e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow)), e.openGLTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), c === Bc.NEAREST ? ((/* @__PURE__ */ new Set([
          1,
          3,
          4
        ])).has(o) && s === zt.UNSIGNED_CHAR && !f && e.openGLTexture.setGenerateMipmap(true), e.openGLTexture.setMinificationFilter(dt.NEAREST), e.openGLTexture.setMagnificationFilter(dt.NEAREST)) : (o === 4 && s === zt.UNSIGNED_CHAR && !f ? (e.openGLTexture.setGenerateMipmap(true), e.openGLTexture.setMinificationFilter(dt.LINEAR_MIPMAP_LINEAR)) : e.openGLTexture.setMinificationFilter(dt.LINEAR), e.openGLTexture.setMagnificationFilter(dt.LINEAR)), e.openGLTexture.setWrapS(Ah.CLAMP_TO_EDGE), e.openGLTexture.setWrapT(Ah.CLAMP_TO_EDGE);
        const N = L[0] * L[1] * o, F = new Float32Array(12), V = new Float32Array(8);
        for (let oe = 0; oe < 4; oe++) V[oe * 2] = oe % 2 ? 1 : 0, V[oe * 2 + 1] = oe > 1 ? 1 : 0;
        const k = [
          Xa.X,
          Xa.Y,
          Xa.Z
        ].includes(e.renderable.getSlicingMode()) ? b : D, _ = i.getSpatialExtent(), K = a.getData();
        let Z = null;
        if (E === Xa.I) {
          Z = new K.constructor(L[2] * L[1] * o);
          let oe = 0;
          for (let he = 0; he < L[2]; he++) for (let Le = 0; Le < L[1]; Le++) {
            let Je = (I + Le * L[0] + he * L[0] * L[1]) * o;
            oe = (he * L[1] + Le) * o;
            const Pe = Je + o;
            for (; Je < Pe; ) Z[oe++] = K[Je++];
          }
          L[0] = L[1], L[1] = L[2], F[0] = k, F[1] = _[2], F[2] = _[4], F[3] = k, F[4] = _[3], F[5] = _[4], F[6] = k, F[7] = _[2], F[8] = _[5], F[9] = k, F[10] = _[3], F[11] = _[5];
        } else if (E === Xa.J) {
          Z = new K.constructor(L[2] * L[0] * o);
          let oe = 0;
          for (let he = 0; he < L[2]; he++) for (let Le = 0; Le < L[0]; Le++) {
            let Je = (Le + I * L[0] + he * L[0] * L[1]) * o;
            oe = (he * L[0] + Le) * o;
            const Pe = Je + o;
            for (; Je < Pe; ) Z[oe++] = K[Je++];
          }
          L[1] = L[2], F[0] = _[0], F[1] = k, F[2] = _[4], F[3] = _[1], F[4] = k, F[5] = _[4], F[6] = _[0], F[7] = k, F[8] = _[5], F[9] = _[1], F[10] = k, F[11] = _[5];
        } else E === Xa.K || E === Xa.NONE ? (Z = K.subarray(I * N, (I + 1) * N), F[0] = _[0], F[1] = _[2], F[2] = k, F[3] = _[1], F[4] = _[2], F[5] = k, F[6] = _[0], F[7] = _[3], F[8] = k, F[9] = _[1], F[10] = _[3], F[11] = k) : Z0("Reformat slicing not yet supported.");
        const j = e._openGLRenderWindow.getGraphicsResourceForObject(Z);
        (j == null ? void 0 : j.vtkObj) ? (e.openGLTexture = j.vtkObj, e.VBOBuildString = j.hash) : (e._scalars !== Z && (e._openGLRenderWindow.releaseGraphicsResourcesForObject(e._scalars), e._scalars = Z), e.openGLTexture.resetFormatAndType(), e.openGLTexture.create2DFilterableFromRaw(L[0], L[1], o, a.getDataType(), Z, (_b3 = (_a3 = e.renderable).getPreferSizeOverAccuracy) == null ? void 0 : _b3.call(_a3)), e._openGLRenderWindow.setGraphicsResourceForObject(Z, e.openGLTexture, e.VBOBuildString)), e.openGLTexture.activate(), e.openGLTexture.sendParameters(), e.openGLTexture.deactivate();
        const B = Tt.newInstance({
          numberOfComponents: 3,
          values: F
        });
        B.setName("points");
        const Y = Tt.newInstance({
          numberOfComponents: 2,
          values: V
        });
        Y.setName("tcoords");
        const X = new Uint16Array(8);
        X[0] = 3, X[1] = 0, X[2] = 1, X[3] = 3, X[4] = 3, X[5] = 0, X[6] = 3, X[7] = 2;
        const ie = Tt.newInstance({
          numberOfComponents: 1,
          values: X
        });
        e.tris.getCABO().createVBO(ie, "polys", fi.SURFACE, {
          points: B,
          tcoords: Y,
          cellOffset: 0
        }), e.VBOBuildTime.modified(), e.VBOBuildString = O;
      }
    }, t.updatelabelOutlineThicknessTexture = (n) => {
      e.labelOutlineThicknessTexture || (e.labelOutlineThicknessTexture = er.newInstance({
        resizable: false
      }), e.labelOutlineThicknessTexture.setOpenGLRenderWindow(e._openGLRenderWindow));
      const r = n.getProperty().getLabelOutlineThickness(), i = e._openGLRenderWindow.getGraphicsResourceForObject(r), a = `${r.join("-")}`;
      if (!(i == null ? void 0 : i.vtkObj) || (i == null ? void 0 : i.hash) !== a || e.labelOutlineThicknessTextureString !== a) {
        const f = new Uint8Array(1024);
        for (let u = 0; u < 1024; ++u) {
          const h = typeof r[u] < "u" ? r[u] : r[0];
          f[u] = h;
        }
        e.labelOutlineThicknessTexture.releaseGraphicsResources(e._openGLRenderWindow), e.labelOutlineThicknessTexture.resetFormatAndType(), e.labelOutlineThicknessTexture.setMinificationFilter(dt.NEAREST), e.labelOutlineThicknessTexture.setMagnificationFilter(dt.NEAREST), e.labelOutlineThicknessTexture.create2DFromRaw(1024, 1, 1, zt.UNSIGNED_CHAR, f), e.labelOutlineThicknessTextureString = a, r && e._openGLRenderWindow.setGraphicsResourceForObject(r, e.labelOutlineThicknessTexture, e.labelOutlineThicknessTextureString);
      } else e.labelOutlineThicknessTexture = i.vtkObj, e.labelOutlineThicknessTextureString = i.hash;
    }, t.getRenderTargetSize = () => {
      if (e._useSmallViewport) return [
        e._smallViewportWidth,
        e._smallViewportHeight
      ];
      const { usize: n, vsize: r } = e._openGLRenderer.getTiledSizeAndOrigin();
      return [
        n,
        r
      ];
    }, t.getRenderTargetOffset = () => {
      const { lowerLeftU: n, lowerLeftV: r } = e._openGLRenderer.getTiledSizeAndOrigin();
      return [
        n,
        r
      ];
    };
  }
  const kQ = {
    VBOBuildTime: 0,
    VBOBuildString: null,
    openGLTexture: null,
    tris: null,
    imagemat: null,
    imagematinv: null,
    colorTexture: null,
    pwfTexture: null,
    labelOutlineThicknessTexture: null,
    labelOutlineThicknessTextureString: null,
    lastHaveSeenDepthRequest: false,
    haveSeenDepthRequest: false,
    lastTextureComponents: 0,
    _scalars: null
  };
  function PQ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, kQ, n), Rn.extend(t, e, n), Ls.implementReplaceShaderCoincidentOffset(t, e, n), Ls.implementBuildShadersWithReplacements(t, e, n), e.tris = Bs.newInstance(), e.imagemat = gt(new Float64Array(16)), e.imagematinv = gt(new Float64Array(16)), e.projectionToWorld = gt(new Float64Array(16)), e.idxToView = gt(new Float64Array(16)), e.idxNormalMatrix = Fa(new Float64Array(9)), e.modelToView = gt(new Float64Array(16)), e.projectionToView = gt(new Float64Array(16)), pr(t, e, []), e.VBOBuildTime = {}, _n(e.VBOBuildTime), _Q(t, e);
  }
  const FR = pn(PQ, "vtkOpenGLImageMapper");
  var GQ = {
    newInstance: FR
  };
  Er("vtkAbstractImageMapper", FR);
  function zQ(t, e) {
    e.classHierarchy.push("vtkOpenGLImageSlice"), t.buildPass = (n) => {
      if (!(!e.renderable || !e.renderable.getVisibility()) && n) {
        if (!e.renderable) return;
        e._openGLRenderWindow = t.getFirstAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes();
      }
    }, t.traverseZBufferPass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children.forEach((r) => {
        r.traverse(n);
      }), t.apply(n, false));
    }, t.traverseOpaqueZBufferPass = (n) => t.traverseOpaquePass(n), t.traverseOpaquePass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children.forEach((r) => {
        r.traverse(n);
      }), t.apply(n, false));
    }, t.traverseTranslucentPass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children.forEach((r) => {
        r.traverse(n);
      }), t.apply(n, false));
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
      }
    }, t.zBufferPass = (n, r) => t.opaquePass(n, r), t.opaqueZBufferPass = (n, r) => t.opaquePass(n, r), t.opaquePass = (n, r) => {
      n && e.context.depthMask(true);
    }, t.translucentPass = (n, r) => {
      e.context.depthMask(!n);
    }, t.getKeyMatrices = () => (e.renderable.getMTime() > e.keyMatrixTime.getMTime() && (sr(e.keyMatrices.mcwc, e.renderable.getMatrix()), en(e.keyMatrices.mcwc, e.keyMatrices.mcwc), e.keyMatrixTime.modified()), e.keyMatrices);
  }
  const WQ = {
    context: null,
    keyMatrixTime: null,
    keyMatrices: null
  };
  function HQ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, WQ, n), Rn.extend(t, e, n), e.keyMatrixTime = {}, _n(e.keyMatrixTime, {
      mtime: 0
    }), e.keyMatrices = {
      mcwc: gt(new Float64Array(16))
    }, pr(t, e, [
      "context"
    ]), zQ(t, e);
  }
  const BR = pn(HQ, "vtkOpenGLImageSlice");
  var jQ = {
    newInstance: BR
  };
  Er("vtkImageSlice", BR);
  const { vtkDebugMacro: KQ } = di;
  function YQ(t, e) {
    e.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"), t.opaquePass = (n, r) => {
      e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent();
      const i = e._openGLRenderer.getAspectRatio(), a = e._openGLRenderer ? e._openGLRenderer.getRenderable().getActiveCamera() : null, s = e._openGLRenderer.getTiledSizeAndOrigin();
      let o = null;
      if (e.renderable.getUseZValues()) {
        const l = r.getZBufferTexture(), c = Math.floor(l.getWidth()), f = Math.floor(l.getHeight()), u = e._openGLRenderWindow.getContext();
        l.bind();
        const h = r.getFramebuffer();
        h ? h.saveCurrentBindingsAndBuffers() : KQ("No framebuffer to save/restore");
        const g = u.createFramebuffer();
        u.bindFramebuffer(u.FRAMEBUFFER, g), u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, l.getHandle(), 0), u.checkFramebufferStatus(u.FRAMEBUFFER) === u.FRAMEBUFFER_COMPLETE && (o = new Uint8Array(c * f * 4), u.viewport(0, 0, c, f), u.readPixels(0, 0, c, f, u.RGBA, u.UNSIGNED_BYTE, o)), h && h.restorePreviousBindingsAndBuffers(), u.deleteFramebuffer(g);
      }
      e.renderable.invokeCallback(e.renderable.getInputData(), a, i, s, o);
    }, t.queryPass = (n, r) => {
      n && e.renderable.getUseZValues() && r.requestDepth();
    };
  }
  const qQ = {};
  function XQ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, qQ, n), Rn.extend(t, e, n), YQ(t, e);
  }
  const _R = pn(XQ, "vtkOpenGLPixelSpaceCallbackMapper");
  var ZQ = {
    newInstance: _R
  };
  Er("vtkPixelSpaceCallbackMapper", _R);
  const { vtkDebugMacro: QQ } = di;
  function JQ(t, e) {
    e.classHierarchy.push("vtkOpenGLRenderer"), t.buildPass = (n) => {
      if (n) {
        if (!e.renderable) return;
        t.updateLights(), t.prepareNodes(), t.addMissingNode(e.renderable.getActiveCamera()), t.addMissingNodes(e.renderable.getViewPropsWithNestedProps()), t.removeUnusedNodes();
      }
    }, t.updateLights = () => {
      let n = 0;
      const r = e.renderable.getLightsByReference();
      for (let i = 0; i < r.length; ++i) r[i].getSwitch() > 0 && n++;
      return n || (QQ("No lights are on, creating one."), e.renderable.createLight()), n;
    }, t.zBufferPass = (n) => {
      if (n) {
        let r = 0;
        const i = e.context;
        e.renderable.getTransparent() || (e.context.clearColor(1, 0, 0, 1), r |= i.COLOR_BUFFER_BIT), e.renderable.getPreserveDepthBuffer() || (i.clearDepth(1), r |= i.DEPTH_BUFFER_BIT, e.context.depthMask(true));
        const a = t.getTiledSizeAndOrigin();
        i.enable(i.SCISSOR_TEST), i.scissor(a.lowerLeftU, a.lowerLeftV, a.usize, a.vsize), i.viewport(a.lowerLeftU, a.lowerLeftV, a.usize, a.vsize), i.colorMask(true, true, true, true), r && i.clear(r), i.enable(i.DEPTH_TEST);
      }
    }, t.opaqueZBufferPass = (n) => t.zBufferPass(n), t.cameraPass = (n) => {
      n && t.clear();
    }, t.getAspectRatio = () => {
      const n = e._parent.getSizeByReference(), r = e.renderable.getViewportByReference();
      return n[0] * (r[2] - r[0]) / ((r[3] - r[1]) * n[1]);
    }, t.getTiledSizeAndOrigin = () => {
      const n = e.renderable.getViewportByReference(), r = [
        0,
        0,
        1,
        1
      ], i = n[0] - r[0], a = n[1] - r[1], s = e._parent.normalizedDisplayToDisplay(i, a), o = Math.round(s[0]), l = Math.round(s[1]), c = n[2] - r[0], f = n[3] - r[1], u = e._parent.normalizedDisplayToDisplay(c, f);
      let h = Math.round(u[0]) - o, g = Math.round(u[1]) - l;
      return h < 0 && (h = 0), g < 0 && (g = 0), {
        usize: h,
        vsize: g,
        lowerLeftU: o,
        lowerLeftV: l
      };
    }, t.clear = () => {
      let n = 0;
      const r = e.context;
      if (!e.renderable.getTransparent()) {
        const a = e.renderable.getBackgroundByReference();
        r.clearColor(a[0], a[1], a[2], a[3]), n |= r.COLOR_BUFFER_BIT;
      }
      e.renderable.getPreserveDepthBuffer() || (r.clearDepth(1), n |= r.DEPTH_BUFFER_BIT, r.depthMask(true)), r.colorMask(true, true, true, true);
      const i = t.getTiledSizeAndOrigin();
      r.enable(r.SCISSOR_TEST), r.scissor(i.lowerLeftU, i.lowerLeftV, i.usize, i.vsize), r.viewport(i.lowerLeftU, i.lowerLeftV, i.usize, i.vsize), n && r.clear(n), r.enable(r.DEPTH_TEST);
    }, t.releaseGraphicsResources = () => {
      e.selector !== null && e.selector.releaseGraphicsResources(), e.renderable && e.renderable.getViewProps().forEach((n) => {
        n.modified();
      });
    }, t.setOpenGLRenderWindow = (n) => {
      e._openGLRenderWindow !== n && (t.releaseGraphicsResources(), e._openGLRenderWindow = n, e.context = null, n && (e.context = e._openGLRenderWindow.getContext()));
    };
  }
  const $Q = {
    context: null,
    _openGLRenderWindow: null,
    selector: null
  };
  function eJ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, $Q, n), Rn.extend(t, e, n), Wi(t, e, [
      "shaderCache"
    ]), pr(t, e, [
      "selector"
    ]), Qh(t, e, [
      "openGLRenderWindow"
    ]), JQ(t, e);
  }
  const kR = pn(eJ, "vtkOpenGLRenderer");
  var tJ = {
    newInstance: kR
  };
  Er("vtkRenderer", kR);
  const { vtkErrorMacro: BT } = di;
  function nJ(t, e) {
    e.classHierarchy.push("vtkOpenGLSkybox"), t.buildPass = (n) => {
      if (n) {
        e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow), e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
        const r = e._openGLRenderer.getRenderable();
        e.openGLCamera = e._openGLRenderer.getViewNodeFor(r.getActiveCamera());
      }
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        r.incrementOpaqueActorCount();
      }
    }, t.opaquePass = (n, r) => {
      if (n && !e._openGLRenderer.getSelector()) {
        t.updateBufferObjects(), e.context.depthMask(true), e._openGLRenderWindow.getShaderCache().readyShaderProgram(e.tris.getProgram()), e.openGLTexture.render(e._openGLRenderWindow);
        const i = e.openGLTexture.getTextureUnit();
        e.tris.getProgram().setUniformi("sbtexture", i);
        const a = e._openGLRenderer.getRenderable(), s = e.openGLCamera.getKeyMatrices(a), o = new Float64Array(16);
        if (Nr(o, s.wcpc), e.tris.getProgram().setUniformMatrix("IMCPCMatrix", o), e.lastFormat === "box") {
          const l = a.getActiveCamera().getPosition();
          e.tris.getProgram().setUniform3f("camPos", l[0], l[1], l[2]);
        }
        e.tris.getVAO().bind(), e.context.drawArrays(e.context.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release(), e.openGLTexture.deactivate();
      }
    }, t.updateBufferObjects = () => {
      if (!e.tris.getCABO().getElementCount()) {
        const r = new Float32Array(12);
        for (let o = 0; o < 4; o++) r[o * 3] = o % 2 * 2 - 1, r[o * 3 + 1] = o > 1 ? 1 : -1, r[o * 3 + 2] = 1;
        const i = Tt.newInstance({
          numberOfComponents: 3,
          values: r
        });
        i.setName("points");
        const a = new Uint16Array(8);
        a[0] = 3, a[1] = 0, a[2] = 1, a[3] = 3, a[4] = 3, a[5] = 0, a[6] = 3, a[7] = 2;
        const s = Tt.newInstance({
          numberOfComponents: 1,
          values: a
        });
        e.tris.getCABO().createVBO(s, "polys", fi.SURFACE, {
          points: i,
          cellOffset: 0
        });
      }
      e.renderable.getFormat() !== e.lastFormat && (e.lastFormat = e.renderable.getFormat(), e.lastFormat === "box" && e.tris.setProgram(e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, "")), e.lastFormat === "background" && e.tris.setProgram(e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, "")), e.tris.getShaderSourceTime().modified(), e.tris.getVAO().bind(), e.tris.getVAO().addAttributeArray(e.tris.getProgram(), e.tris.getCABO(), "vertexMC", e.tris.getCABO().getVertexOffset(), e.tris.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || BT("Error setting vertexMC in shader VAO."));
      const n = e.renderable.getTextures();
      n.length || BT("vtkSkybox requires a texture map"), e.openGLTexture.getRenderable() !== n[0] && (e.openGLTexture.releaseGraphicsResources(e._openGLRenderWindow), e.openGLTexture.setRenderable(n[0]));
    };
  }
  const rJ = {
    context: null
  };
  function iJ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, rJ, n), Rn.extend(t, e, n), e.openGLTexture = er.newInstance(), e.tris = Bs.newInstance(), e.keyMatrixTime = {}, _n(e.keyMatrixTime, {
      mtime: 0
    }), e.keyMatrices = {
      normalMatrix: Fa(new Float64Array(9)),
      mcwc: gt(new Float64Array(16))
    }, pr(t, e, [
      "context"
    ]), Wi(t, e, [
      "activeTextures"
    ]), nJ(t, e);
  }
  const PR = pn(iJ);
  var aJ = {
    newInstance: PR
  };
  Er("vtkSkybox", PR);
  var sJ = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkSphereMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// this shader implements imposters in OpenGL for Spheres

attribute vec4 vertexMC;
attribute vec2 offsetMC;

// optional normal declaration
//VTK::Normal::Dec

//VTK::Picking::Dec

// Texture coordinates
//VTK::TCoord::Dec

uniform mat3 normalMatrix; // transform model coordinate directions to view coordinates

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

varying vec4 vertexVCVSOutput;
varying float radiusVCVSOutput;
varying vec3 centerVCVSOutput;

uniform int cameraParallel;
uniform float scaleFactor;

void main()
{
  //VTK::Picking::Impl

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  // compute the projected vertex position
  vec2 scaledOffsetMC = scaleFactor * offsetMC;
  vertexVCVSOutput = MCVCMatrix * vertexMC;
  centerVCVSOutput = vertexVCVSOutput.xyz;
  radiusVCVSOutput = length(scaledOffsetMC)*0.5;

  // make the triangle face the camera
  if (cameraParallel == 0)
    {
    vec3 dir = normalize(-vertexVCVSOutput.xyz);
    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));
    vec3 base1 = cross(base2,dir);
    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;
    }
  else
    {
    // add in the offset
    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;
    }

  gl_Position = VCPCMatrix * vertexVCVSOutput;
}
`;
  const { vtkErrorMacro: oJ } = di;
  function lJ(t, e) {
    e.classHierarchy.push("vtkOpenGLSphereMapper");
    const n = {
      ...t
    };
    t.getShaderTemplate = (r, i, a) => {
      r.Vertex = sJ, r.Fragment = rd, r.Geometry = "";
    }, t.replaceShaderValues = (r, i, a) => {
      let s = r.Vertex, o = r.Fragment;
      s = se.substitute(s, "//VTK::Camera::Dec", [
        `uniform mat4 VCPCMatrix;
`,
        "uniform mat4 MCVCMatrix;"
      ]).result, o = se.substitute(o, "//VTK::PositionVC::Dec", [
        "varying vec4 vertexVCVSOutput;"
      ]).result, o = se.substitute(o, "//VTK::PositionVC::Impl", [
        `vec4 vertexVC = vertexVCVSOutput;
`
      ]).result;
      const l = [
        `uniform float invertedDepth;
`,
        `uniform int cameraParallel;
`,
        `varying float radiusVCVSOutput;
`,
        `varying vec3 centerVCVSOutput;
`,
        `uniform mat4 VCPCMatrix;
`
      ];
      o = se.substitute(o, "//VTK::Normal::Dec", l).result;
      let c = "";
      e.context.getExtension("EXT_frag_depth") && (c = `gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;
`), e._openGLRenderWindow.getWebgl2() && (c = `gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;
`), o = se.substitute(o, "//VTK::Depth::Impl", [
        `  vec3 EyePos;
`,
        `  vec3 EyeDir;
`,
        `  if (cameraParallel != 0) {
`,
        `    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);
`,
        `    EyeDir = vec3(0.0,0.0,-1.0); }
`,
        `  else {
`,
        `    EyeDir = vertexVC.xyz;
`,
        `    EyePos = vec3(0.0,0.0,0.0);
`,
        `    float lengthED = length(EyeDir);
`,
        `    EyeDir = normalize(EyeDir);
`,
        `    if (lengthED > radiusVCVSOutput*3.0) {
`,
        `      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }
`,
        `    }
`,
        `  EyePos = EyePos - centerVCVSOutput;
`,
        `  EyePos = EyePos/radiusVCVSOutput;
`,
        `  float b = 2.0*dot(EyePos,EyeDir);
`,
        `  float c = dot(EyePos,EyePos) - 1.0;
`,
        `  float d = b*b - 4.0*c;
`,
        `  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);
`,
        `  if (d < 0.0) { discard; }
`,
        `  else {
`,
        `    float t = (-b - invertedDepth*sqrt(d))*0.5;
`,
        `    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);
`,
        `    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;
`,
        `    }
`,
        `  vec4 pos = VCPCMatrix * vertexVC;
`,
        c
      ]).result, o = se.substitute(o, "//VTK::Normal::Impl", "").result, e.haveSeenDepthRequest && (o = se.substitute(o, "//VTK::ZBuffer::Impl", [
        "if (depthRequest == 1) {",
        "float computedZ = (pos.z / pos.w + 1.0) / 2.0;",
        "float iz = floor(computedZ * 65535.0 + 0.1);",
        "float rf = floor(iz/256.0)/255.0;",
        "float gf = mod(iz,256.0)/255.0;",
        "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
      ]).result), r.Vertex = s, r.Fragment = o, n.replaceShaderValues(r, i, a);
    }, t.setMapperShaderParameters = (r, i, a) => {
      if (r.getCABO().getElementCount() && (e.VBOBuildTime > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime()) && r.getProgram().isAttributeUsed("offsetMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "offsetMC", 12, r.getCABO().getStride(), e.context.FLOAT, 2, false) || oJ("Error setting 'offsetMC' in shader VAO.")), r.getProgram().isUniformUsed("invertedDepth") && r.getProgram().setUniformf("invertedDepth", e.invert ? -1 : 1), r.getProgram().isUniformUsed("scaleFactor")) {
        const o = e.currentInput.getPointData();
        e.renderable.getScaleArray() != null && o.hasArray(e.renderable.getScaleArray()) ? r.getProgram().setUniformf("scaleFactor", e.renderable.getScaleFactor()) : r.getProgram().setUniformf("scaleFactor", 1);
      }
      n.setMapperShaderParameters(r, i, a);
    }, t.setCameraShaderParameters = (r, i, a) => {
      const s = r.getProgram(), o = i.getActiveCamera(), l = e.openGLCamera.getKeyMatrices(i);
      if (s.isUniformUsed("VCPCMatrix") && s.setUniformMatrix("VCPCMatrix", l.vcpc), s.isUniformUsed("MCVCMatrix")) if (a.getIsIdentity()) s.setUniformMatrix("MCVCMatrix", l.wcvc);
      else {
        const c = e.openGLActor.getKeyMatrices(), f = new Float64Array(16);
        tn(f, l.wcvc, c.mcwc), s.setUniformMatrix("MCVCMatrix", f);
      }
      s.isUniformUsed("cameraParallel") && r.getProgram().setUniformi("cameraParallel", o.getParallelProjection());
    }, t.getOpenGLMode = (r, i) => e.context.TRIANGLES, t.buildBufferObjects = (r, i) => {
      const a = e.currentInput;
      if (a === null) return;
      e.renderable.mapScalars(a, 1);
      const s = e.renderable.getColorMapColors(), o = e.primitives[e.primTypes.Tris].getCABO(), l = a.getPointData(), c = a.getPoints(), f = c.getNumberOfPoints(), u = c.getData(), h = 5;
      let g = null;
      e.renderable.getScaleArray() != null && l.hasArray(e.renderable.getScaleArray()) && (g = l.getArray(e.renderable.getScaleArray()).getData());
      let v = null, m = 0, y = null;
      s ? (m = s.getNumberOfComponents(), o.setColorOffset(0), o.setColorBOStride(4), v = s.getData(), y = new Uint8Array(3 * f * 4), o.getColorBO() || o.setColorBO(go.newInstance()), o.getColorBO().setOpenGLRenderWindow(e._openGLRenderWindow)) : o.getColorBO() && o.setColorBO(null), o.setColorComponents(m);
      const w = new Float32Array(h * f * 3);
      o.setStride(h * 4);
      const C = Math.cos(rr(30));
      let T = 0, S = 0, E = 0, b = 0;
      for (let D = 0; D < f; ++D) {
        let R = e.renderable.getRadius();
        g && (R = g[D]), T = D * 3, w[E++] = u[T++], w[E++] = u[T++], w[E++] = u[T++], w[E++] = -2 * R * C, w[E++] = -R, v && (S = D * m, y[b++] = v[S], y[b++] = v[S + 1], y[b++] = v[S + 2], y[b++] = v[S + 3]), T = D * 3, w[E++] = u[T++], w[E++] = u[T++], w[E++] = u[T++], w[E++] = 2 * R * C, w[E++] = -R, v && (y[b++] = v[S], y[b++] = v[S + 1], y[b++] = v[S + 2], y[b++] = v[S + 3]), T = D * 3, w[E++] = u[T++], w[E++] = u[T++], w[E++] = u[T++], w[E++] = 0, w[E++] = 2 * R, v && (y[b++] = v[S], y[b++] = v[S + 1], y[b++] = v[S + 2], y[b++] = v[S + 3]);
      }
      o.setElementCount(E / h), o.upload(w, wo.ARRAY_BUFFER), s && o.getColorBO().upload(y, wo.ARRAY_BUFFER), e.VBOBuildTime.modified();
    };
  }
  const cJ = {};
  function uJ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, cJ, n), E5.extend(t, e, n), lJ(t, e);
  }
  const GR = pn(uJ, "vtkOpenGLSphereMapper");
  var fJ = {
    newInstance: GR
  };
  Er("vtkSphereMapper", GR);
  var hJ = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkStickMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// this shader implements imposters in OpenGL for Sticks

attribute vec4 vertexMC;
attribute vec3 orientMC;
attribute vec4 offsetMC;
attribute float radiusMC;

// optional normal declaration
//VTK::Normal::Dec

//VTK::Picking::Dec

// Texture coordinates
//VTK::TCoord::Dec

uniform mat3 normalMatrix; // transform model coordinate directions to view coordinates

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

varying vec4 vertexVCVSOutput;
varying float radiusVCVSOutput;
varying float lengthVCVSOutput;
varying vec3 centerVCVSOutput;
varying vec3 orientVCVSOutput;

uniform int cameraParallel;

void main()
{
  //VTK::Picking::Impl

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  vertexVCVSOutput = MCVCMatrix * vertexMC;
  centerVCVSOutput = vertexVCVSOutput.xyz;
  radiusVCVSOutput = radiusMC;
  lengthVCVSOutput = length(orientMC);
  orientVCVSOutput = normalMatrix * normalize(orientMC);

  // make sure it is pointing out of the screen
  if (orientVCVSOutput.z < 0.0)
    {
    orientVCVSOutput = -orientVCVSOutput;
    }

  // make the basis
  vec3 xbase;
  vec3 ybase;
  vec3 dir = vec3(0.0,0.0,1.0);
  if (cameraParallel == 0)
    {
    dir = normalize(-vertexVCVSOutput.xyz);
    }
  if (abs(dot(dir,orientVCVSOutput)) == 1.0)
    {
    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));
    ybase = cross(xbase,orientVCVSOutput);
    }
  else
    {
    xbase = normalize(cross(orientVCVSOutput,dir));
    ybase = cross(orientVCVSOutput,xbase);
    }

  vec3 offsets = offsetMC.xyz*2.0-1.0;
  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +
    radiusVCVSOutput*offsets.x*xbase +
    radiusVCVSOutput*offsets.y*ybase +
    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;

  gl_Position = VCPCMatrix * vertexVCVSOutput;
}
`;
  const { vtkErrorMacro: U2 } = di;
  function dJ(t, e) {
    e.classHierarchy.push("vtkOpenGLStickMapper");
    const n = {
      ...t
    };
    t.getShaderTemplate = (r, i, a) => {
      r.Vertex = hJ, r.Fragment = rd, r.Geometry = "";
    }, t.replaceShaderValues = (r, i, a) => {
      let s = r.Vertex, o = r.Fragment;
      s = se.substitute(s, "//VTK::Camera::Dec", [
        `uniform mat4 VCPCMatrix;
`,
        "uniform mat4 MCVCMatrix;"
      ]).result, o = se.substitute(o, "//VTK::PositionVC::Dec", "varying vec4 vertexVCVSOutput;").result, o = se.substitute(o, "//VTK::PositionVC::Impl", `  vec4 vertexVC = vertexVCVSOutput;
`).result;
      const l = [
        `uniform int cameraParallel;
`,
        `varying float radiusVCVSOutput;
`,
        `varying vec3 orientVCVSOutput;
`,
        `varying float lengthVCVSOutput;
`,
        `varying vec3 centerVCVSOutput;
`,
        `uniform mat4 VCPCMatrix;
`
      ];
      o = se.substitute(o, "//VTK::Normal::Dec", l).result;
      let c = "";
      e.context.getExtension("EXT_frag_depth") && (c = `  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;
`), e._openGLRenderWindow.getWebgl2() && (c = `gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;
`), o = se.substitute(o, "//VTK::Depth::Impl", [
        `  vec3 EyePos;
`,
        `  vec3 EyeDir;
`,
        `  if (cameraParallel != 0) {
`,
        `    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);
`,
        `    EyeDir = vec3(0.0,0.0,-1.0); }
`,
        `  else {
`,
        `    EyeDir = vertexVC.xyz;
`,
        `    EyePos = vec3(0.0,0.0,0.0);
`,
        `    float lengthED = length(EyeDir);
`,
        `    EyeDir = normalize(EyeDir);
`,
        `    if (lengthED > radiusVCVSOutput*3.0) {
`,
        `      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }
`,
        `    }
`,
        `  EyePos = EyePos - centerVCVSOutput;
`,
        `  vec3 base1;
`,
        `  if (abs(orientVCVSOutput.z) < 0.99) {
`,
        `    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }
`,
        `  else {
`,
        `    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }
`,
        `  vec3 base2 = cross(orientVCVSOutput,base1);
`,
        `  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));
`,
        `  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));
`,
        `  EyePos = EyePos/radiusVCVSOutput;
`,
        `  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;
`,
        `  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);
`,
        `  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;
`,
        `  float d = b*b - 4.0*a*c;
`,
        `  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);
`,
        `  if (d < 0.0) { discard; }
`,
        `  else {
`,
        `    float t =  (-b - sqrt(d))/(2.0*a);
`,
        `    float tz = EyePos.z + t*EyeDir.z;
`,
        `    vec3 iPoint = EyePos + t*EyeDir;
`,
        `    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {
`,
        `      float t2 = (-b + sqrt(d))/(2.0*a);
`,
        `      float tz2 = EyePos.z + t2*EyeDir.z;
`,
        `      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }
`,
        `      else {
`,
        `        normalVCVSOutput = orientVCVSOutput;
`,
        `        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;
`,
        `        iPoint = EyePos + t3*EyeDir;
`,
        `        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;
`,
        `        }
`,
        `      }
`,
        `    else {
`,
        `      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;
`,
        `      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;
`,
        `      }
`,
        `    }
`,
        `  vec4 pos = VCPCMatrix * vertexVC;
`,
        c
      ]).result, o = se.substitute(o, "//VTK::Normal::Impl", "").result, e.haveSeenDepthRequest && (o = se.substitute(o, "//VTK::ZBuffer::Impl", [
        "if (depthRequest == 1) {",
        "float computedZ = (pos.z / pos.w + 1.0) / 2.0;",
        "float iz = floor(computedZ * 65535.0 + 0.1);",
        "float rf = floor(iz/256.0)/255.0;",
        "float gf = mod(iz,256.0)/255.0;",
        "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
      ]).result), r.Vertex = s, r.Fragment = o, n.replaceShaderValues(r, i, a);
    }, t.setMapperShaderParameters = (r, i, a) => {
      r.getCABO().getElementCount() && (e.VBOBuildTime > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime()) && (r.getProgram().isAttributeUsed("orientMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "orientMC", 12, r.getCABO().getStride(), e.context.FLOAT, 3, false) || U2("Error setting 'orientMC' in shader VAO.")), r.getProgram().isAttributeUsed("offsetMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO().getColorBO(), "offsetMC", 0, r.getCABO().getColorBOStride(), e.context.UNSIGNED_BYTE, 3, true) || U2("Error setting 'offsetMC' in shader VAO.")), r.getProgram().isAttributeUsed("radiusMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "radiusMC", 24, r.getCABO().getStride(), e.context.FLOAT, 1, false) || U2("Error setting 'radiusMC' in shader VAO."))), n.setMapperShaderParameters(r, i, a);
    }, t.setCameraShaderParameters = (r, i, a) => {
      const s = r.getProgram(), o = i.getActiveCamera(), l = e.openGLCamera.getKeyMatrices(i);
      if (s.isUniformUsed("VCPCMatrix") && s.setUniformMatrix("VCPCMatrix", l.vcpc), a.getIsIdentity()) s.isUniformUsed("MCVCMatrix") && s.setUniformMatrix("MCVCMatrix", l.wcvc), s.isUniformUsed("normalMatrix") && s.setUniformMatrix3x3("normalMatrix", l.normalMatrix);
      else {
        const c = e.openGLActor.getKeyMatrices();
        if (s.isUniformUsed("MCVCMatrix")) {
          const f = new Float64Array(16);
          tn(f, l.wcvc, c.mcwc), s.setUniformMatrix("MCVCMatrix", f);
        }
        if (s.isUniformUsed("normalMatrix")) {
          const f = new Float64Array(9);
          Ou(f, l.normalMatrix, c.normalMatrix), s.setUniformMatrix3x3("normalMatrix", f);
        }
      }
      s.isUniformUsed("cameraParallel") && r.getProgram().setUniformi("cameraParallel", o.getParallelProjection());
    }, t.getOpenGLMode = (r, i) => e.context.TRIANGLES, t.buildBufferObjects = (r, i) => {
      const a = e.currentInput;
      if (a === null) return;
      e.renderable.mapScalars(a, 1);
      const s = e.renderable.getColorMapColors(), o = e.primitives[e.primTypes.Tris].getCABO(), l = a.getPointData(), c = a.getPoints(), f = c.getNumberOfPoints(), u = c.getData();
      let h = 3;
      h += 4;
      let g = null, v = 0;
      o.setColorBOStride(4), o.getColorBO() || o.setColorBO(go.newInstance()), o.getColorBO().setOpenGLRenderWindow(e._openGLRenderWindow), s && (v = s.getNumberOfComponents(), o.setColorOffset(4), g = s.getData(), o.setColorBOStride(8)), o.setColorComponents(v), o.setStride(h * 4);
      const m = new Float32Array(h * f * 12), y = new Uint8Array(12 * f * (g ? 8 : 4));
      let w = null, C = null;
      e.renderable.getScaleArray() != null && l.hasArray(e.renderable.getScaleArray()) && (w = l.getArray(e.renderable.getScaleArray()).getData()), e.renderable.getOrientationArray() != null && l.hasArray(e.renderable.getOrientationArray()) ? C = l.getArray(e.renderable.getOrientationArray()).getData() : U2([
        `Error setting orientationArray.
`,
        "You have to specify the stick orientation"
      ]);
      const T = [
        0,
        1,
        3,
        0,
        3,
        2,
        2,
        3,
        5,
        2,
        5,
        4
      ];
      let S = 0, E = 0, b = 0, D = 0;
      for (let R = 0; R < f; ++R) {
        let I = e.renderable.getLength(), O = e.renderable.getRadius();
        w && (I = w[R * 2], O = w[R * 2 + 1]);
        for (let L = 0; L < T.length; ++L) S = R * 3, m[b++] = u[S++], m[b++] = u[S++], m[b++] = u[S++], S = R * 3, m[b++] = C[S++] * I, m[b++] = C[S++] * I, m[b++] = C[S++] * I, m[b++] = O, y[D++] = 255 * (T[L] % 2), y[D++] = T[L] >= 4 ? 255 : 0, y[D++] = T[L] >= 2 ? 255 : 0, y[D++] = 255, E = R * v, g && (y[D++] = g[E], y[D++] = g[E + 1], y[D++] = g[E + 2], y[D++] = g[E + 3]);
      }
      o.setElementCount(b / h), o.upload(m, wo.ARRAY_BUFFER), o.getColorBO().upload(y, wo.ARRAY_BUFFER), e.VBOBuildTime.modified();
    };
  }
  const gJ = {};
  function pJ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, gJ, n), E5.extend(t, e, n), dJ(t, e);
  }
  const zR = pn(pJ, "vtkOpenGLStickMapper");
  var mJ = {
    newInstance: zR
  };
  Er("vtkStickMapper", zR);
  function vJ(t, e) {
    e.classHierarchy.push("vtkOpenGLVolume"), t.buildPass = (n) => {
      !e.renderable || !e.renderable.getVisibility() || n && (e._openGLRenderWindow = t.getFirstAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes());
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        r.incrementVolumeCount();
      }
    }, t.traverseVolumePass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children[0].traverse(n), t.apply(n, false));
    }, t.volumePass = (n) => {
      !e.renderable || !e.renderable.getVisibility() || e.context.depthMask(!n);
    }, t.getKeyMatrices = () => (e.renderable.getMTime() > e.keyMatrixTime.getMTime() && (e.renderable.computeMatrix(), sr(e.MCWCMatrix, e.renderable.getMatrix()), en(e.MCWCMatrix, e.MCWCMatrix), e.renderable.getIsIdentity() ? Fa(e.normalMatrix) : (y5(e.normalMatrix, e.MCWCMatrix), td(e.normalMatrix, e.normalMatrix), N8(e.normalMatrix, e.normalMatrix)), e.keyMatrixTime.modified()), {
      mcwc: e.MCWCMatrix,
      normalMatrix: e.normalMatrix
    });
  }
  const yJ = {};
  function xJ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, yJ, n), Rn.extend(t, e, n), e.keyMatrixTime = {}, _n(e.keyMatrixTime, {
      mtime: 0
    }), e.normalMatrix = new Float64Array(9), e.MCWCMatrix = new Float64Array(16), pr(t, e, [
      "context"
    ]), vJ(t, e);
  }
  const WR = pn(xJ, "vtkOpenGLVolume");
  var wJ = {
    newInstance: WR
  };
  Er("vtkVolume", WR);
  const h6 = {
    NEAREST: 0,
    LINEAR: 1,
    FAST_LINEAR: 2
  }, HR = {
    FRACTIONAL: 0,
    PROPORTIONAL: 1
  }, _g = {
    CUSTOM: 0,
    ADDITIVE: 1,
    COLORIZE: 2
  };
  var jR = {
    InterpolationType: h6,
    OpacityMode: HR,
    ColorMixPreset: _g
  }, CJ = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexDC;

varying vec3 vertexVCVSOutput;
uniform mat4 PCVCMatrix;

uniform float dcxmin;
uniform float dcxmax;
uniform float dcymin;
uniform float dcymax;

void main()
{
  // dcsmall is the device coords reduced to the
  // x y area covered by the volume
  vec4 dcsmall = vec4(
    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),
    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),
    vertexDC.z,
    vertexDC.w);
  vec4 vcpos = PCVCMatrix * dcsmall;
  vertexVCVSOutput = vcpos.xyz/vcpos.w;
  gl_Position = dcsmall;
}
`, TJ = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define UseIndependentComponents
//VTK::IndependentComponentsOn

// possibly define vtkCustomComponentsColorMix
//VTK::CustomComponentsColorMixOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// possibly define any components that are forced to nearest interpolation
//VTK::vtkForceNearestComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

#ifdef vtkImageLabelOutlineOn

uniform float outlineOpacity;
uniform float vpWidth;
uniform float vpHeight;
uniform float vpOffsetX;
uniform float vpOffsetY;
uniform mat4 PCWCMatrix;
uniform mat4 vWCtoIDX;
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

//VTK::VolumeShadowOn
//VTK::SurfaceShadowOn
//VTK::localAmbientOcclusionOn
//VTK::LAO::Dec
//VTK::VolumeShadow::Dec

// define vtkComputeNormalFromOpacity
//VTK::vtkComputeNormalFromOpacity

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#ifdef UseIndependentComponents
#if vtkNumComponents > 1
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents > 2
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#if vtkNumComponents > 3
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

// jitter texture
uniform sampler2D jtexture;
uniform sampler2D ttexture;


// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;

// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef UseIndependentComponents
#if vtkNumComponents == 1
uniform float mix0;
#define height0 0.5
#endif
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

//=======================================================================
// global and custom variables (a temporary section before photorealistics rendering module is complete)
vec3 rayDirVC;
float sampleDistanceISVS;
float sampleDistanceIS;

#define SQRT3    1.7321
#define INV4PI   0.0796
#define EPSILON  0.001
#define PI       3.1415
#define PI2      9.8696

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);

  #if defined(vtkComponent0ForceNearest) || \\
      defined(vtkComponent1ForceNearest) || \\
      defined(vtkComponent2ForceNearest) || \\
      defined(vtkComponent3ForceNearest)
    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);
    vec4 nearestValue = texture(texture1, nearestPos);
    #ifdef vtkComponent0ForceNearest
      tmp[0] = nearestValue[0];
    #endif
    #ifdef vtkComponent1ForceNearest
      tmp[1] = nearestValue[1];
    #endif
    #ifdef vtkComponent2ForceNearest
      tmp[2] = nearestValue[2];
    #endif
    #ifdef vtkComponent3ForceNearest
      tmp[3] = nearestValue[3];
    #endif
  #endif

  #ifndef UseIndependentComponents
    #if vtkNumComponents == 1
      tmp.a = tmp.r;
    #endif
    #if vtkNumComponents == 2
      tmp.a = tmp.g;
    #endif
    #if vtkNumComponents == 3
      tmp.a = length(tmp.rgb);
    #endif
  #endif

  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// transformation between VC and IS space

// convert vector position from idx to vc
#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)
vec3 IStoVC(vec3 posIS){
  vec3 posVC = posIS / vVCToIJK;
  return posVC.x * vPlaneNormal0 +
         posVC.y * vPlaneNormal2 +
         posVC.z * vPlaneNormal4 +
         vOriginVC;
}

// convert vector position from vc to idx
vec3 VCtoIS(vec3 posVC){
  posVC = posVC - vOriginVC;
  posVC = vec3(
    dot(posVC, vPlaneNormal0),
    dot(posVC, vPlaneNormal2),
    dot(posVC, vPlaneNormal4));
  return posVC * vVCToIJK;
}
#endif

//Rotate vector to view coordinate
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
void rotateToViewCoord(inout vec3 dirIS){
  dirIS.xyz =
    dirIS.x * vPlaneNormal0 +
    dirIS.y * vPlaneNormal2 +
    dirIS.z * vPlaneNormal4;
}

//Rotate vector to idx coordinate
vec3 rotateToIDX(vec3 dirVC){
  vec3 dirIS;
  dirIS.xyz = vec3(
    dot(dirVC, vPlaneNormal0),
    dot(dirVC, vPlaneNormal2),
    dot(dirVC, vPlaneNormal4));
  return dirIS;
}
#endif

//=======================================================================
// Given a normal compute the gradient opacity factors
float computeGradientOpacityFactor(
  float normalMag, float goscale, float goshift, float gomin, float gomax)
{
  return clamp(normalMag * goscale + goshift, gomin, gomax);
}

//=======================================================================
// compute the normal and gradient magnitude for a position, uses forward difference
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
  #ifdef vtkClippingPlanesOn
    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)
    {
      vec3 g1VC[3];
      for (int i = 0; i < 3; ++i)
      {
        g1VC[i] = IStoVC(texPos[i]);
      }
      vec3 posVC = IStoVC(pos);
      for (int i = 0; i < clip_numPlanes; ++i)
      {
        for (int j = 0; j < 3; ++j)
        {
          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)
          {
            g1[j] = 0.0;
          }
        }
      }
    }
  #endif

  #ifdef vtkComputeNormalFromOpacity
    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {
      vec3 opacityG1, opacityG2;
      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;
      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;
      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;
      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;
      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;
      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;
      opacityG1.xyz *= gradientOpacity;
      opacityG2.xyz *= gradientOpacity;

      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);
      // divide by spacing
      opacityG.xyz /= vSpacing;
      opacityG.w = length(opacityG.xyz);
      // rotate to View Coords
      rotateToViewCoord(opacityG.xyz);
      if (!all(equal(opacityG.xyz, vec3(0.0)))) {
        return vec4(normalize(opacityG.xyz),opacityG.w);
      } else {
        return vec4(0.0);
      }
    }

    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)
    {
      vec3 xvec = vec3(tstep.x, 0.0, 0.0);
      vec3 yvec = vec3(0.0, tstep.y, 0.0);
      vec3 zvec = vec3(0.0, 0.0, tstep.z);
      vec3 texPosPVec[3];
      texPosPVec[0] = pos + xvec;
      texPosPVec[1] = pos + yvec;
      texPosPVec[2] = pos + zvec;
      vec3 texPosNVec[3];
      texPosNVec[0] = pos - xvec;
      texPosNVec[1] = pos - yvec;
      texPosNVec[2] = pos - zvec;
      vec3 g1, g2;

      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];
      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];
      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];
      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];
      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];
      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];

      #ifdef vtkClippingPlanesOn
        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);
        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);
      #endif
      vec4 result;
      result.x = scalarInterp[0].x - scalarInterp[1].x;
      result.y = scalarInterp[0].y - scalarInterp[1].y;
      result.z = scalarInterp[0].z - scalarInterp[1].z;
      // divide by spacing
      result.xyz /= vSpacing;
      result.w = length(result.xyz);
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      if (length(result.xyz) > 0.0) {
        return vec4(normalize(result.xyz),result.w);
      } else {
        return vec4(0.0);
      }
    }
  #endif

  // only works with dependent components
  vec4 computeNormal(vec3 pos, vec3 tstep)
  {
    vec3 xvec = vec3(tstep.x, 0.0, 0.0);
    vec3 yvec = vec3(0.0, tstep.y, 0.0);
    vec3 zvec = vec3(0.0, 0.0, tstep.z);
    vec3 texPosPVec[3];
    texPosPVec[0] = pos + xvec;
    texPosPVec[1] = pos + yvec;
    texPosPVec[2] = pos + zvec;
    vec3 texPosNVec[3];
    texPosNVec[0] = pos - xvec;
    texPosNVec[1] = pos - yvec;
    texPosNVec[2] = pos - zvec;
    vec3 g1, g2;
    g1.x = getTextureValue(texPosPVec[0]).a;
    g1.y = getTextureValue(texPosPVec[1]).a;
    g1.z = getTextureValue(texPosPVec[2]).a;
    g2.x = getTextureValue(texPosNVec[0]).a;
    g2.y = getTextureValue(texPosNVec[1]).a;
    g2.z = getTextureValue(texPosNVec[2]).a;
    #ifdef vtkClippingPlanesOn
      adjustClippedVoxelValues(pos, texPosPVec, g1);
      adjustClippedVoxelValues(pos, texPosNVec, g2);
    #endif
    vec4 result;
    result = vec4(g1 - g2, -1.0);
    // divide by spacing
    result.xyz /= vSpacing;
    result.w = length(result.xyz);
    if (result.w > 0.0){
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      return vec4(normalize(result.xyz),result.w);
    } else {
      return vec4(0.0);
    }
  }
#endif

#ifdef vtkImageLabelOutlineOn
vec3 fragCoordToIndexSpace(vec4 fragCoord) {
  vec4 pcPos = vec4(
    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
    (fragCoord.z - 0.5) * 2.0,
    1.0);

  vec4 worldCoord = PCWCMatrix * pcPos;
  vec4 vertex = (worldCoord/worldCoord.w);

  vec3 index = (vWCtoIDX * vertex).xyz;

  // half voxel fix for labelmapOutline
  return (index + vec3(0.5)) / vec3(volumeDimensions);
}
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// global shadow - secondary ray
#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)
float random()
{
  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);
  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;
  uint pcg_state = floatBitsToUint(jitter);
  uint state = pcg_state;
  pcg_state = pcg_state * uint(747796405) + uint(2891336453);
  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);
  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;
}
#endif

#ifdef VolumeShadowOn
// henyey greenstein phase function
float phase_function(float cos_angle)
{
  // divide by 2.0 instead of 4pi to increase intensity
  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;
}

// Computes the intersection between a ray and a box
struct Hit
{
  float tmin;
  float tmax;
};

struct Ray
{
  vec3 origin;
  vec3 dir;
  vec3 invDir;
};

bool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)
{
  vec3 tbot = r.invDir * (boundMin - r.origin);
  vec3 ttop = r.invDir * (boundMax - r.origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 t = max(tmin.xx, tmin.yz);
  float t0 = max(t.x, t.y);
  t = min(tmax.xx, tmax.yz);
  float t1 = min(t.x, t.y);
  hit.tmin = t0;
  hit.tmax = t1;
  return t1 > max(t0,0.0);
}

// As BBoxIntersect requires the inverse of the ray coords,
// this function is used to avoid numerical issues
void safe_0_vector(inout Ray ray)
{
  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;
  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;
  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;
}

float volume_shadow(vec3 posIS, vec3 lightDirNormIS)
{
  float shadow = 1.0;
  float opacity = 0.0;

  // modify sample distance with a random number between 1.5 and 3.0
  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());
  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;

  // in case the first sample near surface has a very tiled light ray, we need to offset start position
  posIS += sampleDistanceISVS_jitter * lightDirNormIS;

  // compute the start and end points for the ray
  Ray ray;
  Hit hit;
  ray.origin = posIS;
  ray.dir = lightDirNormIS;
  safe_0_vector(ray);
  ray.invDir = 1.0/ray.dir;

  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))
  {
    return 1.0;
  }
  float maxdist = hit.tmax;

  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach
  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);
  maxdist = min(maxdist,maxgi);
  if(maxdist < EPSILON) {
    return 1.0;
  }

  float current_dist = 0.0;
  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);
  float clamped_step = 0.0;

  vec4 scalar = vec4(0.0);
  while(current_dist < maxdist)
  {
#ifdef vtkClippingPlanesOn
    vec3 posVC = IStoVC(posIS);
    for (int i = 0; i < clip_numPlanes; ++i)
    {
      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)
      {
        current_dist = maxdist;
      }
    }
#endif
    scalar = getTextureValue(posIS);
    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;
    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)
      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));
      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
    #endif
    shadow *= 1.0 - opacity;

    // optimization: early termination
    if (shadow < EPSILON){
      return 0.0;
    }

    clamped_step = min(maxdist - current_dist, current_step);
    posIS += clamped_step * lightDirNormIS;
    current_dist += current_step;
  }

  return shadow;
}

vec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)
{
  vec3 vertLight = vec3(0.0);
  vec3 secondary_contrib = vec3(0.0);
  // here we assume only positional light, no effect of cones
  for (int i = 0; i < lightNum; i++)
  {
    #if(vtkLightComplexity==3)
      if (lightPositional[i] == 1){
        vertLight = lightPositionVC[i] - IStoVC(posIS);
      }else{
        vertLight = - lightDirectionVC[i];
      }
    #else
      vertLight = - lightDirectionVC[i];
    #endif
    // here we assume achromatic light, only intensity
    float dDotL = dot(viewDirectionVC, normalize(vertLight));
    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity
    float phase_attenuation = 0.5;
    if (abs(anisotropy) > EPSILON){
      phase_attenuation = phase_function(dDotL);
    }
    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));
    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;
    secondary_contrib += tColor * vAmbient;
  }
  return secondary_contrib;
}
#endif

//=======================================================================
// local ambient occlusion
#ifdef localAmbientOcclusionOn
vec3 sample_direction_uniform(int i)
{
  float rand = random() * 0.5;
  float theta = PI2 * (kernelSample[i][0] + rand);
  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;
  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));
}

// return a matrix that transform startDir into z axis; startDir should be normalized
mat3 zBaseRotationalMatrix(vec3 startDir){
  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));
  float cosA = startDir.z;
  float k = 1.0 / (1.0 + cosA);
  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,
              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,
              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);
  return matrix;
}

float computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){
  // apply LAO only at selected locations, otherwise return full brightness
  if (normal.w > 0.0 && op > 0.05){
    float total_transmittance = 0.0;
    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));
    vec3 currPos, randomDirStep;
    float weight, transmittance, opacity;
    for (int i = 0; i < kernelSize; i++)
    {
      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;
      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));
      currPos = posIS;
      transmittance = 1.0;
      for (int j = 0; j < kernelRadius ; j++){
        currPos += randomDirStep;
        // check if it's at clipping plane, if so return full brightness
        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){
          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;
          #ifdef vtkGradientOpacityOn
             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
          #endif
          transmittance *= 1.0 - opacity;
        }
        else{
          break;
        }
      }
      total_transmittance += transmittance / float(kernelRadius) * weight;

      // early termination if fully translucent
      if (total_transmittance > 1.0 - EPSILON){
        return 1.0;
      }
    }
    // average transmittance and reduce variance
    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);
  } else {
    return 1.0;
  }
}
#endif

//=======================================================================
// surface light contribution
#if vtkLightComplexity > 0
  void applyLighting(inout vec3 tColor, vec4 normal)
  {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    float df, sf = 0.0;
    for (int i = 0; i < lightNum; i++){
        df = abs(dot(normal.rgb, -lightDirectionVC[i]));
        diffuse += df * lightColor[i];
        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);
        specular += sf * lightColor[i];
    }
    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
  }
  #ifdef SurfaceShadowOn
  #if vtkLightComplexity < 3
    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float ndotL,vdotR;
        vertLightDirection = lightDirectionVC[i];
        ndotL = dot(normal.xyz, vertLightDirection);
        if (ndotL < 0.0 && twoSidedLighting)
        {
          ndotL = -ndotL;
        }
        if (ndotL > 0.0)
        {
          diffuse += ndotL * lightColor[i];
          //specular
          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
          if (vdotR > 0.0)
          {
            specular += pow(vdotR, vSpecularPower) * lightColor[i];
          }
        }
        #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
        #endif
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #else
    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float distance,attenuation,ndotL,vdotR;
        vec3 lightDir;
        if (lightPositional[i] == 1){
          lightDir = lightDirectionVC[i];
          vertLightDirection = posVC - lightPositionVC[i];
          distance = length(vertLightDirection);
          vertLightDirection = normalize(vertLightDirection);
          attenuation = 1.0 / (lightAttenuation[i].x
                              + lightAttenuation[i].y * distance
                              + lightAttenuation[i].z * distance * distance);
          // per OpenGL standard cone angle is 90 or less for a spot light
          if (lightConeAngle[i] <= 90.0){
            float coneDot = dot(vertLightDirection, lightDir);
            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone
              attenuation = attenuation * pow(coneDot, lightExponent[i]);
            }
            else {
              attenuation = 0.0;
            }
          }
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * attenuation * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        } else {
          vertLightDirection = lightDirectionVC[i];
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        }
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #endif
  #endif
#endif

// LAO of surface shadows and volume shadows only work with dependent components
vec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {
  #if vtkLightComplexity > 0
    // surface shadows if needed
    #ifdef SurfaceShadowOn
      #if vtkLightComplexity < 3
        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);
      #else
        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));
      #endif
    #endif

    // volume shadows if needed
    #ifdef VolumeShadowOn
      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);
    #endif

    // merge
    #ifdef VolumeShadowOn
      #ifdef SurfaceShadowOn
        // surface shadows + volumetric shadows
        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);
        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;
      #else
        // volumetric shadows only
        tColor = tColorVS;
      #endif
    #else
      #ifdef SurfaceShadowOn
        // surface shadows only
        tColor = tColorS;
      #else
        // no shadows
        applyLighting(tColor, normal3);
      #endif
    #endif
  #endif
  return tColor;
}

//=======================================================================
// Given a texture value compute the color and opacity
//
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{
#ifdef vtkImageLabelOutlineOn
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  int segmentIndex = int(centerValue.r * 255.0);
  
  // Use texture sampling for outlineThickness
  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

  int actualThickness = int(textureValue * 255.0);


  // If it is the background (segment index 0), we should quickly bail out. 
  // Previously, this was determined by tColor.a, which was incorrect as it
  // prevented the outline from appearing when the fill is 0.
  if (segmentIndex == 0){
    return vec4(0, 0, 0, 0);
  }

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  for (int i = -actualThickness; i <= actualThickness; i++) {
    for (int j = -actualThickness; j <= actualThickness; j++) {
      if (i == 0 || j == 0) {
        continue;
      }

      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
        gl_FragCoord.y + float(j),
        gl_FragCoord.z, gl_FragCoord.w);

      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
      vec4 value = getTextureValue(neighborPosIS);

      // If any of my neighbours are not the same value as I
      // am, this means I am on the border of the segment.
      // We can break the loops
      if (any(notEqual(value, centerValue))) {
        pixelOnBorder = true;
        break;
      }
    }

    if (pixelOnBorder == true) {
      break;
    }
  }

  // If I am on the border, I am displayed at full opacity
  if (pixelOnBorder == true) {
    tColor.a = outlineOpacity;
  }

  return tColor;

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4

  #ifdef UseIndependentComponents
    // sample textures
    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;

    #if vtkNumComponents > 1
      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;

      #if vtkNumComponents > 2
        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;

        #if vtkNumComponents > 3
          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #endif
      #endif
    #endif

    #if !defined(vtkCustomComponentsColorMix)
      // default path for component color mix

      // compute the normal vectors as needed
      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #endif

      // compute gradient opacity factors as needed
      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);
      #if defined(vtkGradientOpacityOn)
        #if !defined(vtkComponent0Proportional)
          goFactor.x =
            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
        #endif
        #if vtkNumComponents > 1
          #if !defined(vtkComponent1Proportional)
            goFactor.y =
              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          #endif
          #if vtkNumComponents > 2
            #if !defined(vtkComponent2Proportional)
              goFactor.z =
                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);
            #endif
            #if vtkNumComponents > 3
              #if !defined(vtkComponent3Proportional)
                goFactor.w =
                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);
              #endif
            #endif
          #endif
        #endif
      #endif

      // process color and opacity for each component
      #if !defined(vtkComponent0Proportional)
        float alpha = goFactor.x*mix0*pwfValue0;
        #if vtkLightComplexity > 0
          applyLighting(tColor0, normalMat[0]);
        #endif
      #else
        tColor0 *= pwfValue0;
        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));
      #endif

      #if vtkNumComponents > 1
        #if !defined(vtkComponent1Proportional)
          alpha += goFactor.y*mix1*pwfValue1;
          #if vtkLightComplexity > 0
            applyLighting(tColor1, normalMat[1]);
          #endif
        #else
          tColor1 *= pwfValue1;
          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));
        #endif

        #if vtkNumComponents > 2
          #if !defined(vtkComponent2Proportional)
            alpha += goFactor.z*mix2*pwfValue2;
            #if vtkLightComplexity > 0
              applyLighting(tColor2, normalMat[2]);
            #endif
          #else
            tColor2 *= pwfValue2;
            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));
          #endif
        #endif

        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            alpha += goFactor.w*mix3*pwfValue3;
            #if vtkLightComplexity > 0
              applyLighting(tColor3, normalMat[3]);
            #endif
          #else
            tColor3 *= pwfValue3;
            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));
          #endif
        #endif
      #endif

      // perform final independent blend
      vec3 tColor = mix0 * tColor0;
      #if vtkNumComponents > 1
        tColor += mix1 * tColor1;
        #if vtkNumComponents > 2
          tColor += mix2 * tColor2;
          #if vtkNumComponents > 3
            tColor += mix3 * tColor3;
          #endif
        #endif
      #endif

      return vec4(tColor, alpha);
    #else
      /*
       * Mix the color information from all the independent components to get a single rgba output
       * Gradient opactity factors and normals are not computed
       *
       * You can compute these using:
       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix
       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),
       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper
       * - computeGradientOpacityFactor: always available, used in a lot of places
       *
       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)
       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight
       */
      //VTK::CustomComponentsColorMix::Impl
    #endif
  #else
    // dependent components

    // compute normal if needed
    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value
      #ifdef vtkComputeNormalFromOpacity
        vec3 scalarInterp[2];
        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);
      #else
        vec4 normal0 = computeNormal(posIS, tstep);
      #endif
    #endif

    // compute gradient opacity factor enabled
    #if defined(vtkGradientOpacityOn)
      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);
    #else
      const float gradientOpacity = 1.0;
    #endif

    // get color and opacity
    #if vtkNumComponents == 1
      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      if (alpha < EPSILON){
        return vec4(0.0);
      }
    #endif
    #if vtkNumComponents == 2
      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    #endif
    #if vtkNumComponents == 3
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
    #endif
    #if vtkNumComponents == 4
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
    #endif

    // lighting
    #if (vtkLightComplexity > 0)
      #ifdef vtkComputeNormalFromOpacity
        vec4 normalLight;
        if (!all(equal(normal0, vec4(0.0)))) {
          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;
          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;
          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);
          if (all(equal(normalLight, vec4(0.0)))) {
            normalLight = normal0;
          }
        }
      #else
        vec4 normalLight = normal0;
      #endif
      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);
    #endif

    return vec4(tColor, alpha);
  #endif // dependent
#endif
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #else
    #ifdef UseIndependentComponents
      #if vtkNumComponents == 2
        if (val.r >= min.r && val.r <= max.r &&
            val.g >= min.g && val.g <= max.g) {
          withinRange = true;
        }
      #else
        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
            all(lessThanEqual(val, ipScalarRangeMax))) {
          withinRange = true;
        }
      #endif
    #endif
  #endif
  return withinRange;
}

//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);

  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
  #if vtkBlendMode == 5 // RADON
    float normalizedRayIntensity = 1.0;

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tValue = getTextureValue(posIS);
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));
      return;
    }

    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar value
      tValue = getTextureValue(posIS);

      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;

      posIS += stepIS;
      stepsTraveled++;
    }

    // map normalizedRayIntensity to color
    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));

  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
  #ifdef VolumeShadowOn
    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;
  #endif
}

void main()
{

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, tdims);
}
`;
  const { vtkWarningMacro: SJ, vtkErrorMacro: P4 } = di;
  function _T(t, e, n) {
    return t ? `${t.getMTime()}-${e}-${n}` : "0";
  }
  function AJ(t) {
    switch (t) {
      case _g.CUSTOM:
        return "//VTK::CustomColorMix";
      case _g.ADDITIVE:
        return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);

          vec3 scalarInterp1[2];
          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);
          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;
          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;
          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
          vec4 normalLight1 = normalMat[1];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        float opacity1 = pwfValue1;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          opacity1 *= gof1;
        #endif
        float opacitySum = opacity0 + opacity1;
        if (opacitySum <= 0.0) {
          return vec4(0.0);
        }

        // mix the colors and opacities
        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);
        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);
        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;
        return vec4(mixedColor, min(1.0, opacitySum));
`;
      case _g.COLORIZE:
        return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
        #endif

        // mix the colors and opacities
        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);
        color = applyAllLightning(color, opacity0, posIS, normalLight0);
        return vec4(color, opacity0);
`;
      default:
        return null;
    }
  }
  function EJ(t, e) {
    e.classHierarchy.push("vtkOpenGLVolumeMapper"), t.buildPass = () => {
      e.zBufferTexture = null;
    }, t.zBufferPass = (r, i) => {
      if (r) {
        const a = i.getZBufferTexture();
        a !== e.zBufferTexture && (e.zBufferTexture = a);
      }
    }, t.opaqueZBufferPass = (r, i) => t.zBufferPass(r, i), t.volumePass = (r, i) => {
      if (r) {
        e._openGLRenderWindow = t.getFirstAncestorOfType("vtkOpenGLRenderWindow"), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow), e.jitterTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.scalarTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.opacityTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.labelOutlineThicknessTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.openGLVolume = t.getFirstAncestorOfType("vtkOpenGLVolume");
        const a = e.openGLVolume.getRenderable();
        e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer");
        const s = e._openGLRenderer.getRenderable();
        e.openGLCamera = e._openGLRenderer.getViewNodeFor(s.getActiveCamera()), t.renderPiece(s, a);
      }
    }, t.getShaderTemplate = (r, i, a) => {
      r.Vertex = CJ, r.Fragment = TJ, r.Geometry = "";
    }, t.useIndependentComponents = (r) => {
      var _a3, _b3, _c3;
      const i = r.getIndependentComponents(), s = (_c3 = (_b3 = (_a3 = e.currentInput) == null ? void 0 : _a3.getPointData()) == null ? void 0 : _b3.getScalars()) == null ? void 0 : _c3.getNumberOfComponents(), o = r.getColorMixPreset();
      return i && s >= 2 || !!o;
    }, t.replaceShaderValues = (r, i, a) => {
      const s = a.getProperty();
      let o = r.Fragment;
      s.getInterpolationType() === h6.LINEAR && (o = se.substitute(o, "//VTK::TrilinearOn", "#define vtkTrilinearOn").result), s.getUseLabelOutline() === true && (o = se.substitute(o, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result);
      const f = e.scalarTexture.getComponents();
      o = se.substitute(o, "//VTK::NumComponents", `#define vtkNumComponents ${f}`).result;
      const u = t.useIndependentComponents(s);
      u && (o = se.substitute(o, "//VTK::IndependentComponentsOn", "#define UseIndependentComponents").result);
      const h = [], g = [];
      for (let E = 0; E < f; E++) s.getOpacityMode(E) === HR.PROPORTIONAL && h.push(`#define vtkComponent${E}Proportional`), s.getForceNearestInterpolation(E) && g.push(`#define vtkComponent${E}ForceNearest`);
      o = se.substitute(o, "//VTK::vtkProportionalComponents", h.join(`
`)).result, o = se.substitute(o, "//VTK::vtkForceNearestComponents", g.join(`
`)).result;
      const v = s.getColorMixPreset(), m = AJ(v);
      m && (o = se.substitute(o, "//VTK::CustomComponentsColorMixOn", "#define vtkCustomComponentsColorMix").result, o = se.substitute(o, "//VTK::CustomComponentsColorMix::Impl", m).result);
      const y = e.currentInput.getSpatialExtent(), w = e.currentInput.getSpacing(), C = new Float64Array(3);
      Vn(C, (y[1] - y[0]) * w[0], (y[3] - y[2]) * w[1], (y[5] - y[4]) * w[2]);
      const T = yu(C) / t.getCurrentSampleDistance(i);
      o = se.substitute(o, "//VTK::MaximumSamplesValue", `${Math.ceil(T)}`).result, o = se.substitute(o, "//VTK::LightComplexity", `#define vtkLightComplexity ${e.lightComplexity}`).result, e.lightComplexity > 0 && (e.renderable.getVolumetricScatteringBlending() > 0 && (o = se.substitute(o, "//VTK::VolumeShadowOn", "#define VolumeShadowOn").result), e.renderable.getVolumetricScatteringBlending() < 1 && (o = se.substitute(o, "//VTK::SurfaceShadowOn", "#define SurfaceShadowOn").result), e.renderable.getLocalAmbientOcclusion() && s.getAmbient() > 0 && (o = se.substitute(o, "//VTK::localAmbientOcclusionOn", "#define localAmbientOcclusionOn").result));
      const S = u ? f : 1;
      e.gopacity = false;
      for (let E = 0; !e.gopacity && E < S; ++E) e.gopacity || (e.gopacity = s.getUseGradientOpacity(E));
      e.gopacity && (o = se.substitute(o, "//VTK::GradientOpacityOn", "#define vtkGradientOpacityOn").result), e.renderable.getComputeNormalFromOpacity() && (o = se.substitute(o, "//VTK::vtkComputeNormalFromOpacity", "#define vtkComputeNormalFromOpacity").result), e.zBufferTexture !== null && (o = se.substitute(o, "//VTK::ZBuffer::Dec", [
        "uniform sampler2D zBufferTexture;",
        "uniform float vpZWidth;",
        "uniform float vpZHeight;"
      ]).result, o = se.substitute(o, "//VTK::ZBuffer::Impl", [
        "vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));",
        "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;",
        "zdepth = zdepth * 2.0 - 1.0;",
        "if (cameraParallel == 0) {",
        "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}",
        "else {",
        `zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}
`,
        "zdepth = -zdepth/rayDir.z;",
        "dists.y = min(zdepth,dists.y);"
      ]).result), o = se.substitute(o, "//VTK::BlendMode", `${e.renderable.getBlendMode()}`).result, r.Fragment = o, t.replaceShaderLight(r, i, a), t.replaceShaderClippingPlane(r, i, a);
    }, t.replaceShaderLight = (r, i, a) => {
      if (e.lightComplexity === 0) return;
      let s = r.Fragment, o = 0;
      i.getLights().forEach((l) => {
        l.getSwitch() && (o += 1);
      }), s = se.substitute(s, "//VTK::Light::Dec", [
        "uniform int lightNum;",
        "uniform bool twoSidedLighting;",
        `uniform vec3 lightColor[${o}];`,
        `uniform vec3 lightDirectionVC[${o}]; // normalized`,
        `uniform vec3 lightHalfAngleVC[${o}];`,
        "//VTK::Light::Dec"
      ], false).result, e.lightComplexity === 3 && (s = se.substitute(s, "//VTK::Light::Dec", [
        `uniform vec3 lightPositionVC[${o}];`,
        `uniform vec3 lightAttenuation[${o}];`,
        `uniform float lightConeAngle[${o}];`,
        `uniform float lightExponent[${o}];`,
        `uniform int lightPositional[${o}];`
      ], false).result), e.renderable.getVolumetricScatteringBlending() > 0 && (s = se.substitute(s, "//VTK::VolumeShadow::Dec", [
        "uniform float volumetricScatteringBlending;",
        "uniform float giReach;",
        "uniform float volumeShadowSamplingDistFactor;",
        "uniform float anisotropy;",
        "uniform float anisotropy2;"
      ], false).result), e.renderable.getLocalAmbientOcclusion() && a.getProperty().getAmbient() > 0 && (s = se.substitute(s, "//VTK::LAO::Dec", [
        "uniform int kernelRadius;",
        `uniform vec2 kernelSample[${e.renderable.getLAOKernelRadius()}];`,
        "uniform int kernelSize;"
      ], false).result), r.Fragment = s;
    }, t.replaceShaderClippingPlane = (r, i, a) => {
      let s = r.Fragment;
      if (e.renderable.getClippingPlanes().length > 0) {
        const o = e.renderable.getClippingPlanes().length;
        s = se.substitute(s, "//VTK::ClipPlane::Dec", [
          "uniform vec3 vClipPlaneNormals[6];",
          "uniform float vClipPlaneDistances[6];",
          "uniform vec3 vClipPlaneOrigins[6];",
          "uniform int clip_numPlanes;",
          "//VTK::ClipPlane::Dec",
          "#define vtkClippingPlanesOn"
        ], false).result, s = se.substitute(s, "//VTK::ClipPlane::Impl", [
          `for(int i = 0; i < ${o}; i++) {`,
          "  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);",
          "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];",
          "  if (rayDirRatio == 0.0)",
          "  {",
          "    if (equationResult < 0.0) dists.x = dists.y;",
          "    continue;",
          "  }",
          "  float result = -1.0 * equationResult / rayDirRatio;",
          "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);",
          "  else dists.x = max(dists.x, result);",
          "}",
          "//VTK::ClipPlane::Impl"
        ], false).result;
      }
      r.Fragment = s;
    };
    const n = (r, i) => {
      let a = 0;
      r.getProperty().getShade() && e.renderable.getBlendMode() === mb.COMPOSITE_BLEND && (a = 0, e.numberOfLights = 0, i.forEach((s) => {
        s.getSwitch() > 0 && (e.numberOfLights++, a === 0 && (a = 1)), a === 1 && (e.numberOfLights > 1 || s.getIntensity() !== 1 || !s.lightTypeIsHeadLight()) && (a = 2), a < 3 && s.getPositional() && (a = 3);
      })), a !== e.lightComplexity && (e.lightComplexity = a, t.modified());
    };
    t.getNeedToRebuildShaders = (r, i, a) => {
      var _a3;
      const s = a.getProperty();
      n(a, i.getLights());
      const o = e.scalarTexture.getComponents(), l = [], c = [];
      for (let y = 0; y < o; y++) l.push(s.getOpacityMode(y)), c.push(s.getForceNearestInterpolation(y));
      const f = e.currentInput.getSpatialExtent(), u = e.currentInput.getSpacing(), h = new Float64Array(3);
      Vn(h, (f[1] - f[0]) * u[0], (f[3] - f[2]) * u[1], (f[5] - f[4]) * u[2]);
      const g = yu(h) / t.getCurrentSampleDistance(i), v = !!e.zBufferTexture, m = {
        iComps: s.getIndependentComponents(),
        colorMixPreset: s.getColorMixPreset(),
        interpolationType: s.getInterpolationType(),
        useLabelOutline: s.getUseLabelOutline(),
        numComp: o,
        maxSamples: g,
        useGradientOpacity: s.getUseGradientOpacity(0),
        blendMode: e.renderable.getBlendMode(),
        hasZBufferTexture: v,
        opacityModes: l,
        forceNearestInterps: c
      };
      return ((_a3 = r.getProgram()) == null ? void 0 : _a3.getHandle()) === 0 || r.getShaderSourceTime().getMTime() < t.getMTime() || r.getShaderSourceTime().getMTime() < e.renderable.getMTime() || !e.previousState || !wb(e.previousState, m) ? (e.previousState = m, true) : false;
    }, t.updateShaders = (r, i, a) => {
      if (t.getNeedToRebuildShaders(r, i, a)) {
        const s = {
          Vertex: null,
          Fragment: null,
          Geometry: null
        };
        t.buildShaders(s, i, a);
        const o = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(s.Vertex, s.Fragment, s.Geometry);
        o !== r.getProgram() && (r.setProgram(o), r.getVAO().releaseGraphicsResources()), r.getShaderSourceTime().modified();
      } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(r.getProgram());
      r.getVAO().bind(), t.setMapperShaderParameters(r, i, a), t.setCameraShaderParameters(r, i, a), t.setPropertyShaderParameters(r, i, a), t.getClippingPlaneShaderParameters(r, i, a);
    }, t.setMapperShaderParameters = (r, i, a) => {
      const s = r.getProgram();
      r.getCABO().getElementCount() && (e.VBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime()) && (s.isAttributeUsed("vertexDC") && (r.getVAO().addAttributeArray(s, r.getCABO(), "vertexDC", r.getCABO().getVertexOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || P4("Error setting vertexDC in shader VAO.")), r.getAttributeUpdateTime().modified()), s.setUniformi("texture1", e.scalarTexture.getTextureUnit()), s.setUniformf("sampleDistance", t.getCurrentSampleDistance(i));
      const o = e.scalarTexture.getVolumeInfo(), l = e.renderable.getIpScalarRange(), c = [], f = [];
      for (let u = 0; u < 4; u++) c[u] = l[0] * o.dataComputedScale[u] + o.dataComputedOffset[u], f[u] = l[1] * o.dataComputedScale[u] + o.dataComputedOffset[u], c[u] = (c[u] - o.offset[u]) / o.scale[u], f[u] = (f[u] - o.offset[u]) / o.scale[u];
      if (s.setUniform4f("ipScalarRangeMin", c[0], c[1], c[2], c[3]), s.setUniform4f("ipScalarRangeMax", f[0], f[1], f[2], f[3]), e.zBufferTexture !== null) {
        s.setUniformi("zBufferTexture", e.zBufferTexture.getTextureUnit());
        const u = e._useSmallViewport ? [
          e._smallViewportWidth,
          e._smallViewportHeight
        ] : e._openGLRenderWindow.getFramebufferSize();
        s.setUniformf("vpZWidth", u[0]), s.setUniformf("vpZHeight", u[1]);
      }
    }, t.setCameraShaderParameters = (r, i, a) => {
      const s = e.openGLCamera.getKeyMatrices(i), o = e.openGLVolume.getKeyMatrices();
      tn(e.modelToView, s.wcvc, o.mcwc);
      const l = r.getProgram(), c = e.openGLCamera.getRenderable(), f = c.getClippingRange();
      l.setUniformf("camThick", f[1] - f[0]), l.setUniformf("camNear", f[0]), l.setUniformf("camFar", f[1]);
      const u = e.currentInput.getBounds(), h = e.currentInput.getDimensions(), g = new Float64Array(3), v = new Float64Array(3);
      let m = 1, y = -1, w = 1, C = -1;
      for (let k = 0; k < 8; ++k) {
        if (Vn(g, u[k % 2], u[2 + Math.floor(k / 2) % 2], u[4 + Math.floor(k / 4)]), $t(g, g, e.modelToView), !c.getParallelProjection()) {
          cs(v, g);
          const _ = -f[0] / g[2];
          so(g, v, _);
        }
        $t(g, g, s.vcpc), m = Math.min(g[0], m), y = Math.max(g[0], y), w = Math.min(g[1], w), C = Math.max(g[1], C);
      }
      l.setUniformf("dcxmin", m), l.setUniformf("dcxmax", y), l.setUniformf("dcymin", w), l.setUniformf("dcymax", C), l.isUniformUsed("cameraParallel") && l.setUniformi("cameraParallel", c.getParallelProjection());
      const T = e.currentInput.getSpatialExtent(), S = e.currentInput.getSpacing(), E = new Float64Array(3);
      Vn(E, (T[1] - T[0]) * S[0], (T[3] - T[2]) * S[1], (T[5] - T[4]) * S[2]), l.setUniform3f("vSpacing", S[0], S[1], S[2]), Vn(g, T[0], T[2], T[4]), e.currentInput.indexToWorldVec3(g, g), $t(g, g, e.modelToView), l.setUniform3f("vOriginVC", g[0], g[1], g[2]);
      const b = e.currentInput.getIndexToWorld();
      tn(e.idxToView, e.modelToView, b), Ou(e.idxNormalMatrix, s.normalMatrix, o.normalMatrix), Ou(e.idxNormalMatrix, e.idxNormalMatrix, e.currentInput.getDirectionByReference());
      const D = yu(E) / t.getCurrentSampleDistance(i);
      D > e.renderable.getMaximumSamplesPerRay() && SJ(`The number of steps required ${Math.ceil(D)} is larger than the
        specified maximum number of steps ${e.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);
      const R = new Float64Array(3);
      if (Vn(R, 1, 1, 1), VY(R, R, E), l.setUniform3f("vVCToIJK", R[0], R[1], R[2]), l.setUniform3i("volumeDimensions", h[0], h[1], h[2]), !e._openGLRenderWindow.getWebgl2()) {
        const k = e.scalarTexture.getVolumeInfo();
        l.setUniformf("texWidth", e.scalarTexture.getWidth()), l.setUniformf("texHeight", e.scalarTexture.getHeight()), l.setUniformi("xreps", k.xreps), l.setUniformi("xstride", k.xstride), l.setUniformi("ystride", k.ystride);
      }
      const I = new Float64Array(3), O = new Float64Array(3);
      for (let k = 0; k < 6; ++k) {
        switch (k) {
          case 1:
            Vn(I, -1, 0, 0), Vn(O, T[0], T[2], T[4]);
            break;
          case 2:
            Vn(I, 0, 1, 0), Vn(O, T[1], T[3], T[5]);
            break;
          case 3:
            Vn(I, 0, -1, 0), Vn(O, T[0], T[2], T[4]);
            break;
          case 4:
            Vn(I, 0, 0, 1), Vn(O, T[1], T[3], T[5]);
            break;
          case 5:
            Vn(I, 0, 0, -1), Vn(O, T[0], T[2], T[4]);
            break;
          case 0:
          default:
            Vn(I, 1, 0, 0), Vn(O, T[1], T[3], T[5]);
            break;
        }
        Ug(I, I, e.idxNormalMatrix), $t(O, O, e.idxToView);
        const _ = -1 * Sh(O, I);
        l.setUniform3f(`vPlaneNormal${k}`, I[0], I[1], I[2]), l.setUniformf(`vPlaneDistance${k}`, _);
      }
      if (a.getProperty().getUseLabelOutline()) {
        const _ = e.currentInput.getWorldToIndex();
        l.setUniformMatrix("vWCtoIDX", _);
        const K = i.getActiveCamera(), [Z, j] = K.getClippingRange(), B = K.getDistance();
        K.setClippingRange(B, B + 0.1);
        const Y = e.openGLCamera.getKeyMatrices(i);
        Nr(e.projectionToWorld, Y.wcpc), K.setClippingRange(Z, j), e.openGLCamera.getKeyMatrices(i), l.setUniformMatrix("PCWCMatrix", e.projectionToWorld);
        const X = t.getRenderTargetSize();
        l.setUniformf("vpWidth", X[0]), l.setUniformf("vpHeight", X[1]);
        const ie = t.getRenderTargetOffset();
        l.setUniformf("vpOffsetX", ie[0] / X[0]), l.setUniformf("vpOffsetY", ie[1] / X[1]);
      }
      if (Nr(e.projectionToView, s.vcpc), l.setUniformMatrix("PCVCMatrix", e.projectionToView), e.lightComplexity === 0) return;
      let L = 0;
      const N = [], F = [], V = [];
      if (i.getLights().forEach((k) => {
        if (k.getSwitch() > 0) {
          const K = k.getColor(), Z = k.getIntensity();
          N[0 + L * 3] = K[0] * Z, N[1 + L * 3] = K[1] * Z, N[2 + L * 3] = K[2] * Z;
          const j = k.getDirection();
          Vn(I, j[0], j[1], j[2]), Ug(I, I, s.normalMatrix), cs(I, I), F[0 + L * 3] = I[0], F[1 + L * 3] = I[1], F[2 + L * 3] = I[2], V[0 + L * 3] = -0.5 * I[0], V[1 + L * 3] = -0.5 * I[1], V[2 + L * 3] = -0.5 * (I[2] - 1), L++;
        }
      }), l.setUniformi("twoSidedLighting", i.getTwoSidedLighting()), l.setUniformi("lightNum", L), l.setUniform3fv("lightColor", N), l.setUniform3fv("lightDirectionVC", F), l.setUniform3fv("lightHalfAngleVC", V), e.lightComplexity === 3) {
        L = 0;
        const k = [], _ = [], K = [], Z = [], j = [];
        i.getLights().forEach((B) => {
          if (B.getSwitch() > 0) {
            const X = B.getAttenuationValues();
            _[0 + L * 3] = X[0], _[1 + L * 3] = X[1], _[2 + L * 3] = X[2], Z[L] = B.getExponent(), K[L] = B.getConeAngle(), j[L] = B.getPositional();
            const ie = B.getTransformedPosition();
            $t(ie, ie, e.modelToView), k[0 + L * 3] = ie[0], k[1 + L * 3] = ie[1], k[2 + L * 3] = ie[2], L += 1;
          }
        }), l.setUniform3fv("lightPositionVC", k), l.setUniform3fv("lightAttenuation", _), l.setUniformfv("lightConeAngle", K), l.setUniformfv("lightExponent", Z), l.setUniformiv("lightPositional", j);
      }
      if (e.renderable.getVolumetricScatteringBlending() > 0 && (l.setUniformf("giReach", e.renderable.getGlobalIlluminationReach()), l.setUniformf("volumetricScatteringBlending", e.renderable.getVolumetricScatteringBlending()), l.setUniformf("volumeShadowSamplingDistFactor", e.renderable.getVolumeShadowSamplingDistFactor()), l.setUniformf("anisotropy", e.renderable.getAnisotropy()), l.setUniformf("anisotropy2", e.renderable.getAnisotropy() ** 2)), e.renderable.getLocalAmbientOcclusion() && a.getProperty().getAmbient() > 0) {
        const k = e.renderable.getLAOKernelSize();
        l.setUniformi("kernelSize", k);
        const _ = [];
        for (let K = 0; K < k; K++) _[K * 2] = Math.random() * 0.5, _[K * 2 + 1] = Math.random() * 0.5;
        l.setUniform2fv("kernelSample", _), l.setUniformi("kernelRadius", e.renderable.getLAOKernelRadius());
      }
    }, t.setPropertyShaderParameters = (r, i, a) => {
      const s = r.getProgram();
      s.setUniformi("ctexture", e.colorTexture.getTextureUnit()), s.setUniformi("otexture", e.opacityTexture.getTextureUnit()), s.setUniformi("jtexture", e.jitterTexture.getTextureUnit()), s.setUniformi("ttexture", e.labelOutlineThicknessTexture.getTextureUnit());
      const o = e.scalarTexture.getVolumeInfo(), l = a.getProperty(), c = e.scalarTexture.getComponents(), f = t.useIndependentComponents(l);
      if (f) for (let h = 0; h < c; h++) s.setUniformf(`mix${h}`, a.getProperty().getComponentWeight(h));
      for (let h = 0; h < c; h++) {
        const g = f ? h : 0, v = o.scale[h], y = l.getScalarOpacity(g).getRange(), w = v / (y[1] - y[0]), C = (o.offset[h] - y[0]) / (y[1] - y[0]);
        s.setUniformf(`oshift${h}`, C), s.setUniformf(`oscale${h}`, w);
        const S = l.getRGBTransferFunction(g).getRange(), E = (o.offset[h] - S[0]) / (S[1] - S[0]), b = v / (S[1] - S[0]);
        s.setUniformf(`cshift${h}`, E), s.setUniformf(`cscale${h}`, b);
      }
      if (e.gopacity) if (f) for (let h = 0; h < c; ++h) {
        const g = o.scale[h];
        if (l.getUseGradientOpacity(h)) {
          const m = l.getGradientOpacityMinimumOpacity(h), y = l.getGradientOpacityMaximumOpacity(h);
          s.setUniformf(`gomin${h}`, m), s.setUniformf(`gomax${h}`, y);
          const w = [
            l.getGradientOpacityMinimumValue(h),
            l.getGradientOpacityMaximumValue(h)
          ];
          s.setUniformf(`goscale${h}`, g * (y - m) / (w[1] - w[0])), s.setUniformf(`goshift${h}`, -w[0] * (y - m) / (w[1] - w[0]) + m);
        } else s.setUniformf(`gomin${h}`, 1), s.setUniformf(`gomax${h}`, 1), s.setUniformf(`goscale${h}`, 0), s.setUniformf(`goshift${h}`, 1);
      }
      else {
        const h = o.scale[c - 1], g = l.getGradientOpacityMinimumOpacity(0), v = l.getGradientOpacityMaximumOpacity(0);
        s.setUniformf("gomin0", g), s.setUniformf("gomax0", v);
        const m = [
          l.getGradientOpacityMinimumValue(0),
          l.getGradientOpacityMaximumValue(0)
        ];
        s.setUniformf("goscale0", h * (v - g) / (m[1] - m[0])), s.setUniformf("goshift0", -m[0] * (v - g) / (m[1] - m[0]) + g);
      }
      if (a.getProperty().getUseLabelOutline() === true) {
        const h = a.getProperty().getLabelOutlineOpacity();
        s.setUniformf("outlineOpacity", h);
      }
      e.lightComplexity > 0 && (s.setUniformf("vAmbient", l.getAmbient()), s.setUniformf("vDiffuse", l.getDiffuse()), s.setUniformf("vSpecular", l.getSpecular()), s.setUniformf("vSpecularPower", l.getSpecularPower()));
    }, t.getClippingPlaneShaderParameters = (r, i, a) => {
      if (e.renderable.getClippingPlanes().length > 0) {
        const s = e.openGLCamera.getKeyMatrices(i), o = [], l = [], c = [], f = e.renderable.getClippingPlanes(), u = f.length;
        for (let g = 0; g < u; ++g) {
          const v = f[g].getNormal(), m = f[g].getOrigin();
          Ug(v, v, s.normalMatrix), $t(m, m, s.wcvc);
          const y = -1 * Sh(m, v);
          o.push(v[0]), o.push(v[1]), o.push(v[2]), l.push(y), c.push(m[0]), c.push(m[1]), c.push(m[2]);
        }
        const h = r.getProgram();
        h.setUniform3fv("vClipPlaneNormals", o), h.setUniformfv("vClipPlaneDistances", l), h.setUniform3fv("vClipPlaneOrigins", c), h.setUniformi("clip_numPlanes", u);
      }
    }, t.delete = x8(() => {
      e._animationRateSubscription && (e._animationRateSubscription.unsubscribe(), e._animationRateSubscription = null);
    }, t.delete), t.getRenderTargetSize = () => {
      if (e._useSmallViewport) return [
        e._smallViewportWidth,
        e._smallViewportHeight
      ];
      const { usize: r, vsize: i } = e._openGLRenderer.getTiledSizeAndOrigin();
      return [
        r,
        i
      ];
    }, t.getRenderTargetOffset = () => {
      const { lowerLeftU: r, lowerLeftV: i } = e._openGLRenderer.getTiledSizeAndOrigin();
      return [
        r,
        i
      ];
    }, t.getCurrentSampleDistance = (r) => {
      const i = r.getVTKWindow().getInteractor(), a = e.renderable.getSampleDistance();
      if (i.isAnimating()) {
        const s = e.renderable.getInteractionSampleDistanceFactor();
        return a * s;
      }
      return a;
    }, t.renderPieceStart = (r, i) => {
      const a = r.getVTKWindow().getInteractor();
      if (e._lastScale || (e._lastScale = e.renderable.getInitialInteractionScale()), e._useSmallViewport = false, a.isAnimating() && e._lastScale > 1.5 && (e._useSmallViewport = true), e._animationRateSubscription || (e._animationRateSubscription = a.onAnimationFrameRateUpdate(() => {
        if (e.renderable.getAutoAdjustSampleDistances()) {
          const o = a.getRecentAnimationFrameRate(), l = a.getDesiredUpdateRate() / o;
          (l > 1.15 || l < 0.85) && (e._lastScale *= l), e._lastScale > 400 && (e._lastScale = 400), e._lastScale < 1.5 && (e._lastScale = 1.5);
        } else e._lastScale = e.renderable.getImageSampleDistance() * e.renderable.getImageSampleDistance();
      })), e._useSmallViewport) {
        const o = e._openGLRenderWindow.getFramebufferSize(), l = 1 / Math.sqrt(e._lastScale);
        if (e._smallViewportWidth = Math.ceil(l * o[0]), e._smallViewportHeight = Math.ceil(l * o[1]), e._smallViewportHeight > o[1] && (e._smallViewportHeight = o[1]), e._smallViewportWidth > o[0] && (e._smallViewportWidth = o[0]), e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.getGLFramebuffer() === null) e.framebuffer.create(o[0], o[1]), e.framebuffer.populateFramebuffer();
        else {
          const f = e.framebuffer.getSize();
          (!f || f[0] !== o[0] || f[1] !== o[1]) && (e.framebuffer.create(o[0], o[1]), e.framebuffer.populateFramebuffer());
        }
        e.framebuffer.bind();
        const c = e.context;
        c.clearColor(0, 0, 0, 0), c.colorMask(true, true, true, true), c.clear(c.COLOR_BUFFER_BIT), c.viewport(0, 0, e._smallViewportWidth, e._smallViewportHeight), e.fvp = [
          e._smallViewportWidth / o[0],
          e._smallViewportHeight / o[1]
        ];
      }
      e.context.disable(e.context.DEPTH_TEST), t.updateBufferObjects(r, i), i.getProperty().getInterpolationType() === h6.NEAREST ? (e.scalarTexture.setMinificationFilter(dt.NEAREST), e.scalarTexture.setMagnificationFilter(dt.NEAREST)) : (e.scalarTexture.setMinificationFilter(dt.LINEAR), e.scalarTexture.setMagnificationFilter(dt.LINEAR)), e.zBufferTexture !== null && e.zBufferTexture.activate();
    }, t.renderPieceDraw = (r, i) => {
      const a = e.context;
      e.scalarTexture.activate(), e.opacityTexture.activate(), e.labelOutlineThicknessTexture.activate(), e.colorTexture.activate(), e.jitterTexture.activate(), t.updateShaders(e.tris, r, i), a.drawArrays(a.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release(), e.scalarTexture.deactivate(), e.colorTexture.deactivate(), e.opacityTexture.deactivate(), e.labelOutlineThicknessTexture.deactivate(), e.jitterTexture.deactivate();
    }, t.renderPieceFinish = (r, i) => {
      if (e.zBufferTexture !== null && e.zBufferTexture.deactivate(), e._useSmallViewport) {
        if (e.framebuffer.restorePreviousBindingsAndBuffers(), e.copyShader === null) {
          e.copyShader = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray([
            "//VTK::System::Dec",
            "attribute vec4 vertexDC;",
            "uniform vec2 tfactor;",
            "varying vec2 tcoord;",
            "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"
          ].join(`
`), [
            "//VTK::System::Dec",
            "//VTK::Output::Dec",
            "uniform sampler2D texture1;",
            "varying vec2 tcoord;",
            "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"
          ].join(`
`), "");
          const l = e.copyShader;
          e.copyVAO = Q8.newInstance(), e.copyVAO.setOpenGLRenderWindow(e._openGLRenderWindow), e.tris.getCABO().bind(), e.copyVAO.addAttributeArray(l, e.tris.getCABO(), "vertexDC", e.tris.getCABO().getVertexOffset(), e.tris.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || P4("Error setting vertexDC in copy shader VAO.");
        } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(e.copyShader);
        const a = e._openGLRenderWindow.getFramebufferSize();
        e.context.viewport(0, 0, a[0], a[1]);
        const s = e.framebuffer.getColorTexture();
        s.activate(), e.copyShader.setUniformi("texture", s.getTextureUnit()), e.copyShader.setUniform2f("tfactor", e.fvp[0], e.fvp[1]);
        const o = e.context;
        o.blendFuncSeparate(o.ONE, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA), e.context.drawArrays(e.context.TRIANGLES, 0, e.tris.getCABO().getElementCount()), s.deactivate(), o.blendFuncSeparate(o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA);
      }
    }, t.renderPiece = (r, i) => {
      if (t.invokeEvent({
        type: "StartEvent"
      }), e.renderable.update(), e.currentInput = e.renderable.getInputData(), t.invokeEvent({
        type: "EndEvent"
      }), !e.currentInput) {
        P4("No input!");
        return;
      }
      t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i);
    }, t.computeBounds = (r, i) => {
      if (!t.getInput()) {
        Zu(e.Bounds);
        return;
      }
      e.bounds = t.getInput().getBounds();
    }, t.updateBufferObjects = (r, i) => {
      t.getNeedToRebuildBufferObjects(r, i) && t.buildBufferObjects(r, i);
    }, t.getNeedToRebuildBufferObjects = (r, i) => e.VBOBuildTime.getMTime() < t.getMTime() || e.VBOBuildTime.getMTime() < i.getMTime() || e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < i.getProperty().getMTime() || e.VBOBuildTime.getMTime() < e.currentInput.getMTime(), t.buildBufferObjects = (r, i) => {
      const a = e.currentInput;
      if (!a) return;
      const s = a.getPointData() && a.getPointData().getScalars();
      if (!s) return;
      e._scalars !== s && (e._openGLRenderWindow.releaseGraphicsResourcesForObject(e._scalars), e._scalars = s);
      const o = i.getProperty();
      if (!e.jitterTexture.getHandle()) {
        const S = new Uint8Array(1024);
        for (let E = 0; E < 1024; ++E) S[E] = 255 * Math.random();
        e.jitterTexture.setMinificationFilter(dt.LINEAR), e.jitterTexture.setMagnificationFilter(dt.LINEAR), e.jitterTexture.create2DFromRaw(32, 32, 1, zt.UNSIGNED_CHAR, S);
      }
      const l = s.getNumberOfComponents(), c = t.useIndependentComponents(o), f = c ? l : 1, u = o.getScalarOpacity(), h = e._openGLRenderWindow.getGraphicsResourceForObject(u);
      let g = _T(u, c, f);
      if (!h.vtkObj || h.hash !== g || e.opacityTextureString !== g) {
        const E = 2048 * f, b = new Float32Array(E), D = new Float32Array(1024);
        for (let R = 0; R < f; ++R) {
          const I = o.getScalarOpacity(R), O = t.getCurrentSampleDistance(r) / o.getScalarOpacityUnitDistance(R), L = I.getRange();
          I.getTable(L[0], L[1], 1024, D, 1);
          for (let N = 0; N < 1024; ++N) b[R * 1024 * 2 + N] = 1 - (1 - D[N]) ** O, b[R * 1024 * 2 + N + 1024] = b[R * 1024 * 2 + N];
        }
        if (e.opacityTexture.releaseGraphicsResources(e._openGLRenderWindow), e.opacityTexture.resetFormatAndType(), e.opacityTexture.setMinificationFilter(dt.LINEAR), e.opacityTexture.setMagnificationFilter(dt.LINEAR), e._openGLRenderWindow.getWebgl2() || e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear")) e.opacityTexture.create2DFromRaw(1024, 2 * f, 1, zt.FLOAT, b);
        else {
          const R = new Uint8ClampedArray(E);
          for (let I = 0; I < E; ++I) R[I] = 255 * b[I];
          e.opacityTexture.create2DFromRaw(1024, 2 * f, 1, zt.UNSIGNED_CHAR, R);
        }
        e.opacityTextureString = g, u && e._openGLRenderWindow.setGraphicsResourceForObject(u, e.opacityTexture, e.opacityTextureString);
      } else e.opacityTexture = h.vtkObj, e.opacityTextureString = h.hash;
      const m = o.getRGBTransferFunction();
      g = _T(m, c, f);
      const y = e._openGLRenderWindow.getGraphicsResourceForObject(m);
      if (!(y == null ? void 0 : y.vtkObj) || (y == null ? void 0 : y.hash) !== g || e.colorTextureString !== g) {
        const E = 2048 * f * 3, b = new Uint8ClampedArray(E), D = new Float32Array(1024 * 3);
        for (let R = 0; R < f; ++R) {
          const I = o.getRGBTransferFunction(R), O = I.getRange();
          I.getTable(O[0], O[1], 1024, D, 1);
          for (let L = 0; L < 1024 * 3; ++L) b[R * 1024 * 6 + L] = 255 * D[L], b[R * 1024 * 6 + L + 1024 * 3] = 255 * D[L];
        }
        e.colorTexture.releaseGraphicsResources(e._openGLRenderWindow), e.colorTexture.resetFormatAndType(), e.colorTexture.setMinificationFilter(dt.LINEAR), e.colorTexture.setMagnificationFilter(dt.LINEAR), e.colorTexture.create2DFromRaw(1024, 2 * f, 3, zt.UNSIGNED_CHAR, b), e.colorTextureString = g, m && e._openGLRenderWindow.setGraphicsResourceForObject(m, e.colorTexture, e.colorTextureString);
      } else e.colorTexture = y.vtkObj, e.colorTextureString = y.hash;
      t.updateLabelOutlineThicknessTexture(i);
      const C = e._openGLRenderWindow.getGraphicsResourceForObject(s);
      if (g = `${a.getMTime()}A${s.getMTime()}`, !(C == null ? void 0 : C.vtkObj) || (C == null ? void 0 : C.hash) !== g) {
        const S = a.getDimensions();
        e.scalarTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), e.scalarTexture.releaseGraphicsResources(e._openGLRenderWindow), e.scalarTexture.resetFormatAndType(), e.scalarTexture.create3DFilterableFromDataArray(S[0], S[1], S[2], s, e.renderable.getPreferSizeOverAccuracy()), s && e._openGLRenderWindow.setGraphicsResourceForObject(s, e.scalarTexture, g);
      } else e.scalarTexture = C.vtkObj;
      if (!e.tris.getCABO().getElementCount()) {
        const S = new Float32Array(12);
        for (let R = 0; R < 4; R++) S[R * 3] = R % 2 * 2 - 1, S[R * 3 + 1] = R > 1 ? 1 : -1, S[R * 3 + 2] = -1;
        const E = new Uint16Array(8);
        E[0] = 3, E[1] = 0, E[2] = 1, E[3] = 3, E[4] = 3, E[5] = 0, E[6] = 3, E[7] = 2;
        const b = Tt.newInstance({
          numberOfComponents: 3,
          values: S
        });
        b.setName("points");
        const D = Tt.newInstance({
          numberOfComponents: 1,
          values: E
        });
        e.tris.getCABO().createVBO(D, "polys", fi.SURFACE, {
          points: b,
          cellOffset: 0
        });
      }
      e.VBOBuildTime.modified();
    }, t.updateLabelOutlineThicknessTexture = (r) => {
      const i = r.getProperty().getLabelOutlineThickness(), a = e._openGLRenderWindow.getGraphicsResourceForObject(i), s = `${i.join("-")}`;
      if (!(a == null ? void 0 : a.vtkObj) || (a == null ? void 0 : a.hash) !== s || e.labelOutlineThicknessTextureString !== s) {
        const u = new Uint8Array(1024);
        for (let h = 0; h < 1024; ++h) {
          const g = typeof i[h] < "u" ? i[h] : i[0];
          u[h] = g;
        }
        e.labelOutlineThicknessTexture.releaseGraphicsResources(e._openGLRenderWindow), e.labelOutlineThicknessTexture.resetFormatAndType(), e.labelOutlineThicknessTexture.setMinificationFilter(dt.NEAREST), e.labelOutlineThicknessTexture.setMagnificationFilter(dt.NEAREST), e.labelOutlineThicknessTexture.create2DFromRaw(1024, 1, 1, zt.UNSIGNED_CHAR, u), e.labelOutlineThicknessTextureString = s, i && e._openGLRenderWindow.setGraphicsResourceForObject(i, e.labelOutlineThicknessTexture, e.labelOutlineThicknessTextureString);
      } else e.labelOutlineThicknessTexture = a.vtkObj, e.labelOutlineThicknessTextureString = a.hash;
    };
  }
  const bJ = {
    context: null,
    VBOBuildTime: null,
    scalarTexture: null,
    scalarTextureString: null,
    opacityTexture: null,
    opacityTextureString: null,
    colorTexture: null,
    colorTextureString: null,
    jitterTexture: null,
    labelOutlineThicknessTexture: null,
    labelOutlineThicknessTextureString: null,
    tris: null,
    framebuffer: null,
    copyShader: null,
    copyVAO: null,
    lastXYF: 1,
    targetXYF: 1,
    zBufferTexture: null,
    lastZBufferTexture: null,
    lightComplexity: 0,
    fullViewportTime: 1,
    idxToView: null,
    idxNormalMatrix: null,
    modelToView: null,
    projectionToView: null,
    avgWindowArea: 0,
    avgFrameTime: 0,
    _scalars: null
  };
  function KR(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, bJ, n), Rn.extend(t, e, n), Ls.implementBuildShadersWithReplacements(t, e, n), e.VBOBuildTime = {}, _n(e.VBOBuildTime, {
      mtime: 0
    }), e.tris = Bs.newInstance(), e.scalarTexture = er.newInstance(), e.opacityTexture = er.newInstance(), e.colorTexture = er.newInstance(), e.jitterTexture = er.newInstance(), e.jitterTexture.setWrapS(Ah.REPEAT), e.jitterTexture.setWrapT(Ah.REPEAT), e.labelOutlineThicknessTexture = er.newInstance(), e.framebuffer = C5.newInstance(), e.idxToView = gt(new Float64Array(16)), e.idxNormalMatrix = Fa(new Float64Array(9)), e.modelToView = gt(new Float64Array(16)), e.projectionToView = gt(new Float64Array(16)), e.projectionToWorld = gt(new Float64Array(16)), pr(t, e, [
      "context"
    ]), EJ(t, e);
  }
  const YR = pn(KR, "vtkOpenGLVolumeMapper");
  var qR = {
    newInstance: YR,
    extend: KR
  };
  Er("vtkVolumeMapper", YR);
  function DJ(t, e) {
    e.classHierarchy.push("vtkStreamingOpenGLVolumeMapper"), t.buildBufferObjects = (n, r) => {
      const i = e.currentInput;
      if (!i) return;
      const a = i.getPointData() && i.getPointData().getScalars();
      if (!a) return;
      const s = r.getProperty();
      if (!e.jitterTexture.getHandle()) {
        const u = new Uint8Array(1024);
        for (let h = 0; h < 1024; ++h) u[h] = 255 * Math.random();
        e.jitterTexture.setMinificationFilter(dt.LINEAR), e.jitterTexture.setMagnificationFilter(dt.LINEAR), e.jitterTexture.create2DFromRaw(32, 32, 1, zt.UNSIGNED_CHAR, u);
      }
      const o = a.getNumberOfComponents(), c = s.getIndependentComponents() ? o : 1;
      let f = `${s.getMTime()}`;
      if (e.opacityTextureString !== f) {
        const h = 2048 * c, g = new Float32Array(h), v = new Float32Array(1024);
        for (let m = 0; m < c; ++m) {
          const y = s.getScalarOpacity(m), w = e.renderable.getSampleDistance() / s.getScalarOpacityUnitDistance(m), C = y.getRange();
          y.getTable(C[0], C[1], 1024, v, 1);
          for (let T = 0; T < 1024; ++T) g[m * 1024 * 2 + T] = 1 - (1 - v[T]) ** w, g[m * 1024 * 2 + T + 1024] = g[m * 1024 * 2 + T];
        }
        if (e.opacityTexture.releaseGraphicsResources(e._openGLRenderWindow), e.opacityTexture.setMinificationFilter(dt.LINEAR), e.opacityTexture.setMagnificationFilter(dt.LINEAR), e._openGLRenderWindow.getWebgl2() || e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear")) e.opacityTexture.create2DFromRaw(1024, 2 * c, 1, zt.FLOAT, g);
        else {
          const m = new Uint8Array(h);
          for (let y = 0; y < h; ++y) m[y] = 255 * g[y];
          e.opacityTexture.create2DFromRaw(1024, 2 * c, 1, zt.UNSIGNED_CHAR, m);
        }
        e.opacityTextureString = f;
      }
      if (f = `${s.getMTime()}`, e.colorTextureString !== f) {
        const h = 2048 * c * 3, g = new Uint8Array(h), v = new Float32Array(1024 * 3);
        for (let m = 0; m < c; ++m) {
          const y = s.getRGBTransferFunction(m), w = y.getRange();
          y.getTable(w[0], w[1], 1024, v, 1);
          for (let C = 0; C < 1024 * 3; ++C) g[m * 1024 * 6 + C] = 255 * v[C], g[m * 1024 * 6 + C + 1024 * 3] = 255 * v[C];
        }
        e.colorTexture.releaseGraphicsResources(e._openGLRenderWindow), e.colorTexture.setMinificationFilter(dt.LINEAR), e.colorTexture.setMagnificationFilter(dt.LINEAR), e.colorTexture.create2DFromRaw(1024, 2 * c, 3, zt.UNSIGNED_CHAR, g), e.colorTextureString = f;
      }
      if (t.updateLabelOutlineThicknessTexture(r), f = `${i.getMTime()}`, e.scalarTextureString !== f) {
        const u = i.getDimensions(), h = e.scalarTexture.getTextureParameters(), g = i.getPointData().getScalars().getDataType(), v = i.getPointData().getScalars().getData();
        let m = true;
        if (h.dataType && h.dataType === g) {
          const y = h.width * h.height * h.depth * h.numComps;
          v.length === y && (m = false);
        }
        if (m) {
          const y = e.context.getExtension("EXT_texture_norm16");
          e.scalarTexture.setOglNorm16Ext(y), e.scalarTexture.releaseGraphicsResources(e._openGLRenderWindow), e.scalarTexture.resetFormatAndType(), e.renderable.getPreferSizeOverAccuracy() || y && g === zt.UNSIGNED_SHORT || g === zt.SHORT ? e.scalarTexture.create3DFilterableFromDataArray(u[0], u[1], u[2], a, e.renderable.getPreferSizeOverAccuracy()) : e.scalarTexture.create3DFilterableFromRaw(u[0], u[1], u[2], o, a.getDataType(), a.getData());
        } else e.scalarTexture.deactivate(), e.scalarTexture.update3DFromRaw(v);
        e.scalarTextureString = f;
      }
      if (!e.tris.getCABO().getElementCount()) {
        const u = new Float32Array(12);
        for (let m = 0; m < 4; m++) u[m * 3] = m % 2 * 2 - 1, u[m * 3 + 1] = m > 1 ? 1 : -1, u[m * 3 + 2] = -1;
        const h = new Uint16Array(8);
        h[0] = 3, h[1] = 0, h[2] = 1, h[3] = 3, h[4] = 3, h[5] = 0, h[6] = 3, h[7] = 2;
        const g = Tt.newInstance({
          numberOfComponents: 3,
          values: u
        });
        g.setName("points");
        const v = Tt.newInstance({
          numberOfComponents: 1,
          values: h
        });
        e.tris.getCABO().createVBO(v, "polys", fi.SURFACE, {
          points: g,
          cellOffset: 0
        });
      }
      e.VBOBuildTime.modified();
    }, t.getRenderTargetSize = () => {
      if (e._useSmallViewport) return [
        e._smallViewportWidth,
        e._smallViewportHeight
      ];
      const { usize: n, vsize: r } = e._openGLRenderer.getTiledSizeAndOrigin();
      return [
        n,
        r
      ];
    }, t.getRenderTargetOffset = () => {
      const { lowerLeftU: n, lowerLeftV: r } = e._openGLRenderer.getTiledSizeAndOrigin();
      return [
        n,
        r
      ];
    };
  }
  const MJ = {};
  function RJ(t, e, n = {}) {
    Object.assign(e, MJ, n), qR.extend(t, e, n), e.scalarTexture = n.scalarTexture, e.previousState = {}, DJ(t, e);
  }
  const OJ = H.newInstance(RJ, "vtkStreamingOpenGLVolumeMapper"), IJ = {
    newInstance: OJ
  }, XR = /* @__PURE__ */ Object.create(null);
  function si(t, e) {
    XR[t] = e;
  }
  function VJ(t, e) {
    e.classHierarchy.push("vtkStreamingOpenGLViewNodeFactory"), t.createNode = (n) => {
      if (n.isDeleted()) return null;
      let r = 0, i = n.getClassName(r++), a = false;
      const s = Object.keys(e.overrides);
      for (; i && !a; ) s.indexOf(i) !== -1 ? a = true : i = n.getClassName(r++);
      if (!a) return null;
      const o = e.getModelInitialValues(n), l = e.overrides[i](o);
      return l.setMyFactory(t), l;
    }, e.overrides = XR, e.getModelInitialValues = (n) => {
      const r = {};
      return n.getClassName() === "vtkSharedVolumeMapper" && (r.scalarTexture = n.getScalarTexture()), r;
    };
  }
  const NJ = {};
  function ZR(t, e, n = {}) {
    Object.assign(e, NJ, n), X8.extend(t, e, n), VJ(t, e), si("vtkActor", LZ.newInstance), si("vtkActor2D", _Z.newInstance), si("vtkCamera", zZ.newInstance), si("vtkGlyph3DMapper", LQ.newInstance), si("vtkImageMapper", GQ.newInstance), si("vtkImageSlice", jQ.newInstance), si("vtkMapper", E5.newInstance), si("vtkPixelSpaceCallbackMapper", ZQ.newInstance), si("vtkRenderer", tJ.newInstance), si("vtkSkybox", aJ.newInstance), si("vtkSphereMapper", fJ.newInstance), si("vtkStickMapper", mJ.newInstance), si("vtkTexture", er.newInstance), si("vtkVolume", wJ.newInstance), si("vtkVolumeMapper", qR.newInstance), si("vtkSharedVolumeMapper", IJ.newInstance);
  }
  const LJ = H.newInstance(ZR, "vtkStreamingOpenGLViewNodeFactory"), UJ = {
    newInstance: LJ,
    extend: ZR
  };
  function FJ(t, e) {
    e.classHierarchy.push("vtkStreamingOpenGLRenderWindow");
  }
  function QR(t, e, n = {}) {
    Object.assign(e, n), OZ.extend(t, e, n), e.myFactory = UJ.newInstance(), si("vtkRenderWindow", JR), FJ(t, e);
  }
  const JR = H.newInstance(QR, "vtkStreamingOpenGLRenderWindow"), BJ = {
    newInstance: JR,
    extend: QR
  }, { vtkDebugMacro: F2 } = H;
  function _J(t, e) {
    e.classHierarchy.push("vtkCamera");
    const n = new Float64Array(3), r = new Float64Array([
      0,
      0,
      -1
    ]), i = new Float64Array([
      0,
      1,
      0
    ]), a = gt(new Float64Array(16)), s = gt(new Float64Array(16)), o = new Float64Array(3), l = new Float64Array(3), c = new Float64Array(3), f = gt(new Float64Array(16)), u = gt(new Float64Array(16)), h = new Float64Array(3), g = new Float64Array(3);
    function v() {
      e.viewPlaneNormal[0] = -e.directionOfProjection[0], e.viewPlaneNormal[1] = -e.directionOfProjection[1], e.viewPlaneNormal[2] = -e.directionOfProjection[2];
    }
    t.orthogonalizeViewUp = () => {
      const m = t.getViewMatrix();
      e.viewUp[0] = m[4], e.viewUp[1] = m[5], e.viewUp[2] = m[6], t.modified();
    }, t.setPosition = (m, y, w) => {
      m === e.position[0] && y === e.position[1] && w === e.position[2] || (e.position[0] = m, e.position[1] = y, e.position[2] = w, t.computeDistance(), t.modified());
    }, t.setFocalPoint = (m, y, w) => {
      m === e.focalPoint[0] && y === e.focalPoint[1] && w === e.focalPoint[2] || (e.focalPoint[0] = m, e.focalPoint[1] = y, e.focalPoint[2] = w, t.computeDistance(), t.modified());
    }, t.setDistance = (m) => {
      if (e.distance === m) return;
      e.distance = m, e.distance < 1e-20 && (e.distance = 1e-20, F2("Distance is set to minimum."));
      const y = e.directionOfProjection;
      e.focalPoint[0] = e.position[0] + y[0] * e.distance, e.focalPoint[1] = e.position[1] + y[1] * e.distance, e.focalPoint[2] = e.position[2] + y[2] * e.distance, t.modified();
    }, t.computeDistance = () => {
      const m = e.focalPoint[0] - e.position[0], y = e.focalPoint[1] - e.position[1], w = e.focalPoint[2] - e.position[2];
      if (e.distance = Math.sqrt(m * m + y * y + w * w), e.distance < 1e-20) {
        e.distance = 1e-20, F2("Distance is set to minimum.");
        const C = e.directionOfProjection;
        e.focalPoint[0] = e.position[0] + C[0] * e.distance, e.focalPoint[1] = e.position[1] + C[1] * e.distance, e.focalPoint[2] = e.position[2] + C[2] * e.distance;
      }
      e.directionOfProjection[0] = m / e.distance, e.directionOfProjection[1] = y / e.distance, e.directionOfProjection[2] = w / e.distance, v();
    }, t.dolly = (m) => {
      if (m <= 0) return;
      const y = e.distance / m;
      t.setPosition(e.focalPoint[0] - y * e.directionOfProjection[0], e.focalPoint[1] - y * e.directionOfProjection[1], e.focalPoint[2] - y * e.directionOfProjection[2]);
    }, t.roll = (m) => {
      const y = e.position, w = e.focalPoint, C = e.viewUp, T = new Float64Array([
        C[0],
        C[1],
        C[2],
        0
      ]);
      gt(f);
      const S = new Float64Array([
        w[0] - y[0],
        w[1] - y[1],
        w[2] - y[2]
      ]);
      $a(f, f, rr(m), S), Nc(T, T, f), e.viewUp[0] = T[0], e.viewUp[1] = T[1], e.viewUp[2] = T[2], t.modified();
    }, t.azimuth = (m) => {
      const y = e.focalPoint;
      gt(u), $n(u, u, y), $a(u, u, rr(m), e.viewUp), $n(u, u, [
        -y[0],
        -y[1],
        -y[2]
      ]), $t(h, e.position, u), t.setPosition(h[0], h[1], h[2]);
    }, t.yaw = (m) => {
      const y = e.position;
      gt(u), $n(u, u, y), $a(u, u, rr(m), e.viewUp), $n(u, u, [
        -y[0],
        -y[1],
        -y[2]
      ]), $t(g, e.focalPoint, u), t.setFocalPoint(g[0], g[1], g[2]);
    }, t.elevation = (m) => {
      const y = e.focalPoint, w = t.getViewMatrix(), C = [
        -w[0],
        -w[1],
        -w[2]
      ];
      gt(u), $n(u, u, y), $a(u, u, rr(m), C), $n(u, u, [
        -y[0],
        -y[1],
        -y[2]
      ]), $t(h, e.position, u), t.setPosition(h[0], h[1], h[2]);
    }, t.pitch = (m) => {
      const y = e.position, w = t.getViewMatrix(), C = [
        w[0],
        w[1],
        w[2]
      ];
      gt(u), $n(u, u, y), $a(u, u, rr(m), C), $n(u, u, [
        -y[0],
        -y[1],
        -y[2]
      ]), $t(g, e.focalPoint, u), t.setFocalPoint(...g);
    }, t.zoom = (m) => {
      m <= 0 || (e.parallelProjection ? e.parallelScale /= m : e.viewAngle /= m, t.modified());
    }, t.translate = (m, y, w) => {
      const C = [
        m,
        y,
        w
      ];
      lp(e.position, C, e.position), lp(e.focalPoint, C, e.focalPoint), t.computeDistance(), t.modified();
    }, t.applyTransform = (m) => {
      const y = [
        ...e.viewUp,
        1
      ], w = [], C = [], T = [];
      y[0] += e.position[0], y[1] += e.position[1], y[2] += e.position[2], Nc(w, [
        ...e.position,
        1
      ], m), Nc(C, [
        ...e.focalPoint,
        1
      ], m), Nc(T, y, m), T[0] -= w[0], T[1] -= w[1], T[2] -= w[2], t.setPosition(...w.slice(0, 3)), t.setFocalPoint(...C.slice(0, 3)), t.setViewUp(...T.slice(0, 3));
    }, t.getThickness = () => e.clippingRange[1] - e.clippingRange[0], t.setThickness = (m) => {
      let y = m;
      y < 1e-20 && (y = 1e-20, F2("Thickness is set to minimum.")), t.setClippingRange(e.clippingRange[0], e.clippingRange[0] + y);
    }, t.setThicknessFromFocalPoint = (m) => {
      let y = m;
      y < 1e-20 && (y = 1e-20, F2("Thickness is set to minimum.")), t.setClippingRange(e.distance - y / 2, e.distance + y / 2);
    }, t.setRoll = (m) => {
    }, t.getRoll = () => {
    }, t.setObliqueAngles = (m, y) => {
    }, t.getOrientation = () => {
    }, t.getOrientationWXYZ = () => {
    }, t.getFrustumPlanes = (m) => {
    }, t.getCameraLightTransformMatrix = (m) => (sr(m, e.cameraLightTransform), m), t.computeCameraLightTransform = () => {
      sr(a, t.getViewMatrix()), Nr(a, a), k8(s, [
        e.distance,
        e.distance,
        e.distance
      ]), tn(a, a, s), gt(e.cameraLightTransform), $n(e.cameraLightTransform, a, [
        0,
        0,
        -1
      ]);
    }, t.deepCopy = (m) => {
    }, t.physicalOrientationToWorldDirection = (m) => {
      const y = mT(m[0], m[1], m[2], m[3]), w = jc(), C = mT(0, 0, 1, 0);
      return kY(w, y), pT(C, y, C), pT(C, C, w), [
        C[0],
        C[1],
        C[2]
      ];
    }, t.getPhysicalToWorldMatrix = (m) => {
      t.getWorldToPhysicalMatrix(m), Nr(m, m);
    }, t.getWorldToPhysicalMatrix = (m) => {
      gt(m);
      const y = [
        3
      ];
      Ns(e.physicalViewNorth, e.physicalViewUp, y), m[0] = y[0], m[1] = y[1], m[2] = y[2], m[4] = e.physicalViewUp[0], m[5] = e.physicalViewUp[1], m[6] = e.physicalViewUp[2], m[8] = -e.physicalViewNorth[0], m[9] = -e.physicalViewNorth[1], m[10] = -e.physicalViewNorth[2], en(m, m), Vn(o, 1 / e.physicalScale, 1 / e.physicalScale, 1 / e.physicalScale), Fl(m, m, o), $n(m, m, e.physicalTranslation);
    }, t.computeViewParametersFromViewMatrix = (m) => {
      Nr(a, m), $t(o, n, a), t.computeDistance();
      const y = e.distance;
      t.setPosition(o[0], o[1], o[2]), $t(l, r, a), bl(l, l, o), cs(l, l), t.setDirectionOfProjection(l[0], l[1], l[2]), $t(c, i, a), bl(c, c, o), cs(c, c), t.setViewUp(c[0], c[1], c[2]), t.setDistance(y);
    }, t.computeViewParametersFromPhysicalMatrix = (m) => {
      t.getWorldToPhysicalMatrix(a), tn(a, m, a), t.computeViewParametersFromViewMatrix(a);
    }, t.setViewMatrix = (m) => {
      e.viewMatrix = m, e.viewMatrix && (sr(a, e.viewMatrix), t.computeViewParametersFromViewMatrix(a), en(e.viewMatrix, e.viewMatrix));
    }, t.getViewMatrix = () => {
      if (e.viewMatrix) return e.viewMatrix;
      eM(a, e.position, e.focalPoint, e.viewUp), en(a, a);
      const m = new Float64Array(16);
      return sr(m, a), m;
    }, t.setProjectionMatrix = (m) => {
      e.projectionMatrix = m;
    }, t.getProjectionMatrix = (m, y, w) => {
      const C = new Float64Array(16);
      if (gt(C), e.projectionMatrix) {
        const E = 1 / e.physicalScale;
        return Vn(o, E, E, E), sr(C, e.projectionMatrix), Fl(C, C, o), en(C, C), C;
      }
      gt(a);
      const T = e.clippingRange[1] - e.clippingRange[0], S = [
        e.clippingRange[0] + (y + 1) * T / 2,
        e.clippingRange[0] + (w + 1) * T / 2
      ];
      if (e.parallelProjection) {
        const E = e.parallelScale * m, b = e.parallelScale, D = (e.windowCenter[0] - 1) * E, R = (e.windowCenter[0] + 1) * E, I = (e.windowCenter[1] - 1) * b, O = (e.windowCenter[1] + 1) * b;
        $D(a, D, R, I, O, S[0], S[1]), en(a, a);
      } else {
        if (e.useOffAxisProjection) throw new Error("Off-Axis projection is not supported at this time");
        {
          const E = Math.tan(rr(e.viewAngle) / 2);
          let b, D;
          e.useHorizontalViewAngle === true ? (b = e.clippingRange[0] * E, D = e.clippingRange[0] * E / m) : (b = e.clippingRange[0] * E * m, D = e.clippingRange[0] * E);
          const R = (e.windowCenter[0] - 1) * b, I = (e.windowCenter[0] + 1) * b, O = (e.windowCenter[1] - 1) * D, L = (e.windowCenter[1] + 1) * D, N = S[0], F = S[1];
          a[0] = 2 * N / (I - R), a[5] = 2 * N / (L - O), a[2] = (R + I) / (I - R), a[6] = (O + L) / (L - O), a[10] = -(N + F) / (F - N), a[14] = -1, a[11] = -2 * N * F / (F - N), a[15] = 0;
        }
      }
      return sr(C, a), C;
    }, t.getCompositeProjectionMatrix = (m, y, w) => {
      const C = t.getViewMatrix(), T = t.getProjectionMatrix(m, y, w);
      return tn(T, C, T), T;
    }, t.setDirectionOfProjection = (m, y, w) => {
      if (e.directionOfProjection[0] === m && e.directionOfProjection[1] === y && e.directionOfProjection[2] === w) return;
      e.directionOfProjection[0] = m, e.directionOfProjection[1] = y, e.directionOfProjection[2] = w;
      const C = e.directionOfProjection;
      e.focalPoint[0] = e.position[0] + C[0] * e.distance, e.focalPoint[1] = e.position[1] + C[1] * e.distance, e.focalPoint[2] = e.position[2] + C[2] * e.distance, v();
    }, t.setDeviceAngles = (m, y, w, C) => {
      const T = [
        3
      ];
      Ns(e.physicalViewNorth, e.physicalViewUp, T);
      const S = gt(new Float64Array(16));
      $a(S, S, rr(m), e.physicalViewUp), $a(S, S, rr(y), T), $a(S, S, rr(w), e.physicalViewNorth), $a(S, S, rr(-C), e.physicalViewUp);
      const E = new Float64Array([
        -e.physicalViewUp[0],
        -e.physicalViewUp[1],
        -e.physicalViewUp[2]
      ]), b = new Float64Array(e.physicalViewNorth);
      $t(E, E, S), $t(b, b, S), t.setDirectionOfProjection(E[0], E[1], E[2]), t.setViewUp(b[0], b[1], b[2]), t.modified();
    }, t.setOrientationWXYZ = (m, y, w, C) => {
      const T = gt(new Float64Array(16));
      if (m !== 0 && (y !== 0 || w !== 0 || C !== 0)) {
        const b = rr(m), D = jc();
        P8(D, [
          y,
          w,
          C
        ], b), mp(T, D);
      }
      const S = new Float64Array(3);
      $t(S, [
        0,
        0,
        -1
      ], T);
      const E = new Float64Array(3);
      $t(E, [
        0,
        1,
        0
      ], T), t.setDirectionOfProjection(...S), t.setViewUp(...E), t.modified();
    }, t.computeClippingRange = (m) => {
      let y = null, w = null;
      y = e.viewPlaneNormal, w = e.position;
      const C = -y[0], T = -y[1], S = -y[2], E = -(C * w[0] + T * w[1] + S * w[2]), b = [
        C * m[0] + T * m[2] + S * m[4] + E,
        1e-18
      ];
      for (let D = 0; D < 2; D++) for (let R = 0; R < 2; R++) for (let I = 0; I < 2; I++) {
        const O = C * m[I] + T * m[2 + R] + S * m[4 + D] + E;
        b[0] = O < b[0] ? O : b[0], b[1] = O > b[1] ? O : b[1];
      }
      return b;
    };
  }
  const kJ = {
    position: [
      0,
      0,
      1
    ],
    focalPoint: [
      0,
      0,
      0
    ],
    viewUp: [
      0,
      1,
      0
    ],
    directionOfProjection: [
      0,
      0,
      -1
    ],
    parallelProjection: false,
    useHorizontalViewAngle: false,
    viewAngle: 30,
    parallelScale: 1,
    clippingRange: [
      0.01,
      1000.01
    ],
    windowCenter: [
      0,
      0
    ],
    viewPlaneNormal: [
      0,
      0,
      1
    ],
    useOffAxisProjection: false,
    screenBottomLeft: [
      -0.5,
      -0.5,
      -0.5
    ],
    screenBottomRight: [
      0.5,
      -0.5,
      -0.5
    ],
    screenTopRight: [
      0.5,
      0.5,
      -0.5
    ],
    freezeFocalPoint: false,
    projectionMatrix: null,
    viewMatrix: null,
    cameraLightTransform: L8(),
    physicalTranslation: [
      0,
      0,
      0
    ],
    physicalScale: 1,
    physicalViewUp: [
      0,
      1,
      0
    ],
    physicalViewNorth: [
      0,
      0,
      -1
    ]
  };
  function $R(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, kJ, n), H.obj(t, e), H.get(t, e, [
      "distance"
    ]), H.setGet(t, e, [
      "parallelProjection",
      "useHorizontalViewAngle",
      "viewAngle",
      "parallelScale",
      "useOffAxisProjection",
      "freezeFocalPoint",
      "physicalScale"
    ]), H.getArray(t, e, [
      "directionOfProjection",
      "viewPlaneNormal",
      "position",
      "focalPoint"
    ]), H.setGetArray(t, e, [
      "clippingRange",
      "windowCenter"
    ], 2), H.setGetArray(t, e, [
      "viewUp",
      "screenBottomLeft",
      "screenBottomRight",
      "screenTopRight",
      "physicalTranslation",
      "physicalViewUp",
      "physicalViewNorth"
    ], 3), _J(t, e);
  }
  const PJ = H.newInstance($R, "vtkCamera");
  var iy = {
    newInstance: PJ,
    extend: $R
  };
  function GJ(t, e) {
    e.classHierarchy.push("vtkLight");
    const n = new Float64Array(3);
    t.getTransformedPosition = () => (e.transformMatrix ? $t(n, e.position, e.transformMatrix) : Vn(n, e.position[0], e.position[1], e.position[2]), n), t.getTransformedFocalPoint = () => (e.transformMatrix ? $t(n, e.focalPoint, e.transformMatrix) : Vn(n, e.focalPoint[0], e.focalPoint[1], e.focalPoint[2]), n), t.getDirection = () => (e.directionMTime < e.mtime && (o6(e.direction, e.focalPoint, e.position), Hc(e.direction), e.directionMTime = e.mtime), e.direction), t.setDirection = (r) => {
      const i = new Float64Array(3);
      o6(i, e.position, r), e.focalPoint = i;
    }, t.setDirectionAngle = (r, i) => {
      const a = rr(r), s = rr(i);
      t.setPosition(Math.cos(a) * Math.sin(s), Math.sin(a), Math.cos(a) * Math.cos(s)), t.setFocalPoint(0, 0, 0), t.setPositional(0);
    }, t.setLightTypeToHeadLight = () => {
      t.setLightType("HeadLight");
    }, t.setLightTypeToCameraLight = () => {
      t.setLightType("CameraLight");
    }, t.setLightTypeToSceneLight = () => {
      t.setTransformMatrix(null), t.setLightType("SceneLight");
    }, t.lightTypeIsHeadLight = () => e.lightType === "HeadLight", t.lightTypeIsSceneLight = () => e.lightType === "SceneLight", t.lightTypeIsCameraLight = () => e.lightType === "CameraLight";
  }
  const zJ = {
    switch: true,
    intensity: 1,
    color: [
      1,
      1,
      1
    ],
    position: [
      0,
      0,
      1
    ],
    focalPoint: [
      0,
      0,
      0
    ],
    positional: false,
    exponent: 1,
    coneAngle: 30,
    coneFalloff: 5,
    attenuationValues: [
      1,
      0,
      0
    ],
    transformMatrix: null,
    lightType: "SceneLight",
    shadowAttenuation: 1,
    direction: [
      0,
      0,
      0
    ],
    directionMTime: 0
  };
  function WJ(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, zJ, n), H.obj(t, e), H.setGet(t, e, [
      "intensity",
      "switch",
      "positional",
      "exponent",
      "coneAngle",
      "coneFalloff",
      "transformMatrix",
      "lightType",
      "shadowAttenuation",
      "attenuationValues"
    ]), H.setGetArray(t, e, [
      "color",
      "position",
      "focalPoint",
      "attenuationValues"
    ], 3), GJ(t, e);
  }
  const HJ = H.newInstance(WJ, "vtkLight");
  var jJ = {
    newInstance: HJ
  };
  const { vtkErrorMacro: kg } = H;
  function KJ(t) {
    return () => kg(`vtkViewport::${t} - NOT IMPLEMENTED`);
  }
  function YJ(t, e) {
    e.classHierarchy.push("vtkViewport"), t.getViewProps = () => e.props, t.hasViewProp = (r) => e.props.includes(r), t.addViewProp = (r) => {
      r && !t.hasViewProp(r) && e.props.push(r);
    }, t.removeViewProp = (r) => {
      const i = e.props.filter((a) => a !== r);
      e.props.length !== i.length && (e.props = i);
    }, t.removeAllViewProps = () => {
      e.props = [];
    };
    function n(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      i.push(r);
      const a = r.getNestedProps();
      if (a && a.length) for (let s = 0; s < a.length; s++) n(a[s], i);
      return i;
    }
    t.getViewPropsWithNestedProps = () => {
      const r = [];
      for (let i = 0; i < e.props.length; i++) n(e.props[i], r);
      return r;
    }, t.addActor2D = t.addViewProp, t.removeActor2D = (r) => {
      t.removeViewProp(r);
    }, t.getActors2D = () => (e.actors2D = [], e.props.forEach((r) => {
      e.actors2D = e.actors2D.concat(r.getActors2D());
    }), e.actors2D), t.displayToView = () => kg("call displayToView on your view instead"), t.viewToDisplay = () => kg("callviewtodisplay on your view instead"), t.getSize = () => kg("call getSize on your View instead"), t.normalizedDisplayToProjection = (r, i, a) => {
      const s = t.normalizedDisplayToNormalizedViewport(r, i, a);
      return t.normalizedViewportToProjection(s[0], s[1], s[2]);
    }, t.normalizedDisplayToNormalizedViewport = (r, i, a) => {
      const s = [
        e.viewport[2] - e.viewport[0],
        e.viewport[3] - e.viewport[1]
      ];
      return [
        (r - e.viewport[0]) / s[0],
        (i - e.viewport[1]) / s[1],
        a
      ];
    }, t.normalizedViewportToProjection = (r, i, a) => [
      r * 2 - 1,
      i * 2 - 1,
      a * 2 - 1
    ], t.projectionToNormalizedDisplay = (r, i, a) => {
      const s = t.projectionToNormalizedViewport(r, i, a);
      return t.normalizedViewportToNormalizedDisplay(s[0], s[1], s[2]);
    }, t.normalizedViewportToNormalizedDisplay = (r, i, a) => {
      const s = [
        e.viewport[2] - e.viewport[0],
        e.viewport[3] - e.viewport[1]
      ];
      return [
        r * s[0] + e.viewport[0],
        i * s[1] + e.viewport[1],
        a
      ];
    }, t.projectionToNormalizedViewport = (r, i, a) => [
      (r + 1) * 0.5,
      (i + 1) * 0.5,
      (a + 1) * 0.5
    ], t.PickPropFrom = KJ("PickPropFrom");
  }
  const qJ = {
    background: [
      0,
      0,
      0
    ],
    background2: [
      0.2,
      0.2,
      0.2
    ],
    gradientBackground: false,
    viewport: [
      0,
      0,
      1,
      1
    ],
    aspect: [
      1,
      1
    ],
    pixelAspect: [
      1,
      1
    ],
    props: [],
    actors2D: []
  };
  function eO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, qJ, n), H.obj(t, e), H.event(t, e, "event"), H.setGetArray(t, e, [
      "viewport"
    ], 4), H.setGetArray(t, e, [
      "background",
      "background2"
    ], 3), YJ(t, e);
  }
  const XJ = H.newInstance(eO, "vtkViewport");
  var ZJ = {
    newInstance: XJ,
    extend: eO
  };
  const { vtkDebugMacro: x1, vtkErrorMacro: gl, vtkWarningMacro: QJ } = di;
  function kT(t) {
    return () => gl(`vtkRenderer::${t} - NOT IMPLEMENTED`);
  }
  function JJ(t, e) {
    e.classHierarchy.push("vtkRenderer");
    const n = {
      type: "ComputeVisiblePropBoundsEvent",
      renderer: t
    }, r = {
      type: "ResetCameraClippingRangeEvent",
      renderer: t
    }, i = {
      type: "ResetCameraEvent",
      renderer: t
    };
    t.updateCamera = () => (e.activeCamera || (x1("No cameras are on, creating one."), t.getActiveCameraAndResetIfCreated()), e.activeCamera.render(t), true), t.updateLightsGeometryToFollowCamera = () => {
      const a = t.getActiveCameraAndResetIfCreated();
      e.lights.forEach((s) => {
        s.lightTypeIsSceneLight() || (s.lightTypeIsHeadLight() ? (s.setPositionFrom(a.getPositionByReference()), s.setFocalPointFrom(a.getFocalPointByReference()), s.modified(a.getMTime())) : s.lightTypeIsCameraLight() ? s.setTransformMatrix(a.getCameraLightTransformMatrix(L8())) : gl("light has unknown light type", s.get()));
      });
    }, t.updateLightGeometry = () => e.lightFollowCamera ? t.updateLightsGeometryToFollowCamera() : true, t.allocateTime = kT("allocateTime"), t.updateGeometry = kT("updateGeometry"), t.getVTKWindow = () => e._renderWindow, t.setLayer = (a) => {
      x1(t.getClassName(), t, "setting Layer to ", a), e.layer !== a && (e.layer = a, t.modified()), t.setPreserveColorBuffer(!!a);
    }, t.setActiveCamera = (a) => e.activeCamera === a ? false : (e.activeCamera = a, t.modified(), t.invokeEvent({
      type: "ActiveCameraEvent",
      camera: a
    }), true), t.makeCamera = () => {
      const a = iy.newInstance();
      return t.invokeEvent({
        type: "CreateCameraEvent",
        camera: a
      }), a;
    }, t.getActiveCamera = () => (e.activeCamera || (e.activeCamera = t.makeCamera()), e.activeCamera), t.getActiveCameraAndResetIfCreated = () => (e.activeCamera || (t.getActiveCamera(), t.resetCamera()), e.activeCamera), t.getActors = () => (e.actors = [], e.props.forEach((a) => {
      e.actors = e.actors.concat(a.getActors());
    }), e.actors), t.addActor = t.addViewProp, t.removeActor = (a) => {
      e.actors = e.actors.filter((s) => s !== a), t.removeViewProp(a), t.modified();
    }, t.removeAllActors = () => {
      t.getActors().forEach((s) => {
        t.removeViewProp(s);
      }), e.actors = [], t.modified();
    }, t.getVolumes = () => (e.volumes = [], e.props.forEach((a) => {
      e.volumes = e.volumes.concat(a.getVolumes());
    }), e.volumes), t.addVolume = t.addViewProp, t.removeVolume = (a) => {
      e.volumes = e.volumes.filter((s) => s !== a), t.removeViewProp(a), t.modified();
    }, t.removeAllVolumes = () => {
      t.getVolumes().forEach((s) => {
        t.removeViewProp(s);
      }), e.volumes = [], t.modified();
    }, t.hasLight = (a) => e.lights.includes(a), t.addLight = (a) => {
      a && !t.hasLight(a) && (e.lights.push(a), t.modified());
    }, t.removeLight = (a) => {
      e.lights = e.lights.filter((s) => s !== a), t.modified();
    }, t.removeAllLights = () => {
      e.lights = [], t.modified();
    }, t.setLightCollection = (a) => {
      e.lights = a, t.modified();
    }, t.makeLight = jJ.newInstance, t.createLight = () => {
      e.automaticLightCreation && (e._createdLight && (t.removeLight(e._createdLight), e._createdLight.delete(), e._createdLight = null), e._createdLight = t.makeLight(), t.addLight(e._createdLight), e._createdLight.setLightTypeToHeadLight(), e._createdLight.setPosition(t.getActiveCamera().getPosition()), e._createdLight.setFocalPoint(t.getActiveCamera().getFocalPoint()));
    }, t.normalizedDisplayToWorld = (a, s, o, l) => {
      let c = t.normalizedDisplayToProjection(a, s, o);
      return c = t.projectionToView(c[0], c[1], c[2], l), t.viewToWorld(c[0], c[1], c[2]);
    }, t.worldToNormalizedDisplay = (a, s, o, l) => {
      let c = t.worldToView(a, s, o);
      return c = t.viewToProjection(c[0], c[1], c[2], l), t.projectionToNormalizedDisplay(c[0], c[1], c[2]);
    }, t.viewToWorld = (a, s, o) => {
      if (e.activeCamera === null) return gl("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"), [
        0,
        0,
        0
      ];
      const l = e.activeCamera.getViewMatrix();
      Nr(l, l), en(l, l);
      const c = new Float64Array([
        a,
        s,
        o
      ]);
      return $t(c, c, l), c;
    }, t.projectionToView = (a, s, o, l) => {
      if (e.activeCamera === null) return gl("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"), [
        0,
        0,
        0
      ];
      const c = e.activeCamera.getProjectionMatrix(l, -1, 1);
      Nr(c, c), en(c, c);
      const f = new Float64Array([
        a,
        s,
        o
      ]);
      return $t(f, f, c), f;
    }, t.worldToView = (a, s, o) => {
      if (e.activeCamera === null) return gl("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"), [
        0,
        0,
        0
      ];
      const l = e.activeCamera.getViewMatrix();
      en(l, l);
      const c = new Float64Array([
        a,
        s,
        o
      ]);
      return $t(c, c, l), c;
    }, t.viewToProjection = (a, s, o, l) => {
      if (e.activeCamera === null) return gl("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"), [
        0,
        0,
        0
      ];
      const c = e.activeCamera.getProjectionMatrix(l, -1, 1);
      en(c, c);
      const f = new Float64Array([
        a,
        s,
        o
      ]);
      return $t(f, f, c), f;
    }, t.computeVisiblePropBounds = () => {
      e.allBounds[0] = En.INIT_BOUNDS[0], e.allBounds[1] = En.INIT_BOUNDS[1], e.allBounds[2] = En.INIT_BOUNDS[2], e.allBounds[3] = En.INIT_BOUNDS[3], e.allBounds[4] = En.INIT_BOUNDS[4], e.allBounds[5] = En.INIT_BOUNDS[5];
      let a = true;
      t.invokeEvent(n);
      for (let s = 0; s < e.props.length; ++s) {
        const o = e.props[s];
        if (o.getVisibility() && o.getUseBounds()) {
          const l = o.getBounds();
          l && Vg(l) && (a = false, l[0] < e.allBounds[0] && (e.allBounds[0] = l[0]), l[1] > e.allBounds[1] && (e.allBounds[1] = l[1]), l[2] < e.allBounds[2] && (e.allBounds[2] = l[2]), l[3] > e.allBounds[3] && (e.allBounds[3] = l[3]), l[4] < e.allBounds[4] && (e.allBounds[4] = l[4]), l[5] > e.allBounds[5] && (e.allBounds[5] = l[5]));
        }
      }
      return a && (Zu(e.allBounds), x1("Can't compute bounds, no 3D props are visible")), e.allBounds;
    }, t.resetCamera = function() {
      const s = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || t.computeVisiblePropBounds(), o = [
        0,
        0,
        0
      ];
      if (!Vg(s)) return x1("Cannot reset camera!"), false;
      let l = null;
      if (t.getActiveCamera()) l = e.activeCamera.getViewPlaneNormal();
      else return gl("Trying to reset non-existent camera"), false;
      e.activeCamera.setViewAngle(30), o[0] = (s[0] + s[1]) / 2, o[1] = (s[2] + s[3]) / 2, o[2] = (s[4] + s[5]) / 2;
      let c = s[1] - s[0], f = s[3] - s[2], u = s[5] - s[4];
      c *= c, f *= f, u *= u;
      let h = c + f + u;
      h = h === 0 ? 1 : h, h = Math.sqrt(h) * 0.5;
      const g = rr(e.activeCamera.getViewAngle()), v = h, m = h / Math.sin(g * 0.5), y = e.activeCamera.getViewUp();
      return Math.abs(Ht(y, l)) > 0.999 && (QJ("Resetting view-up since view plane normal is parallel"), e.activeCamera.setViewUp(-y[2], y[0], y[1])), e.activeCamera.setFocalPoint(o[0], o[1], o[2]), e.activeCamera.setPosition(o[0] + m * l[0], o[1] + m * l[1], o[2] + m * l[2]), t.resetCameraClippingRange(s), e.activeCamera.setParallelScale(v), e.activeCamera.setPhysicalScale(h), e.activeCamera.setPhysicalTranslation(-o[0], -o[1], -o[2]), t.invokeEvent(i), true;
    }, t.resetCameraClippingRange = function() {
      const s = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || t.computeVisiblePropBounds();
      if (!Vg(s)) return x1("Cannot reset camera clipping range!"), false;
      if (t.getActiveCameraAndResetIfCreated(), !e.activeCamera) return gl("Trying to reset clipping range of non-existent camera"), false;
      const o = e.activeCamera.computeClippingRange(s);
      let l = 0;
      if (e.activeCamera.getParallelProjection()) l = 0.2 * e.activeCamera.getParallelScale();
      else {
        const c = rr(e.activeCamera.getViewAngle());
        l = 0.2 * Math.tan(c / 2) * o[1];
      }
      return o[1] - o[0] < l && (l = l - o[1] + o[0], o[1] += l / 2, o[0] -= l / 2), o[0] < 0 && (o[0] = 0), o[0] = 0.99 * o[0] - (o[1] - o[0]) * e.clippingRangeExpansion, o[1] = 1.01 * o[1] + (o[1] - o[0]) * e.clippingRangeExpansion, o[0] = o[0] >= o[1] ? 0.01 * o[1] : o[0], e.nearClippingPlaneTolerance || (e.nearClippingPlaneTolerance = 0.01), o[0] < e.nearClippingPlaneTolerance * o[1] && (o[0] = e.nearClippingPlaneTolerance * o[1]), e.activeCamera.setClippingRange(o[0], o[1]), t.invokeEvent(r), false;
    }, t.setRenderWindow = (a) => {
      a !== e._renderWindow && (e._vtkWindow = a, e._renderWindow = a);
    }, t.visibleActorCount = () => e.props.filter((a) => a.getVisibility()).length, t.visibleVolumeCount = t.visibleActorCount, t.getMTime = () => {
      let a = e.mtime;
      const s = e.activeCamera ? e.activeCamera.getMTime() : 0;
      s > a && (a = s);
      const o = e._createdLight ? e._createdLight.getMTime() : 0;
      return o > a && (a = o), a;
    }, t.getTransparent = () => !!e.preserveColorBuffer, t.isActiveCameraCreated = () => !!e.activeCamera;
  }
  const $J = {
    pickedProp: null,
    activeCamera: null,
    allBounds: [],
    ambient: [
      1,
      1,
      1
    ],
    allocatedRenderTime: 100,
    timeFactor: 1,
    automaticLightCreation: true,
    twoSidedLighting: true,
    lastRenderTimeInSeconds: -1,
    renderWindow: null,
    lights: [],
    actors: [],
    volumes: [],
    lightFollowCamera: true,
    numberOfPropsRendered: 0,
    propArray: null,
    pathArray: null,
    layer: 0,
    preserveColorBuffer: false,
    preserveDepthBuffer: false,
    computeVisiblePropBounds: Ll(),
    interactive: true,
    nearClippingPlaneTolerance: 0,
    clippingRangeExpansion: 0.05,
    erase: true,
    draw: true,
    useShadows: false,
    useDepthPeeling: false,
    occlusionRatio: 0,
    maximumNumberOfPeels: 4,
    selector: null,
    delegate: null,
    texturedBackground: false,
    backgroundTexture: null,
    environmentTexture: null,
    environmentTextureDiffuseStrength: 1,
    environmentTextureSpecularStrength: 1,
    useEnvironmentTextureAsBackground: false,
    pass: 0
  };
  function tO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (Object.assign(e, $J, n), ZJ.extend(t, e, n), e.background || (e.background = [
      0,
      0,
      0,
      1
    ]); e.background.length < 3; ) e.background.push(0);
    e.background.length === 3 && e.background.push(1), Wi(t, e, [
      "_renderWindow",
      "allocatedRenderTime",
      "timeFactor",
      "lastRenderTimeInSeconds",
      "numberOfPropsRendered",
      "lastRenderingUsedDepthPeeling",
      "selector"
    ]), pr(t, e, [
      "twoSidedLighting",
      "lightFollowCamera",
      "automaticLightCreation",
      "erase",
      "draw",
      "nearClippingPlaneTolerance",
      "clippingRangeExpansion",
      "backingStore",
      "interactive",
      "layer",
      "preserveColorBuffer",
      "preserveDepthBuffer",
      "useDepthPeeling",
      "occlusionRatio",
      "maximumNumberOfPeels",
      "delegate",
      "backgroundTexture",
      "texturedBackground",
      "environmentTexture",
      "environmentTextureDiffuseStrength",
      "environmentTextureSpecularStrength",
      "useEnvironmentTextureAsBackground",
      "useShadows",
      "pass"
    ]), Xu(t, e, [
      "actors",
      "volumes",
      "lights"
    ]), m8(t, e, [
      "background"
    ], 4, 1), Qh(t, e, [
      "renderWindow"
    ]), JJ(t, e);
  }
  const e$ = pn(tO, "vtkRenderer");
  var t$ = {
    newInstance: e$,
    extend: tO
  };
  const n$ = {
    Unknown: 0,
    LeftController: 1,
    RightController: 2
  }, r$ = {
    Unknown: 0,
    Trigger: 1,
    TrackPad: 2,
    Grip: 3,
    Thumbstick: 4,
    A: 5,
    B: 6,
    ApplicationMenu: 7
  }, i$ = {
    Unknown: 0,
    TouchpadX: 1,
    TouchpadY: 2,
    ThumbstickX: 3,
    ThumbstickY: 4
  };
  var nO = {
    Device: n$,
    Input: r$,
    Axis: i$
  };
  const { Device: B2, Input: Ac } = nO, { vtkWarningMacro: _2, vtkErrorMacro: k2, normalizeWheel: a$, vtkOnceErrorMacro: s$ } = H, Q0 = {
    ctrlKey: false,
    altKey: false,
    shiftKey: false
  }, G4 = {
    "xr-standard": [
      Ac.Trigger,
      Ac.Grip,
      Ac.TrackPad,
      Ac.Thumbstick,
      Ac.A,
      Ac.B
    ]
  }, ay = [
    "StartAnimation",
    "Animation",
    "EndAnimation",
    "PointerEnter",
    "PointerLeave",
    "MouseEnter",
    "MouseLeave",
    "StartMouseMove",
    "MouseMove",
    "EndMouseMove",
    "LeftButtonPress",
    "LeftButtonRelease",
    "MiddleButtonPress",
    "MiddleButtonRelease",
    "RightButtonPress",
    "RightButtonRelease",
    "KeyPress",
    "KeyDown",
    "KeyUp",
    "StartMouseWheel",
    "MouseWheel",
    "EndMouseWheel",
    "StartPinch",
    "Pinch",
    "EndPinch",
    "StartPan",
    "Pan",
    "EndPan",
    "StartRotate",
    "Rotate",
    "EndRotate",
    "Button3D",
    "Move3D",
    "StartPointerLock",
    "EndPointerLock",
    "StartInteraction",
    "Interaction",
    "EndInteraction",
    "AnimationFrameRateUpdate"
  ];
  function w1(t) {
    t.cancelable && t.preventDefault();
  }
  function P2(t) {
    const e = /* @__PURE__ */ Object.create(null);
    return t.forEach((n) => {
      let { pointerId: r, position: i } = n;
      e[r] = i;
    }), e;
  }
  function o$(t, e) {
    e.classHierarchy.push("vtkRenderWindowInteractor");
    const n = {
      ...t
    }, r = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();
    let a = 1;
    t.start = () => {
      !e.initialized && (t.initialize(), !e.initialized) || t.startEventLoop();
    }, t.setRenderWindow = (m) => {
      k2("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor");
    }, t.setInteractorStyle = (m) => {
      e.interactorStyle !== m && (e.interactorStyle != null && e.interactorStyle.setInteractor(null), e.interactorStyle = m, e.interactorStyle != null && e.interactorStyle.getInteractor() !== t && e.interactorStyle.setInteractor(t));
    }, t.initialize = () => {
      e.initialized = true, t.enable(), t.render();
    }, t.enable = () => t.setEnabled(true), t.disable = () => t.setEnabled(false), t.startEventLoop = () => _2("empty event loop");
    function s(m, y) {
      e._forcedRenderer || (e.currentRenderer = t.findPokedRenderer(m, y));
    }
    t.getCurrentRenderer = () => (e.currentRenderer || s(0, 0), e.currentRenderer);
    function o(m) {
      const y = e._view.getCanvas(), w = y.getBoundingClientRect(), C = y.width / w.width, T = y.height / w.height, S = {
        x: C * (m.clientX - w.left),
        y: T * (w.height - m.clientY + w.top),
        z: 0
      };
      return (i.size <= 1 || !e.currentRenderer) && s(S.x, S.y), S;
    }
    const l = e._getScreenEventPositionFor || o;
    function c(m) {
      return {
        controlKey: m.ctrlKey,
        altKey: m.altKey,
        shiftKey: m.shiftKey
      };
    }
    function f(m) {
      const y = c(m);
      return {
        key: m.key,
        keyCode: m.charCode,
        ...y
      };
    }
    function u(m) {
      return m.pointerType || "";
    }
    const h = () => {
      if (e.container === null) return;
      const { container: m } = e;
      m.addEventListener("contextmenu", w1), m.addEventListener("wheel", t.handleWheel), m.addEventListener("DOMMouseScroll", t.handleWheel), m.addEventListener("pointerenter", t.handlePointerEnter), m.addEventListener("pointerleave", t.handlePointerLeave), m.addEventListener("pointermove", t.handlePointerMove, {
        passive: false
      }), m.addEventListener("pointerdown", t.handlePointerDown, {
        passive: false
      }), m.addEventListener("pointerup", t.handlePointerUp), m.addEventListener("pointercancel", t.handlePointerCancel), document.addEventListener("keypress", t.handleKeyPress), document.addEventListener("keydown", t.handleKeyDown), document.addEventListener("keyup", t.handleKeyUp), document.addEventListener("pointerlockchange", t.handlePointerLockChange), m.style.touchAction = "none", m.style.userSelect = "none", m.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
    };
    t.bindEvents = (m) => {
      if (m === null) return;
      n.setContainer(m) && h();
    };
    const g = () => {
      clearTimeout(e.moveTimeoutID), clearTimeout(e.wheelTimeoutID), e.moveTimeoutID = 0, e.wheelTimeoutID = 0, a = 1;
      const { container: m } = e;
      m && (m.removeEventListener("contextmenu", w1), m.removeEventListener("wheel", t.handleWheel), m.removeEventListener("DOMMouseScroll", t.handleWheel), m.removeEventListener("pointerenter", t.handlePointerEnter), m.removeEventListener("pointerleave", t.handlePointerLeave), m.removeEventListener("pointermove", t.handlePointerMove, {
        passive: false
      }), m.removeEventListener("pointerdown", t.handlePointerDown, {
        passive: false
      }), m.removeEventListener("pointerup", t.handlePointerUp), m.removeEventListener("pointercancel", t.handlePointerCancel)), document.removeEventListener("keypress", t.handleKeyPress), document.removeEventListener("keydown", t.handleKeyDown), document.removeEventListener("keyup", t.handleKeyUp), document.removeEventListener("pointerlockchange", t.handlePointerLockChange), i.clear();
    };
    t.unbindEvents = () => {
      g(), n.setContainer(null);
    }, t.handleKeyPress = (m) => {
      const y = f(m);
      t.keyPressEvent(y);
    }, t.handleKeyDown = (m) => {
      const y = f(m);
      t.keyDownEvent(y);
    }, t.handleKeyUp = (m) => {
      const y = f(m);
      t.keyUpEvent(y);
    }, t.handlePointerEnter = (m) => {
      const y = {
        ...c(m),
        position: l(m),
        deviceType: u(m)
      };
      t.pointerEnterEvent(y), y.deviceType === "mouse" && t.mouseEnterEvent(y);
    }, t.handlePointerLeave = (m) => {
      const y = {
        ...c(m),
        position: l(m),
        deviceType: u(m)
      };
      t.pointerLeaveEvent(y), y.deviceType === "mouse" && t.mouseLeaveEvent(y);
    }, t.handlePointerDown = (m) => {
      if (!(m.button > 2 || t.isPointerLocked())) switch (e.preventDefaultOnPointerDown && w1(m), m.target.hasPointerCapture(m.pointerId) && m.target.releasePointerCapture(m.pointerId), e.container.setPointerCapture(m.pointerId), i.has(m.pointerId) && _2("[RenderWindowInteractor] duplicate pointerId detected"), i.set(m.pointerId, {
        pointerId: m.pointerId,
        position: l(m)
      }), m.pointerType) {
        case "pen":
        case "touch":
          t.handleTouchStart(m);
          break;
        case "mouse":
        default:
          t.handleMouseDown(m);
          break;
      }
    }, t.handlePointerUp = (m) => {
      if (i.has(m.pointerId)) switch (e.preventDefaultOnPointerUp && w1(m), i.delete(m.pointerId), e.container.releasePointerCapture(m.pointerId), m.pointerType) {
        case "pen":
        case "touch":
          t.handleTouchEnd(m);
          break;
        case "mouse":
        default:
          t.handleMouseUp(m);
          break;
      }
    }, t.handlePointerCancel = (m) => {
      if (i.has(m.pointerId)) switch (i.delete(m.pointerId), m.pointerType) {
        case "pen":
        case "touch":
          t.handleTouchEnd(m);
          break;
        case "mouse":
        default:
          t.handleMouseUp(m);
          break;
      }
    }, t.handlePointerMove = (m) => {
      if (i.has(m.pointerId)) {
        const y = i.get(m.pointerId);
        y.position = l(m);
      }
      switch (m.pointerType) {
        case "pen":
        case "touch":
          t.handleTouchMove(m);
          break;
        case "mouse":
        default:
          t.handleMouseMove(m);
          break;
      }
    }, t.handleMouseDown = (m) => {
      const y = {
        ...c(m),
        position: l(m),
        deviceType: u(m)
      };
      switch (m.button) {
        case 0:
          t.leftButtonPressEvent(y);
          break;
        case 1:
          t.middleButtonPressEvent(y);
          break;
        case 2:
          t.rightButtonPressEvent(y);
          break;
        default:
          k2(`Unknown mouse button pressed: ${m.button}`);
          break;
      }
    }, t.requestPointerLock = () => {
      e.container && e.container.requestPointerLock();
    }, t.exitPointerLock = () => {
      var _a3;
      return (_a3 = document.exitPointerLock) == null ? void 0 : _a3.call(document);
    }, t.isPointerLocked = () => !!e.container && document.pointerLockElement === e.container, t.handlePointerLockChange = () => {
      t.isPointerLocked() ? t.startPointerLockEvent() : t.endPointerLockEvent();
    };
    function v() {
      e._view && e.enabled && e.enableRender && (e.inRender = true, e._view.traverseAllPasses(), e.inRender = false), t.invokeRenderEvent();
    }
    t.requestAnimation = (m) => {
      if (m === void 0) {
        k2("undefined requester, can not start animating");
        return;
      }
      if (r.has(m)) {
        _2("requester is already registered for animating");
        return;
      }
      r.add(m), !e.animationRequest && r.size === 1 && !e.xrAnimation && (e._animationStartTime = Date.now(), e._animationFrameCount = 0, e.animationRequest = requestAnimationFrame(t.handleAnimation), t.startAnimationEvent());
    }, t.extendAnimation = (m) => {
      const y = Date.now() + m;
      e._animationExtendedEnd = Math.max(e._animationExtendedEnd, y), !e.animationRequest && r.size === 0 && !e.xrAnimation && (e._animationStartTime = Date.now(), e._animationFrameCount = 0, e.animationRequest = requestAnimationFrame(t.handleAnimation), t.startAnimationEvent());
    }, t.isAnimating = () => e.xrAnimation || e.animationRequest !== null, t.cancelAnimation = function(m) {
      let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!r.has(m)) {
        if (!y) {
          const w = m && m.getClassName ? m.getClassName() : m;
          _2(`${w} did not request an animation`);
        }
        return;
      }
      r.delete(m), e.animationRequest && r.size === 0 && Date.now() > e._animationExtendedEnd && (cancelAnimationFrame(e.animationRequest), e.animationRequest = null, t.endAnimationEvent(), t.render());
    }, t.switchToXRAnimation = () => {
      e.animationRequest && (cancelAnimationFrame(e.animationRequest), e.animationRequest = null), e.xrAnimation = true;
    }, t.returnFromXRAnimation = () => {
      e.xrAnimation = false, r.size !== 0 && (e.recentAnimationFrameRate = 10, e.animationRequest = requestAnimationFrame(t.handleAnimation));
    }, t.updateXRGamepads = (m, y, w) => {
      m.inputSources.forEach((C) => {
        const T = C.gripSpace == null ? null : y.getPose(C.gripSpace, w), S = C.gripSpace == null ? null : y.getPose(C.targetRaySpace, w), E = C.gamepad, b = C.handedness;
        if (E) {
          E.index in e.lastGamepadValues || (e.lastGamepadValues[E.index] = {
            left: {
              buttons: {}
            },
            right: {
              buttons: {}
            },
            none: {
              buttons: {}
            }
          });
          for (let D = 0; D < E.buttons.length; ++D) D in e.lastGamepadValues[E.index][b].buttons || (e.lastGamepadValues[E.index][b].buttons[D] = false), e.lastGamepadValues[E.index][b].buttons[D] !== E.buttons[D].pressed && T != null && (t.button3DEvent({
            gamepad: E,
            position: T.transform.position,
            orientation: T.transform.orientation,
            targetPosition: S.transform.position,
            targetOrientation: S.transform.orientation,
            pressed: E.buttons[D].pressed,
            device: C.handedness === "left" ? B2.LeftController : B2.RightController,
            input: G4[E.mapping] && G4[E.mapping][D] ? G4[E.mapping][D] : Ac.Trigger
          }), e.lastGamepadValues[E.index][b].buttons[D] = E.buttons[D].pressed), e.lastGamepadValues[E.index][b].buttons[D] && T != null && t.move3DEvent({
            gamepad: E,
            position: T.transform.position,
            orientation: T.transform.orientation,
            targetPosition: S.transform.position,
            targetOrientation: S.transform.orientation,
            device: C.handedness === "left" ? B2.LeftController : B2.RightController
          });
        }
      });
    }, t.handleMouseMove = (m) => {
      const y = {
        ...c(m),
        position: l(m),
        deviceType: u(m)
      };
      e.moveTimeoutID === 0 ? t.startMouseMoveEvent(y) : (t.mouseMoveEvent(y), clearTimeout(e.moveTimeoutID)), e.moveTimeoutID = setTimeout(() => {
        t.endMouseMoveEvent(), e.moveTimeoutID = 0;
      }, 200);
    }, t.handleAnimation = () => {
      const m = Date.now();
      e._animationFrameCount++, m - e._animationStartTime > 1e3 && e._animationFrameCount > 1 && (e.recentAnimationFrameRate = 1e3 * (e._animationFrameCount - 1) / (m - e._animationStartTime), e.lastFrameTime = 1 / e.recentAnimationFrameRate, t.animationFrameRateUpdateEvent(), e._animationStartTime = m, e._animationFrameCount = 1), t.animationEvent(), v(), r.size > 0 || Date.now() < e._animationExtendedEnd ? e.animationRequest = requestAnimationFrame(t.handleAnimation) : (cancelAnimationFrame(e.animationRequest), e.animationRequest = null, t.endAnimationEvent(), t.render());
    }, t.handleWheel = (m) => {
      w1(m);
      const y = {
        ...a$(m),
        ...c(m),
        position: l(m),
        deviceType: u(m)
      };
      e.wheelTimeoutID === 0 && (Math.abs(y.spinY) >= 0.3 ? a = Math.abs(y.spinY) : a = 1), y.spinY /= a, e.wheelTimeoutID === 0 ? (t.startMouseWheelEvent(y), t.mouseWheelEvent(y)) : (t.mouseWheelEvent(y), clearTimeout(e.wheelTimeoutID)), e.mouseScrollDebounceByPass ? (t.extendAnimation(600), t.endMouseWheelEvent(), e.wheelTimeoutID = 0) : e.wheelTimeoutID = setTimeout(() => {
        t.extendAnimation(600), t.endMouseWheelEvent(), e.wheelTimeoutID = 0;
      }, 200);
    }, t.handleMouseUp = (m) => {
      const y = {
        ...c(m),
        position: l(m),
        deviceType: u(m)
      };
      switch (m.button) {
        case 0:
          t.leftButtonReleaseEvent(y);
          break;
        case 1:
          t.middleButtonReleaseEvent(y);
          break;
        case 2:
          t.rightButtonReleaseEvent(y);
          break;
        default:
          k2(`Unknown mouse button released: ${m.button}`);
          break;
      }
    }, t.handleTouchStart = (m) => {
      const y = [
        ...i.values()
      ];
      if (e.recognizeGestures && y.length > 1) {
        const w = P2(i);
        if (y.length === 2) {
          const C = {
            ...c(Q0),
            position: y[0].position,
            deviceType: u(m)
          };
          t.leftButtonReleaseEvent(C);
        }
        t.recognizeGesture("TouchStart", w);
      } else if (y.length === 1) {
        const w = {
          ...c(Q0),
          position: l(m),
          deviceType: u(m)
        };
        t.leftButtonPressEvent(w);
      }
    }, t.handleTouchMove = (m) => {
      const y = [
        ...i.values()
      ];
      if (e.recognizeGestures && y.length > 1) {
        const w = P2(i);
        t.recognizeGesture("TouchMove", w);
      } else if (y.length === 1) {
        const w = {
          ...c(Q0),
          position: y[0].position,
          deviceType: u(m)
        };
        t.mouseMoveEvent(w);
      }
    }, t.handleTouchEnd = (m) => {
      const y = [
        ...i.values()
      ];
      if (e.recognizeGestures) if (y.length === 0) {
        const w = {
          ...c(Q0),
          position: l(m),
          deviceType: u(m)
        };
        t.leftButtonReleaseEvent(w);
      } else if (y.length === 1) {
        const w = P2(i);
        t.recognizeGesture("TouchEnd", w);
        const C = {
          ...c(Q0),
          position: y[0].position,
          deviceType: u(m)
        };
        t.leftButtonPressEvent(C);
      } else {
        const w = P2(i);
        t.recognizeGesture("TouchMove", w);
      }
      else if (y.length === 1) {
        const w = {
          ...c(Q0),
          position: y[0].position,
          deviceType: u(m)
        };
        t.leftButtonReleaseEvent(w);
      }
    }, t.setView = (m) => {
      e._view !== m && (e._view = m, e._view.getRenderable().setInteractor(t), t.modified());
    }, t.getFirstRenderer = () => {
      var _a3, _b3, _c3;
      return (_c3 = (_b3 = (_a3 = e._view) == null ? void 0 : _a3.getRenderable()) == null ? void 0 : _b3.getRenderersByReference()) == null ? void 0 : _c3[0];
    }, t.findPokedRenderer = function() {
      var _a3, _b3;
      let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!e._view) return null;
      const w = (_b3 = (_a3 = e._view) == null ? void 0 : _a3.getRenderable()) == null ? void 0 : _b3.getRenderers();
      if (!w || w.length === 0) return null;
      w.sort((b, D) => b.getLayer() - D.getLayer());
      let C = null, T = null, S = null, E = w.length;
      for (; E--; ) {
        const b = w[E];
        if (e._view.isInViewport(m, y, b) && b.getInteractive()) {
          S = b;
          break;
        }
        C === null && b.getInteractive() && (C = b), T === null && e._view.isInViewport(m, y, b) && (T = b);
      }
      return S === null && (S = C), S === null && (S = T), S == null && (S = w[0]), S;
    }, t.render = () => {
      !t.isAnimating() && !e.inRender && v();
    }, ay.forEach((m) => {
      const y = m.charAt(0).toLowerCase() + m.slice(1);
      t[`${y}Event`] = (w) => {
        if (!e.enabled) return;
        if (!t.getCurrentRenderer()) {
          s$(`
          Can not forward events without a current renderer on the interactor.
        `);
          return;
        }
        const T = {
          type: m,
          pokedRenderer: e.currentRenderer,
          firstRenderer: t.getFirstRenderer(),
          ...w
        };
        t[`invoke${m}`](T);
      };
    }), t.recognizeGesture = (m, y) => {
      if (Object.keys(y).length > 2) return;
      if (e.startingEventPositions || (e.startingEventPositions = {}), m === "TouchStart") {
        Object.keys(y).forEach((O) => {
          e.startingEventPositions[O] = y[O];
        }), e.currentGesture = "Start";
        return;
      }
      if (m === "TouchEnd") {
        e.currentGesture === "Pinch" && (t.render(), t.endPinchEvent()), e.currentGesture === "Rotate" && (t.render(), t.endRotateEvent()), e.currentGesture === "Pan" && (t.render(), t.endPanEvent()), e.currentGesture = "Start", e.startingEventPositions = {};
        return;
      }
      let w = 0;
      const C = [], T = [];
      Object.keys(y).forEach((O) => {
        C[w] = y[O], T[w] = e.startingEventPositions[O], w++;
      });
      const S = Math.sqrt((T[0].x - T[1].x) * (T[0].x - T[1].x) + (T[0].y - T[1].y) * (T[0].y - T[1].y)), E = Math.sqrt((C[0].x - C[1].x) * (C[0].x - C[1].x) + (C[0].y - C[1].y) * (C[0].y - C[1].y));
      let b = op(Math.atan2(T[1].y - T[0].y, T[1].x - T[0].x)), D = op(Math.atan2(C[1].y - C[0].y, C[1].x - C[0].x)), R = D - b;
      D = D + 180 >= 360 ? D - 180 : D + 180, b = b + 180 >= 360 ? b - 180 : b + 180, Math.abs(D - b) < Math.abs(R) && (R = D - b);
      const I = [];
      if (I[0] = (C[0].x - T[0].x + C[1].x - T[1].x) / 2, I[1] = (C[0].y - T[0].y + C[1].y - T[1].y) / 2, m === "TouchMove") if (e.currentGesture === "Start") {
        let O = 0.01 * Math.sqrt(e.container.clientWidth * e.container.clientWidth + e.container.clientHeight * e.container.clientHeight);
        O < 15 && (O = 15);
        const L = Math.abs(E - S), N = E * 3.1415926 * Math.abs(R) / 360, F = Math.sqrt(I[0] * I[0] + I[1] * I[1]);
        if (L > O && L > N && L > F) {
          e.currentGesture = "Pinch";
          const V = {
            scale: 1,
            touches: y
          };
          t.startPinchEvent(V);
        } else if (N > O && N > F) {
          e.currentGesture = "Rotate";
          const V = {
            rotation: 0,
            touches: y
          };
          t.startRotateEvent(V);
        } else if (F > O) {
          e.currentGesture = "Pan";
          const V = {
            translation: [
              0,
              0
            ],
            touches: y
          };
          t.startPanEvent(V);
        }
      } else {
        if (e.currentGesture === "Rotate") {
          const O = {
            rotation: R,
            touches: y
          };
          t.rotateEvent(O);
        }
        if (e.currentGesture === "Pinch") {
          const O = {
            scale: E / S,
            touches: y
          };
          t.pinchEvent(O);
        }
        if (e.currentGesture === "Pan") {
          const O = {
            translation: I,
            touches: y
          };
          t.panEvent(O);
        }
      }
    }, t.handleVisibilityChange = () => {
      e._animationStartTime = Date.now(), e._animationFrameCount = 0;
    }, t.setCurrentRenderer = (m) => {
      e._forcedRenderer = !!m, e.currentRenderer = m;
    }, t.setContainer = (m) => {
      g();
      const y = n.setContainer(m ?? null);
      return y && h(), y;
    }, t.delete = () => {
      for (; r.size; ) t.cancelAnimation(r.values().next().value);
      typeof document.hidden < "u" && document.removeEventListener("visibilitychange", t.handleVisibilityChange), e.container && t.setContainer(null), n.delete();
    }, typeof document.hidden < "u" && document.addEventListener("visibilitychange", t.handleVisibilityChange, false);
  }
  const l$ = {
    renderWindow: null,
    interactorStyle: null,
    picker: null,
    pickingManager: null,
    initialized: false,
    enabled: false,
    enableRender: true,
    currentRenderer: null,
    lightFollowCamera: true,
    desiredUpdateRate: 30,
    stillUpdateRate: 2,
    container: null,
    recognizeGestures: true,
    currentGesture: "Start",
    animationRequest: null,
    lastFrameTime: 0.1,
    recentAnimationFrameRate: 10,
    wheelTimeoutID: 0,
    moveTimeoutID: 0,
    lastGamepadValues: {},
    preventDefaultOnPointerDown: false,
    preventDefaultOnPointerUp: false,
    mouseScrollDebounceByPass: false
  };
  function rO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, l$, n), H.obj(t, e), e._animationExtendedEnd = 0, H.event(t, e, "RenderEvent"), ay.forEach((r) => H.event(t, e, r)), H.get(t, e, [
      "initialized",
      "interactorStyle",
      "lastFrameTime",
      "recentAnimationFrameRate",
      "_view"
    ]), H.setGet(t, e, [
      "container",
      "lightFollowCamera",
      "enabled",
      "enableRender",
      "recognizeGestures",
      "desiredUpdateRate",
      "stillUpdateRate",
      "picker",
      "preventDefaultOnPointerDown",
      "preventDefaultOnPointerUp",
      "mouseScrollDebounceByPass"
    ]), H.moveToProtected(t, e, [
      "view"
    ]), o$(t, e);
  }
  const c$ = H.newInstance(rO, "vtkRenderWindowInteractor");
  var u$ = {
    newInstance: c$,
    extend: rO,
    handledEvents: ay,
    ...nO
  };
  const { vtkErrorMacro: f$ } = H, h$ = [
    1,
    -1,
    1,
    -1,
    1,
    -1
  ];
  function d$(t, e) {
    e.classHierarchy.push("vtkPoints"), t.getNumberOfPoints = t.getNumberOfTuples, t.setNumberOfPoints = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      t.getNumberOfPoints() !== n && (e.size = n * r, e.values = H.newTypedArray(e.dataType, e.size), t.setNumberOfComponents(r), t.modified());
    }, t.setPoint = function(n) {
      for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++) i[a - 1] = arguments[a];
      t.setTuple(n, i);
    }, t.getPoint = t.getTuple, t.findPoint = t.findTuple, t.insertNextPoint = (n, r, i) => t.insertNextTuple([
      n,
      r,
      i
    ]), t.getBounds = () => {
      if (t.getNumberOfComponents() === 3) {
        const i = t.getRange(0);
        e.bounds[0] = i[0], e.bounds[1] = i[1];
        const a = t.getRange(1);
        e.bounds[2] = a[0], e.bounds[3] = a[1];
        const s = t.getRange(2);
        return e.bounds[4] = s[0], e.bounds[5] = s[1], e.bounds;
      }
      if (t.getNumberOfComponents() !== 2) return f$(`getBounds called on an array with components of
        ${t.getNumberOfComponents()}`), h$;
      const n = t.getRange(0);
      e.bounds[0] = n[0], e.bounds[1] = n[1];
      const r = t.getRange(1);
      return e.bounds[2] = r[0], e.bounds[3] = r[1], e.bounds[4] = 0, e.bounds[5] = 0, e.bounds;
    }, t.computeBounds = t.getBounds, t.setNumberOfComponents(e.numberOfComponents < 2 ? 3 : e.numberOfComponents);
  }
  const g$ = {
    empty: true,
    numberOfComponents: 3,
    dataType: zt.FLOAT,
    bounds: [
      1,
      -1,
      1,
      -1,
      1,
      -1
    ]
  };
  function iO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, g$, n), Tt.extend(t, e, n), d$(t, e);
  }
  const p$ = H.newInstance(iO, "vtkPoints");
  var Sp = {
    newInstance: p$,
    extend: iO
  };
  function aO(t) {
    let e = 0;
    return t.filter((n, r) => r === e ? (e += n + 1, true) : false);
  }
  function sO(t) {
    let e = 0;
    for (let n = 0; n < t.length; ) n += t[n] + 1, e++;
    return e;
  }
  const m$ = {
    extractCellSizes: aO,
    getNumberOfCells: sO
  };
  function v$(t, e) {
    e.classHierarchy.push("vtkCellArray");
    const n = {
      ...t
    };
    t.getNumberOfCells = (r) => (e.numberOfCells !== void 0 && !r || (e.cellSizes ? e.numberOfCells = e.cellSizes.length : e.numberOfCells = sO(t.getData())), e.numberOfCells), t.getCellSizes = (r) => (e.cellSizes !== void 0 && !r || (e.cellSizes = aO(t.getData())), e.cellSizes), t.resize = (r) => {
      const i = t.getNumberOfTuples();
      n.resize(r);
      const a = t.getNumberOfTuples();
      a < i && (a === 0 ? (e.numberOfCells = 0, e.cellSizes = []) : (e.numberOfCells = void 0, e.cellSizes = void 0));
    }, t.setData = (r) => {
      n.setData(r, 1), e.numberOfCells = void 0, e.cellSizes = void 0;
    }, t.getCell = (r) => {
      let i = r;
      const a = e.values[i++];
      return e.values.subarray(i, i + a);
    }, t.insertNextCell = (r) => {
      const i = t.getNumberOfCells();
      return t.insertNextTuples([
        r.length,
        ...r
      ]), ++e.numberOfCells, e.cellSizes != null && e.cellSizes.push(r.length), i;
    };
  }
  function y$(t) {
    return {
      empty: true,
      numberOfComponents: 1,
      dataType: zt.UNSIGNED_INT,
      ...t
    };
  }
  function oO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Tt.extend(t, e, y$(n)), v$(t, e);
  }
  const x$ = H.newInstance(oO, "vtkCellArray");
  var Yc = {
    newInstance: x$,
    extend: oO,
    ...m$
  };
  function w$(t, e) {
    e.classHierarchy.push("vtkCell"), t.initialize = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (r) {
        e.pointsIds = r;
        let i = e.points.getData();
        i.length !== 3 * e.pointsIds.length && (i = H.newTypedArray(n.getDataType(), 3 * e.pointsIds.length));
        const a = n.getData();
        e.pointsIds.forEach((s, o) => {
          let l = 3 * s, c = 3 * o;
          i[c] = a[l], i[++c] = a[++l], i[++c] = a[++l];
        }), e.points.setData(i);
      } else {
        e.points = n, e.pointsIds = new Array(n.getNumberOfPoints());
        for (let i = n.getNumberOfPoints() - 1; i >= 0; --i) e.pointsIds[i] = i;
      }
    }, t.getBounds = () => {
      const n = e.points.getNumberOfPoints(), r = [];
      if (n) {
        e.points.getPoint(0, r), e.bounds[0] = r[0], e.bounds[1] = r[0], e.bounds[2] = r[1], e.bounds[3] = r[1], e.bounds[4] = r[2], e.bounds[5] = r[2];
        for (let i = 1; i < n; i++) e.points.getPoint(i, r), e.bounds[0] = r[0] < e.bounds[0] ? r[0] : e.bounds[0], e.bounds[1] = r[0] > e.bounds[1] ? r[0] : e.bounds[1], e.bounds[2] = r[1] < e.bounds[2] ? r[1] : e.bounds[2], e.bounds[3] = r[1] > e.bounds[3] ? r[1] : e.bounds[3], e.bounds[4] = r[2] < e.bounds[4] ? r[2] : e.bounds[4], e.bounds[5] = r[2] > e.bounds[5] ? r[2] : e.bounds[5];
      } else Zu(e.bounds);
      return e.bounds;
    }, t.getLength2 = () => {
      t.getBounds();
      let n = 0, r = 0;
      for (let i = 0; i < 3; i++) r = e.bounds[2 * i + 1] - e.bounds[2 * i], n += r * r;
      return n;
    }, t.getParametricDistance = (n) => {
      let r, i = 0;
      for (let a = 0; a < 3; a++) n[a] < 0 ? r = -n[a] : n[a] > 1 ? r = n[a] - 1 : r = 0, r > i && (i = r);
      return i;
    }, t.getNumberOfPoints = () => e.points.getNumberOfPoints(), t.deepCopy = (n) => {
      n.initialize(e.points, e.pointsIds);
    }, t.getCellDimension = () => {
    }, t.intersectWithLine = (n, r, i, a, s, o, l) => {
    }, t.evaluatePosition = (n, r, i, a, s, o) => {
      H.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
    };
  }
  const C$ = {
    bounds: [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ],
    pointsIds: []
  };
  function lO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, C$, n), H.obj(t, e), e.points || (e.points = Sp.newInstance()), H.get(t, e, [
      "points",
      "pointsIds"
    ]), w$(t, e);
  }
  const T$ = H.newInstance(lO, "vtkCell");
  var Ap = {
    newInstance: T$,
    extend: lO
  };
  function S$(t, e) {
    let n = e;
    for (e >= t.array.length && (n += t.array.length); n > t.array.length; ) t.array.push({
      ncells: 0,
      cells: null
    });
    t.array.length = n;
  }
  function A$(t, e) {
    e.classHierarchy.push("vtkCellLinks"), t.buildLinks = (n) => {
      const r = n.getPoints().getNumberOfPoints(), i = n.getNumberOfCells(), a = new Uint32Array(r);
      if (n.isA("vtkPolyData")) {
        for (let s = 0; s < i; ++s) {
          const { cellPointIds: o } = n.getCellPoints(s);
          o.forEach((l) => {
            t.incrementLinkCount(l);
          });
        }
        t.allocateLinks(r), e.maxId = r - 1;
        for (let s = 0; s < i; ++s) {
          const { cellPointIds: o } = n.getCellPoints(s);
          o.forEach((l) => {
            t.insertCellReference(l, a[l]++, s);
          });
        }
      } else {
        for (let s = 0; s < i; s++) Ap.newInstance().getPointsIds().forEach((l) => {
          t.incrementLinkCount(l);
        });
        t.allocateLinks(r), e.maxId = r - 1;
        for (let s = 0; s < i; ++s) Ap.newInstance().getPointsIds().forEach((l) => {
          t.insertCellReference(l, a[l]++, s);
        });
      }
    }, t.allocate = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
      e.array = Array(n).fill().map(() => ({
        ncells: 0,
        cells: null
      })), e.extend = r, e.maxId = -1;
    }, t.initialize = () => {
      e.array = null;
    }, t.getLink = (n) => e.array[n], t.getNcells = (n) => e.array[n].ncells, t.getCells = (n) => e.array[n].cells, t.insertNextPoint = (n) => {
      e.array.push({
        ncells: n,
        cells: Array(n)
      }), ++e.maxId;
    }, t.insertNextCellReference = (n, r) => {
      e.array[n].cells[e.array[n].ncells++] = r;
    }, t.deletePoint = (n) => {
      e.array[n].ncells = 0, e.array[n].cells = null;
    }, t.removeCellReference = (n, r) => {
      e.array[r].cells = e.array[r].cells.filter((i) => i !== n), e.array[r].ncells = e.array[r].cells.length;
    }, t.addCellReference = (n, r) => {
      e.array[r].cells[e.array[r].ncells++] = n;
    }, t.resizeCellList = (n, r) => {
      e.array[n].cells.length = r;
    }, t.squeeze = () => {
      S$(e, e.maxId + 1);
    }, t.reset = () => {
      e.maxId = -1;
    }, t.deepCopy = (n) => {
      e.array = [
        ...n.array
      ], e.extend = n.extend, e.maxId = n.maxId;
    }, t.incrementLinkCount = (n) => {
      ++e.array[n].ncells;
    }, t.allocateLinks = (n) => {
      for (let r = 0; r < n; ++r) e.array[r].cells = new Array(e.array[r].ncells);
    }, t.insertCellReference = (n, r, i) => {
      e.array[n].cells[r] = i;
    };
  }
  const E$ = {
    array: null,
    maxId: 0,
    extend: 0
  };
  function cO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, E$, n), H.obj(t, e), A$(t, e);
  }
  const b$ = H.newInstance(cO, "vtkCellLinks");
  var D$ = {
    newInstance: b$,
    extend: cO
  };
  const Gn = {
    VTK_EMPTY_CELL: 0,
    VTK_VERTEX: 1,
    VTK_POLY_VERTEX: 2,
    VTK_LINE: 3,
    VTK_POLY_LINE: 4,
    VTK_TRIANGLE: 5,
    VTK_TRIANGLE_STRIP: 6,
    VTK_POLYGON: 7,
    VTK_QUAD: 9,
    VTK_QUADRATIC_EDGE: 21,
    VTK_CONVEX_POINT_SET: 41,
    VTK_POLYHEDRON: 42
  }, d6 = [
    "vtkEmptyCell",
    "vtkVertex",
    "vtkPolyVertex",
    "vtkLine",
    "vtkPolyLine",
    "vtkTriangle",
    "vtkTriangleStrip",
    "vtkPolygon",
    "vtkPixel",
    "vtkQuad",
    "vtkTetra",
    "vtkVoxel",
    "vtkHexahedron",
    "vtkWedge",
    "vtkPyramid",
    "vtkPentagonalPrism",
    "vtkHexagonalPrism",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "vtkQuadraticEdge",
    "vtkQuadraticTriangle",
    "vtkQuadraticQuad",
    "vtkQuadraticTetra",
    "vtkQuadraticHexahedron",
    "vtkQuadraticWedge",
    "vtkQuadraticPyramid",
    "vtkBiQuadraticQuad",
    "vtkTriQuadraticHexahedron",
    "vtkQuadraticLinearQuad",
    "vtkQuadraticLinearWedge",
    "vtkBiQuadraticQuadraticWedge",
    "vtkBiQuadraticQuadraticHexahedron",
    "vtkBiQuadraticTriangle",
    "vtkCubicLine",
    "vtkQuadraticPolygon",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "vtkConvexPointSet",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "vtkParametricCurve",
    "vtkParametricSurface",
    "vtkParametricTriSurface",
    "vtkParametricQuadSurface",
    "vtkParametricTetraRegion",
    "vtkParametricHexRegion",
    "UnknownClass",
    "UnknownClass",
    "UnknownClass",
    "vtkHigherOrderEdge",
    "vtkHigherOrderTriangle",
    "vtkHigherOrderQuad",
    "vtkHigherOrderPolygon",
    "vtkHigherOrderTetrahedron",
    "vtkHigherOrderWedge",
    "vtkHigherOrderPyramid",
    "vtkHigherOrderHexahedron"
  ];
  function M$(t) {
    return t < d6.length ? d6[t] : "UnknownClass";
  }
  function R$(t) {
    return d6.findIndex(t);
  }
  function O$(t) {
    return t < Gn.VTK_QUADRATIC_EDGE || t === Gn.VTK_CONVEX_POINT_SET || t === Gn.VTK_POLYHEDRON;
  }
  function I$(t) {
    return t === Gn.VTK_TRIANGLE_STRIP || t === Gn.VTK_POLY_LINE || t === Gn.VTK_POLY_VERTEX;
  }
  const V$ = {
    getClassNameFromTypeId: M$,
    getTypeIdFromClassName: R$,
    isLinear: O$,
    hasSubCells: I$
  };
  function N$(t, e) {
    e.classHierarchy.push("vtkCellTypes"), t.allocate = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
      e.size = n > 0 ? n : 1, e.extend = r > 0 ? r : 1, e.maxId = -1, e.typeArray = new Uint8Array(n), e.locationArray = new Uint32Array(n);
    }, t.insertCell = (n, r, i) => {
      e.typeArray[n] = r, e.locationArray[n] = i, n > e.maxId && (e.maxId = n);
    }, t.insertNextCell = (n, r) => (t.insertCell(++e.maxId, n, r), e.maxId), t.setCellTypes = (n, r, i) => {
      e.size = n, e.typeArray = r, e.locationArray = i, e.maxId = n - 1;
    }, t.getCellLocation = (n) => e.locationArray[n], t.deleteCell = (n) => {
      e.typeArray[n] = Gn.VTK_EMPTY_CELL;
    }, t.getNumberOfTypes = () => e.maxId + 1, t.isType = (n) => {
      const r = t.getNumberOfTypes();
      for (let i = 0; i < r; ++i) if (n === t.getCellType(i)) return true;
      return false;
    }, t.insertNextType = (n) => t.insertNextCell(n, -1), t.getCellType = (n) => e.typeArray[n], t.reset = () => {
      e.maxId = -1;
    }, t.deepCopy = (n) => {
      t.allocate(n.getSize(), n.getExtend()), e.typeArray.set(n.getTypeArray()), e.locationArray.set(n.getLocationArray()), e.maxId = n.getMaxId();
    };
  }
  const L$ = {
    size: 0,
    maxId: -1,
    extend: 1e3
  };
  function uO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, L$, n), H.obj(t, e), H.get(t, e, [
      "size",
      "maxId",
      "extend"
    ]), H.getArray(t, e, [
      "typeArray",
      "locationArray"
    ]), N$(t, e);
  }
  const U$ = H.newInstance(uO, "vtkCellTypes");
  var F$ = {
    newInstance: U$,
    extend: uO,
    ...V$
  };
  const B$ = {
    NO_INTERSECTION: 0,
    YES_INTERSECTION: 1,
    ON_LINE: 2
  };
  var fO = {
    IntersectionState: B$
  };
  const { IntersectionState: Pg } = fO;
  function uu(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    const i = {
      t: Number.MIN_VALUE,
      distance: 0
    }, a = [];
    let s;
    a[0] = n[0] - e[0], a[1] = n[1] - e[1], a[2] = n[2] - e[2];
    const o = a[0] * (t[0] - e[0]) + a[1] * (t[1] - e[1]) + a[2] * (t[2] - e[2]), l = Ht(a, a);
    let c = 1e-5 * o;
    return l !== 0 && (i.t = o / l), c < 0 && (c = -c), -c < l && l < c || l <= 0 || i.t < 0 ? s = e : i.t > 1 ? s = n : (s = a, a[0] = e[0] + i.t * a[0], a[1] = e[1] + i.t * a[1], a[2] = e[2] + i.t * a[2]), r && (r[0] = s[0], r[1] = s[1], r[2] = s[2]), i.distance = bs(s, t), i;
  }
  function hO(t, e, n, r, i, a) {
    const s = [], o = [], l = [];
    i[0] = 0, a[0] = 0, xo(e, t, s), xo(r, n, o), xo(n, t, l);
    const c = [
      Ht(s, s),
      -Ht(s, o),
      -Ht(s, o),
      Ht(o, o)
    ], f = [];
    if (f[0] = Ht(s, l), f[1] = -Ht(o, l), aD(c, f, 2) === 0) {
      let u = Number.MAX_VALUE;
      const h = [
        t,
        e,
        n,
        r
      ], g = [
        n,
        n,
        t,
        t
      ], v = [
        r,
        r,
        e,
        e
      ];
      a[0], a[0], i[0], i[0], i[0], i[0], a[0], a[0];
      let m;
      for (let y = 0; y < 4; y++) m = uu(h[y], g[y], v[y]), m.distance < u && (u = m.distance);
      return Pg.ON_LINE;
    }
    return i[0] = f[0], a[0] = f[1], i[0] >= 0 && i[0] <= 1 && a[0] >= 0 && a[0] <= 1 ? Pg.YES_INTERSECTION : Pg.NO_INTERSECTION;
  }
  const _$ = {
    distanceToLine: uu,
    intersection: hO
  };
  function k$(t, e) {
    e.classHierarchy.push("vtkLine");
    function n(r) {
      return r >= 0 && r <= 1;
    }
    t.getCellDimension = () => 1, t.intersectWithLine = (r, i, a, s, o) => {
      const l = {
        intersect: 0,
        t: Number.MAX_VALUE,
        subId: 0,
        betweenPoints: null
      };
      o[1] = 0, o[2] = 0;
      const c = [], f = [], u = [];
      e.points.getPoint(0, f), e.points.getPoint(1, u);
      const h = [], g = [], v = hO(r, i, f, u, h, g);
      if (l.t = h[0], l.betweenPoints = n(l.t), o[0] = g[0], v === Pg.YES_INTERSECTION) {
        for (let m = 0; m < 3; m++) s[m] = f[m] + o[0] * (u[m] - f[m]), c[m] = r[m] + l.t * (i[m] - r[m]);
        if (bs(s, c) <= a * a) return l.intersect = 1, l;
      } else {
        let m;
        if (l.t < 0) return m = uu(r, f, u, s), m.distance <= a * a && (l.t = 0, l.intersect = 1, l.betweenPoints = true), l;
        if (l.t > 1) return m = uu(i, f, u, s), m.distance <= a * a && (l.t = 1, l.intersect = 1, l.betweenPoints = true), l;
        if (o[0] < 0) return o[0] = 0, m = uu(f, r, i, s), l.t = m.t, m.distance <= a * a && (l.intersect = 1), l;
        if (o[0] > 1) return o[0] = 1, m = uu(u, r, i, s), l.t = m.t, m.distance <= a * a && (l.intersect = 1), l;
      }
      return l;
    }, t.evaluateLocation = (r, i, a) => {
      const s = [], o = [];
      e.points.getPoint(0, s), e.points.getPoint(1, o);
      for (let l = 0; l < 3; l++) i[l] = s[l] + r[0] * (o[l] - s[l]);
      a[0] = 1 - r[0], a[1] = r[0];
    }, t.evaluateOrientation = (r, i, a) => e.orientations ? (Fg(i, e.orientations[0], e.orientations[1], r[0]), a[0] = 1 - r[0], a[1] = r[0], true) : false;
  }
  const P$ = {
    orientations: null
  };
  function dO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, P$, n), Ap.extend(t, e, n), H.setGet(t, e, [
      "orientations"
    ]), k$(t, e);
  }
  const G$ = H.newInstance(dO, "vtkLine");
  var Va = {
    newInstance: G$,
    extend: dO,
    ..._$,
    ...fO
  };
  function z$(t, e) {
    e.classHierarchy.push("vtkPointSet"), e.points ? e.points = ss(e.points) : e.points = Sp.newInstance(), t.getNumberOfPoints = () => e.points.getNumberOfPoints(), t.getBounds = () => e.points.getBounds(), t.computeBounds = () => {
      t.getBounds();
    };
    const n = t.shallowCopy;
    t.shallowCopy = function(r) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      n(r, i), e.points = Sp.newInstance(), e.points.shallowCopy(r.getPoints());
    };
  }
  const W$ = {};
  function gO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, W$, n), $u.extend(t, e, n), H.setGet(t, e, [
      "points"
    ]), z$(t, e);
  }
  const H$ = H.newInstance(gO, "vtkPointSet");
  var j$ = {
    newInstance: H$,
    extend: gO
  };
  function sy(t, e, n, r) {
    const i = n[0] - e[0], a = n[1] - e[1], s = n[2] - e[2], o = t[0] - e[0], l = t[1] - e[1], c = t[2] - e[2];
    r[0] = a * c - s * l, r[1] = s * o - i * c, r[2] = i * l - a * o;
  }
  function Ep(t, e, n, r) {
    sy(t, e, n, r);
    const i = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
    i !== 0 && (r[0] /= i, r[1] /= i, r[2] /= i);
  }
  function K$(t, e, n, r, i, a) {
    let s = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6, o = false;
    const l = [], c = [], f = [], u = [], h = [];
    Ep(t, e, n, u), Ep(r, i, a, h);
    const g = -Ht(u, t), v = -Ht(h, r), m = [
      Ht(h, t) + v,
      Ht(h, e) + v,
      Ht(h, n) + v
    ];
    if (m[0] * m[1] > s && m[0] * m[2] > s) return {
      intersect: false,
      coplanar: o,
      pt1: l,
      pt2: c,
      surfaceId: f
    };
    const y = [
      Ht(u, r) + g,
      Ht(u, i) + g,
      Ht(u, a) + g
    ];
    if (y[0] * y[1] > s && y[0] * y[2] > s) return {
      intersect: false,
      coplanar: o,
      pt1: l,
      pt2: c,
      surfaceId: f
    };
    if (Math.abs(u[0] - h[0]) < 1e-9 && Math.abs(u[1] - h[1]) < 1e-9 && Math.abs(u[2] - h[2]) < 1e-9 && Math.abs(g - v) < 1e-9) return o = true, {
      intersect: false,
      coplanar: o,
      pt1: l,
      pt2: c,
      surfaceId: f
    };
    const w = [
      t,
      e,
      n
    ], C = [
      r,
      i,
      a
    ], T = Ht(u, h), S = (g - v * T) / (T * T - 1), E = (v - g * T) / (T * T - 1), b = [
      S * u[0] + E * h[0],
      S * u[1] + E * h[1],
      S * u[2] + E * h[2]
    ], D = Ns(u, h, []);
    Hc(D);
    let R = 0, I = 0;
    const O = [], L = [];
    let N = 50, F = 50;
    for (let _ = 0; _ < 3; _++) {
      const K = _, Z = (_ + 1) % 3, j = Si.intersectWithLine(w[K], w[Z], r, h);
      j.intersection && j.t > 0 - s && j.t < 1 + s && (j.t < 1 + s && j.t > 1 - s && (N = R), O[R++] = Ht(j.x, D) - Ht(b, D));
      const B = Si.intersectWithLine(C[K], C[Z], t, u);
      B.intersection && B.t > 0 - s && B.t < 1 + s && (B.t < 1 + s && B.t > 1 - s && (F = I), L[I++] = Ht(B.x, D) - Ht(b, D));
    }
    if (R > 2) {
      R--;
      const _ = O[2];
      O[2] = O[N], O[N] = _;
    }
    if (I > 2) {
      I--;
      const _ = L[2];
      L[2] = L[F], L[F] = _;
    }
    if (R !== 2 || I !== 2) return {
      intersect: false,
      coplanar: o,
      pt1: l,
      pt2: c,
      surfaceId: f
    };
    if (Number.isNaN(O[0]) || Number.isNaN(O[1]) || Number.isNaN(L[0]) || Number.isNaN(L[1])) return {
      intersect: false,
      coplanar: o,
      pt1: l,
      pt2: c,
      surfaceId: f
    };
    if (O[0] > O[1]) {
      const _ = O[1];
      O[1] = O[0], O[0] = _;
    }
    if (L[0] > L[1]) {
      const _ = L[1];
      L[1] = L[0], L[0] = _;
    }
    let V, k;
    return O[1] < L[0] || L[1] < O[0] ? {
      intersect: false,
      coplanar: o,
      pt1: l,
      pt2: c,
      surfaceId: f
    } : (O[0] < L[0] ? O[1] < L[1] ? (f[0] = 2, f[1] = 1, V = L[0], k = O[1]) : (f[0] = 2, f[1] = 2, V = L[0], k = L[1]) : O[1] < L[1] ? (f[0] = 1, f[1] = 1, V = O[0], k = O[1]) : (f[0] = 1, f[1] = 2, V = O[0], k = L[1]), Kv(b, D, V, l), Kv(b, D, k, c), {
      intersect: true,
      coplanar: o,
      pt1: l,
      pt2: c,
      surfaceId: f
    });
  }
  const Y$ = {
    computeNormalDirection: sy,
    computeNormal: Ep,
    intersectWithTriangle: K$
  };
  function q$(t, e) {
    e.classHierarchy.push("vtkTriangle"), t.getCellDimension = () => 2, t.intersectWithLine = (n, r, i, a, s) => {
      const o = {
        subId: 0,
        t: Number.MAX_VALUE,
        intersect: 0,
        betweenPoints: false
      };
      s[2] = 0;
      const l = [], c = i * i, f = [], u = [], h = [];
      e.points.getPoint(0, f), e.points.getPoint(1, u), e.points.getPoint(2, h);
      const g = [], v = [];
      if (Ep(f, u, h, g), g[0] !== 0 || g[1] !== 0 || g[2] !== 0) {
        const T = Si.intersectWithLine(n, r, f, g);
        if (o.betweenPoints = T.betweenPoints, o.t = T.t, a[0] = T.x[0], a[1] = T.x[1], a[2] = T.x[2], !T.intersection) return s[0] = 0, s[1] = 0, o.intersect = 0, o;
        const S = t.evaluatePosition(a, l, s, v);
        if (S.evaluation >= 0) return S.dist2 <= c ? (o.intersect = 1, o) : (o.intersect = S.evaluation, o);
      }
      const m = bs(f, u), y = bs(u, h), w = bs(h, f);
      e.line || (e.line = Va.newInstance()), m > y && m > w ? (e.line.getPoints().setPoint(0, f), e.line.getPoints().setPoint(1, u)) : y > w && y > m ? (e.line.getPoints().setPoint(0, u), e.line.getPoints().setPoint(1, h)) : (e.line.getPoints().setPoint(0, h), e.line.getPoints().setPoint(1, f));
      const C = e.line.intersectWithLine(n, r, i, a, s);
      if (o.betweenPoints = C.betweenPoints, o.t = C.t, C.intersect) {
        const T = [], S = [], E = [];
        for (let b = 0; b < 3; b++) T[b] = f[b] - h[b], S[b] = u[b] - h[b], E[b] = a[b] - h[b];
        return s[0] = Ht(E, T) / w, s[1] = Ht(E, S) / y, o.intersect = 1, o;
      }
      return s[0] = 0, s[1] = 0, o.intersect = 0, o;
    }, t.evaluatePosition = (n, r, i, a) => {
      const s = {
        subId: 0,
        dist2: 0,
        evaluation: -1
      };
      let o, l;
      const c = [], f = [], u = [], h = [];
      let g;
      const v = [], m = [], y = [];
      let w = 0, C = 0;
      const T = [];
      let S, E, b, D = [];
      const R = [], I = [], O = [];
      s.subId = 0, i[2] = 0, e.points.getPoint(1, c), e.points.getPoint(2, f), e.points.getPoint(0, u), sy(c, f, u, h), Si.generalizedProjectPoint(n, c, h, O);
      let L = 0;
      for (o = 0; o < 3; o++) h[o] < 0 ? g = -h[o] : g = h[o], g > L && (L = g, C = o);
      for (l = 0, o = 0; o < 3; o++) o !== C && (T[l++] = o);
      for (o = 0; o < 2; o++) v[o] = O[T[o]] - u[T[o]], m[o] = c[T[o]] - u[T[o]], y[o] = f[T[o]] - u[T[o]];
      if (w = ir(m, y), w === 0) return i[0] = 0, i[1] = 0, s.evaluation = -1, s;
      if (i[0] = ir(v, y) / w, i[1] = ir(m, v) / w, a[0] = 1 - (i[0] + i[1]), a[1] = i[0], a[2] = i[1], a[0] >= 0 && a[0] <= 1 && a[1] >= 0 && a[1] <= 1 && a[2] >= 0 && a[2] <= 1) r && (s.dist2 = bs(O, n), r[0] = O[0], r[1] = O[1], r[2] = O[2]), s.evaluation = 1;
      else {
        let N;
        if (r) {
          if (a[1] < 0 && a[2] < 0) for (S = bs(n, u), E = Va.distanceToLine(n, c, u, N, R), b = Va.distanceToLine(n, u, f, N, I), S < E ? (s.dist2 = S, D = u) : (s.dist2 = E, D = R), b < s.dist2 && (s.dist2 = b, D = I), o = 0; o < 3; o++) r[o] = D[o];
          else if (a[2] < 0 && a[0] < 0) for (S = bs(n, c), E = Va.distanceToLine(n, c, u, N, R), b = Va.distanceToLine(n, c, f, N, I), S < E ? (s.dist2 = S, D = c) : (s.dist2 = E, D = R), b < s.dist2 && (s.dist2 = b, D = I), o = 0; o < 3; o++) r[o] = D[o];
          else if (a[1] < 0 && a[0] < 0) for (S = bs(n, f), E = Va.distanceToLine(n, f, u, N, R), b = Va.distanceToLine(n, c, f, N, I), S < E ? (s.dist2 = S, D = f) : (s.dist2 = E, D = R), b < s.dist2 && (s.dist2 = b, D = I), o = 0; o < 3; o++) r[o] = D[o];
          else if (a[0] < 0) {
            const F = Va.distanceToLine(n, c, f, r);
            s.dist2 = F.distance;
          } else if (a[1] < 0) {
            const F = Va.distanceToLine(n, f, u, r);
            s.dist2 = F.distance;
          } else if (a[2] < 0) {
            const F = Va.distanceToLine(n, c, u, r);
            s.dist2 = F.distance;
          }
        }
        s.evaluation = 0;
      }
      return s;
    }, t.evaluateLocation = (n, r, i) => {
      const a = [], s = [], o = [];
      e.points.getPoint(0, a), e.points.getPoint(1, s), e.points.getPoint(2, o);
      const l = 1 - n[0] - n[1];
      for (let c = 0; c < 3; c++) r[c] = a[c] * l + s[c] * n[0] + o[c] * n[1];
      i[0] = l, i[1] = n[0], i[2] = n[1];
    }, t.getParametricDistance = (n) => {
      let r, i = 0;
      const a = [];
      a[0] = n[0], a[1] = n[1], a[2] = 1 - n[0] - n[1];
      for (let s = 0; s < 3; s++) a[s] < 0 ? r = -a[s] : a[s] > 1 ? r = a[s] - 1 : r = 0, r > i && (i = r);
      return i;
    };
  }
  const X$ = {};
  function pO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, X$, n), Ap.extend(t, e, n), q$(t, e);
  }
  const Z$ = H.newInstance(pO, "vtkTriangle");
  var Q$ = {
    newInstance: Z$,
    extend: pO,
    ...Y$
  };
  const z4 = [
    "verts",
    "lines",
    "polys",
    "strips"
  ], { vtkWarningMacro: PT } = H, J$ = {
    [Gn.VTK_LINE]: Va,
    [Gn.VTK_POLY_LINE]: Va,
    [Gn.VTK_TRIANGLE]: Q$
  };
  function $$(t, e) {
    e.classHierarchy.push("vtkPolyData");
    function n(i) {
      return i.replace(/(?:^\w|[A-Z]|\b\w)/g, (a) => a.toUpperCase()).replace(/\s+/g, "");
    }
    z4.forEach((i) => {
      t[`getNumberOf${n(i)}`] = () => e[i].getNumberOfCells(), e[i] ? e[i] = ss(e[i]) : e[i] = Yc.newInstance();
    }), t.getNumberOfCells = () => z4.reduce((i, a) => i + e[a].getNumberOfCells(), 0);
    const r = t.shallowCopy;
    t.shallowCopy = function(i) {
      let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      r(i, a), z4.forEach((s) => {
        e[s] = Yc.newInstance(), e[s].shallowCopy(i.getReferenceByName(s));
      });
    }, t.buildCells = () => {
      const i = t.getNumberOfVerts(), a = t.getNumberOfLines(), s = t.getNumberOfPolys(), o = t.getNumberOfStrips(), l = i + a + s + o, c = new Uint8Array(l);
      let f = c;
      const u = new Uint32Array(l);
      let h = u;
      if (i) {
        let g = 0;
        e.verts.getCellSizes().forEach((v, m) => {
          h[m] = g, f[m] = v > 1 ? Gn.VTK_POLY_VERTEX : Gn.VTK_VERTEX, g += v + 1;
        }), h = h.subarray(i), f = f.subarray(i);
      }
      if (a) {
        let g = 0;
        e.lines.getCellSizes().forEach((v, m) => {
          h[m] = g, f[m] = v > 2 ? Gn.VTK_POLY_LINE : Gn.VTK_LINE, v === 1 && PT("Building VTK_LINE ", m, " with only one point, but VTK_LINE needs at least two points. Check the input."), g += v + 1;
        }), h = h.subarray(a), f = f.subarray(a);
      }
      if (s) {
        let g = 0;
        e.polys.getCellSizes().forEach((v, m) => {
          switch (h[m] = g, v) {
            case 3:
              f[m] = Gn.VTK_TRIANGLE;
              break;
            case 4:
              f[m] = Gn.VTK_QUAD;
              break;
            default:
              f[m] = Gn.VTK_POLYGON;
              break;
          }
          v < 3 && PT("Building VTK_TRIANGLE ", m, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."), g += v + 1;
        }), h += h.subarray(s), f += f.subarray(s);
      }
      if (o) {
        let g = 0;
        f.fill(Gn.VTK_TRIANGLE_STRIP, 0, o), e.strips.getCellSizes().forEach((v, m) => {
          h[m] = g, g += v + 1;
        });
      }
      e.cells = F$.newInstance(), e.cells.setCellTypes(l, c, u);
    }, t.buildLinks = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      e.cells === void 0 && t.buildCells(), e.links = D$.newInstance(), i > 0 ? e.links.allocate(i) : e.links.allocate(t.getPoints().getNumberOfPoints()), e.links.buildLinks(t);
    }, t.getCellType = (i) => e.cells.getCellType(i), t.getCellPoints = (i) => {
      const a = t.getCellType(i);
      let s = null;
      switch (a) {
        case Gn.VTK_VERTEX:
        case Gn.VTK_POLY_VERTEX:
          s = e.verts;
          break;
        case Gn.VTK_LINE:
        case Gn.VTK_POLY_LINE:
          s = e.lines;
          break;
        case Gn.VTK_TRIANGLE:
        case Gn.VTK_QUAD:
        case Gn.VTK_POLYGON:
          s = e.polys;
          break;
        case Gn.VTK_TRIANGLE_STRIP:
          s = e.strips;
          break;
        default:
          return s = null, {
            type: 0,
            cellPointIds: null
          };
      }
      const o = e.cells.getCellLocation(i), l = s.getCell(o);
      return {
        cellType: a,
        cellPointIds: l
      };
    }, t.getPointCells = (i) => e.links.getCells(i), t.getCellEdgeNeighbors = (i, a, s) => {
      const o = e.links.getLink(a), l = e.links.getLink(s);
      return o.cells.filter((c) => c !== i && l.cells.indexOf(c) !== -1);
    }, t.getCell = function(i) {
      let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      const s = t.getCellPoints(i), o = a || J$[s.cellType].newInstance();
      return o.initialize(t.getPoints(), s.cellPointIds), o;
    };
  }
  const eee = {};
  function mO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, eee, n), j$.extend(t, e, n), H.get(t, e, [
      "cells",
      "links"
    ]), H.setGet(t, e, [
      "verts",
      "lines",
      "polys",
      "strips"
    ]), $$(t, e);
  }
  const tee = H.newInstance(mO, "vtkPolyData");
  var $i = {
    newInstance: tee,
    extend: mO
  };
  const nee = 1e-6;
  function ree(t, e) {
    e.classHierarchy.push("vtkProp3D"), t.addPosition = (r) => {
      e.position = e.position.map((i, a) => i + r[a]), t.modified();
    }, t.getOrientationWXYZ = () => {
      const r = jc();
      s6(r, e.rotation);
      const i = new Float64Array(3), a = _Y(i, r);
      return [
        op(a),
        i[0],
        i[1],
        i[2]
      ];
    }, t.getOrientationQuaternion = function() {
      let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return s6(r, e.rotation);
    }, t.rotateX = (r) => {
      r !== 0 && (U8(e.rotation, e.rotation, rr(r)), t.modified());
    }, t.rotateY = (r) => {
      r !== 0 && (F8(e.rotation, e.rotation, rr(r)), t.modified());
    }, t.rotateZ = (r) => {
      r !== 0 && (B8(e.rotation, e.rotation, rr(r)), t.modified());
    }, t.rotateWXYZ = (r, i, a, s) => {
      if (r === 0 || i === 0 && a === 0 && s === 0) return;
      const o = rr(r), l = jc();
      P8(l, [
        i,
        a,
        s
      ], o);
      const c = new Float64Array(16);
      mp(c, l), tn(e.rotation, e.rotation, c), t.modified();
    }, t.rotateQuaternion = (r) => {
      if (Math.abs(r[3]) >= 1 - nee) return;
      const i = mp(new Float64Array(16), r);
      tn(e.rotation, e.rotation, i), t.modified();
    }, t.setOrientation = (r, i, a) => r === e.orientation[0] && i === e.orientation[1] && a === e.orientation[2] ? false : (e.orientation = [
      r,
      i,
      a
    ], gt(e.rotation), t.rotateZ(a), t.rotateX(r), t.rotateY(i), t.modified(), true), t.setUserMatrix = (r) => $h(e.userMatrix, r) ? false : (sr(e.userMatrix, r), t.modified(), true), t.getMatrix = () => (t.computeMatrix(), e.matrix), t.computeMatrix = () => {
      if (t.getMTime() > e.matrixMTime.getMTime()) {
        gt(e.matrix), e.userMatrix && tn(e.matrix, e.matrix, e.userMatrix), $n(e.matrix, e.matrix, e.origin), $n(e.matrix, e.matrix, e.position), tn(e.matrix, e.matrix, e.rotation), Fl(e.matrix, e.matrix, e.scale), $n(e.matrix, e.matrix, [
          -e.origin[0],
          -e.origin[1],
          -e.origin[2]
        ]), en(e.matrix, e.matrix), e.isIdentity = true;
        for (let r = 0; r < 4; ++r) for (let i = 0; i < 4; ++i) (r === i ? 1 : 0) !== e.matrix[r + i * 4] && (e.isIdentity = false);
        e.matrixMTime.modified();
      }
    }, t.getCenter = () => En.getCenter(e.bounds), t.getLength = () => En.getLength(e.bounds), t.getXRange = () => En.getXRange(e.bounds), t.getYRange = () => En.getYRange(e.bounds), t.getZRange = () => En.getZRange(e.bounds), t.getUserMatrix = () => e.userMatrix;
    function n() {
      t.computeMatrix();
    }
    t.onModified(n);
  }
  const iee = {
    origin: [
      0,
      0,
      0
    ],
    position: [
      0,
      0,
      0
    ],
    orientation: [
      0,
      0,
      0
    ],
    rotation: null,
    scale: [
      1,
      1,
      1
    ],
    bounds: [
      1,
      -1,
      1,
      -1,
      1,
      -1
    ],
    userMatrix: null,
    userMatrixMTime: null,
    cachedProp3D: null,
    isIdentity: true,
    matrixMTime: null
  };
  function vO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, iee, n), nd.extend(t, e, n), e.matrixMTime = {}, H.obj(e.matrixMTime), H.get(t, e, [
      "bounds",
      "isIdentity"
    ]), H.getArray(t, e, [
      "orientation"
    ]), H.setGetArray(t, e, [
      "origin",
      "position",
      "scale"
    ], 3), e.matrix = gt(new Float64Array(16)), e.rotation = gt(new Float64Array(16)), e.userMatrix = gt(new Float64Array(16)), e.transform = null, ree(t, e);
  }
  const aee = H.newInstance(vO, "vtkProp3D");
  var oy = {
    newInstance: aee,
    extend: vO
  };
  const { vtkDebugMacro: see } = H;
  function oee(t, e) {
    e.classHierarchy.push("vtkActor");
    const n = {
      ...t
    };
    t.getActors = () => [
      t
    ], t.getIsOpaque = () => {
      if (e.forceOpaque) return true;
      if (e.forceTranslucent) return false;
      e.property || t.getProperty();
      let r = e.property.getOpacity() >= 1;
      return r = r && (!e.texture || !e.texture.isTranslucent()), r = r && (!e.mapper || e.mapper.getIsOpaque()), r;
    }, t.hasTranslucentPolygonalGeometry = () => e.mapper === null ? false : (e.property === null && t.setProperty(t.makeProperty()), !t.getIsOpaque()), t.makeProperty = ef.newInstance, t.getProperty = () => (e.property === null && (e.property = t.makeProperty()), e.property), t.getBounds = () => {
      if (e.mapper === null) return e.bounds;
      const r = e.mapper.getBounds();
      if (!r || r.length !== 6) return r;
      if (r[0] > r[1]) return e.mapperBounds = r.concat(), e.bounds = [
        1,
        -1,
        1,
        -1,
        1,
        -1
      ], e.boundsMTime.modified(), r;
      if (!e.mapperBounds || r[0] !== e.mapperBounds[0] || r[1] !== e.mapperBounds[1] || r[2] !== e.mapperBounds[2] || r[3] !== e.mapperBounds[3] || r[4] !== e.mapperBounds[4] || r[5] !== e.mapperBounds[5] || t.getMTime() > e.boundsMTime.getMTime()) {
        see("Recomputing bounds..."), e.mapperBounds = r.concat();
        const i = [];
        En.getCorners(r, i), t.computeMatrix();
        const a = new Float64Array(16);
        en(a, e.matrix), i.forEach((s) => $t(s, s, a)), e.bounds[0] = e.bounds[2] = e.bounds[4] = Number.MAX_VALUE, e.bounds[1] = e.bounds[3] = e.bounds[5] = -Number.MAX_VALUE, e.bounds = e.bounds.map((s, o) => o % 2 === 0 ? i.reduce((l, c) => l > c[o / 2] ? c[o / 2] : l, s) : i.reduce((l, c) => l < c[(o - 1) / 2] ? c[(o - 1) / 2] : l, s)), e.boundsMTime.modified();
      }
      return e.bounds;
    }, t.getMTime = () => {
      let r = n.getMTime();
      if (e.property !== null) {
        const i = e.property.getMTime();
        r = i > r ? i : r;
      }
      if (e.backfaceProperty !== null) {
        const i = e.backfaceProperty.getMTime();
        r = i > r ? i : r;
      }
      return r;
    }, t.getRedrawMTime = () => {
      let r = e.mtime;
      if (e.mapper !== null) {
        let i = e.mapper.getMTime();
        r = i > r ? i : r, e.mapper.getInput() !== null && (e.mapper.getInputAlgorithm().update(), i = e.mapper.getInput().getMTime(), r = i > r ? i : r);
      }
      return r;
    }, t.getSupportsSelection = () => e.mapper ? e.mapper.getSupportsSelection() : false, t.processSelectorPixelBuffers = (r, i) => {
      e.mapper && e.mapper.processSelectorPixelBuffers && e.mapper.processSelectorPixelBuffers(r, i);
    };
  }
  const lee = {
    mapper: null,
    property: null,
    backfaceProperty: null,
    forceOpaque: false,
    forceTranslucent: false,
    bounds: [
      1,
      -1,
      1,
      -1,
      1,
      -1
    ]
  };
  function yO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, lee, n), oy.extend(t, e, n), e.boundsMTime = {}, H.obj(e.boundsMTime), H.set(t, e, [
      "property"
    ]), H.setGet(t, e, [
      "backfaceProperty",
      "forceOpaque",
      "forceTranslucent",
      "mapper"
    ]), oee(t, e);
  }
  const cee = H.newInstance(yO, "vtkActor");
  var qc = {
    newInstance: cee,
    extend: yO
  };
  function uee(t, e) {
    const n = t.invokeResize;
    delete t.invokeResize, e.renderWindow = Rq.newInstance(), e.rendererMap = {}, e.openGLRenderWindow = BJ.newInstance(), e.renderWindow.addView(e.openGLRenderWindow), e.interactor = u$.newInstance(), e.interactor.setView(e.openGLRenderWindow), e.interactor.initialize(), t.addRenderer = ({ viewport: r, id: i, background: a }) => {
      const s = t$.newInstance({
        viewport: r,
        background: a || e.background
      });
      e.renderWindow.addRenderer(s), e.rendererMap[i] = s;
    }, t.destroy = () => {
      e.renderWindow.getInteractor().delete();
    }, t.removeRenderer = (r) => {
      const i = t.getRenderer(r);
      e.renderWindow.removeRenderer(i), i.delete(), delete e.rendererMap[r];
    }, t.getRenderer = (r) => e.rendererMap[r], t.getRenderers = () => {
      const { rendererMap: r } = e;
      return Object.keys(r).map((a) => ({
        id: a,
        renderer: r[a]
      }));
    }, t.resize = () => {
      if (e.container) {
        const { width: r, height: i } = e.container;
        e.openGLRenderWindow.setSize(Math.floor(r), Math.floor(i)), n(), e.renderWindow.render();
      }
    }, t.setContainer = (r) => {
      e.container = r, e.openGLRenderWindow.setContainer(e.container);
    }, t.delete = H.chain(t.setContainer, t.destroy, e.openGLRenderWindow.delete, t.delete), t.resize();
  }
  const fee = {
    background: [
      0,
      0,
      0
    ],
    container: null
  };
  function xO(t, e, n = {}) {
    Object.assign(e, fee, n), H.obj(t, e), H.get(t, e, [
      "renderWindow",
      "openGLRenderWindow",
      "interactor",
      "container"
    ]), H.event(t, e, "resize"), uee(t, e);
  }
  const hee = H.newInstance(xO), dee = {
    newInstance: hee,
    extend: xO
  }, { vtkErrorMacro: G2 } = H;
  function gee(t, e) {
    e.classHierarchy.push("vtkPiecewiseFunction"), t.getSize = () => e.nodes.length, t.getType = () => {
      let n, r = 0, i = 0;
      e.nodes.length > 0 && (r = e.nodes[0].y);
      for (let a = 1; a < e.nodes.length; a++) {
        if (n = e.nodes[a].y, n !== r) if (n > r) switch (i) {
          case 0:
          case 1:
            i = 1;
            break;
          case 2:
          default:
            i = 3;
            break;
        }
        else switch (i) {
          case 0:
          case 2:
            i = 2;
            break;
          case 1:
          default:
            i = 3;
            break;
        }
        if (r = n, i === 3) break;
      }
      switch (i) {
        case 0:
          return "Constant";
        case 1:
          return "NonDecreasing";
        case 2:
          return "NonIncreasing";
        case 3:
        default:
          return "Varied";
      }
    }, t.getDataPointer = () => {
      const n = e.nodes.length;
      if (e.function = null, n > 0) {
        e.function = [];
        for (let r = 0; r < n; r++) e.function[2 * r] = e.nodes[r].x, e.function[2 * r + 1] = e.nodes[r].y;
      }
      return e.function;
    }, t.getFirstNonZeroValue = () => {
      if (e.nodes.length === 0) return 0;
      let n = 1, r = 0, i = 0;
      for (; i < e.nodes.length; i++) if (e.nodes[i].y !== 0) {
        n = 0;
        break;
      }
      return n ? r = Number.MAX_VALUE : i > 0 ? r = e.nodes[i - 1].x : e.clamping ? r = -Number.MAX_VALUE : r = e.nodes[0].x, r;
    }, t.getNodeValue = (n, r) => {
      const i = e.nodes.length;
      return n < 0 || n >= i ? (G2("Index out of range!"), -1) : (r[0] = e.nodes[n].x, r[1] = e.nodes[n].y, r[2] = e.nodes[n].midpoint, r[3] = e.nodes[n].sharpness, 1);
    }, t.setNodeValue = (n, r) => {
      const i = e.nodes.length;
      if (n < 0 || n >= i) return G2("Index out of range!"), -1;
      const a = e.nodes[n].x;
      return e.nodes[n].x = r[0], e.nodes[n].y = r[1], e.nodes[n].midpoint = r[2], e.nodes[n].sharpness = r[3], a !== r[0] ? t.sortAndUpdateRange() : t.modified(), 1;
    }, t.addPoint = (n, r) => t.addPointLong(n, r, 0.5, 0), t.addPointLong = (n, r, i, a) => {
      if (i < 0 || i > 1) return G2("Midpoint outside range [0.0, 1.0]"), -1;
      if (a < 0 || a > 1) return G2("Sharpness outside range [0.0, 1.0]"), -1;
      e.allowDuplicateScalars || t.removePoint(n);
      const s = {
        x: n,
        y: r,
        midpoint: i,
        sharpness: a
      };
      e.nodes.push(s), t.sortAndUpdateRange();
      let o;
      for (o = 0; o < e.nodes.length && e.nodes[o].x !== n; o++) ;
      return o < e.nodes.length ? o : -1;
    }, t.setNodes = (n) => {
      e.nodes !== n && (e.nodes = n, t.sortAndUpdateRange());
    }, t.sortAndUpdateRange = () => {
      e.nodes.sort((r, i) => r.x - i.x), t.updateRange() || t.modified();
    }, t.updateRange = () => {
      const n = e.range.slice(), r = e.nodes.length;
      return r ? (e.range[0] = e.nodes[0].x, e.range[1] = e.nodes[r - 1].x) : (e.range[0] = 0, e.range[1] = 0), n[0] === e.range[0] && n[1] === e.range[1] ? false : (t.modified(), true);
    }, t.removePoint = (n) => {
      let r;
      for (r = 0; r < e.nodes.length && e.nodes[r].x !== n; r++) ;
      if (r >= e.nodes.length) return -1;
      const i = r;
      let a = false;
      return e.nodes.splice(r, 1), (r === 0 || r === e.nodes.length) && (a = t.updateRange()), a || t.modified(), i;
    }, t.removeAllPoints = () => {
      e.nodes = [], t.sortAndUpdateRange();
    }, t.addSegment = (n, r, i, a) => {
      t.sortAndUpdateRange();
      for (let s = 0; s < e.nodes.length; ) e.nodes[s].x >= n && e.nodes[s].x <= i ? e.nodes.splice(s, 1) : s++;
      t.addPoint(n, r, 0.5, 0), t.addPoint(i, a, 0.5, 0);
    }, t.getValue = (n) => {
      const r = [];
      return t.getTable(n, n, 1, r), r[0];
    }, t.adjustRange = (n) => {
      if (n.length < 2) return 0;
      const r = t.getRange();
      r[0] < n[0] ? t.addPoint(n[0], t.getValue(n[0])) : t.addPoint(n[0], t.getValue(r[0])), r[1] > n[1] ? t.addPoint(n[1], t.getValue(n[1])) : t.addPoint(n[1], t.getValue(r[1])), t.sortAndUpdateRange();
      for (let i = 0; i < e.nodes.length; ) e.nodes[i].x >= n[0] && e.nodes[i].x <= n[1] ? e.nodes.splice(i, 1) : ++i;
      return t.sortAndUpdateRange(), 1;
    }, t.estimateMinNumberOfSamples = (n, r) => {
      const i = t.findMinimumXDistance();
      return Math.ceil((r - n) / i);
    }, t.findMinimumXDistance = () => {
      const n = e.nodes.length;
      if (n < 2) return -1;
      let r = e.nodes[1].x - e.nodes[0].x;
      for (let i = 0; i < n - 1; i++) {
        const a = e.nodes[i + 1].x - e.nodes[i].x;
        a < r && (r = a);
      }
      return r;
    }, t.getTable = function(n, r, i, a) {
      let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, o, l = 0;
      const c = e.nodes.length;
      let f = 0;
      c !== 0 && (f = e.nodes[c - 1].y);
      let u = 0, h = 0, g = 0, v = 0, m = 0, y = 0, w = 0;
      for (o = 0; o < i; o++) {
        const C = s * o;
        for (i > 1 ? u = n + o / (i - 1) * (r - n) : u = 0.5 * (n + r); l < c && u > e.nodes[l].x; ) l++, l < c && (h = e.nodes[l - 1].x, g = e.nodes[l].x, v = e.nodes[l - 1].y, m = e.nodes[l].y, y = e.nodes[l - 1].midpoint, w = e.nodes[l - 1].sharpness, y < 1e-5 && (y = 1e-5), y > 0.99999 && (y = 0.99999));
        if (l >= c) a[C] = e.clamping ? f : 0;
        else if (l === 0) a[C] = e.clamping ? e.nodes[0].y : 0;
        else {
          let T = (u - h) / (g - h);
          if (T < y ? T = 0.5 * T / y : T = 0.5 + 0.5 * (T - y) / (1 - y), w > 0.99) if (T < 0.5) {
            a[C] = v;
            continue;
          } else {
            a[C] = m;
            continue;
          }
          if (w < 0.01) {
            a[C] = (1 - T) * v + T * m;
            continue;
          }
          T < 0.5 ? T = 0.5 * (T * 2) ** (1 + 10 * w) : T > 0.5 && (T = 1 - 0.5 * ((1 - T) * 2) ** (1 + 10 * w));
          const S = T * T, E = S * T, b = 2 * E - 3 * S + 1, D = -2 * E + 3 * S, R = E - 2 * S + T, I = E - S, O = m - v, L = (1 - w) * O;
          a[C] = b * v + D * m + R * L + I * L;
          const N = v < m ? v : m, F = v > m ? v : m;
          a[C] = a[C] < N ? N : a[C], a[C] = a[C] > F ? F : a[C];
        }
      }
    };
  }
  const pee = {
    range: [
      0,
      0
    ],
    clamping: true,
    allowDuplicateScalars: false
  };
  function wO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, pee, n), H.obj(t, e), e.nodes = [], H.setGet(t, e, [
      "allowDuplicateScalars",
      "clamping"
    ]), H.setArray(t, e, [
      "range"
    ], 2), H.getArray(t, e, [
      "range"
    ]), gee(t, e);
  }
  const mee = H.newInstance(wO, "vtkPiecewiseFunction");
  var Iu = {
    newInstance: mee,
    extend: wO
  };
  const { BlendMode: pl, FilterMode: Z1 } = EW;
  function vee(t, e, n, r, i) {
    let a = null;
    return i ? (a = i, a.removeAllPoints()) : a = Iu.newInstance(), a.addPointLong(-1024, 0, 1, 1), a.addPoint(t, e), a.addPoint(n, r), a;
  }
  const yee = {
    createRadonTransferFunction: vee
  };
  function xee(t, e) {
    e.classHierarchy.push("vtkVolumeMapper");
    const n = {
      ...t
    };
    t.getBounds = () => {
      const r = t.getInputData();
      return r ? (e.static || t.update(), e.bounds = r.getBounds()) : e.bounds = Ll(), e.bounds;
    }, t.update = () => {
      t.getInputData();
    }, t.setBlendModeToComposite = () => {
      t.setBlendMode(pl.COMPOSITE_BLEND);
    }, t.setBlendModeToMaximumIntensity = () => {
      t.setBlendMode(pl.MAXIMUM_INTENSITY_BLEND);
    }, t.setBlendModeToMinimumIntensity = () => {
      t.setBlendMode(pl.MINIMUM_INTENSITY_BLEND);
    }, t.setBlendModeToAverageIntensity = () => {
      t.setBlendMode(pl.AVERAGE_INTENSITY_BLEND);
    }, t.setBlendModeToAdditiveIntensity = () => {
      t.setBlendMode(pl.ADDITIVE_INTENSITY_BLEND);
    }, t.setBlendModeToRadonTransform = () => {
      t.setBlendMode(pl.RADON_TRANSFORM_BLEND);
    }, t.getBlendModeAsString = () => H.enumToString(pl, e.blendMode), t.setAverageIPScalarRange = (r, i) => {
      console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"), t.setIpScalarRange(r, i);
    }, t.getFilterModeAsString = () => H.enumToString(Z1, e.filterMode), t.setFilterModeToOff = () => {
      t.setFilterMode(Z1.OFF);
    }, t.setFilterModeToNormalized = () => {
      t.setFilterMode(Z1.NORMALIZED);
    }, t.setFilterModeToRaw = () => {
      t.setFilterMode(Z1.RAW);
    }, t.setGlobalIlluminationReach = (r) => n.setGlobalIlluminationReach(os(r, 0, 1)), t.setVolumetricScatteringBlending = (r) => n.setVolumetricScatteringBlending(os(r, 0, 1)), t.setVolumeShadowSamplingDistFactor = (r) => n.setVolumeShadowSamplingDistFactor(r >= 1 ? r : 1), t.setAnisotropy = (r) => n.setAnisotropy(os(r, -0.99, 0.99)), t.setLAOKernelSize = (r) => n.setLAOKernelSize(E8(os(r, 1, 32))), t.setLAOKernelRadius = (r) => n.setLAOKernelRadius(r >= 1 ? r : 1);
  }
  const wee = {
    bounds: [
      1,
      -1,
      1,
      -1,
      1,
      -1
    ],
    sampleDistance: 1,
    imageSampleDistance: 1,
    maximumSamplesPerRay: 1e3,
    autoAdjustSampleDistances: true,
    initialInteractionScale: 1,
    interactionSampleDistanceFactor: 1,
    blendMode: pl.COMPOSITE_BLEND,
    ipScalarRange: [
      -1e6,
      1e6
    ],
    filterMode: Z1.OFF,
    preferSizeOverAccuracy: false,
    computeNormalFromOpacity: false,
    volumetricScatteringBlending: 0,
    globalIlluminationReach: 0,
    volumeShadowSamplingDistFactor: 5,
    anisotropy: 0,
    localAmbientOcclusion: false,
    LAOKernelSize: 15,
    LAOKernelRadius: 7
  };
  function CO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, wee, n), ey.extend(t, e, n), H.setGet(t, e, [
      "sampleDistance",
      "imageSampleDistance",
      "maximumSamplesPerRay",
      "autoAdjustSampleDistances",
      "initialInteractionScale",
      "interactionSampleDistanceFactor",
      "blendMode",
      "filterMode",
      "preferSizeOverAccuracy",
      "computeNormalFromOpacity",
      "volumetricScatteringBlending",
      "globalIlluminationReach",
      "volumeShadowSamplingDistFactor",
      "anisotropy",
      "localAmbientOcclusion",
      "LAOKernelSize",
      "LAOKernelRadius"
    ]), H.setGetArray(t, e, [
      "ipScalarRange"
    ], 2), H.event(t, e, "lightingActivated"), xee(t, e);
  }
  const Cee = H.newInstance(CO, "vtkVolumeMapper");
  var Tee = {
    newInstance: Cee,
    extend: CO,
    ...yee
  };
  function See(t, e) {
    e.classHierarchy.push("vtkSharedVolumeMapper");
    const n = t.delete;
    t.delete = () => {
      e.scalarTexture = null, n();
    };
  }
  const Aee = {
    scalarTexture: null
  };
  function TO(t, e, n = {}) {
    Object.assign(e, Aee, n), Tee.extend(t, e, n), H.setGet(t, e, [
      "scalarTexture"
    ]), See(t, e);
  }
  const Eee = H.newInstance(TO, "vtkSharedVolumeMapper"), bee = {
    newInstance: Eee,
    extend: TO
  };
  function Dee(t, e) {
    e.classHierarchy.push("vtkStreamingOpenGLTexture");
    const n = t.create3DFilterableFromRaw;
    t.create3DFilterableFromRaw = (r, i, a, s, o, l, c) => {
      e.inputDataType = o, e.inputNumComps = s, n(r, i, a, s, o, l, c);
    }, t.update3DFromRaw = (r) => {
      const { updatedFrames: i } = e;
      if (!i.length) return;
      e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind();
      let a, s;
      if (r instanceof Uint8Array) a = 1, s = Uint8Array;
      else if (r instanceof Int16Array) a = 2, s = Int16Array;
      else if (r instanceof Uint16Array) a = 2, s = Uint16Array;
      else if (r instanceof Float32Array) a = 4, s = Float32Array;
      else throw new Error("No support for given TypedArray.");
      for (let o = 0; o < i.length; o++) i[o] && e.fillSubImage3D(r, o, a, s);
      return e.updatedFrames = [], e.generateMipmap && e.context.generateMipmap(e.target), t.deactivate(), true;
    }, e.fillSubImage3D = (r, i, a, s) => {
      const o = r.buffer, c = e.width * e.height * e.components * a, f = i * c, u = e.width * e.components, h = e.context, g = h.getParameter(h.MAX_TEXTURE_SIZE);
      let v = Math.floor(a * g / e.width);
      v = Math.min(v, e.height);
      const { useNorm16Texture: m, preferSizeOverAccuracy: y } = Do().rendering;
      m && !y && (v = 1);
      const w = u * v, C = w * a, T = Math.floor(e.height / v), S = e.height % v, E = u * S;
      for (let b = 0; b < T; b++) {
        const D = b * v;
        let R = new s(o, f + b * C, w);
        if (e.useHalfFloat && (s === Uint16Array || s === Int16Array)) {
          for (let I = 0; I < R.length; I++) R[I] = yl.toHalf(R[I]);
          s === Int16Array && (R = new Uint16Array(R));
        }
        h.texSubImage3D(e.target, 0, 0, D, i, e.width, v, 1, e.format, e.openGLDataType, R);
      }
      if (S !== 0) {
        const b = T * v, D = new s(o, f + T * C, E);
        h.texSubImage3D(e.target, 0, 0, b, i, e.width, S, 1, e.format, e.openGLDataType, D);
      }
    }, t.getTextureParameters = () => ({
      width: e.width,
      height: e.height,
      depth: e.depth,
      numComps: e.inputNumComps,
      dataType: e.inputDataType
    }), t.setUpdatedFrame = (r) => {
      e.updatedFrames[r] = true;
    };
  }
  const Mee = {
    updatedFrames: []
  };
  function SO(t, e, n = {}) {
    Object.assign(e, Mee, n), er.extend(t, e, n), Dee(t, e);
  }
  const Ree = H.newInstance(SO, "vtkStreamingOpenGLTexture"), Oee = {
    newInstance: Ree,
    extend: SO
  }, Iee = {
    isPerformingCoordinateTransformation: false
  };
  function AO(t, e, n = {}) {
    Object.assign(e, Iee, n), iy.extend(t, e, n), H.setGet(t, e, [
      "isPerformingCoordinateTransformation"
    ]), Nee(t, e);
  }
  const Vee = H.newInstance(AO, "vtkSlabCamera");
  function Nee(t, e) {
    e.classHierarchy.push("vtkSlabCamera");
    const n = Jg(new Float64Array(16)), r = new Float64Array(3);
    t.getProjectionMatrix = (i, a, s) => {
      const o = Yt();
      if (e.projectionMatrix) {
        const h = 1 / e.physicalScale;
        return Ml(r, h, h, h), Iv(o, e.projectionMatrix), Vv(o, o, r), _i(o, o), o;
      }
      Jg(n);
      let l = e.clippingRange[0], c = e.clippingRange[1];
      e.isPerformingCoordinateTransformation && (l = e.distance, c = e.distance + 0.1);
      const f = c - l, u = [
        l + (a + 1) * f / 2,
        l + (s + 1) * f / 2
      ];
      if (e.parallelProjection) {
        const h = e.parallelScale * i, g = e.parallelScale, v = (e.windowCenter[0] - 1) * h, m = (e.windowCenter[0] + 1) * h, y = (e.windowCenter[1] - 1) * g, w = (e.windowCenter[1] + 1) * g;
        U1(n, v, m, y, w, u[0], u[1]), _i(n, n);
      } else {
        if (e.useOffAxisProjection) throw new Error("Off-Axis projection is not supported at this time");
        {
          const h = Math.tan(La.radiansFromDegrees(e.viewAngle) / 2);
          let g, v;
          e.useHorizontalViewAngle === true ? (g = l * h, v = l * h / i) : (g = l * h * i, v = l * h);
          const m = (e.windowCenter[0] - 1) * g, y = (e.windowCenter[0] + 1) * g, w = (e.windowCenter[1] - 1) * v, C = (e.windowCenter[1] + 1) * v, T = u[0], S = u[1];
          n[0] = 2 * T / (y - m), n[5] = 2 * T / (C - w), n[2] = (m + y) / (y - m), n[6] = (w + C) / (C - w), n[10] = -(T + S) / (S - T), n[14] = -1, n[11] = -2 * T * S / (S - T), n[15] = 0;
        }
      }
      return Iv(o, n), o;
    };
  }
  const Lee = {
    newInstance: Vee,
    extend: AO
  }, gh = [];
  function ly(t, e = 0) {
    let n;
    for (n = 0; n < gh.length && !(gh[n].priority <= e); n++) ;
    gh.splice(n, 0, {
      priority: e,
      provider: t
    });
  }
  function Ct(t, ...e) {
    for (let n = 0; n < gh.length; n++) {
      const r = gh[n].provider(t, ...e);
      if (r !== void 0) return r;
    }
  }
  class Gl {
    constructor(e) {
      this._imageIdsIndexMap = /* @__PURE__ */ new Map(), this._imageURIsIndexMap = /* @__PURE__ */ new Map(), this.cornerstoneImageMetaData = null, this.imageCacheOffsetMap = /* @__PURE__ */ new Map(), this.isPreScaled = false;
      const { imageIds: n, scalarData: r, scaling: i, dimensions: a, spacing: s, origin: o, direction: l, volumeId: c, referencedVolumeId: f, sizeInBytes: u, imageData: h, metadata: g, referencedImageIds: v, additionalDetails: m } = e;
      if (this.imageIds = n, this.volumeId = c, this.metadata = g, this.dimensions = a, this.spacing = s, this.origin = o, this.direction = l, this.scalarData = r, this.sizeInBytes = u, this.vtkOpenGLTexture = Oee.newInstance(), this.numVoxels = this.dimensions[0] * this.dimensions[1] * this.dimensions[2], h) this.imageData = h;
      else {
        const y = Bl.newInstance(), w = Tt.newInstance({
          name: "Pixels",
          numberOfComponents: 1,
          values: r
        });
        y.setDimensions(a), y.setSpacing(s), y.setDirection(l), y.setOrigin(o), y.getPointData().setScalars(w), this.imageData = y;
      }
      this.numFrames = this._getNumFrames(), this._reprocessImageIds(), this._createCornerstoneImageMetaData(), i && (this.scaling = i), f && (this.referencedVolumeId = f), v && (this.referencedImageIds = v), m && (this.additionalDetails = m);
    }
    get imageIds() {
      return this._imageIds;
    }
    set imageIds(e) {
      this._imageIds = e, this._reprocessImageIds();
    }
    _reprocessImageIds() {
      this._imageIdsIndexMap.clear(), this._imageURIsIndexMap.clear(), this._imageIds.forEach((e, n) => {
        const r = va(e);
        this._imageIdsIndexMap.set(e, n), this._imageURIsIndexMap.set(r, n);
      });
    }
    isDynamicVolume() {
      return false;
    }
    getScalarData() {
      if (Sq(this.scalarData)) return this.scalarData;
      throw new Error("Unknown scalar data type");
    }
    getImageIdIndex(e) {
      return this._imageIdsIndexMap.get(e);
    }
    getImageURIIndex(e) {
      return this._imageURIsIndexMap.get(e);
    }
    destroy() {
      this.imageData.delete(), this.imageData = null, this.scalarData = null, this.vtkOpenGLTexture.releaseGraphicsResources(), this.vtkOpenGLTexture.delete();
    }
    getScalarDataArrays() {
      return this.isDynamicVolume() ? this.scalarData : [
        this.scalarData
      ];
    }
    modified() {
      if (this.imageData.modified(), this.isDynamicVolume()) throw new Error("Not implemented");
      this.scalarData = this.imageData.getPointData().getScalars().getData(), this.numFrames = this._getNumFrames();
    }
    decache(e = false) {
      e ? this.removeFromCache() : this.convertToImageSlicesAndCache();
    }
    removeFromCache() {
      Ke.removeVolumeLoadObject(this.volumeId);
    }
    getScalarDataLength() {
      const { scalarData: e } = this;
      return this.isDynamicVolume() ? e[0].length : e.length;
    }
    _getNumFrames() {
      const { imageIds: e, scalarData: n } = this, r = this.isDynamicVolume() ? n.length : 1;
      return e.length / r;
    }
    _getScalarDataLength() {
      const { scalarData: e } = this;
      return this.isDynamicVolume() ? e[0].length : e.length;
    }
    _createCornerstoneImageMetaData() {
      const { numFrames: e } = this;
      if (e === 0) return;
      const n = this.sizeInBytes / e, i = this._getScalarDataLength() / this.numVoxels, a = this.dimensions[0] * this.dimensions[1] * i, { PhotometricInterpretation: s, voiLut: o, VOILUTFunction: l } = this.metadata;
      let c = [], f = [];
      o && o.length && (c = o.map((h) => h.windowCenter), f = o.map((h) => h.windowWidth));
      const u = i > 1;
      this.cornerstoneImageMetaData = {
        bytesPerImage: n,
        numComponents: i,
        pixelsPerImage: a,
        windowCenter: c,
        windowWidth: f,
        color: u,
        rgba: false,
        spacing: this.spacing,
        dimensions: this.dimensions,
        photometricInterpretation: s,
        voiLUTFunction: l,
        invert: s === "MONOCHROME1"
      };
    }
    getScalarDataByImageIdIndex(e) {
      if (e < 0 || e >= this.imageIds.length) throw new Error("imageIdIndex out of range");
      const n = this.getScalarDataArrays(), r = Math.floor(e / this.numFrames);
      return n[r];
    }
    getCornerstoneImage(e, n) {
      const { imageIds: r } = this, i = this.imageIdIndexToFrameIndex(n), { bytesPerImage: a, pixelsPerImage: s, windowCenter: o, windowWidth: l, numComponents: c, color: f, dimensions: u, spacing: h, invert: g, voiLUTFunction: v, photometricInterpretation: m } = this.cornerstoneImageMetaData, y = this.getScalarDataByImageIdIndex(n), w = y.buffer, C = y.constructor, T = a / s;
      let S = a * i;
      y.BYTES_PER_ELEMENT !== T && (S *= y.BYTES_PER_ELEMENT / T);
      const E = new C(s), b = new C(w, S, s);
      E.set(b);
      const D = r[n], R = Ct("modalityLutModule", D) || {}, I = V8(E), O = R.rescaleIntercept ? R.rescaleIntercept : 0;
      return {
        imageId: e,
        intercept: O,
        windowCenter: o,
        windowWidth: l,
        voiLUTFunction: v,
        color: f,
        rgba: false,
        numComps: c,
        rows: u[1],
        columns: u[0],
        sizeInBytes: E.byteLength,
        getPixelData: () => E,
        minPixelValue: I.min,
        maxPixelValue: I.max,
        slope: R.rescaleSlope ? R.rescaleSlope : 1,
        getCanvas: void 0,
        height: u[0],
        width: u[1],
        columnPixelSpacing: h[0],
        rowPixelSpacing: h[1],
        invert: g,
        photometricInterpretation: m
      };
    }
    imageIdIndexToFrameIndex(e) {
      return e % this.numFrames;
    }
    convertToCornerstoneImage(e, n) {
      return this.getCornerstoneImageLoadObject(e, n);
    }
    getCornerstoneImageLoadObject(e, n) {
      const r = this.getCornerstoneImage(e, n);
      return {
        promise: Promise.resolve(r)
      };
    }
    getCornerstoneImages() {
      const { imageIds: e } = this;
      return e.map((n, r) => this.getCornerstoneImage(n, r));
    }
    convertToImageSlicesAndCache() {
      var _a3, _b3, _c3;
      const e = this.sizeInBytes;
      if (!((_a3 = this.imageIds) == null ? void 0 : _a3.length)) {
        const s = this.referencedVolumeId;
        let o = this.dimensions[2];
        s && (o = ((_c3 = (_b3 = Ke.getVolume(s)) == null ? void 0 : _b3.imageIds) == null ? void 0 : _c3.length) ?? o), this.imageIds = Array.from({
          length: o
        }, (l, c) => `generated:${this.volumeId}:${c}`), this._reprocessImageIds(), this.numFrames = this._getNumFrames(), this._createCornerstoneImageMetaData();
      }
      const n = this.imageIds.length, { bytesPerImage: r } = this.cornerstoneImageMetaData;
      let i = Ke.decacheIfNecessaryUntilBytesAvailable(e, this.imageIds);
      for (let s = 0; s < n; s++) {
        const o = this.imageIds[s];
        i = i - r;
        const l = this.getCornerstoneImage(o, s), c = {
          promise: Promise.resolve(l)
        };
        if (Ke.getImageLoadObject(o) || Ke.putImageLoadObject(o, c).catch((T) => {
          console.error(T);
        }), i <= r) break;
        const f = [
          this.direction[0],
          this.direction[1],
          this.direction[2],
          this.direction[3],
          this.direction[4],
          this.direction[5]
        ], u = 6, h = [
          parseFloat((this.origin[0] + s * this.direction[6] * this.spacing[0]).toFixed(u)),
          parseFloat((this.origin[1] + s * this.direction[7] * this.spacing[1]).toFixed(u)),
          parseFloat((this.origin[2] + s * this.direction[8] * this.spacing[2]).toFixed(u))
        ], m = {
          bitsAllocated: l.getPixelData().BYTES_PER_ELEMENT * 8,
          photometricInterpretation: l.photometricInterpretation,
          windowWidth: l.windowWidth,
          windowCenter: l.windowCenter,
          voiLUTFunction: l.voiLUTFunction
        }, y = {
          rowCosines: [
            this.direction[0],
            this.direction[1],
            this.direction[2]
          ],
          columnCosines: [
            this.direction[3],
            this.direction[4],
            this.direction[5]
          ],
          pixelSpacing: [
            this.spacing[0],
            this.spacing[1]
          ],
          imageOrientationPatient: f,
          imagePositionPatient: h,
          columnPixelSpacing: l.columnPixelSpacing,
          rowPixelSpacing: l.rowPixelSpacing,
          columns: l.columns,
          rows: l.rows
        }, C = {
          imagePixelModule: m,
          imagePlaneModule: y,
          generalSeriesModule: {}
        };
        [
          "imagePixelModule",
          "imagePlaneModule",
          "generalSeriesModule"
        ].forEach((T) => {
          Nu.add(o, {
            type: T,
            metadata: C[T]
          });
        });
      }
      const a = Ke.filterVolumesByReferenceId(this.volumeId);
      return a.length && a.forEach((s) => {
        s.referencedImageIds = this.imageIds;
      }), this.removeFromCache(), this.imageIds;
    }
  }
  const GT = 1073741824;
  class Uee {
    constructor() {
      this._imageCache = /* @__PURE__ */ new Map(), this._volumeCache = /* @__PURE__ */ new Map(), this._imageCacheSize = 0, this._volumeCacheSize = 0, this._maxCacheSize = 3 * GT, this._maxInstanceSize = 4 * GT - 8, this.setMaxCacheSize = (e) => {
        if (!e || typeof e != "number") {
          const n = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;
          throw new Error(n);
        }
        this._maxCacheSize = e;
      }, this.isCacheable = (e) => {
        if (e > this._maxInstanceSize) return false;
        const n = this.getBytesAvailable(), r = this._imageCacheSize;
        return n + r > e;
      }, this.getMaxCacheSize = () => this._maxCacheSize, this.getMaxInstanceSize = () => this._maxInstanceSize, this.getCacheSize = () => this._imageCacheSize + this._volumeCacheSize, this._decacheImage = (e) => {
        const n = this._imageCache.get(e);
        if (!n) return;
        const { imageLoadObject: r } = n;
        r.cancelFn && r.cancelFn(), r.decache && r.decache(), this._imageCache.delete(e);
      }, this._decacheVolume = (e) => {
        const n = this._volumeCache.get(e);
        if (!n) return;
        const { volumeLoadObject: r, volume: i } = n;
        i && (i.cancelLoading && i.cancelLoading(), i.imageData && i.imageData.delete(), this._restoreImagesFromBuffer(i), r.cancelFn && r.cancelFn(), r.decache && r.decache(), this._volumeCache.delete(e));
      }, this.purgeCache = () => {
        const e = this._imageCache.keys();
        for (; ; ) {
          const { value: n, done: r } = e.next();
          if (r) break;
          this.removeImageLoadObject(n), qe(je, ze.IMAGE_CACHE_IMAGE_REMOVED, {
            imageId: n
          });
        }
        this.purgeVolumeCache();
      }, this.purgeVolumeCache = () => {
        const e = this._volumeCache.keys();
        for (; ; ) {
          const { value: n, done: r } = e.next();
          if (r) break;
          this.removeVolumeLoadObject(n), qe(je, ze.VOLUME_CACHE_VOLUME_REMOVED, {
            volumeId: n
          });
        }
      }, this.getVolumeLoadObject = (e) => {
        if (e === void 0) throw new Error("getVolumeLoadObject: volumeId must not be undefined");
        const n = this._volumeCache.get(e);
        if (n) return n.timeStamp = Date.now(), n.volumeLoadObject;
      }, this.getGeometry = (e) => {
        if (e == null) throw new Error("getGeometry: geometryId must not be undefined");
        const n = this._geometryCache.get(e);
        if (n) return n.timeStamp = Date.now(), n.geometry;
      }, this.getImage = (e) => {
        if (e === void 0) throw new Error("getImage: imageId must not be undefined");
        const n = this._imageCache.get(e);
        if (n) return n.timeStamp = Date.now(), n.image;
      }, this.getVolume = (e) => {
        if (e === void 0) throw new Error("getVolume: volumeId must not be undefined");
        const n = this._volumeCache.get(e);
        if (n) return n.timeStamp = Date.now(), n.volume;
      }, this.getVolumes = () => Array.from(this._volumeCache.values()).map((n) => n.volume), this.filterVolumesByReferenceId = (e) => this.getVolumes().filter((r) => r.referencedVolumeId === e), this.removeImageLoadObject = (e) => {
        if (e === void 0) throw new Error("removeImageLoadObject: imageId must not be undefined");
        const n = this._imageCache.get(e);
        if (!n) throw new Error("removeImageLoadObject: imageId was not present in imageCache");
        this.incrementImageCacheSize(-n.sizeInBytes);
        const r = {
          image: n,
          imageId: e
        };
        qe(je, ze.IMAGE_CACHE_IMAGE_REMOVED, r), this._decacheImage(e);
      }, this.removeVolumeLoadObject = (e) => {
        if (e === void 0) throw new Error("removeVolumeLoadObject: volumeId must not be undefined");
        const n = this._volumeCache.get(e);
        if (!n) throw new Error("removeVolumeLoadObject: volumeId was not present in volumeCache");
        this.incrementVolumeCacheSize(-n.sizeInBytes);
        const r = {
          volume: n,
          volumeId: e
        };
        qe(je, ze.VOLUME_CACHE_VOLUME_REMOVED, r), this._decacheVolume(e);
      }, this.putGeometryLoadObject = (e, n) => {
        if (e == null) throw new Error("putGeometryLoadObject: geometryId must not be undefined");
        if (this._geometryCache.has(e)) throw new Error("putGeometryLoadObject: geometryId already present in geometryCache");
        const r = {
          geometryId: e,
          geometryLoadObject: n,
          loaded: false,
          timeStamp: Date.now(),
          sizeInBytes: 0
        };
        return this._geometryCache.set(e, r), n.promise.then((i) => {
          if (!this._geometryCache.has(e)) {
            console.warn("putGeometryLoadObject: geometryId was removed from geometryCache");
            return;
          }
          if (Number.isNaN(i.sizeInBytes)) throw new Error("putGeometryLoadObject: geometry.sizeInBytes is not a number");
          r.loaded = true, r.geometry = i, r.sizeInBytes = i.sizeInBytes;
          const a = {
            geometry: i,
            geometryId: e
          };
          qe(je, ze.GEOMETRY_CACHE_GEOMETRY_ADDED, a);
        }).catch((i) => {
          throw this._geometryCache.delete(e), i;
        });
      }, this.incrementImageCacheSize = (e) => {
        this._imageCacheSize += e;
      }, this.incrementVolumeCacheSize = (e) => {
        this._volumeCacheSize += e;
      }, this.decrementImageCacheSize = (e) => {
        this._imageCacheSize -= e;
      }, this.decrementVolumeCacheSize = (e) => {
        this._volumeCacheSize -= e;
      }, this._geometryCache = /* @__PURE__ */ new Map();
    }
    getBytesAvailable() {
      return this.getMaxCacheSize() - this.getCacheSize();
    }
    decacheIfNecessaryUntilBytesAvailable(e, n) {
      let r = this.getBytesAvailable();
      if (r >= e) return r;
      let i = Array.from(this._imageCache.values());
      function a(l, c) {
        return l.timeStamp > c.timeStamp ? 1 : l.timeStamp < c.timeStamp ? -1 : 0;
      }
      i.sort(a);
      let s = i.map((l) => l.imageId), o = s;
      n && (o = s.filter((l) => !n.includes(l)));
      for (const l of o) if (this.removeImageLoadObject(l), qe(je, ze.IMAGE_CACHE_IMAGE_REMOVED, {
        imageId: l
      }), r = this.getBytesAvailable(), r >= e) return r;
      i = Array.from(this._imageCache.values()), s = i.map((l) => l.imageId);
      for (const l of s) if (this.removeImageLoadObject(l), qe(je, ze.IMAGE_CACHE_IMAGE_REMOVED, {
        imageId: l
      }), r = this.getBytesAvailable(), r >= e) return r;
    }
    putImageLoadObject(e, n) {
      if (e === void 0) throw new Error("putImageLoadObject: imageId must not be undefined");
      if (n.promise === void 0) throw new Error("putImageLoadObject: imageLoadObject.promise must not be undefined");
      if (this._imageCache.has(e)) throw new Error("putImageLoadObject: imageId already in cache");
      if (n.cancelFn && typeof n.cancelFn != "function") throw new Error("putImageLoadObject: imageLoadObject.cancel must be a function");
      const r = {
        loaded: false,
        imageId: e,
        sharedCacheKey: void 0,
        imageLoadObject: n,
        timeStamp: Date.now(),
        sizeInBytes: 0
      };
      return this._imageCache.set(e, r), n.promise.then((i) => {
        if (!this._imageCache.get(e)) {
          console.warn("The image was purged from the cache before it completed loading.");
          return;
        }
        if (i.sizeInBytes === void 0 || Number.isNaN(i.sizeInBytes)) throw new Error("putImageLoadObject: image.sizeInBytes must not be undefined");
        if (i.sizeInBytes.toFixed === void 0) throw new Error("putImageLoadObject: image.sizeInBytes is not a number");
        if (!this.isCacheable(i.sizeInBytes)) throw new Error(ze.CACHE_SIZE_EXCEEDED);
        this.decacheIfNecessaryUntilBytesAvailable(i.sizeInBytes), r.loaded = true, r.image = i, r.sizeInBytes = i.sizeInBytes, this.incrementImageCacheSize(r.sizeInBytes);
        const a = {
          image: r
        };
        qe(je, ze.IMAGE_CACHE_IMAGE_ADDED, a), r.sharedCacheKey = i.sharedCacheKey;
      }).catch((i) => {
        throw this._imageCache.delete(e), i;
      });
    }
    getImageLoadObject(e) {
      if (e === void 0) throw new Error("getImageLoadObject: imageId must not be undefined");
      const n = this._imageCache.get(e);
      if (n) return n.timeStamp = Date.now(), n.imageLoadObject;
    }
    isLoaded(e) {
      const n = this._imageCache.get(e);
      return n ? n.loaded : false;
    }
    getVolumeContainingImageId(e) {
      var _a3;
      const n = Array.from(this._volumeCache.keys()), r = va(e);
      for (const i of n) {
        const a = this._volumeCache.get(i);
        if (!a) return;
        const { volume: s } = a;
        if (!((_a3 = s == null ? void 0 : s.imageIds) == null ? void 0 : _a3.length)) return;
        const o = s.getImageURIIndex(r);
        if (o > -1) return {
          volume: s,
          imageIdIndex: o
        };
      }
    }
    getCachedImageBasedOnImageURI(e) {
      const n = va(e), i = Array.from(this._imageCache.keys()).find((a) => va(a) === n);
      if (i) return this._imageCache.get(i);
    }
    putVolumeLoadObject(e, n) {
      if (e === void 0) throw new Error("putVolumeLoadObject: volumeId must not be undefined");
      if (n.promise === void 0) throw new Error("putVolumeLoadObject: volumeLoadObject.promise must not be undefined");
      if (this._volumeCache.has(e)) throw new Error(`putVolumeLoadObject: volumeId:${e} already in cache`);
      if (n.cancelFn && typeof n.cancelFn != "function") throw new Error("putVolumeLoadObject: volumeLoadObject.cancel must be a function");
      const r = {
        loaded: false,
        volumeId: e,
        volumeLoadObject: n,
        timeStamp: Date.now(),
        sizeInBytes: 0
      };
      return this._volumeCache.set(e, r), n.promise.then((i) => {
        if (!this._volumeCache.get(e)) {
          console.warn("The image was purged from the cache before it completed loading.");
          return;
        }
        if (Number.isNaN(i.sizeInBytes)) throw new Error("putVolumeLoadObject: volume.sizeInBytes must not be undefined");
        if (i.sizeInBytes.toFixed === void 0) throw new Error("putVolumeLoadObject: volume.sizeInBytes is not a number");
        this.decacheIfNecessaryUntilBytesAvailable(i.sizeInBytes, i.imageIds), r.volume = i, r.sizeInBytes = i.sizeInBytes, this.incrementVolumeCacheSize(r.sizeInBytes);
        const a = {
          volume: r
        };
        qe(je, ze.VOLUME_CACHE_VOLUME_ADDED, a);
      }).catch((i) => {
        throw this._volumeCache.delete(e), i;
      });
    }
    _restoreImagesFromBuffer(e) {
      if (!(e instanceof Gl)) {
        console.warn("Volume is not an ImageVolume. Cannot restore images from buffer.");
        return;
      }
      const n = e.getScalarData(), r = e.imageCacheOffsetMap;
      if (r.size !== 0) {
        for (const [i, { offset: a }] of r) {
          const s = this.getImage(i);
          if (!s) {
            console.warn(`Image with id ${i} not found in cache.`);
            continue;
          }
          const o = s.getPixelData(), l = o.length, c = new o.constructor(n.buffer, a, l);
          s.getPixelData = () => c, s.imageFrame && (s.imageFrame.pixelData = c), delete s.bufferView, this.incrementImageCacheSize(s.sizeInBytes);
        }
        console.log(`Images restored from buffer for volume ${e.volumeId}.`);
      }
    }
  }
  const Ke = new Uee();
  class Fee {
    constructor(e) {
      this.color = [
        200,
        0,
        0
      ], this.id = e.id, this.points = e.data.points, this.polys = e.data.polys, this.color = e.color ?? this.color, this.frameOfReferenceUID = e.frameOfReferenceUID, this.sizeInBytes = this._getSizeInBytes();
    }
    _getSizeInBytes() {
      return this.points.length * 4 + this.polys.length * 4;
    }
    getColor() {
      return this.color;
    }
    getPoints() {
      return this.points;
    }
    getPolys() {
      return this.polys;
    }
    setColor(e) {
      this.color = e;
    }
    setPoints(e) {
      this.points = e;
    }
    setPolys(e) {
      this.polys = e;
    }
    getSizeInBytes() {
      return this.sizeInBytes;
    }
  }
  function Bee(t, e) {
    var _a3, _b3;
    if (t.modality) return t.modality;
    if (t.setVolumes) return e = e ?? ((_a3 = t.getDefaultActor()) == null ? void 0 : _a3.uid), e ? (_b3 = Ke.getVolume(e)) == null ? void 0 : _b3.metadata.Modality : void 0;
    throw new Error("Invalid viewport type");
  }
  function Vu(t, e) {
    const { direction: n, spacing: r } = t, i = n.slice(0, 3), a = n.slice(3, 6), s = n.slice(6, 9), o = [
      Bt(i, e),
      Bt(a, e),
      Bt(s, e)
    ], l = He();
    return Ml(l, o[0] * r[0], o[1] * r[1], o[2] * r[2]), Ms(l);
  }
  function bp(t, e, n) {
    if (!t) return;
    const { direction: r, imageIds: i } = t;
    if (!i || !i.length) return;
    const a = r.slice(6, 9), s = Bt(a, n);
    if (Math.abs(s) < 1 - Vl) return;
    const l = Vu(t, n) / 2;
    let c;
    for (let f = 0; f < i.length; f++) {
      const u = i[f], { imagePositionPatient: h } = Ct("imagePlaneModule", u), g = He();
      hi(g, e, h);
      const v = Bt(g, n);
      Math.abs(v) < l && (c = u);
    }
    return c;
  }
  const { vtkErrorMacro: _ee } = H;
  class kee {
    constructor() {
      this.segmentMapping = {}, this.segments = [
        null
      ], this.faces = [];
    }
    addSegment(e) {
      const n = e[0], r = e[e.length - 1];
      if (n === r || e.length < 2) return;
      const i = this.segmentMapping[n], a = this.segmentMapping[r];
      if (i !== void 0 && a !== void 0) if (Math.abs(i) === Math.abs(a)) {
        const s = i < a ? a : i, o = this.segments[s];
        if (i > 0) for (let l = 1; l < e.length - 1; l++) o.push(e[l]);
        else for (let l = 1; l < e.length - 1; l++) o.unshift(e[e.length - 1 - l]);
        this.faces.push(o), this.segments[s] = null, this.segmentMapping[n] = void 0, this.segmentMapping[r] = void 0;
      } else {
        const s = Math.abs(i), o = Math.abs(a), l = this.segments[s], c = this.segments[o];
        this.segments[s] = null, this.segments[o] = null, this.segmentMapping[l[0]] = void 0, this.segmentMapping[c[0]] = void 0, this.segmentMapping[l[l.length - 1]] = void 0, this.segmentMapping[c[c.length - 1]] = void 0, this.addSegment(e), this.addSegment(l), this.addSegment(c);
      }
      else if (i !== void 0) {
        if (i > 0) {
          const s = this.segments[i];
          for (let o = 1; o < e.length; o++) s.push(e[o]);
          this.segmentMapping[r] = i;
        } else {
          const s = this.segments[-i];
          this.segmentMapping[r] = i;
          for (let o = 1; o < e.length; o++) s.unshift(e[o]);
        }
        this.segmentMapping[n] = void 0;
      } else if (a !== void 0) {
        if (a > 0) {
          const s = this.segments[a];
          for (let o = 1; o < e.length; o++) s.push(e[e.length - 1 - o]);
          this.segmentMapping[n] = a;
        } else {
          const s = this.segments[-a];
          this.segmentMapping[n] = a;
          for (let o = 1; o < e.length; o++) s.unshift(e[e.length - o - 1]);
        }
        this.segmentMapping[r] = void 0;
      } else {
        const s = this.segments.length;
        this.segments.push(e), this.segmentMapping[n] = -s, this.segmentMapping[r] = s;
      }
    }
  }
  function Pee(t, e) {
    e.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"), t.requestData = (n, r) => {
      const i = n[0];
      if (!i) {
        _ee("Invalid or missing input");
        return;
      }
      const a = $i.newInstance();
      a.shallowCopy(i);
      const s = new kee(), o = i.getLines().getData();
      let l = 0;
      for (; l < o.length; ) {
        const h = o[l++], g = [];
        for (let v = 0; v < h; v++) g.push(o[l + v]);
        s.addSegment(g), l += h;
      }
      const { faces: c } = s;
      let f = c.length;
      for (let h = 0; h < c.length; h++) f += c[h].length;
      const u = new Uint16Array(f);
      l = 0;
      for (let h = 0; h < c.length; h++) {
        const g = c[h];
        u[l++] = g.length;
        for (let v = 0; v < g.length; v++) u[l++] = g[v];
      }
      a.setPolys(Yc.newInstance({
        values: u,
        name: "faces"
      })), r[0] = a;
    };
  }
  const Gee = {};
  function EO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Gee, n), H.obj(t, e), H.algo(t, e, 1, 1), Pee(t, e);
  }
  const zee = H.newInstance(EO, "vtkClosedPolyLineToSurfaceFilter");
  var Wee = {
    newInstance: zee,
    extend: EO
  };
  const { vtkErrorMacro: zT } = di;
  function Hee(t) {
    const e = t.getPolys().getData(), n = t.getStrips().getData(), r = {
      cellSize: 0,
      cell: [],
      done: false,
      polyIdx: 0,
      stripIdx: 0,
      remainingStripLength: 0,
      next() {
        if (r.polyIdx < e.length) {
          r.cellSize = e[r.polyIdx];
          const i = r.polyIdx + 1, a = i + r.cellSize;
          r.polyIdx = a;
          let s = 0;
          for (let o = i; o < a; ++o) r.cell[s++] = e[o];
        } else if (r.stripIdx < n.length) {
          r.cellSize = 3, r.remainingStripLength === 0 && (r.remainingStripLength = n[r.stripIdx] - 2, r.stripIdx += 3);
          const i = r.stripIdx - 2, a = r.stripIdx + 1;
          r.stripIdx++, r.remainingStripLength--;
          let s = 0;
          for (let o = i; o < a; ++o) r.cell[s++] = n[o];
        } else if (!r.done) r.done = true;
        else throw new Error("Iterator is done");
      }
    };
    return r.next(), r;
  }
  function jee(t, e) {
    e.classHierarchy.push("vtkCutter");
    const n = {
      ...t
    };
    t.getMTime = () => {
      let i = n.getMTime();
      return e.cutFunction && (i = Math.max(i, e.cutFunction.getMTime())), i;
    };
    function r(i, a) {
      const s = i.getPoints(), o = s.getData(), l = s.getNumberOfPoints(), c = [], f = [], u = [];
      (!e.cutScalars || e.cutScalars.length < l) && (e.cutScalars = new Float32Array(l));
      let h = 0, g = 0;
      for (; h < o.length; ) e.cutScalars[g++] = e.cutFunction.evaluateFunction(o[h++], o[h++], o[h++]);
      const v = [], m = new Array(3), y = new Array(3), w = [];
      for (const T = Hee(i); !T.done; T.next()) {
        if (T.cellSize <= 2) continue;
        for (let R = 0; R < T.cellSize; ) w[R] = e.cutScalars[T.cell[R++]];
        const S = w[0] > 0;
        let E = true;
        for (let R = 1; R < T.cell.length; R++) if (w[R] > 0 !== S) {
          E = false;
          break;
        }
        if (E) continue;
        const b = [];
        for (let R = 0; R < T.cellSize; R++) {
          const I = R + 1 === T.cellSize ? 0 : R + 1, O = w[R] > 0;
          if (w[I] > 0 === O) continue;
          let N = R, F = I, V = w[F] - w[N];
          V <= 0 && (N = I, F = R, V *= -1);
          let k = 0;
          V !== 0 && (k = (e.cutValue - w[N]) / V);
          const _ = T.cell[N], K = T.cell[F];
          m[0] = o[_ * 3], m[1] = o[_ * 3 + 1], m[2] = o[_ * 3 + 2], y[0] = o[K * 3], y[1] = o[K * 3 + 1], y[2] = o[K * 3 + 2];
          const Z = [
            m[0] + k * (y[0] - m[0]),
            m[1] + k * (y[1] - m[1]),
            m[2] + k * (y[2] - m[2])
          ];
          b.push({
            pointEdge1: _,
            pointEdge2: K,
            intersectedPoint: Z,
            newPointID: -1
          });
        }
        for (let R = 0; R < b.length; R++) {
          const I = b[R];
          let O = false;
          for (let L = 0; L < v.length; L++) {
            const N = v[L], F = I.pointEdge1 === N.pointEdge1 && I.pointEdge2 === N.pointEdge2, V = I.intersectedPoint[0] === N.intersectedPoint[0] && I.intersectedPoint[1] === N.intersectedPoint[1] && I.intersectedPoint[2] === N.intersectedPoint[2];
            if (F || V) {
              O = true, b[R].newPointID = v[L].newPointID;
              break;
            }
          }
          O || (c.push(I.intersectedPoint[0]), c.push(I.intersectedPoint[1]), c.push(I.intersectedPoint[2]), b[R].newPointID = c.length / 3 - 1, v.push(b[R]));
        }
        const D = b.length;
        D === 2 ? f.push(D, b[0].newPointID, b[1].newPointID) : D > 2 && (u.push(D), b.forEach((R) => {
          u.push(R.newPointID);
        }));
      }
      a.getPoints().setData(d5(s.getDataType(), c), 3), f.length !== 0 && a.getLines().setData(Uint16Array.from(f)), u.length !== 0 && a.getPolys().setData(Uint16Array.from(u));
    }
    t.requestData = (i, a) => {
      const s = i[0];
      if (!s) {
        zT("Invalid or missing input");
        return;
      }
      if (!e.cutFunction) {
        zT("Missing cut function");
        return;
      }
      const o = $i.newInstance();
      r(s, o), a[0] = o;
    };
  }
  const Kee = {
    cutFunction: null,
    cutScalars: null,
    cutValue: 0
  };
  function bO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Kee, n), _n(t, e), v8(t, e, 1, 1), pr(t, e, [
      "cutFunction",
      "cutValue"
    ]), jee(t, e);
  }
  const Yee = pn(bO, "vtkCutter");
  var qee = {
    newInstance: Yee,
    extend: bO
  };
  const Xee = (t) => t, WT = 1e-6;
  let DO = class {
    constructor() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.matrix = gt(new Float64Array(16)), this.tmp = new Float64Array(3), this.angleConv = e ? LK : Xee;
    }
    rotateFromDirections(e, n) {
      const r = new Float64Array(3), i = new Float64Array(3), a = new Float64Array(16);
      Vn(r, e[0], e[1], e[2]), Vn(i, n[0], n[1], n[2]), cs(r, r), cs(i, i);
      const s = Sh(r, i);
      return s >= 1 ? this : (xu(this.tmp, r, i), yu(this.tmp) < WT && (xu(this.tmp, [
        1,
        0,
        0
      ], e), yu(this.tmp) < WT && xu(this.tmp, [
        0,
        1,
        0
      ], e)), YD(a, Math.acos(s), this.tmp), tn(this.matrix, this.matrix, a), this);
    }
    rotate(e, n) {
      return Vn(this.tmp, ...n), cs(this.tmp, this.tmp), $a(this.matrix, this.matrix, this.angleConv(e), this.tmp), this;
    }
    rotateX(e) {
      return U8(this.matrix, this.matrix, this.angleConv(e)), this;
    }
    rotateY(e) {
      return F8(this.matrix, this.matrix, this.angleConv(e)), this;
    }
    rotateZ(e) {
      return B8(this.matrix, this.matrix, this.angleConv(e)), this;
    }
    translate(e, n, r) {
      return Vn(this.tmp, e, n, r), $n(this.matrix, this.matrix, this.tmp), this;
    }
    scale(e, n, r) {
      return Vn(this.tmp, e, n, r), Fl(this.matrix, this.matrix, this.tmp), this;
    }
    multiply(e) {
      return tn(this.matrix, this.matrix, e), this;
    }
    multiply3x3(e) {
      return tn(this.matrix, this.matrix, [
        e[0],
        e[1],
        e[2],
        0,
        e[3],
        e[4],
        e[5],
        0,
        e[6],
        e[7],
        e[8],
        0,
        0,
        0,
        0,
        1
      ]), this;
    }
    invert() {
      return Nr(this.matrix, this.matrix), this;
    }
    identity() {
      return gt(this.matrix), this;
    }
    apply(e) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      if ($h(T8, this.matrix)) return this;
      const i = r === -1 ? e.length : n + r * 3;
      for (let a = n; a < i; a += 3) Vn(this.tmp, e[a], e[a + 1], e[a + 2]), $t(this.tmp, this.tmp, this.matrix), e[a] = this.tmp[0], e[a + 1] = this.tmp[1], e[a + 2] = this.tmp[2];
      return this;
    }
    getMatrix() {
      return this.matrix;
    }
    setMatrix(e) {
      return e && e.length === 16 && sr(this.matrix, e), this;
    }
  };
  function Zee() {
    return new DO(true);
  }
  function Qee() {
    return new DO(false);
  }
  var Lc = {
    buildFromDegree: Zee,
    buildFromRadian: Qee
  };
  const Jee = [
    2,
    0,
    1,
    2,
    2,
    3,
    2,
    4,
    5,
    2,
    6,
    7,
    2,
    0,
    2,
    2,
    1,
    3,
    2,
    4,
    6,
    2,
    5,
    7,
    2,
    0,
    4,
    2,
    1,
    5,
    2,
    2,
    6,
    2,
    3,
    7
  ], $ee = [
    4,
    0,
    1,
    3,
    2,
    4,
    4,
    6,
    7,
    5,
    4,
    8,
    10,
    11,
    9,
    4,
    12,
    13,
    15,
    14,
    4,
    16,
    18,
    19,
    17,
    4,
    20,
    21,
    23,
    22
  ];
  function ete(t, e) {
    e.classHierarchy.push("vtkCubeSource");
    function n(r, i) {
      if (e.deleted) return;
      const a = $i.newInstance();
      i[0] = a;
      const s = 24, o = H.newTypedArray(e.pointType, s * 3);
      a.getPoints().setData(o, 3);
      const l = H.newTypedArray(e.pointType, s * 3), c = Tt.newInstance({
        name: "Normals",
        values: l,
        numberOfComponents: 3
      });
      a.getPointData().setNormals(c);
      let f = 2;
      e.generate3DTextureCoordinates === true && (f = 3);
      const u = H.newTypedArray(e.pointType, s * f), h = Tt.newInstance({
        name: "TextureCoordinates",
        values: u,
        numberOfComponents: f
      });
      a.getPointData().setTCoords(h);
      const g = [
        0,
        0,
        0
      ], v = [
        0,
        0,
        0
      ], m = [
        0,
        0
      ];
      let y = 0;
      g[0] = -e.xLength / 2, v[0] = -1, v[1] = 0, v[2] = 0;
      for (let w = 0; w < 2; w++) {
        g[1] = -e.yLength / 2;
        for (let C = 0; C < 2; C++) {
          m[1] = g[1] + 0.5, g[2] = -e.zLength / 2;
          for (let T = 0; T < 2; T++) m[0] = (g[2] + 0.5) * (1 - 2 * w), o[y * 3] = g[0], o[y * 3 + 1] = g[1], o[y * 3 + 2] = g[2], l[y * 3] = v[0], l[y * 3 + 1] = v[1], l[y * 3 + 2] = v[2], f === 2 ? (u[y * f] = m[0], u[y * f + 1] = m[1]) : (u[y * f] = 2 * w - 1, u[y * f + 1] = 2 * C - 1, u[y * f + 2] = 2 * T - 1), y++, g[2] += e.zLength;
          g[1] += e.yLength;
        }
        g[0] += e.xLength, v[0] += 2;
      }
      g[1] = -e.yLength / 2, v[1] = -1, v[0] = 0, v[2] = 0;
      for (let w = 0; w < 2; w++) {
        g[0] = -e.xLength / 2;
        for (let C = 0; C < 2; C++) {
          m[0] = (g[0] + 0.5) * (2 * w - 1), g[2] = -e.zLength / 2;
          for (let T = 0; T < 2; T++) m[1] = (g[2] + 0.5) * -1, o[y * 3] = g[0], o[y * 3 + 1] = g[1], o[y * 3 + 2] = g[2], l[y * 3] = v[0], l[y * 3 + 1] = v[1], l[y * 3 + 2] = v[2], f === 2 ? (u[y * f] = m[0], u[y * f + 1] = m[1]) : (u[y * f] = 2 * C - 1, u[y * f + 1] = 2 * w - 1, u[y * f + 2] = 2 * T - 1), y++, g[2] += e.zLength;
          g[0] += e.xLength;
        }
        g[1] += e.yLength, v[1] += 2;
      }
      g[2] = -e.zLength / 2, v[2] = -1, v[0] = 0, v[1] = 0;
      for (let w = 0; w < 2; w++) {
        g[1] = -e.yLength / 2;
        for (let C = 0; C < 2; C++) {
          m[1] = g[1] + 0.5, g[0] = -e.xLength / 2;
          for (let T = 0; T < 2; T++) m[0] = (g[0] + 0.5) * (2 * w - 1), o[y * 3] = g[0], o[y * 3 + 1] = g[1], o[y * 3 + 2] = g[2], l[y * 3] = v[0], l[y * 3 + 1] = v[1], l[y * 3 + 2] = v[2], f === 2 ? (u[y * f] = m[0], u[y * f + 1] = m[1]) : (u[y * f] = 2 * T - 1, u[y * f + 1] = 2 * C - 1, u[y * f + 2] = 2 * w - 1), y++, g[0] += e.xLength;
          g[1] += e.yLength;
        }
        g[2] += e.zLength, v[2] += 2;
      }
      if (e.rotations && Lc.buildFromDegree().rotateX(e.rotations[0]).rotateY(e.rotations[1]).rotateZ(e.rotations[2]).apply(o).apply(l), e.center && Lc.buildFromRadian().translate(...e.center).apply(o), e.matrix) {
        Lc.buildFromRadian().setMatrix(e.matrix).apply(o);
        const w = [
          e.matrix[0],
          e.matrix[1],
          e.matrix[2],
          0,
          e.matrix[4],
          e.matrix[5],
          e.matrix[6],
          0,
          e.matrix[8],
          e.matrix[9],
          e.matrix[10],
          0,
          0,
          0,
          0,
          1
        ];
        Lc.buildFromRadian().setMatrix(w).apply(l);
      }
      e.generateFaces ? a.getPolys().deepCopy(e._polys) : a.getPolys().initialize(), e.generateLines ? (a.getLines().deepCopy(e._lineCells), a.getPointData().setNormals(null)) : a.getLines().initialize(), a.modified();
    }
    t.setBounds = function() {
      let r = [];
      if (Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) r = arguments.length <= 0 ? void 0 : arguments[0];
      else for (let i = 0; i < arguments.length; i++) r.push(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
      r.length === 6 && (t.setXLength(r[1] - r[0]), t.setYLength(r[3] - r[2]), t.setZLength(r[5] - r[4]), t.setCenter([
        (r[0] + r[1]) / 2,
        (r[2] + r[3]) / 2,
        (r[4] + r[5]) / 2
      ]));
    }, t.requestData = n;
  }
  const tte = {
    xLength: 1,
    yLength: 1,
    zLength: 1,
    pointType: "Float64Array",
    generate3DTextureCoordinates: false,
    generateFaces: true,
    generateLines: false
  };
  function MO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, tte, n), H.obj(t, e), H.setGet(t, e, [
      "xLength",
      "yLength",
      "zLength",
      "generate3DTextureCoordinates",
      "generateFaces",
      "generateLines"
    ]), H.setGetArray(t, e, [
      "center",
      "rotations"
    ], 3), H.setGetArray(t, e, [
      "matrix"
    ], 16), e._polys = Yc.newInstance({
      values: Uint16Array.from($ee)
    }), e._lineCells = Yc.newInstance({
      values: Uint16Array.from(Jee)
    }), H.moveToProtected(t, e, [
      "polys",
      "lineCells"
    ]), H.algo(t, e, 0, 1), ete(t, e);
  }
  const nte = H.newInstance(MO, "vtkCubeSource");
  var rte = {
    newInstance: nte,
    extend: MO
  };
  const { vtkErrorMacro: HT } = H;
  function ite(t, e) {
    e.classHierarchy.push("vtkImageDataOutlineFilter");
    const n = {
      ...t
    };
    t.requestData = (r, i) => {
      const a = r[0];
      if (!a || !a.isA("vtkImageData")) {
        HT("Invalid or missing input");
        return;
      }
      const s = a.getSpatialExtent();
      if (!s) {
        HT("Unable to fetch spatial extents of input image.");
        return;
      }
      e._cubeSource.setBounds(s), e._cubeSource.setMatrix(a.getIndexToWorld()), i[0] = e._cubeSource.getOutputData();
    }, t.getMTime = () => Math.max(n.getMTime(), e._cubeSource.getMTime()), t.setGenerateFaces = e._cubeSource.setGenerateFaces, t.setGenerateLines = e._cubeSource.setGenerateLines, t.getGenerateFaces = e._cubeSource.getGenerateFaces, t.getGenerateLines = e._cubeSource.getGenerateLines;
  }
  const ate = {};
  function RO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, ate, n), H.obj(t, e), H.algo(t, e, 1, 1), e._cubeSource = rte.newInstance(), H.moveToProtected(t, e, [
      "cubeSource",
      "tmpOut"
    ]), ite(t, e);
  }
  const ste = H.newInstance(RO, "vtkImageDataOutlineFilter");
  var ote = {
    newInstance: ste,
    extend: RO
  };
  let cy;
  function lte(t, e) {
    e.classHierarchy.push("vtkAbstractTransform", "vtkHomogeneousTransform", "vtkTransform"), t.transformPoint = (n, r) => ($t(r, n, e.matrix), r), t.transformPoints = (n, r) => {
      const i = new Float64Array(3), a = new Float64Array(3);
      for (let s = 0; s < n.length; s += 3) i[0] = n[s], i[1] = n[s + 1], i[2] = n[s + 2], $t(a, i, e.matrix), r[s] = a[0], r[s + 1] = a[1], r[s + 2] = a[2];
      return r;
    }, t.preMultiply = () => {
      t.setPreMultiplyFlag(true);
    }, t.postMultiply = () => {
      t.setPreMultiplyFlag(false);
    }, t.transformMatrix = (n, r) => (e.preMultiplyFlag ? tn(r, e.matrix, n) : tn(r, n, e.matrix), r), t.transformMatrices = (n, r) => {
      const i = new Float64Array(16), a = new Float64Array(16), s = e.preMultiplyFlag ? () => tn(a, e.matrix, i) : () => tn(a, i, e.matrix);
      for (let o = 0; o < n.length; o += 16) {
        for (let l = 0; l < 16; ++l) i[l] = n[o + l];
        s();
        for (let l = 0; l < 16; ++l) r[o + l] = a[l];
      }
      return r;
    }, t.getInverse = () => cy({
      matrix: La.invertMatrix(Array.from(e.matrix), [], 4),
      preMultiplyFlag: e.preMultiplyFlag
    });
  }
  const cte = {
    preMultiplyFlag: false,
    matrix: [
      ...T8
    ]
  };
  function OO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, cte, n), H.obj(t, e), H.setGet(t, e, [
      "preMultiplyFlag"
    ]), H.setGetArray(t, e, [
      "matrix"
    ], 16), lte(t, e);
  }
  cy = H.newInstance(OO, "vtkTransform");
  var ute = {
    newInstance: cy,
    extend: OO
  }, fte = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

// all variables that represent positions or directions have a suffix
// indicating the coordinate system they are in. The possible values are
// MC - Model coordinates
// WC - World coordinates
// VC - View coordinates
// DC - Display coordinates
// TC - Texture coordinates

// frag position in VC
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// camera and actor matrix values
//VTK::Camera::Dec

void main()
{
  //VTK::PositionVC::Impl

  //VTK::TCoord::Impl

  //VTK::Picking::Impl
}
`, hte = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the gpu image mapper fragment shader

// VC position of this fragment
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

// the output of this shader
//VTK::Output::Dec

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  //VTK::TCoord::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;
  const { vtkErrorMacro: vc } = di;
  function jT(t, e, n) {
    if (e) {
      const r = t.getIndependentComponents();
      return `${e.getMTime()}-${r}-${n}`;
    }
    return "0";
  }
  function KT(t, e, n) {
    return e.identity(n), t.reduce((r, i, a) => a === 0 ? i ? e.copy(r, i) : e.identity(r) : i ? e.multiply(r, r, i) : r, n);
  }
  function dte(t, e) {
    e.classHierarchy.push("vtkOpenGLImageResliceMapper"), t.buildPass = (r) => {
      if (r) {
        e.currentRenderPass = null, e._openGLImageSlice = t.getFirstAncestorOfType("vtkOpenGLImageSlice"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer");
        const i = e._openGLRenderer.getRenderable();
        e._openGLCamera = e._openGLRenderer.getViewNodeFor(i.getActiveCamera()), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow);
      }
    }, t.translucentPass = (r, i) => {
      r && (e.currentRenderPass = i, t.render());
    }, t.zBufferPass = (r) => {
      r && (e.haveSeenDepthRequest = true, e.renderDepth = true, t.render(), e.renderDepth = false);
    }, t.opaqueZBufferPass = (r) => t.zBufferPass(r), t.opaquePass = (r) => {
      r && t.render();
    }, t.getCoincidentParameters = (r, i) => e.renderable.getResolveCoincidentTopology() ? e.renderable.getCoincidentTopologyPolygonOffsetParameters() : null, t.render = () => {
      const r = e._openGLImageSlice.getRenderable(), i = e._openGLRenderer.getRenderable();
      t.renderPiece(i, r);
    }, t.renderPiece = (r, i) => {
      if (t.invokeEvent({
        type: "StartEvent"
      }), e.renderable.update(), e.currentInput = e.renderable.getInputData(), !e.currentInput) {
        vc("No input!");
        return;
      }
      t.updateResliceGeometry(), t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i), t.invokeEvent({
        type: "EndEvent"
      });
    }, t.renderPieceStart = (r, i) => {
      t.updateBufferObjects(r, i), i.getProperty().getInterpolationType() === Bc.NEAREST ? (e.openGLTexture.setMinificationFilter(dt.NEAREST), e.openGLTexture.setMagnificationFilter(dt.NEAREST), e.colorTexture.setMinificationFilter(dt.NEAREST), e.colorTexture.setMagnificationFilter(dt.NEAREST), e.pwfTexture.setMinificationFilter(dt.NEAREST), e.pwfTexture.setMagnificationFilter(dt.NEAREST)) : (e.openGLTexture.setMinificationFilter(dt.LINEAR), e.openGLTexture.setMagnificationFilter(dt.LINEAR), e.colorTexture.setMinificationFilter(dt.LINEAR), e.colorTexture.setMagnificationFilter(dt.LINEAR), e.pwfTexture.setMinificationFilter(dt.LINEAR), e.pwfTexture.setMagnificationFilter(dt.LINEAR)), e.lastBoundBO = null;
    }, t.renderPieceDraw = (r, i) => {
      const a = e.context;
      e.openGLTexture.activate(), e.colorTexture.activate(), e.pwfTexture.activate(), t.updateShaders(e.tris, r, i), a.drawArrays(a.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release(), e.openGLTexture.deactivate(), e.colorTexture.deactivate(), e.pwfTexture.deactivate();
    }, t.renderPieceFinish = (r, i) => {
    }, t.updateBufferObjects = (r, i) => {
      t.getNeedToRebuildBufferObjects(r, i) && t.buildBufferObjects(r, i);
    }, t.getNeedToRebuildBufferObjects = (r, i) => e.VBOBuildTime.getMTime() < t.getMTime() || e.VBOBuildTime.getMTime() < i.getMTime() || e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < i.getProperty().getMTime() || e.VBOBuildTime.getMTime() < e.currentInput.getMTime() || e.VBOBuildTime.getMTime() < e.resliceGeom.getMTime(), t.buildBufferObjects = (r, i) => {
      var _a3;
      const a = e.currentInput;
      if (!a) return;
      const s = (_a3 = a.getPointData()) == null ? void 0 : _a3.getScalars();
      if (!s) return;
      e._scalars !== s && (e._openGLRenderWindow.releaseGraphicsResourcesForObject(e._scalars), e._scalars = s);
      const o = s.getNumberOfComponents();
      let l = `${a.getMTime()}A${s.getMTime()}`;
      const c = e._openGLRenderWindow.getGraphicsResourceForObject(s);
      if (!(c == null ? void 0 : c.vtkObj) || (c == null ? void 0 : c.hash) !== l || e.openGLTextureString !== l) {
        e.openGLTexture || (e.openGLTexture = er.newInstance(), e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow));
        const b = a.getDimensions();
        e.openGLTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), e.openGLTexture.releaseGraphicsResources(e._openGLRenderWindow), e.openGLTexture.resetFormatAndType(), e.openGLTexture.create3DFilterableFromDataArray(b[0], b[1], b[2], s), e.openGLTextureString = l, s && e._openGLRenderWindow.setGraphicsResourceForObject(s, e.openGLTexture, e.openGLTextureString);
      } else e.openGLTexture = c.vtkObj, e.openGLTextureString = c.hash;
      const u = i.getProperty(), h = u.getIndependentComponents(), g = h ? o : 1, v = h ? 2 * g : 1, m = u.getRGBTransferFunction();
      l = jT(u, m, g);
      const y = e._openGLRenderWindow.getGraphicsResourceForObject(m);
      if (!(y == null ? void 0 : y.vtkObj) || (y == null ? void 0 : y.hash) !== l || e.colorTextureString !== l) {
        const D = 1024 * v * 3, R = new Uint8ClampedArray(D);
        if (e.colorTexture || (e.colorTexture = er.newInstance(), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow)), m) {
          const I = new Float32Array(3072);
          for (let O = 0; O < g; O++) {
            const L = u.getRGBTransferFunction(O), N = L.getRange();
            if (L.getTable(N[0], N[1], 1024, I, 1), h) for (let F = 0; F < 1024 * 3; F++) R[O * 1024 * 6 + F] = 255 * I[F], R[O * 1024 * 6 + F + 1024 * 3] = 255 * I[F];
            else for (let F = 0; F < 1024 * 3; F++) R[O * 1024 * 6 + F] = 255 * I[F];
          }
          e.colorTexture.releaseGraphicsResources(e._openGLRenderWindow), e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, v, 3, zt.UNSIGNED_CHAR, R);
        } else {
          for (let I = 0; I < 1024 * 3; ++I) R[I] = 255 * I / (1023 * 3), R[I + 1] = 255 * I / (1023 * 3), R[I + 2] = 255 * I / (1023 * 3);
          e.colorTexture.releaseGraphicsResources(e._openGLRenderWindow), e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, 1, 3, zt.UNSIGNED_CHAR, R);
        }
        e.colorTextureString = l, m && e._openGLRenderWindow.setGraphicsResourceForObject(m, e.colorTexture, e.colorTextureString);
      } else e.colorTexture = y.vtkObj, e.colorTextureString = y.hash;
      const C = u.getPiecewiseFunction();
      l = jT(u, C, g);
      const T = e._openGLRenderWindow.getGraphicsResourceForObject(C);
      if (!(T == null ? void 0 : T.vtkObj) || (T == null ? void 0 : T.hash) !== l || e.pwfTextureString !== l) {
        const D = 1024 * v, R = new Uint8ClampedArray(D);
        if (e.pwfTexture || (e.pwfTexture = er.newInstance(), e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow)), C) {
          const I = new Float32Array(D), O = new Float32Array(1024);
          for (let L = 0; L < g; ++L) {
            const N = u.getPiecewiseFunction(L);
            if (N === null) I.fill(1);
            else {
              const F = N.getRange();
              if (N.getTable(F[0], F[1], 1024, O, 1), h) for (let V = 0; V < 1024; V++) I[L * 1024 * 2 + V] = O[V], I[L * 1024 * 2 + V + 1024] = O[V];
              else for (let V = 0; V < 1024; V++) I[L * 1024 * 2 + V] = O[V];
            }
          }
          e.pwfTexture.releaseGraphicsResources(e._openGLRenderWindow), e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, v, 1, zt.FLOAT, I);
        } else R.fill(255), e.pwfTexture.releaseGraphicsResources(e._openGLRenderWindow), e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, 1, 1, zt.UNSIGNED_CHAR, R);
        e.pwfTextureString = l, C && e._openGLRenderWindow.setGraphicsResourceForObject(C, e.pwfTexture, e.pwfTextureString);
      } else e.pwfTexture = T.vtkObj, e.pwfTextureString = T.hash;
      const E = `${e.resliceGeom.getMTime()}A${e.renderable.getSlabThickness()}`;
      if (!e.tris.getCABO().getElementCount() || e.VBOBuildString !== E) {
        const b = Tt.newInstance({
          numberOfComponents: 3,
          values: e.resliceGeom.getPoints().getData()
        });
        b.setName("points");
        const D = Tt.newInstance({
          numberOfComponents: 1,
          values: e.resliceGeom.getPolys().getData()
        }), R = {
          points: b,
          cellOffset: 0
        };
        if (e.renderable.getSlabThickness() > 0) {
          const I = e.resliceGeom.getPointData().getNormals();
          I ? R.normals = I : vc("Slab mode requested without normals");
        }
        e.tris.getCABO().createVBO(D, "polys", fi.SURFACE, R);
      }
      e.VBOBuildString = E, e.VBOBuildTime.modified();
    }, t.updateShaders = (r, i, a) => {
      if (e.lastBoundBO = r, t.getNeedToRebuildShaders(r, i, a)) {
        const s = {
          Vertex: null,
          Fragment: null,
          Geometry: null
        };
        t.buildShaders(s, i, a);
        const o = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(s.Vertex, s.Fragment, s.Geometry);
        o !== r.getProgram() && (r.setProgram(o), r.getVAO().releaseGraphicsResources()), r.getShaderSourceTime().modified();
      } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(r.getProgram());
      r.getVAO().bind(), t.setMapperShaderParameters(r, i, a), t.setCameraShaderParameters(r, i, a), t.setPropertyShaderParameters(r, i, a);
    }, t.setMapperShaderParameters = (r, i, a) => {
      const s = r.getProgram();
      if (r.getCABO().getElementCount() && (e.VBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime())) {
        s.isUniformUsed("texture1") && s.setUniformi("texture1", e.openGLTexture.getTextureUnit()), s.isAttributeUsed("vertexWC") && (r.getVAO().addAttributeArray(s, r.getCABO(), "vertexWC", r.getCABO().getVertexOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || vc("Error setting vertexWC in shader VAO.")), s.isAttributeUsed("normalWC") && (r.getVAO().addAttributeArray(s, r.getCABO(), "normalWC", r.getCABO().getNormalOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || vc("Error setting normalWC in shader VAO.")), s.isUniformUsed("slabThickness") && s.setUniformf("slabThickness", e.renderable.getSlabThickness()), s.isUniformUsed("spacing") && s.setUniform3fv("spacing", e.currentInput.getSpacing()), s.isUniformUsed("slabType") && s.setUniformi("slabType", e.renderable.getSlabType()), s.isUniformUsed("slabType") && s.setUniformi("slabType", e.renderable.getSlabType()), s.isUniformUsed("slabTrapezoid") && s.setUniformi("slabTrapezoid", e.renderable.getSlabTrapezoidIntegration());
        const l = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null;
        if (s.isUniformUsed("WCTCMatrix")) {
          const c = e.currentInput, f = c.getDimensions();
          sr(e.tmpMat4, c.getIndexToWorld()), Fl(e.tmpMat4, e.tmpMat4, f), Nr(e.tmpMat4, e.tmpMat4), l && tn(e.tmpMat4, e.tmpMat4, l), s.setUniformMatrix("WCTCMatrix", e.tmpMat4);
        }
        s.isUniformUsed("vboScaling") && s.setUniform3fv("vboScaling", r.getCABO().getCoordScale()), r.getAttributeUpdateTime().modified();
      }
      if (e.haveSeenDepthRequest && r.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), r.getProgram().isUniformUsed("coffset")) {
        const o = t.getCoincidentParameters(i, a);
        r.getProgram().setUniformf("coffset", o.offset), r.getProgram().isUniformUsed("cfactor") && r.getProgram().setUniformf("cfactor", o.factor);
      }
    }, t.setCameraShaderParameters = (r, i, a) => {
      const s = e._openGLCamera.getKeyMatrices(i), o = e._openGLImageSlice.getKeyMatrices(), c = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null, f = r.getProgram();
      f.isUniformUsed("MCPCMatrix") && (gt(e.tmpMat4), f.setUniformMatrix("MCPCMatrix", KT([
        s.wcpc,
        o.mcwc,
        c
      ], Th, e.tmpMat4))), f.isUniformUsed("MCVCMatrix") && (gt(e.tmpMat4), f.setUniformMatrix("MCVCMatrix", KT([
        s.wcvc,
        o.mcwc,
        c
      ], Th, e.tmpMat4)));
    }, t.setPropertyShaderParameters = (r, i, a) => {
      const s = r.getProgram(), o = a.getProperty(), l = o.getOpacity();
      s.setUniformf("opacity", l);
      const c = e.openGLTexture.getComponents(), f = o.getIndependentComponents();
      if (f) for (let v = 0; v < c; ++v) s.setUniformf(`mix${v}`, o.getComponentWeight(v));
      const u = e.openGLTexture.getVolumeInfo();
      for (let v = 0; v < c; v++) {
        let m = o.getColorWindow(), y = o.getColorLevel();
        const w = f ? v : 0, C = o.getRGBTransferFunction(w);
        if (C && o.getUseLookupTableScalarRange()) {
          const E = C.getRange();
          m = E[1] - E[0], y = 0.5 * (E[1] + E[0]);
        }
        const T = u.scale[v] / m, S = (u.offset[v] - y) / m + 0.5;
        s.setUniformf(`cshift${v}`, S), s.setUniformf(`cscale${v}`, T);
      }
      const h = e.colorTexture.getTextureUnit();
      s.setUniformi("colorTexture1", h);
      for (let v = 0; v < c; v++) {
        let m = 1, y = 0;
        const w = f ? v : 0, C = o.getPiecewiseFunction(w);
        if (C) {
          const T = C.getRange(), S = T[1] - T[0], E = 0.5 * (T[0] + T[1]);
          m = u.scale[v] / S, y = (u.offset[v] - E) / S + 0.5;
        }
        s.setUniformf(`pwfshift${v}`, y), s.setUniformf(`pwfscale${v}`, m);
      }
      const g = e.pwfTexture.getTextureUnit();
      s.setUniformi("pwfTexture1", g), s.setUniform4fv("backgroundColor", e.renderable.getBackgroundColor());
    }, t.getNeedToRebuildShaders = (r, i, a) => {
      var _a3;
      const s = e.openGLTexture.getComponents(), o = a.getProperty().getIndependentComponents(), l = e.renderable.getSlabThickness(), c = e.renderable.getSlabType(), f = e.renderable.getSlabTrapezoidIntegration();
      let u = false;
      return (!e.currentRenderPass && e.lastRenderPassShaderReplacement || e.currentRenderPass && e.currentRenderPass.getShaderReplacement() !== e.lastRenderPassShaderReplacement) && (u = true), u || e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || ((_a3 = r.getProgram()) == null ? void 0 : _a3.getHandle()) === 0 || e.lastTextureComponents !== s || e.lastIndependentComponents !== o || e.lastSlabThickness !== l || e.lastSlabType !== c || e.lastSlabTrapezoidIntegration !== f ? (e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, e.lastTextureComponents = s, e.lastIndependentComponents = o, e.lastSlabThickness = l, e.lastSlabType = c, e.lastSlabTrapezoidIntegration = f, true) : false;
    }, t.getShaderTemplate = (r, i, a) => {
      r.Vertex = fte, r.Fragment = hte, r.Geometry = "";
    }, t.replaceShaderValues = (r, i, a) => {
      if (t.replaceShaderTCoord(r, i, a), t.replaceShaderPositionVC(r, i, a), e.haveSeenDepthRequest) {
        let s = r.Fragment;
        s = se.substitute(s, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, s = se.substitute(s, "//VTK::ZBuffer::Impl", [
          "if (depthRequest == 1) {",
          "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
          "float rf = floor(iz/256.0)/255.0;",
          "float gf = mod(iz,256.0)/255.0;",
          "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
        ]).result, r.Fragment = s;
      }
      t.replaceShaderCoincidentOffset(r, i, a);
    }, t.replaceShaderTCoord = (r, i, a) => {
      let s = r.Vertex;
      const o = r.Geometry;
      let l = r.Fragment;
      const c = [
        "uniform mat4 WCTCMatrix;",
        "out vec3 fragTexCoord;"
      ], f = e.renderable.getSlabThickness();
      s = se.substitute(s, "//VTK::TCoord::Dec", c).result;
      const u = [
        "fragTexCoord = (WCTCMatrix * vertexWC).xyz;"
      ];
      s = se.substitute(s, "//VTK::TCoord::Impl", u).result;
      const h = e.openGLTexture.getComponents(), g = a.getProperty().getIndependentComponents();
      let v = [
        "in vec3 fragTexCoord;",
        "uniform highp sampler3D texture1;",
        "uniform mat4 WCTCMatrix;",
        "uniform float cshift0;",
        "uniform float cscale0;",
        "uniform float pwfshift0;",
        "uniform float pwfscale0;",
        "uniform sampler2D colorTexture1;",
        "uniform sampler2D pwfTexture1;",
        "uniform float opacity;",
        "uniform vec4 backgroundColor;"
      ];
      if (g) {
        for (let y = 1; y < h; y++) v = v.concat([
          `uniform float cshift${y};`,
          `uniform float cscale${y};`,
          `uniform float pwfshift${y};`,
          `uniform float pwfscale${y};`
        ]);
        switch (h) {
          case 1:
            v = v.concat([
              "uniform float mix0;",
              "#define height0 0.5"
            ]);
            break;
          case 2:
            v = v.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "#define height0 0.25",
              "#define height1 0.75"
            ]);
            break;
          case 3:
            v = v.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "uniform float mix2;",
              "#define height0 0.17",
              "#define height1 0.5",
              "#define height2 0.83"
            ]);
            break;
          case 4:
            v = v.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "uniform float mix2;",
              "uniform float mix3;",
              "#define height0 0.125",
              "#define height1 0.375",
              "#define height2 0.625",
              "#define height3 0.875"
            ]);
            break;
          default:
            vc("Unsupported number of independent coordinates.");
        }
      }
      f > 0 && (v = v.concat([
        "uniform vec3 spacing;",
        "uniform float slabThickness;",
        "uniform int slabType;",
        "uniform int slabTrapezoid;",
        "uniform vec3 vboScaling;"
      ]), v = v.concat([
        "vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)",
        "{",
        "  vec4 retVal = vec4(1.0);",
        "  if (slabType == 0) // min",
        "  {",
        "    retVal = min(currVal, valToComp);",
        "  }",
        "  else if (slabType == 1) // max",
        "  {",
        "    retVal = max(currVal, valToComp);",
        "  }",
        "  else if (slabType == 3) // sum",
        "  {",
        "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ",
        "  }",
        "  else // mean",
        "  {",
        "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ",
        "  }",
        "  return retVal;",
        "}"
      ])), l = se.substitute(l, "//VTK::TCoord::Dec", v).result;
      let m = [
        "if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))",
        "{",
        "  // set the background color and exit",
        "  gl_FragData[0] = backgroundColor;",
        "  return;",
        "}",
        "vec4 tvalue = texture(texture1, fragTexCoord);"
      ];
      if (f > 0 && (m = m.concat([
        "// Get the first and last samples",
        "int numSlices = 1;",
        "float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;",
        "vec3 normalxspacing = scaling * normalWCVSOutput;",
        "float distTraveled = length(normalxspacing);",
        "int trapezoid = 0;",
        "while (distTraveled < slabThickness * 0.5)",
        "{",
        "  distTraveled += length(normalxspacing);",
        "  float fnumSlices = float(numSlices);",
        "  if (distTraveled > slabThickness * 0.5)",
        "  {",
        "    // Before stepping outside the slab, sample at the boundaries",
        "    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;",
        "    trapezoid = slabTrapezoid;",
        "  }",
        "  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;",
        "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))",
        "  {",
        "    vec4 newVal = texture(texture1, fragTCoordNeg);",
        "    tvalue = compositeValue(tvalue, newVal, trapezoid);",
        "    numSlices += 1;",
        "  }",
        "  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;",
        "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))",
        "  {",
        "    vec4 newVal = texture(texture1, fragTCoordPos);",
        "    tvalue = compositeValue(tvalue, newVal, trapezoid);",
        "    numSlices += 1;",
        "  }",
        "}",
        "// Finally, if slab type is *mean*, divide the sum by the numSlices",
        "if (slabType == 2)",
        "{",
        "  tvalue = tvalue / float(numSlices);",
        "}"
      ])), g) {
        const y = [
          "r",
          "g",
          "b",
          "a"
        ];
        for (let w = 0; w < h; ++w) m = m.concat([
          `vec3 tcolor${w} = mix${w} * texture2D(colorTexture1, vec2(tvalue.${y[w]} * cscale${w} + cshift${w}, height${w})).rgb;`,
          `float compWeight${w} = mix${w} * texture2D(pwfTexture1, vec2(tvalue.${y[w]} * pwfscale${w} + pwfshift${w}, height${w})).r;`
        ]);
        switch (h) {
          case 1:
            m = m.concat([
              "gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"
            ]);
            break;
          case 2:
            m = m.concat([
              "float weightSum = compWeight0 + compWeight1;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"
            ]);
            break;
          case 3:
            m = m.concat([
              "float weightSum = compWeight0 + compWeight1 + compWeight2;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"
            ]);
            break;
          case 4:
            m = m.concat([
              "float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"
            ]);
            break;
          default:
            vc("Unsupported number of independent coordinates.");
        }
      } else switch (h) {
        case 1:
          m = m.concat([
            "// Dependent components",
            "float intensity = tvalue.r;",
            "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;",
            "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;",
            "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"
          ]);
          break;
        case 2:
          m = m.concat([
            "float intensity = tvalue.r*cscale0 + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"
          ]);
          break;
        case 3:
          m = m.concat([
            "vec4 tcolor = cscale0*tvalue + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"
          ]);
          break;
        default:
          m = m.concat([
            "vec4 tcolor = cscale0*tvalue + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"
          ]);
      }
      l = se.substitute(l, "//VTK::TCoord::Impl", m).result, r.Vertex = s, r.Fragment = l, r.Geometry = o;
    }, t.replaceShaderPositionVC = (r, i, a) => {
      let s = r.Vertex;
      const o = r.Geometry;
      let l = r.Fragment;
      const c = e.renderable.getSlabThickness();
      let f = [
        "attribute vec4 vertexWC;"
      ];
      f = f.concat([
        `//${t.getMTime()}${e.resliceGeomUpdateString}`
      ]), c > 0 && (f = f.concat([
        "attribute vec3 normalWC;",
        "varying vec3 normalWCVSOutput;",
        "varying vec4 vertexWCVSOutput;"
      ])), s = se.substitute(s, "//VTK::PositionVC::Dec", f).result;
      let u = [
        "gl_Position = MCPCMatrix * vertexWC;"
      ];
      c > 0 && (u = u.concat([
        "normalWCVSOutput = normalWC;",
        "vertexWCVSOutput = vertexWC;"
      ])), s = se.substitute(s, "//VTK::PositionVC::Impl", u).result, s = se.substitute(s, "//VTK::Camera::Dec", [
        "uniform mat4 MCPCMatrix;",
        "uniform mat4 MCVCMatrix;"
      ]).result;
      let h = [];
      c > 0 && (h = h.concat([
        "varying vec3 normalWCVSOutput;",
        "varying vec4 vertexWCVSOutput;"
      ])), l = se.substitute(l, "//VTK::PositionVC::Dec", h).result, r.Vertex = s, r.Geometry = o, r.Fragment = l;
    };
    function n(r) {
      La.normalize(r);
      const i = [
        0,
        0,
        0
      ];
      for (let a = 0; a < 3; ++a) {
        NY(i), i[a] = 1;
        const s = La.dot(r, i);
        if (s < -0.999 || s > 0.999) return [
          true,
          a
        ];
      }
      return [
        false,
        2
      ];
    }
    t.updateResliceGeometry = () => {
      var _a3;
      let r = "";
      const i = e.currentInput, a = i == null ? void 0 : i.getBounds();
      let s = true, o = 2;
      const l = e.renderable.getSlicePolyData(), c = e.renderable.getSlicePlane();
      if (l) r = r.concat(`PolyData${l.getMTime()}`);
      else if (c) {
        r = r.concat(`Plane${c.getMTime()}`), i && (r = r.concat(`Image${i.getMTime()}`));
        const f = jD(i == null ? void 0 : i.getDirection());
        td(f, f);
        const u = [
          ...c.getNormal()
        ];
        Ug(u, u, f), [s, o] = n(u);
      } else {
        const f = Si.newInstance();
        f.setNormal(0, 0, 1);
        let u = [
          0,
          1,
          0,
          1,
          0,
          1
        ];
        i && (u = a), f.setOrigin(u[0], u[2], 0.5 * (u[5] + u[4])), e.renderable.setSlicePlane(f), r = r.concat(`Plane${c == null ? void 0 : c.getMTime()}`), i && (r = r.concat(`Image${i.getMTime()}`));
      }
      if (!e.resliceGeom || e.resliceGeomUpdateString !== r) {
        if (l) e.resliceGeom || (e.resliceGeom = $i.newInstance()), e.resliceGeom.getPoints().setData(l.getPoints().getData(), 3), e.resliceGeom.getPolys().setData(l.getPolys().getData(), 1), e.resliceGeom.getPointData().setNormals(l.getPointData().getNormals());
        else if (c) if (s) {
          const f = new Float32Array(12), u = i.worldToIndex(c.getOrigin(), [
            0,
            0,
            0
          ]), h = [
            (o + 1) % 3,
            (o + 2) % 3
          ].sort(), g = i.getDimensions(), v = [
            0,
            g[0] - 1,
            0,
            g[1] - 1,
            0,
            g[2] - 1
          ];
          let m = 0;
          for (let S = 0; S < 2; ++S) for (let E = 0; E < 2; ++E) f[m + o] = u[o], f[m + h[0]] = v[2 * h[0] + E], f[m + h[1]] = v[2 * h[1] + S], m += 3;
          e.transform.setMatrix(i.getIndexToWorld()), e.transform.transformPoints(f, f);
          const y = new Uint16Array(8);
          y[0] = 3, y[1] = 0, y[2] = 1, y[3] = 3, y[4] = 3, y[5] = 0, y[6] = 3, y[7] = 2;
          const w = c.getNormal();
          La.normalize(w);
          const C = new Float32Array(12);
          for (let S = 0; S < 4; ++S) C[3 * S] = w[0], C[3 * S + 1] = w[1], C[3 * S + 2] = w[2];
          e.resliceGeom || (e.resliceGeom = $i.newInstance()), e.resliceGeom.getPoints().setData(f, 3), e.resliceGeom.getPolys().setData(y, 1);
          const T = Tt.newInstance({
            numberOfComponents: 3,
            values: C,
            name: "Normals"
          });
          e.resliceGeom.getPointData().setNormals(T);
        } else {
          e.outlineFilter.setInputData(i), e.cutter.setInputConnection(e.outlineFilter.getOutputPort()), e.cutter.setCutFunction(c), e.lineToSurfaceFilter.setInputConnection(e.cutter.getOutputPort()), e.lineToSurfaceFilter.update(), e.resliceGeom || (e.resliceGeom = $i.newInstance());
          const f = e.lineToSurfaceFilter.getOutputData();
          e.resliceGeom.getPoints().setData(f.getPoints().getData(), 3), e.resliceGeom.getPolys().setData(f.getPolys().getData(), 1), e.resliceGeom.getPointData().setNormals(f.getPointData().getNormals());
          const u = c.getNormal(), h = e.resliceGeom.getNumberOfPoints();
          La.normalize(u);
          const g = new Float32Array(h * 3);
          for (let m = 0; m < h; ++m) g[3 * m] = u[0], g[3 * m + 1] = u[1], g[3 * m + 2] = u[2];
          const v = Tt.newInstance({
            numberOfComponents: 3,
            values: g,
            name: "Normals"
          });
          e.resliceGeom.getPointData().setNormals(v);
        }
        else vc("Something went wrong.", "A default slice plane should have been created in the beginning of", "updateResliceGeometry.");
        e.resliceGeomUpdateString = r, (_a3 = e.resliceGeom) == null ? void 0 : _a3.modified();
      }
    }, t.setOpenGLTexture = (r) => {
      r && (e.openGLTexture = r, e._externalOpenGLTexture = true);
    };
  }
  const gte = {
    VBOBuildTime: {},
    VBOBuildString: null,
    haveSeenDepthRequest: false,
    lastHaveSeenDepthRequest: false,
    lastIndependentComponents: false,
    lastTextureComponents: 0,
    lastSlabThickness: 0,
    lastSlabTrapezoidIntegration: 0,
    lastSlabType: -1,
    openGLTexture: null,
    openGLTextureString: null,
    colorTextureString: null,
    pwfTextureString: null,
    resliceGeom: null,
    resliceGeomUpdateString: null,
    tris: null,
    colorTexture: null,
    pwfTexture: null,
    _externalOpenGLTexture: false,
    _scalars: null
  };
  function pte(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, gte, n), Rn.extend(t, e, n), Ls.implementReplaceShaderCoincidentOffset(t, e, n), Ls.implementBuildShadersWithReplacements(t, e, n), e.tris = Bs.newInstance(), e.openGLTexture = null, e.colorTexture = null, e.pwfTexture = null, e.VBOBuildTime = {}, _n(e.VBOBuildTime), e.tmpMat4 = gt(new Float64Array(16)), e.outlineFilter = ote.newInstance(), e.outlineFilter.setGenerateFaces(true), e.outlineFilter.setGenerateLines(false), e.cubePolyData = $i.newInstance(), e.cutter = qee.newInstance(), e.lineToSurfaceFilter = Wee.newInstance(), e.transform = ute.newInstance(), Wi(t, e, [
      "openGLTexture"
    ]), dte(t, e);
  }
  const mte = pn(pte, "vtkOpenGLImageResliceMapper");
  Er("vtkImageResliceMapper", mte);
  const yc = {
    MAX: 0,
    MIN: 1,
    AVERAGE: 2
  }, { vtkErrorMacro: z2 } = H;
  function YT(t, e, n) {
    if (e.apply(t)) {
      const i = t.getIndependentComponents();
      return `${t.getMTime()}-${i}-${n}`;
    }
    return "0";
  }
  function vte(t, e) {
    e.classHierarchy.push("vtkOpenGLImageCPRMapper"), t.buildPass = (n) => {
      n && (e.currentRenderPass = null, e.openGLImageSlice = t.getFirstAncestorOfType("vtkOpenGLImageSlice"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.context = e._openGLRenderWindow.getContext(), e.openGLCamera = e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow), e.volumeTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow));
    }, t.opaquePass = (n, r) => {
      n && (e.currentRenderPass = r, t.render());
    }, t.opaqueZBufferPass = (n) => {
      n && (e.haveSeenDepthRequest = true, e.renderDepth = true, t.render(), e.renderDepth = false);
    }, t.getCoincidentParameters = (n, r) => e.renderable.getResolveCoincidentTopology() ? e.renderable.getCoincidentTopologyPolygonOffsetParameters() : null, t.render = () => {
      const n = e.openGLImageSlice.getRenderable(), r = e._openGLRenderer.getRenderable();
      t.renderPiece(r, n);
    }, t.renderPiece = (n, r) => {
      t.invokeEvent({
        type: "StartEvent"
      }), e.renderable.update(), t.invokeEvent({
        type: "EndEvent"
      }), e.renderable.preRenderCheck() && (e.currentImageDataInput = e.renderable.getInputData(0), e.currentCenterlineInput = e.renderable.getOrientedCenterline(), t.renderPieceStart(n, r), t.renderPieceDraw(n, r), t.renderPieceFinish(n, r));
    }, t.renderPieceStart = (n, r) => {
      t.updateBufferObjects(n, r);
    }, t.renderPieceDraw = (n, r) => {
      const i = e.context;
      e.volumeTexture.activate(), e.colorTexture.activate(), e.pwfTexture.activate(), e.tris.getCABO().getElementCount() && (t.updateShaders(e.tris, n, r), i.drawArrays(i.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release()), e.volumeTexture.deactivate(), e.colorTexture.deactivate(), e.pwfTexture.deactivate();
    }, t.renderPieceFinish = (n, r) => {
    }, t.updateBufferObjects = (n, r) => {
      t.getNeedToRebuildBufferObjects(n, r) && t.buildBufferObjects(n, r);
    }, t.getNeedToRebuildBufferObjects = (n, r) => {
      const i = e.VBOBuildTime.getMTime();
      return i < t.getMTime() || i < e.renderable.getMTime() || i < r.getMTime() || i < e.currentImageDataInput.getMTime() || i < e.currentCenterlineInput.getMTime();
    }, t.buildBufferObjects = (n, r) => {
      const i = e.currentImageDataInput, a = e.currentCenterlineInput;
      r.getProperty().getInterpolationType() === Bc.NEAREST ? (e.volumeTexture.setMinificationFilter(dt.NEAREST), e.volumeTexture.setMagnificationFilter(dt.NEAREST), e.colorTexture.setMinificationFilter(dt.NEAREST), e.colorTexture.setMagnificationFilter(dt.NEAREST), e.pwfTexture.setMinificationFilter(dt.NEAREST), e.pwfTexture.setMagnificationFilter(dt.NEAREST)) : (e.volumeTexture.setMinificationFilter(dt.LINEAR), e.volumeTexture.setMagnificationFilter(dt.LINEAR), e.colorTexture.setMinificationFilter(dt.LINEAR), e.colorTexture.setMagnificationFilter(dt.LINEAR), e.pwfTexture.setMinificationFilter(dt.LINEAR), e.pwfTexture.setMagnificationFilter(dt.LINEAR));
      const o = i.getMTime();
      if (e.volumeTextureTime !== o) {
        const y = i.getDimensions(), w = i.getPointData().getScalars();
        if (!w) return;
        e.volumeTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), e.volumeTexture.releaseGraphicsResources(e._openGLRenderWindow), e.volumeTexture.resetFormatAndType(), e.volumeTexture.create3DFilterableFromRaw(y[0], y[1], y[2], w.getNumberOfComponents(), w.getDataType(), w.getData(), e.renderable.getPreferSizeOverAccuracy()), e.volumeTextureTime = o;
      }
      const l = i.getPointData() && i.getPointData().getScalars();
      if (!l) return;
      const c = l.getNumberOfComponents(), f = r.getProperty(), u = f.getIndependentComponents(), h = u ? c : 1, g = u ? 2 * h : 1, v = YT(f, f.getRGBTransferFunction, h);
      if (e.colorTextureString !== v) {
        const w = 1024 * g * 3, C = new Uint8ClampedArray(w);
        let T = f.getRGBTransferFunction();
        if (T) {
          const S = new Float32Array(3072);
          for (let E = 0; E < h; E++) {
            T = f.getRGBTransferFunction(E);
            const b = T.getRange();
            if (T.getTable(b[0], b[1], 1024, S, 1), u) for (let D = 0; D < 1024 * 3; D++) C[E * 1024 * 6 + D] = 255 * S[D], C[E * 1024 * 6 + D + 1024 * 3] = 255 * S[D];
            else for (let D = 0; D < 1024 * 3; D++) C[E * 1024 * 6 + D] = 255 * S[D];
          }
          e.colorTexture.releaseGraphicsResources(e._openGLRenderWindow), e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, g, 3, zt.UNSIGNED_CHAR, C);
        } else {
          for (let S = 0; S < 1024 * 3; ++S) C[S] = 255 * S / (1023 * 3), C[S + 1] = 255 * S / (1023 * 3), C[S + 2] = 255 * S / (1023 * 3);
          e.colorTexture.create2DFromRaw(1024, 1, 3, zt.UNSIGNED_CHAR, C);
        }
        e.colorTextureString = v;
      }
      const m = YT(f, f.getPiecewiseFunction, h);
      if (e.pwfTextureString !== m) {
        const w = 1024 * g, C = new Uint8ClampedArray(w);
        let T = f.getPiecewiseFunction();
        if (e.pwfTexture.releaseGraphicsResources(e._openGLRenderWindow), e.pwfTexture.resetFormatAndType(), T) {
          const S = new Float32Array(w), E = new Float32Array(1024);
          for (let b = 0; b < h; ++b) if (T = f.getPiecewiseFunction(b), T === null) S.fill(1);
          else {
            const D = T.getRange();
            if (T.getTable(D[0], D[1], 1024, E, 1), u) for (let R = 0; R < 1024; R++) S[b * 1024 * 2 + R] = E[R], S[b * 1024 * 2 + R + 1024] = E[R];
            else for (let R = 0; R < 1024; R++) S[b * 1024 * 2 + R] = E[R];
          }
          e.pwfTexture.create2DFromRaw(1024, g, 1, zt.FLOAT, S);
        } else C.fill(255), e.pwfTexture.create2DFromRaw(1024, 1, 1, zt.UNSIGNED_CHAR, C);
        e.pwfTextureString = m;
      }
      if (e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < a.getMTime()) {
        const y = a.getNumberOfPoints(), w = y <= 1 ? 0 : y - 1, C = a.getDistancesToFirstPoint(), T = e.renderable.getHeight(), S = 4 * w, E = new Float32Array(3 * S), b = e.renderable.getWidth();
        for (let Z = 0, j = 0; Z < w; ++Z) E.set([
          0,
          T - C[Z],
          0
        ], j), j += 3, E.set([
          b,
          T - C[Z],
          0
        ], j), j += 3, E.set([
          b,
          T - C[Z + 1],
          0
        ], j), j += 3, E.set([
          0,
          T - C[Z + 1],
          0
        ], j), j += 3;
        const D = Tt.newInstance({
          numberOfComponents: 3,
          values: E
        });
        D.setName("points");
        const R = new Uint16Array(5 * w);
        for (let Z = 0, j = 0, B = 0; Z < w; ++Z) R.set([
          4,
          B + 3,
          B + 2,
          B + 1,
          B
        ], j), j += 5, B += 4;
        const I = Tt.newInstance({
          numberOfComponents: 1,
          values: R
        }), O = a.getPoints(), L = new Float32Array(3 * S), N = new Array(3), F = new Array(3);
        for (let Z = 0, j = 0; Z < w; ++Z) O.getPoint(Z, N), O.getPoint(Z + 1, F), L.set(N, j), j += 3, L.set(N, j), j += 3, L.set(F, j), j += 3, L.set(F, j), j += 3;
        const V = Tt.newInstance({
          numberOfComponents: 3,
          values: L,
          name: "centerlinePosition"
        }), k = new Float32Array(S);
        for (let Z = 0, j = 0; Z < w; ++Z) k.set([
          0,
          1,
          3,
          2
        ], j), j += 4;
        const _ = Tt.newInstance({
          numberOfComponents: 1,
          values: k,
          name: "quadIndex"
        }), K = [
          V,
          _
        ];
        if (!e.renderable.getUseUniformOrientation()) {
          const Z = e.renderable.getOrientedCenterline().getOrientations() ?? [], j = new Float32Array(4 * S), B = new Float32Array(4 * S);
          for (let ie = 0; ie < w; ++ie) {
            const oe = Z[ie], he = Z[ie + 1];
            for (let Le = 0; Le < 4; ++Le) {
              const Pe = 4 * (Le + 4 * ie);
              j.set(oe, Pe), B.set(he, Pe);
            }
          }
          const Y = Tt.newInstance({
            numberOfComponents: 4,
            values: j,
            name: "centerlineTopOrientation"
          }), X = Tt.newInstance({
            numberOfComponents: 4,
            values: B,
            name: "centerlineBotOrientation"
          });
          K.push(Y, X);
        }
        e.tris.getCABO().createVBO(I, "polys", fi.SURFACE, {
          points: D,
          customAttributes: K
        }), e.VBOBuildTime.modified();
      }
    }, t.getNeedToRebuildShaders = (n, r, i) => {
      const a = e.volumeTexture.getComponents(), s = i.getProperty().getIndependentComponents(), o = !!e.renderable.getCenterPoint(), l = e.renderable.getUseUniformOrientation(), c = e.renderable.isProjectionEnabled() && e.renderable.getProjectionMode();
      return n.getProgram() === 0 || e.lastUseCenterPoint !== o || e.lastUseUniformOrientation !== l || e.lastProjectionMode !== c || e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || e.lastTextureComponents !== a || e.lastIndependentComponents !== s ? (e.lastUseCenterPoint = o, e.lastUseUniformOrientation = l, e.lastProjectionMode = c, e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, e.lastTextureComponents = a, e.lastIndependentComponents = s, true) : false;
    }, t.buildShaders = (n, r, i) => {
      t.getShaderTemplate(n, r, i), t.replaceShaderValues(n, r, i);
    }, t.replaceShaderValues = (n, r, i) => {
      let a = n.Vertex, s = n.Fragment;
      const o = [
        "vec3 applyQuaternionToVec(vec4 q, vec3 v) {",
        "  float uvx = q.y * v.z - q.z * v.y;",
        "  float uvy = q.z * v.x - q.x * v.z;",
        "  float uvz = q.x * v.y - q.y * v.x;",
        "  float uuvx = q.y * uvz - q.z * uvy;",
        "  float uuvy = q.z * uvx - q.x * uvz;",
        "  float uuvz = q.x * uvy - q.y * uvx;",
        "  float w2 = q.w * 2.0;",
        "  uvx *= w2;",
        "  uvy *= w2;",
        "  uvz *= w2;",
        "  uuvx *= 2.0;",
        "  uuvy *= 2.0;",
        "  uuvz *= 2.0;",
        "  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);",
        "}"
      ];
      a = se.substitute(a, "//VTK::Camera::Dec", [
        "uniform mat4 MCPCMatrix;"
      ]).result, a = se.substitute(a, "//VTK::PositionVC::Impl", [
        "  gl_Position = MCPCMatrix * vertexMC;"
      ]).result;
      const l = [
        "attribute vec3 centerlinePosition;",
        "attribute float quadIndex;",
        "uniform float width;",
        "out vec2 quadOffsetVSOutput;",
        "out vec3 centerlinePosVSOutput;"
      ], c = e.renderable.isProjectionEnabled(), f = e.renderable.getUseUniformOrientation();
      f ? (l.push("out vec3 samplingDirVSOutput;", "uniform vec4 centerlineOrientation;", "uniform vec3 tangentDirection;", ...o), c && l.push("out vec3 projectionDirVSOutput;", "uniform vec3 bitangentDirection;")) : l.push("out vec4 centerlineTopOrientationVSOutput;", "out vec4 centerlineBotOrientationVSOutput;", "attribute vec4 centerlineTopOrientation;", "attribute vec4 centerlineBotOrientation;"), a = se.substitute(a, "//VTK::Color::Dec", l).result;
      const u = [
        "quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);",
        "centerlinePosVSOutput = centerlinePosition;"
      ];
      f ? (u.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"), c && u.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")) : u.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;", "centerlineBotOrientationVSOutput = centerlineBotOrientation;"), a = se.substitute(a, "//VTK::Color::Impl", u).result;
      const h = e.volumeTexture.getComponents(), g = i.getProperty().getIndependentComponents();
      let v = [
        "uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates",
        "in vec2 quadOffsetVSOutput;",
        "in vec3 centerlinePosVSOutput;",
        "uniform highp sampler3D volumeTexture;",
        "uniform sampler2D colorTexture1;",
        "uniform sampler2D pwfTexture1;",
        "uniform float opacity;",
        "uniform vec4 backgroundColor;",
        "uniform float cshift0;",
        "uniform float cscale0;",
        "uniform float pwfshift0;",
        "uniform float pwfscale0;"
      ];
      c && v.push("uniform vec3 volumeSizeMC;", "uniform int projectionSlabNumberOfSamples;", "uniform float projectionConstantOffset;", "uniform float projectionStepLength;"), f ? (v.push("in vec3 samplingDirVSOutput;"), c && v.push("in vec3 projectionDirVSOutput;")) : (v.push("uniform vec3 tangentDirection;", "in vec4 centerlineTopOrientationVSOutput;", "in vec4 centerlineBotOrientationVSOutput;", ...o), c && v.push("uniform vec3 bitangentDirection;"));
      const m = e.renderable.getCenterPoint();
      if (m && v.push("uniform vec3 globalCenterPoint;"), g) {
        for (let w = 1; w < h; w++) v = v.concat([
          `uniform float cshift${w};`,
          `uniform float cscale${w};`,
          `uniform float pwfshift${w};`,
          `uniform float pwfscale${w};`
        ]);
        switch (h) {
          case 1:
            v = v.concat([
              "uniform float mix0;",
              "#define height0 0.5"
            ]);
            break;
          case 2:
            v = v.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "#define height0 0.25",
              "#define height1 0.75"
            ]);
            break;
          case 3:
            v = v.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "uniform float mix2;",
              "#define height0 0.17",
              "#define height1 0.5",
              "#define height2 0.83"
            ]);
            break;
          case 4:
            v = v.concat([
              "uniform float mix0;",
              "uniform float mix1;",
              "uniform float mix2;",
              "uniform float mix3;",
              "#define height0 0.125",
              "#define height1 0.375",
              "#define height2 0.625",
              "#define height3 0.875"
            ]);
            break;
          default:
            z2("Unsupported number of independent coordinates.");
        }
      }
      s = se.substitute(s, "//VTK::TCoord::Dec", v).result;
      let y = [];
      if (f ? (y.push("vec3 samplingDirection = samplingDirVSOutput;"), c && y.push("vec3 projectionDirection = projectionDirVSOutput;")) : (y.push("vec4 q0 = centerlineBotOrientationVSOutput;", "vec4 q1 = centerlineTopOrientationVSOutput;", "float qCosAngle = dot(q0, q1);", "vec4 interpolatedOrientation;", "if (qCosAngle > 0.999 || qCosAngle < -0.999) {", "  // Use LERP instead of SLERP when the two quaternions are close or opposite", "  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));", "} else {", "  float omega = acos(qCosAngle);", "  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);", "}", "vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"), c && y.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")), m ? y.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);", "float horizontalOffset = quadOffsetVSOutput.x + baseOffset;") : y.push("float horizontalOffset = quadOffsetVSOutput.x;"), y.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;", "vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;", "if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))", "{", "  // set the background color and exit", "  gl_FragData[0] = backgroundColor;", "  return;", "}"), c) {
        const w = e.renderable.getProjectionMode();
        switch (w) {
          case yc.MIN:
            y.push("const vec4 initialProjectionTextureValue = vec4(1.0);");
            break;
          case yc.MAX:
          case yc.AVERAGE:
          default:
            y.push("const vec4 initialProjectionTextureValue = vec4(0.0);");
            break;
        }
        switch (y.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;", "vec3 projectionStep = projectionStepLength * projectionScaledDirection;", "vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;", "vec4 tvalue = initialProjectionTextureValue;", "for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {", "  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;", "  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"), w) {
          case yc.MAX:
            y.push("  tvalue = max(tvalue, sampledTextureValue);");
            break;
          case yc.MIN:
            y.push("  tvalue = min(tvalue, sampledTextureValue);");
            break;
          case yc.AVERAGE:
          default:
            y.push("  tvalue = tvalue + sampledTextureValue;");
            break;
        }
        y.push("}"), w === yc.AVERAGE && y.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);");
      } else y.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");
      if (g) {
        const w = [
          "r",
          "g",
          "b",
          "a"
        ];
        for (let C = 0; C < h; ++C) y = y.concat([
          `vec3 tcolor${C} = mix${C} * texture2D(colorTexture1, vec2(tvalue.${w[C]} * cscale${C} + cshift${C}, height${C})).rgb;`,
          `float compWeight${C} = mix${C} * texture2D(pwfTexture1, vec2(tvalue.${w[C]} * pwfscale${C} + pwfshift${C}, height${C})).r;`
        ]);
        switch (h) {
          case 1:
            y = y.concat([
              "gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"
            ]);
            break;
          case 2:
            y = y.concat([
              "float weightSum = compWeight0 + compWeight1;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"
            ]);
            break;
          case 3:
            y = y.concat([
              "float weightSum = compWeight0 + compWeight1 + compWeight2;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"
            ]);
            break;
          case 4:
            y = y.concat([
              "float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;",
              "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"
            ]);
            break;
          default:
            z2("Unsupported number of independent coordinates.");
        }
      } else switch (h) {
        case 1:
          y = y.concat([
            "// Dependent components",
            "float intensity = tvalue.r;",
            "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;",
            "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;",
            "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"
          ]);
          break;
        case 2:
          y = y.concat([
            "float intensity = tvalue.r*cscale0 + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"
          ]);
          break;
        case 3:
          y = y.concat([
            "vec4 tcolor = cscale0*tvalue + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"
          ]);
          break;
        default:
          y = y.concat([
            "vec4 tcolor = cscale0*tvalue + cshift0;",
            "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
            "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"
          ]);
      }
      s = se.substitute(s, "//VTK::TCoord::Impl", y).result, e.haveSeenDepthRequest && (s = se.substitute(s, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, s = se.substitute(s, "//VTK::ZBuffer::Impl", [
        "if (depthRequest == 1) {",
        "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
        "float rf = floor(iz/256.0)/255.0;",
        "float gf = mod(iz,256.0)/255.0;",
        "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
      ]).result), n.Vertex = a, n.Fragment = s, t.replaceShaderClip(n, r, i), t.replaceShaderCoincidentOffset(n, r, i);
    }, t.replaceShaderClip = (n, r, i) => {
      let a = n.Vertex, s = n.Fragment;
      if (e.renderable.getNumberOfClippingPlanes()) {
        let o = e.renderable.getNumberOfClippingPlanes();
        o > 6 && (H.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"), o = 6), a = se.substitute(a, "//VTK::Clip::Dec", [
          "uniform int numClipPlanes;",
          "uniform vec4 clipPlanes[6];",
          "varying float clipDistancesVSOutput[6];"
        ]).result, a = se.substitute(a, "//VTK::Clip::Impl", [
          "for (int planeNum = 0; planeNum < 6; planeNum++)",
          "    {",
          "    if (planeNum >= numClipPlanes)",
          "        {",
          "        break;",
          "        }",
          "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);",
          "    }"
        ]).result, s = se.substitute(s, "//VTK::Clip::Dec", [
          "uniform int numClipPlanes;",
          "varying float clipDistancesVSOutput[6];"
        ]).result, s = se.substitute(s, "//VTK::Clip::Impl", [
          "for (int planeNum = 0; planeNum < 6; planeNum++)",
          "    {",
          "    if (planeNum >= numClipPlanes)",
          "        {",
          "        break;",
          "        }",
          "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;",
          "    }"
        ]).result;
      }
      n.Vertex = a, n.Fragment = s;
    }, t.getShaderTemplate = (n, r, i) => {
      n.Vertex = ry, n.Fragment = rd, n.Geometry = "";
    }, t.setMapperShaderParameters = (n, r, i) => {
      const a = n.getProgram(), s = n.getCABO();
      s.getElementCount() && (e.VBOBuildTime.getMTime() > n.getAttributeUpdateTime().getMTime() || n.getShaderSourceTime().getMTime() > n.getAttributeUpdateTime().getMTime()) && (a.isAttributeUsed("vertexMC") && (n.getVAO().addAttributeArray(a, s, "vertexMC", s.getVertexOffset(), s.getStride(), e.context.FLOAT, 3, e.context.FALSE) || z2("Error setting vertexMC in shader VAO.")), n.getCABO().getCustomData().forEach((h) => {
        h && a.isAttributeUsed(h.name) && !n.getVAO().addAttributeArray(a, s, h.name, h.offset, s.getStride(), e.context.FLOAT, h.components, e.context.FALSE) && z2(`Error setting ${h.name} in shader VAO.`);
      }), n.getAttributeUpdateTime().modified());
      const o = e.volumeTexture.getTextureUnit();
      if (a.setUniformi("volumeTexture", o), a.setUniformf("width", e.renderable.getWidth()), n.getProgram().setUniform4fv("backgroundColor", e.renderable.getBackgroundColor()), a.isUniformUsed("tangentDirection")) {
        const h = e.renderable.getTangentDirection();
        n.getProgram().setUniform3fArray("tangentDirection", h);
      }
      if (a.isUniformUsed("bitangentDirection")) {
        const h = e.renderable.getBitangentDirection();
        n.getProgram().setUniform3fArray("bitangentDirection", h);
      }
      if (a.isUniformUsed("centerlineOrientation")) {
        const h = e.renderable.getUniformOrientation();
        n.getProgram().setUniform4fv("centerlineOrientation", h);
      }
      if (a.isUniformUsed("globalCenterPoint")) {
        const h = e.renderable.getCenterPoint();
        a.setUniform3fArray("globalCenterPoint", h);
      }
      if (e.renderable.isProjectionEnabled()) {
        const h = e.currentImageDataInput, g = h.getSpacing(), v = h.getDimensions(), m = e.renderable.getProjectionSlabThickness(), y = e.renderable.getProjectionSlabNumberOfSamples(), w = LY([], g, v);
        a.setUniform3fArray("volumeSizeMC", w), a.setUniformi("projectionSlabNumberOfSamples", y);
        const C = -0.5 * m;
        a.setUniformf("projectionConstantOffset", C);
        const T = m / (y - 1);
        a.setUniformf("projectionStepLength", T);
      }
      const l = e.currentImageDataInput, c = l.getWorldToIndex(), f = k8(new Float32Array(16), rM([], l.getDimensions())), u = vp(f, f, c);
      if (a.setUniformMatrix("MCTCMatrix", u), e.haveSeenDepthRequest && n.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), e.renderable.getNumberOfClippingPlanes()) {
        let h = e.renderable.getNumberOfClippingPlanes();
        h > 6 && (H.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"), h = 6);
        const v = s.getCoordShiftAndScaleEnabled() ? s.getInverseShiftAndScaleMatrix() : null, m = v ? sr(e.imagematinv, i.getMatrix()) : i.getMatrix();
        v && (en(m, m), tn(m, m, v), en(m, m)), en(e.imagemat, e.currentImageDataInput.getIndexToWorld()), tn(e.imagematinv, m, e.imagemat);
        const y = [];
        for (let w = 0; w < h; w++) {
          const C = [];
          e.renderable.getClippingPlaneInDataCoords(e.imagematinv, w, C);
          for (let T = 0; T < 4; T++) y.push(C[T]);
        }
        a.setUniformi("numClipPlanes", h), a.setUniform4fv("clipPlanes", y);
      }
      if (a.isUniformUsed("coffset")) {
        const h = t.getCoincidentParameters(r, i);
        a.setUniformf("coffset", h.offset), a.isUniformUsed("cfactor") && a.setUniformf("cfactor", h.factor);
      }
    }, t.setCameraShaderParameters = (n, r, i) => {
      const a = e.openGLImageSlice.getKeyMatrices().mcwc, s = e.openGLCamera.getKeyMatrices(r).wcpc;
      if (tn(e.imagemat, s, a), n.getCABO().getCoordShiftAndScaleEnabled()) {
        const o = n.getCABO().getInverseShiftAndScaleMatrix();
        tn(e.imagemat, e.imagemat, o);
      }
      n.getProgram().setUniformMatrix("MCPCMatrix", e.imagemat);
    }, t.setPropertyShaderParameters = (n, r, i) => {
      const a = n.getProgram(), s = i.getProperty(), o = s.getOpacity();
      a.setUniformf("opacity", o);
      const l = e.volumeTexture.getComponents(), c = s.getIndependentComponents();
      if (c) for (let g = 0; g < l; ++g) a.setUniformf(`mix${g}`, s.getComponentWeight(g));
      const f = e.volumeTexture.getVolumeInfo();
      for (let g = 0; g < l; g++) {
        let v = s.getColorWindow(), m = s.getColorLevel();
        const y = c ? g : 0, w = s.getRGBTransferFunction(y);
        if (w && s.getUseLookupTableScalarRange()) {
          const S = w.getRange();
          v = S[1] - S[0], m = 0.5 * (S[1] + S[0]);
        }
        const C = f.scale[g] / v, T = (f.offset[g] - m) / v + 0.5;
        a.setUniformf(`cshift${g}`, T), a.setUniformf(`cscale${g}`, C);
      }
      const u = e.colorTexture.getTextureUnit();
      a.setUniformi("colorTexture1", u);
      for (let g = 0; g < l; g++) {
        let v = 1, m = 0;
        const y = c ? g : 0, w = s.getPiecewiseFunction(y);
        if (w) {
          const C = w.getRange(), T = C[1] - C[0], S = 0.5 * (C[0] + C[1]);
          v = f.scale[g] / T, m = (f.offset[g] - S) / T + 0.5;
        }
        a.setUniformf(`pwfshift${g}`, m), a.setUniformf(`pwfscale${g}`, v);
      }
      const h = e.pwfTexture.getTextureUnit();
      a.setUniformi("pwfTexture1", h);
    }, t.updateShaders = (n, r, i) => {
      if (t.getNeedToRebuildShaders(n, r, i)) {
        const a = {
          Vertex: null,
          Fragment: null,
          Geometry: null
        };
        t.buildShaders(a, r, i);
        const s = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex, a.Fragment, a.Geometry);
        s !== n.getProgram() && (n.setProgram(s), n.getVAO().releaseGraphicsResources()), n.getShaderSourceTime().modified();
      } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());
      n.getVAO().bind(), t.setMapperShaderParameters(n, r, i), t.setCameraShaderParameters(n, r, i), t.setPropertyShaderParameters(n, r, i);
    };
  }
  const yte = {
    currentRenderPass: null,
    volumeTexture: null,
    volumeTextureTime: 0,
    colorTexture: null,
    colorTextureString: null,
    pwfTexture: null,
    pwfTextureString: null,
    tris: null,
    lastHaveSeenDepthRequest: false,
    haveSeenDepthRequest: false,
    lastTextureComponents: 0,
    lastIndependentComponents: 0,
    imagemat: null,
    imagematinv: null
  };
  function xte(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, yte, n), Rn.extend(t, e, n), Ls.implementReplaceShaderCoincidentOffset(t, e, n), H.algo(t, e, 2, 0), e.tris = Bs.newInstance(), e.volumeTexture = er.newInstance(), e.colorTexture = er.newInstance(), e.pwfTexture = er.newInstance(), e.imagemat = gt(new Float64Array(16)), e.imagematinv = gt(new Float64Array(16)), e.VBOBuildTime = {}, H.obj(e.VBOBuildTime, {
      mtime: 0
    }), vte(t, e);
  }
  const wte = H.newInstance(xte, "vtkOpenGLImageCPRMapper");
  Er("vtkImageCPRMapper", wte);
  const IO = /* @__PURE__ */ Object.create(null);
  function ka(t, e) {
    IO[t] = e;
  }
  function Cte(t, e) {
    e.classHierarchy.push("vtkWebGPUViewNodeFactory");
  }
  const Tte = {};
  function Ste(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Tte, n), e.overrides = IO, X8.extend(t, e, n), Cte(t, e);
  }
  H.newInstance(Ste, "vtkWebGPUViewNodeFactory");
  function Ate(t, e) {
    e.classHierarchy.push("vtkWebGPUCamera"), t.getProjectionMatrix = (n, r, i, a) => {
      if (gt(n), e.renderable.getParallelProjection()) {
        const s = e.renderable.getParallelScale(), o = s * r, l = s, c = (a[0] - 1) * o, f = (a[0] + 1) * o, u = (a[1] - 1) * l, h = (a[1] + 1) * l, g = 1 / (f - c), v = 1 / (h - u);
        n[0] = 2 * g, n[5] = 2 * v, n[10] = 1 / (i[1] - i[0]), n[12] = (f + c) * g, n[13] = (h + u) * v, n[14] = i[1] / (i[1] - i[0]);
      } else {
        const s = Math.tan(Math.PI * e.renderable.getViewAngle() / 360);
        let o, l;
        e.renderable.getUseHorizontalViewAngle() === true ? (o = i[0] * s, l = i[0] * s / r) : (o = i[0] * s * r, l = i[0] * s);
        const c = (a[0] - 1) * o, f = (a[0] + 1) * o, u = (a[1] - 1) * l, h = (a[1] + 1) * l;
        n[0] = 2 * i[0] / (f - c), n[5] = 2 * i[0] / (h - u), n[12] = (c + f) / (f - c), n[13] = (u + h) / (h - u), n[10] = 0, n[14] = i[0], n[11] = -1, n[15] = 0;
      }
    }, t.convertToOpenGLDepth = (n) => {
      if (e.renderable.getParallelProjection()) return 1 - n;
      const r = e.renderable.getClippingRangeByReference();
      let i = -r[0] / n;
      return i = (r[0] + r[1]) / (r[1] - r[0]) + 2 * r[0] * r[1] / (i * (r[1] - r[0])), 0.5 * i + 0.5;
    }, t.getKeyMatrices = (n) => {
      const r = n.getRenderable(), i = n.getParent();
      if (Math.max(i.getMTime(), t.getMTime(), r.getMTime(), e.renderable.getMTime(), n.getStabilizedTime()) > e.keyMatrixTime.getMTime()) {
        const a = e.renderable.getViewMatrix();
        sr(e.keyMatrices.normalMatrix, a), e.keyMatrices.normalMatrix[3] = 0, e.keyMatrices.normalMatrix[7] = 0, e.keyMatrices.normalMatrix[11] = 0, Nr(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), en(e.keyMatrices.wcvc, a);
        const s = n.getStabilizedCenterByReference();
        $n(e.keyMatrices.scvc, e.keyMatrices.wcvc, s);
        const o = n.getAspectRatio(), l = e.renderable.getClippingRangeByReference();
        t.getProjectionMatrix(e.keyMatrices.vcpc, o, l, e.renderable.getWindowCenterByReference()), tn(e.keyMatrices.scpc, e.keyMatrices.vcpc, e.keyMatrices.scvc), Nr(e.keyMatrices.pcsc, e.keyMatrices.scpc), e.keyMatrixTime.modified();
      }
      return e.keyMatrices;
    };
  }
  const Ete = {
    keyMatrixTime: null,
    keyMatrices: null
  };
  function bte(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Ete, n), Rn.extend(t, e, n), e.keyMatrixTime = {}, H.obj(e.keyMatrixTime), e.keyMatrices = {
      normalMatrix: new Float64Array(16),
      vcpc: new Float64Array(16),
      pcsc: new Float64Array(16),
      wcvc: new Float64Array(16),
      scpc: new Float64Array(16),
      scvc: new Float64Array(16)
    }, H.setGet(t, e, [
      "keyMatrixTime"
    ]), Ate(t, e);
  }
  const Dte = H.newInstance(bte);
  ka("vtkCamera", Dte);
  function Mte(t, e) {
    e.classHierarchy.push("vtkWebGPUBindGroup"), t.setBindables = (n) => {
      if (e.bindables.length === n.length) {
        let r = true;
        for (let i = 0; i < e.bindables.length; i++) e.bindables[i] !== n[i] && (r = false);
        if (r) return;
      }
      e.bindables = n, t.modified();
    }, t.getBindGroupLayout = (n) => {
      const r = [];
      for (let i = 0; i < e.bindables.length; i++) {
        const a = e.bindables[i].getBindGroupLayoutEntry();
        a.binding = i, r.push(a);
      }
      return n.getBindGroupLayout({
        entries: r
      });
    }, t.getBindGroup = (n) => {
      let r = t.getMTime();
      for (let a = 0; a < e.bindables.length; a++) {
        const s = e.bindables[a].getBindGroupTime().getMTime();
        r = s > r ? s : r;
      }
      if (r < e.bindGroupTime.getMTime()) return e.bindGroup;
      const i = [];
      for (let a = 0; a < e.bindables.length; a++) {
        const s = e.bindables[a].getBindGroupEntry();
        s.binding = a, i.push(s);
      }
      return e.bindGroup = n.getHandle().createBindGroup({
        layout: t.getBindGroupLayout(n),
        entries: i,
        label: e.label
      }), e.bindGroupTime.modified(), e.bindGroup;
    }, t.getShaderCode = (n) => {
      const r = [], i = n.getBindGroupLayoutCount(e.label);
      for (let a = 0; a < e.bindables.length; a++) r.push(e.bindables[a].getShaderCode(a, i));
      return r.join(`
`);
    };
  }
  const Rte = {
    device: null,
    handle: null,
    label: null
  };
  function VO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Rte, n), H.obj(t, e), e.bindables = [], e.bindGroupTime = {}, H.obj(e.bindGroupTime, {
      mtime: 0
    }), H.get(t, e, [
      "bindGroupTime",
      "handle",
      "sizeInBytes",
      "usage"
    ]), H.setGet(t, e, [
      "label",
      "device",
      "arrayInformation"
    ]), Mte(t, e);
  }
  const Ote = H.newInstance(VO);
  var NO = {
    newInstance: Ote,
    extend: VO
  };
  function Ite(t, e) {
    e.classHierarchy.push("vtkWebGPUShaderModule"), t.initialize = (n, r) => {
      e.device = n, e.handle = e.device.getHandle().createShaderModule({
        code: r.getCode()
      });
    };
  }
  const Vte = {
    device: null,
    handle: null
  };
  function LO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Vte, n), H.obj(t, e), H.get(t, e, [
      "lastCameraMTime"
    ]), H.setGet(t, e, [
      "device",
      "handle"
    ]), Ite(t, e);
  }
  const Nte = H.newInstance(LO, "vtkWebGPUShaderModule");
  var Lte = {
    newInstance: Nte,
    extend: LO
  };
  function Ute(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    const i = Array.isArray(n) ? n.join(`
`) : n;
    let a = false;
    t.search(e) !== -1 && (a = true);
    let s = "";
    r && (s = "g");
    const o = new RegExp(e, s), l = t.replace(o, i);
    return {
      replace: a,
      result: l
    };
  }
  function Fte(t, e) {
    e.classHierarchy.push("vtkWebGPUShaderCache"), t.getShaderModule = (n) => {
      const r = n.getType(), i = n.getHash(), a = e._shaderModules.keys();
      for (let o = 0; o < a.length; o++) {
        const l = a[o];
        if (l.getHash() === i && l.getType() === r) return e._shaderModules.get(l);
      }
      const s = Lte.newInstance();
      return s.initialize(e.device, n), e._shaderModules.set(n, s), s;
    };
  }
  const Bte = {
    shaderModules: null,
    device: null,
    window: null
  };
  function UO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Bte, n), e._shaderModules = /* @__PURE__ */ new Map(), H.obj(t, e), H.setGet(t, e, [
      "device",
      "window"
    ]), Fte(t, e);
  }
  const _te = H.newInstance(UO, "vtkWebGPUShaderCache");
  var Dn = {
    newInstance: _te,
    extend: UO,
    substitute: Ute
  };
  function kte(t, e) {
    e.classHierarchy.push("vtkWebGPUPipeline"), t.getShaderDescriptions = () => e.shaderDescriptions, t.initialize = (n, r) => {
      e.pipelineDescription = e.renderEncoder.getPipelineSettings(), e.pipelineDescription.primitive.topology = e.topology, e.pipelineDescription.vertex = e.vertexState, e.pipelineDescription.label = r;
      const i = [];
      for (let a = 0; a < e.layouts.length; a++) i.push(e.layouts[a].layout);
      e.pipelineLayout = n.getHandle().createPipelineLayout({
        bindGroupLayouts: i
      }), e.pipelineDescription.layout = e.pipelineLayout;
      for (let a = 0; a < e.shaderDescriptions.length; a++) {
        const s = e.shaderDescriptions[a], o = n.getShaderModule(s);
        s.getType() === "vertex" && (e.pipelineDescription.vertex.module = o.getHandle(), e.pipelineDescription.vertex.entryPoint = "main"), s.getType() === "fragment" && (e.pipelineDescription.fragment.module = o.getHandle(), e.pipelineDescription.fragment.entryPoint = "main");
      }
      e.handle = n.getHandle().createRenderPipeline(e.pipelineDescription);
    }, t.getShaderDescription = (n) => {
      for (let r = 0; r < e.shaderDescriptions.length; r++) if (e.shaderDescriptions[r].getType() === n) return e.shaderDescriptions[r];
      return null;
    }, t.addBindGroupLayout = (n) => {
      n && e.layouts.push({
        layout: n.getBindGroupLayout(e.device),
        label: n.getLabel()
      });
    }, t.getBindGroupLayout = (n) => e.layouts[n].layout, t.getBindGroupLayoutCount = (n) => {
      for (let r = 0; r < e.layouts.length; r++) if (e.layouts[r].label === n) return r;
      return 0;
    }, t.bindVertexInput = (n, r) => {
      r.bindBuffers(n);
    };
  }
  const Pte = {
    handle: null,
    layouts: null,
    renderEncoder: null,
    shaderDescriptions: null,
    vertexState: null,
    topology: null,
    pipelineDescription: null
  };
  function FO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Pte, n), _n(t, e), e.layouts = [], e.shaderDescriptions = [], Wi(t, e, [
      "handle",
      "pipelineDescription"
    ]), pr(t, e, [
      "device",
      "renderEncoder",
      "topology",
      "vertexState"
    ]), kte(t, e);
  }
  const Gte = pn(FO, "vtkWebGPUPipeline");
  var zte = {
    newInstance: Gte,
    extend: FO
  };
  function Wte(t, e) {
    e.classHierarchy.push("vtkWebGPUShaderDescription"), t.hasOutput = (n) => e.outputNames.includes(n), t.addOutput = function(n, r) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      e.outputTypes.push(n), e.outputNames.push(r), e.outputInterpolations.push(i);
    }, t.addBuiltinOutput = (n, r) => {
      e.builtinOutputTypes.push(n), e.builtinOutputNames.push(r);
    }, t.addBuiltinInput = (n, r) => {
      e.builtinInputTypes.push(n), e.builtinInputNames.push(r);
    }, t.replaceShaderCode = (n, r) => {
      const i = [];
      let a = [];
      if (r && i.push(r.getShaderCode()), n || e.builtinInputNames.length) {
        const s = [];
        if (s.push(`struct ${e.type}Input
{`), n) {
          const o = n.getOutputNamesByReference(), l = n.getOutputTypesByReference(), c = n.getOutputInterpolationsByReference();
          for (let f = 0; f < o.length; f++) c[f] !== void 0 ? s.push(`  @location(${f}) @interpolate(${c[f]}) ${o[f]} : ${l[f]},`) : s.push(`  @location(${f}) ${o[f]} : ${l[f]},`);
        }
        for (let o = 0; o < e.builtinInputNames.length; o++) s.push(`  ${e.builtinInputNames[o]} : ${e.builtinInputTypes[o]},`);
        s.length > 1 && (s.push("};"), a = s, i[i.length - 1] += ",", i.push(`input: ${e.type}Input`));
      }
      if (i.length && (e.code = Dn.substitute(e.code, "//VTK::IOStructs::Input", i).result), e.outputNames.length + e.builtinOutputNames.length) {
        const s = [
          `struct ${e.type}Output
{`
        ];
        for (let o = 0; o < e.outputNames.length; o++) e.outputInterpolations[o] !== void 0 ? s.push(`  @location(${o}) @interpolate(${e.outputInterpolations[o]}) ${e.outputNames[o]} : ${e.outputTypes[o]},`) : s.push(`  @location(${o}) ${e.outputNames[o]} : ${e.outputTypes[o]},`);
        for (let o = 0; o < e.builtinOutputNames.length; o++) s.push(`  ${e.builtinOutputNames[o]} : ${e.builtinOutputTypes[o]},`);
        s.push("};"), a = a.concat(s), e.code = Dn.substitute(e.code, "//VTK::IOStructs::Output", [
          `-> ${e.type}Output`
        ]).result;
      }
      e.code = Dn.substitute(e.code, "//VTK::IOStructs::Dec", a).result;
    };
  }
  const Hte = {
    type: null,
    hash: null,
    code: null,
    outputNames: null,
    outputTypes: null
  };
  function BO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Hte, n), e.outputNames = [], e.outputTypes = [], e.outputInterpolations = [], e.builtinOutputNames = [], e.builtinOutputTypes = [], e.builtinInputNames = [], e.builtinInputTypes = [], H.obj(t, e), H.setGet(t, e, [
      "type",
      "hash",
      "code"
    ]), H.getArray(t, e, [
      "outputTypes",
      "outputNames",
      "outputInterpolations"
    ]), Wte(t, e);
  }
  const jte = H.newInstance(BO, "vtkWebGPUShaderDescription");
  var qT = {
    newInstance: jte,
    extend: BO
  };
  const XT = {
    r8unorm: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "float"
    },
    r8snorm: {
      numComponents: 1,
      nativeType: Int8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "float"
    },
    r8uint: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "uint"
    },
    r8sint: {
      numComponents: 1,
      nativeType: Int8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "sint"
    },
    r16uint: {
      numComponents: 1,
      nativeType: Uint16Array,
      stride: 2,
      elementSize: 2,
      sampleType: "uint"
    },
    r16sint: {
      numComponents: 1,
      nativeType: Int16Array,
      stride: 2,
      elementSize: 2,
      sampleType: "sint"
    },
    r16float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 2,
      elementSize: 2,
      sampleType: "float"
    },
    rg8unorm: {
      numComponents: 2,
      nativeType: Uint8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "float"
    },
    rg8snorm: {
      numComponents: 2,
      nativeType: Int8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "float"
    },
    rg8uint: {
      numComponents: 2,
      nativeType: Uint8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "uint"
    },
    rg8sint: {
      numComponents: 2,
      nativeType: Int8Array,
      stride: 2,
      elementSize: 1,
      sampleType: "sint"
    },
    r32uint: {
      numComponents: 1,
      nativeType: Uint32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "uint"
    },
    r32sint: {
      numComponents: 1,
      nativeType: Int32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "sint"
    },
    r32float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "unfilterable-float"
    },
    rg16uint: {
      numComponents: 2,
      nativeType: Uint16Array,
      stride: 4,
      elementSize: 2,
      sampleType: "uint"
    },
    rg16sint: {
      numComponents: 2,
      nativeType: Int16Array,
      stride: 4,
      elementSize: 2,
      sampleType: "sint"
    },
    rg16float: {
      numComponents: 2,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 2,
      sampleType: "float"
    },
    rgba8unorm: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    "rgba8unorm-srgb": {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    rgba8snorm: {
      numComponents: 4,
      nativeType: Int8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    rgba8uint: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "uint"
    },
    rgba8sint: {
      numComponents: 4,
      nativeType: Int8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "sint"
    },
    bgra8unorm: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    "bgra8unorm-srgb": {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: "float"
    },
    rgb9e5ufloat: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: "float"
    },
    rgb10a2unorm: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: "float"
    },
    rg11b10ufloat: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 4,
      sampleType: "float"
    },
    rg32uint: {
      numComponents: 2,
      nativeType: Uint32Array,
      stride: 8,
      elementSize: 4,
      sampleType: "uint"
    },
    rg32sint: {
      numComponents: 2,
      nativeType: Int32Array,
      stride: 8,
      elementSize: 4,
      sampleType: "sint"
    },
    rg32float: {
      numComponents: 2,
      nativeType: Float32Array,
      stride: 8,
      elementSize: 4,
      sampleType: "unfilterable-float"
    },
    rgba16uint: {
      numComponents: 4,
      nativeType: Uint16Array,
      stride: 8,
      elementSize: 2,
      sampleType: "uint"
    },
    rgba16sint: {
      numComponents: 4,
      nativeType: Int16Array,
      stride: 8,
      elementSize: 2,
      sampleType: "sint"
    },
    rgba16float: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 8,
      elementSize: 2,
      sampleType: "float"
    },
    rgba32uint: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 16,
      elementSize: 4,
      sampleType: "uint"
    },
    rgba32sint: {
      numComponents: 4,
      nativeType: Int32Array,
      stride: 16,
      elementSize: 4,
      sampleType: "sint"
    },
    rgba32float: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 16,
      elementSize: 4,
      sampleType: "unfilterable-float"
    },
    stencil8: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: "uint"
    },
    depth16unorm: {
      numComponents: 1,
      nativeType: Uint16Array,
      stride: 2,
      elementSize: 2,
      sampleType: "depth"
    },
    depth24plus: {
      numComponents: 1,
      nativeType: Uint32Array,
      stride: 4,
      elementSize: 3,
      sampleType: "depth"
    },
    "depth24plus-stencil8": {
      numComponents: 2,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: "mixed"
    },
    depth32float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 4,
      sampleType: "depth"
    }
  };
  function Kte(t) {
    return !t || t.length < 6 ? 0 : t in XT ? XT[t] : (Jt(`unknown format ${t}`), null);
  }
  function Yte(t) {
    if (!t || t.length < 5) return 0;
    let e = 1;
    t[t.length - 2] === "x" && (e = Number(t[t.length - 1]));
    const n = e === 1 ? t.length - 1 : t.length - 3, r = Number(t[n]);
    if (Number.isNaN(r)) return Jt(`unknown format ${t}`), 0;
    const i = 5 - r / 2;
    return e * i;
  }
  function qte(t) {
    if (!t || t.length < 5) return 0;
    let e = 1;
    return t[t.length - 2] === "x" && (e = Number(t[t.length - 1])), e;
  }
  function Xte(t) {
    if (!t || t.length < 5) return 0;
    let e;
    if (t[0] === "f") e = "Float";
    else if (t[0] === "s") e = "Int";
    else if (t[0] === "u") e = "Uint";
    else {
      Jt(`unknown format ${t}`);
      return;
    }
    const n = t.split("x")[0], r = Number(n[n.length - 1]);
    if (Number.isNaN(r)) {
      Jt(`unknown format ${t}`);
      return;
    }
    return e += 8 * (5 - r / 2), e += "Array", e;
  }
  function Zte(t) {
    let e;
    if (t[0] === "f" || t[1] === "n") e = "f32";
    else if (t[0] === "s" && t[1] === "i") e = "i32";
    else if (t[0] === "u" && t[1] === "i") e = "u32";
    else {
      Jt(`unknown format ${t}`);
      return;
    }
    let n = 1;
    return t[t.length - 2] === "x" && (n = Number(t[t.length - 1])), n === 4 ? `vec4<${e}>` : n === 3 ? `vec3<${e}>` : n === 2 ? `vec2<${e}>` : e;
  }
  function Qte(t) {
    if (!t) return 0;
    let e = 1;
    return t.substring(0, 3) === "vec" ? e = Number(t[3]) : t.substring(0, 3) === "mat" && (e = t[3] * t[5]), e * 4;
  }
  function Jte(t) {
    if (t) {
      if (t.includes("f32")) return "Float32Array";
      if (t.includes("i32")) return "Int32Array";
      if (t.includes("u32")) return "Uint32Array";
      Jt(`unknown format ${t}`);
    }
  }
  var ui = {
    getDetailsFromTextureFormat: Kte,
    getByteStrideFromBufferFormat: Yte,
    getNumberOfComponentsFromBufferFormat: qte,
    getNativeTypeFromBufferFormat: Xte,
    getShaderTypeFromBufferFormat: Zte,
    getByteStrideFromShaderFormat: Qte,
    getNativeTypeFromShaderFormat: Jte
  };
  function $te(t, e) {
    if (t === e) return true;
    if (t == null || e == null || t.length !== e.length) return false;
    for (let n = 0; n < t.length; ++n) if (!e.includes(t[n])) return false;
    return true;
  }
  function ene(t, e) {
    e.classHierarchy.push("vtkWebGPUVertexInput"), t.addBuffer = function(n, r) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex", a = r;
      Array.isArray(a) || (a = [
        a
      ]);
      for (let s = 0; s < e.inputs.length; s++) if ($te(e.inputs[s].names, a)) {
        if (e.inputs[s].buffer === n) return;
        e.inputs[s].buffer = n;
        return;
      }
      e.inputs.push({
        buffer: n,
        stepMode: i,
        names: a
      }), e.inputs = e.inputs.sort((s, o) => s.names[0] < o.names[0] ? -1 : s.names[0] > o.names[0] ? 1 : 0);
    }, t.removeBufferIfPresent = (n) => {
      for (let r = 0; r < e.inputs.length; r++) e.inputs[r].names.includes(n) && e.inputs.splice(r, 1);
    }, t.getBuffer = (n) => {
      for (let r = 0; r < e.inputs.length; r++) if (e.inputs[r].names.includes(n)) return e.inputs[r].buffer;
      return null;
    }, t.hasAttribute = (n) => {
      for (let r = 0; r < e.inputs.length; r++) if (e.inputs[r].names.includes(n)) return true;
      return false;
    }, t.getAttributeTime = (n) => {
      for (let r = 0; r < e.inputs.length; r++) if (e.inputs[r].names.includes(n)) return e.inputs[r].buffer.getSourceTime();
      return 0;
    }, t.getShaderCode = () => {
      let n = "", r = 0;
      for (let i = 0; i < e.inputs.length; i++) for (let a = 0; a < e.inputs[i].names.length; a++) {
        const s = e.inputs[i].buffer.getArrayInformation()[a], o = ui.getShaderTypeFromBufferFormat(s.format);
        r > 0 && (n += `,
`), n = `${n}  @location(${r}) ${e.inputs[i].names[a]} : ${o}`, r++;
      }
      return n;
    }, t.getVertexInputInformation = () => {
      const n = {};
      if (e.inputs.length) {
        const r = [];
        let i = 0;
        for (let a = 0; a < e.inputs.length; a++) {
          const s = e.inputs[a].buffer, o = {
            arrayStride: s.getStrideInBytes(),
            stepMode: e.inputs[a].stepMode,
            attributes: []
          }, l = s.getArrayInformation();
          for (let c = 0; c < e.inputs[a].names.length; c++) o.attributes.push({
            shaderLocation: i,
            offset: l[c].offset,
            format: l[c].format
          }), i++;
          r.push(o);
        }
        n.buffers = r;
      }
      return n;
    }, t.bindBuffers = (n) => {
      for (let r = 0; r < e.inputs.length; r++) n.setVertexBuffer(r, e.inputs[r].buffer.getHandle());
      e.indexBuffer && n.setIndexBuffer(e.indexBuffer.getHandle(), e.indexBuffer.getArrayInformation()[0].format);
    }, t.getReady = () => {
    }, t.releaseGraphicsResources = () => {
      e.created && (e.inputs = [], e.bindingDescriptions = [], e.attributeDescriptions = []);
    };
  }
  const tne = {
    inputs: null,
    bindingDescriptions: false,
    attributeDescriptions: null,
    indexBuffer: null
  };
  function _O(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, tne, n), _n(t, e), e.bindingDescriptions = [], e.attributeDescriptions = [], e.inputs = [], pr(t, e, [
      "created",
      "device",
      "handle",
      "indexBuffer"
    ]), ene(t, e);
  }
  const nne = pn(_O, "vtkWebGPUVertexInput");
  var rne = {
    newInstance: nne,
    extend: _O
  };
  const ine = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`, ane = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  function sne(t, e) {
    e.classHierarchy.push("vtkWebGPUSimpleMapper"), t.generateShaderDescriptions = (n, r, i) => {
      const a = qT.newInstance({
        type: "vertex",
        hash: n,
        code: e.vertexShaderTemplate
      }), s = qT.newInstance({
        type: "fragment",
        hash: n,
        code: e.fragmentShaderTemplate
      }), o = r.getShaderDescriptions();
      o.push(a), o.push(s);
      const l = e.vertexShaderTemplate + e.fragmentShaderTemplate, c = new RegExp("//VTK::[^:]*::", "g"), u = l.match(c).filter((h, g, v) => v.indexOf(h) === g).map((h) => `replaceShader${h.substring(7, h.length - 2)}`);
      for (let h = 0; h < u.length; h++) {
        const g = u[h];
        g !== "replaceShaderIOStructs" && e.shaderReplacements.has(g) && e.shaderReplacements.get(g)(n, r, i);
      }
      t.replaceShaderIOStructs(n, r, i);
    }, t.replaceShaderIOStructs = (n, r, i) => {
      const a = r.getShaderDescription("vertex");
      a.replaceShaderCode(null, i), r.getShaderDescription("fragment").replaceShaderCode(a);
    }, t.replaceShaderRenderEncoder = (n, r, i) => {
      e.renderEncoder.replaceShaderCode(r);
    }, e.shaderReplacements.set("replaceShaderRenderEncoder", t.replaceShaderRenderEncoder), t.replaceShaderRenderer = (n, r, i) => {
      if (!e.WebGPURenderer) return;
      const a = e.WebGPURenderer.getBindGroup().getShaderCode(r), s = r.getShaderDescription("vertex");
      let o = s.getCode();
      o = Dn.substitute(o, "//VTK::Renderer::Dec", [
        a
      ]).result, s.setCode(o);
      const l = r.getShaderDescription("fragment");
      o = l.getCode(), o = Dn.substitute(o, "//VTK::Renderer::Dec", [
        a
      ]).result, l.setCode(o);
    }, e.shaderReplacements.set("replaceShaderRenderer", t.replaceShaderRenderer), t.replaceShaderMapper = (n, r, i) => {
      const a = e.bindGroup.getShaderCode(r), s = r.getShaderDescription("vertex");
      let o = s.getCode();
      o = Dn.substitute(o, "//VTK::Mapper::Dec", [
        a
      ]).result, s.setCode(o);
      const l = r.getShaderDescription("fragment");
      l.addBuiltinInput("bool", "@builtin(front_facing) frontFacing"), o = l.getCode(), o = Dn.substitute(o, "//VTK::Mapper::Dec", [
        a
      ]).result, l.setCode(o);
    }, e.shaderReplacements.set("replaceShaderMapper", t.replaceShaderMapper), t.replaceShaderPosition = (n, r, i) => {
      const a = r.getShaderDescription("vertex");
      a.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
      let s = a.getCode();
      s = Dn.substitute(s, "//VTK::Position::Impl", [
        "    output.Position = rendererUBO.SCPCMatrix*vertexBC;"
      ]).result, a.setCode(s);
    }, e.shaderReplacements.set("replaceShaderPosition", t.replaceShaderPosition), t.replaceShaderTCoord = (n, r, i) => {
      r.getShaderDescription("vertex").addOutput("vec2<f32>", "tcoordVS");
    }, e.shaderReplacements.set("replaceShaderTCoord", t.replaceShaderTCoord), t.addTextureView = (n) => {
      e.textureViews.includes(n) || e.textureViews.push(n);
    }, t.prepareToDraw = (n) => {
      e.renderEncoder = n, t.updateInput(), t.updateBuffers(), t.updateBindings(), t.updatePipeline();
    }, t.updateInput = () => {
    }, t.updateBuffers = () => {
    }, t.updateBindings = () => {
      e.bindGroup.setBindables(t.getBindables());
    }, t.computePipelineHash = () => {
    }, t.registerDrawCallback = (n) => {
      n.registerDrawCallback(e.pipeline, t.draw);
    }, t.prepareAndDraw = (n) => {
      t.prepareToDraw(n), n.setPipeline(e.pipeline), t.draw(n);
    }, t.draw = (n) => {
      const r = n.getBoundPipeline();
      n.activateBindGroup(e.bindGroup), e.WebGPURenderer && e.WebGPURenderer.bindUBO(n), r.bindVertexInput(n, e.vertexInput);
      const i = e.vertexInput.getIndexBuffer();
      i ? n.drawIndexed(i.getIndexCount(), e.numberOfInstances, 0, 0, 0) : n.draw(e.numberOfVertices, e.numberOfInstances, 0, 0);
    }, t.getBindables = () => {
      const n = [
        ...e.additionalBindables
      ];
      e.UBO && n.push(e.UBO), e.SSBO && n.push(e.SSBO);
      for (let r = 0; r < e.textureViews.length; r++) {
        n.push(e.textureViews[r]);
        const i = e.textureViews[r].getSampler();
        i && n.push(i);
      }
      return n;
    }, t.updatePipeline = () => {
      t.computePipelineHash(), e.pipeline = e.device.getPipeline(e.pipelineHash), e.pipeline || (e.pipeline = zte.newInstance(), e.pipeline.setDevice(e.device), e.WebGPURenderer && e.pipeline.addBindGroupLayout(e.WebGPURenderer.getBindGroup()), e.pipeline.addBindGroupLayout(e.bindGroup), t.generateShaderDescriptions(e.pipelineHash, e.pipeline, e.vertexInput), e.pipeline.setTopology(e.topology), e.pipeline.setRenderEncoder(e.renderEncoder), e.pipeline.setVertexState(e.vertexInput.getVertexInputInformation()), e.device.createPipeline(e.pipelineHash, e.pipeline));
    };
  }
  const one = {
    additionalBindables: void 0,
    bindGroup: null,
    device: null,
    fragmentShaderTemplate: null,
    numberOfInstances: 1,
    numberOfVertices: 0,
    pipelineHash: null,
    shaderReplacements: null,
    SSBO: null,
    textureViews: null,
    topology: "triangle-list",
    UBO: null,
    vertexShaderTemplate: null,
    WebGPURenderer: null
  };
  function kO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, one, n), Rn.extend(t, e, n), e.textureViews = [], e.vertexInput = rne.newInstance(), e.bindGroup = NO.newInstance({
      label: "mapperBG"
    }), e.additionalBindables = [], e.fragmentShaderTemplate = e.fragmentShaderTemplate || ane, e.vertexShaderTemplate = e.vertexShaderTemplate || ine, e.shaderReplacements = /* @__PURE__ */ new Map(), H.get(t, e, [
      "pipeline",
      "vertexInput"
    ]), H.setGet(t, e, [
      "additionalBindables",
      "device",
      "fragmentShaderTemplate",
      "interpolate",
      "numberOfInstances",
      "numberOfVertices",
      "pipelineHash",
      "shaderReplacements",
      "SSBO",
      "textureViews",
      "topology",
      "UBO",
      "vertexShaderTemplate",
      "WebGPURenderer"
    ]), sne(t, e);
  }
  const lne = H.newInstance(kO, "vtkWebGPUSimpleMapper");
  var PO = {
    newInstance: lne,
    extend: kO
  };
  function cne(t, e) {
    e.classHierarchy.push("vtkWebGPUFullScreenQuad"), t.replaceShaderPosition = (n, r, i) => {
      const a = r.getShaderDescription("vertex");
      a.addBuiltinOutput("vec4<f32>", "@builtin(position) Position"), a.addOutput("vec4<f32>", "vertexVC");
      let s = a.getCode();
      s = Dn.substitute(s, "//VTK::Position::Impl", [
        "output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);",
        "output.Position = vec4<f32>(vertexBC, 1.0);",
        "output.vertexVC = vec4<f32>(vertexBC, 1);"
      ]).result, a.setCode(s);
    }, e.shaderReplacements.set("replaceShaderPosition", t.replaceShaderPosition), t.updateBuffers = () => {
      const n = e.device.getBufferManager().getFullScreenQuadBuffer();
      e.vertexInput.addBuffer(n, [
        "vertexBC"
      ]), e.numberOfVertices = 6;
    };
  }
  const une = {};
  function GO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, une, n), PO.extend(t, e, n), cne(t, e);
  }
  const fne = H.newInstance(GO, "vtkWebGPUFullScreenQuad");
  var g6 = {
    newInstance: fne,
    extend: GO
  };
  const hne = {
    Verts: 0,
    Lines: 1,
    Triangles: 2,
    Strips: 3,
    LinesFromStrips: 4,
    LinesFromTriangles: 5,
    Points: 6,
    UniformArray: 7,
    PointArray: 8,
    NormalsFromPoints: 9,
    Texture: 10,
    RawVertex: 11,
    Storage: 12,
    Index: 13
  }, dne = {
    Start: 0,
    Points: 0,
    Lines: 1,
    Triangles: 2,
    TriangleStrips: 3,
    TriangleEdges: 4,
    TriangleStripEdges: 5,
    End: 6
  };
  var id = {
    BufferUsage: hne,
    PrimitiveTypes: dne
  };
  const W4 = [
    "getMappedRange",
    "mapAsync",
    "unmap"
  ];
  function gne(t, e, n, r) {
    const i = r.byteLength, a = t.createBuffer({
      size: i,
      usage: GPUBufferUsage.COPY_SRC,
      mappedAtCreation: true
    }), s = a.getMappedRange(0, i);
    new Uint8Array(s).set(new Uint8Array(r)), a.unmap();
    const o = t.createCommandEncoder();
    o.copyBufferToBuffer(a, 0, e, n, i);
    const l = o.finish();
    t.queue.submit([
      l
    ]), a.destroy();
  }
  function pne(t, e) {
    e.classHierarchy.push("vtkWebGPUBuffer"), t.create = (n, r) => {
      e.handle = e.device.getHandle().createBuffer({
        size: n,
        usage: r,
        label: e.label
      }), e.sizeInBytes = n, e.usage = r;
    }, t.write = (n) => {
      gne(e.device.getHandle(), e.handle, 0, n.buffer);
    }, t.createAndWrite = (n, r) => {
      e.handle = e.device.getHandle().createBuffer({
        size: n.byteLength,
        usage: r,
        mappedAtCreation: true,
        label: e.label
      }), e.sizeInBytes = n.byteLength, e.usage = r, new Uint8Array(e.handle.getMappedRange()).set(new Uint8Array(n.buffer)), e.handle.unmap();
    };
    for (let n = 0; n < W4.length; n++) t[W4[n]] = function() {
      return e.handle[W4[n]](...arguments);
    };
  }
  const mne = {
    device: null,
    handle: null,
    sizeInBytes: 0,
    strideInBytes: 0,
    arrayInformation: null,
    usage: null,
    label: null,
    sourceTime: null
  };
  function zO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, mne, n), H.obj(t, e), H.get(t, e, [
      "handle",
      "sizeInBytes",
      "usage"
    ]), H.setGet(t, e, [
      "strideInBytes",
      "device",
      "arrayInformation",
      "label",
      "sourceTime"
    ]), pne(t, e);
  }
  const vne = H.newInstance(zO);
  var p6 = {
    newInstance: vne,
    extend: zO,
    ...id
  };
  const { Representation: ZT } = ef, { PrimitiveTypes: vl } = id;
  class yne {
    constructor() {
      this.keys = new Uint32Array(10), this.values = new Uint32Array(10), this.count = 0;
    }
    clear() {
      this.count = 0;
    }
    has(e) {
      for (let n = 0; n < this.count; n++) if (this.keys[n] === e) return true;
    }
    get(e) {
      for (let n = 0; n < this.count; n++) if (this.keys[n] === e) return this.values[n];
    }
    set(e, n) {
      this.count < 9 && (this.keys[this.count] = e, this.values[this.count++] = n);
    }
  }
  function xne(t) {
    switch (t) {
      case vl.Points:
        return "points";
      case vl.Lines:
        return "lines";
      case vl.Triangles:
      case vl.TriangleEdges:
        return "polys";
      case vl.TriangleStripEdges:
      case vl.TriangleStrips:
        return "strips";
      default:
        return "";
    }
  }
  function W2(t, e, n) {
    let r = t.pointIdToFlatId[e];
    return r < 0 && (r = t.flatId, t.pointIdToFlatId[e] = r, t.flatIdToPointId[t.flatId] = e, t.flatIdToCellId[t.flatId] = n, t.flatId++), r;
  }
  function wne(t, e, n) {
    const r = t.length;
    for (let s = 0; s < r; s++) {
      let o = t[s];
      if (n.cellProvokedMap.has(o)) {
        n.ibo[n.iboId++] = n.cellProvokedMap.get(o);
        for (let l = s + 1; l < s + r; l++) {
          o = t[l % r];
          const c = W2(n, o, e);
          n.ibo[n.iboId++] = c;
        }
        return;
      }
    }
    for (let s = 0; s < r; s++) {
      let o = t[s];
      if (!n.provokedPointIds[o]) {
        let l = W2(n, o, e);
        n.provokedPointIds[o] = 1, n.cellProvokedMap.set(o, l), n.flatIdToCellId[l] = e, n.ibo[n.iboId++] = l;
        for (let c = s + 1; c < s + r; c++) o = t[c % r], l = W2(n, o, e), n.ibo[n.iboId++] = l;
        return;
      }
    }
    let i = t[0], a = n.flatId;
    n.cellProvokedMap.set(i, a), n.flatIdToPointId[n.flatId] = i, n.flatIdToCellId[n.flatId] = e, n.flatId++, n.ibo[n.iboId++] = a;
    for (let s = 1; s < r; s++) i = t[s], a = W2(n, i, e), n.ibo[n.iboId++] = a;
  }
  function Cne(t, e, n) {
    const r = t.length;
    n.iboSize += r;
    for (let i = 0; i < r; i++) {
      const a = t[i];
      if (n.cellProvokedMap.has(a)) return;
    }
    for (let i = 0; i < r; i++) {
      const a = t[i];
      if (!n.provokedPointIds[a]) {
        n.provokedPointIds[a] = 1, n.cellProvokedMap.set(a, 1);
        return;
      }
    }
    n.cellProvokedMap.set(t[0], 1), n.extraPoints++;
  }
  let oo;
  const QT = new Uint32Array(1), Oa = new Uint32Array(2), cl = new Uint32Array(3), H4 = {
    anythingToPoints(t, e, n, r, i) {
      for (let a = 0; a < t; ++a) QT[0] = e[n + a], oo(QT, r, i);
    },
    linesToWireframe(t, e, n, r, i) {
      for (let a = 0; a < t - 1; ++a) Oa[0] = e[n + a], Oa[1] = e[n + a + 1], oo(Oa, r, i);
    },
    polysToWireframe(t, e, n, r, i) {
      if (t > 2) for (let a = 0; a < t; ++a) Oa[0] = e[n + a], Oa[1] = e[n + (a + 1) % t], oo(Oa, r, i);
    },
    stripsToWireframe(t, e, n, r, i) {
      if (t > 2) {
        for (let a = 0; a < t - 1; ++a) Oa[0] = e[n + a], Oa[1] = e[n + a + 1], oo(Oa, r, i);
        for (let a = 0; a < t - 2; a++) Oa[0] = e[n + a], Oa[1] = e[n + a + 2], oo(Oa, r, i);
      }
    },
    polysToSurface(t, e, n, r, i) {
      for (let a = 0; a < t - 2; a++) cl[0] = e[n], cl[1] = e[n + a + 1], cl[2] = e[n + a + 2], oo(cl, r, i);
    },
    stripsToSurface(t, e, n, r, i) {
      for (let a = 0; a < t - 2; a++) cl[0] = e[n + a], cl[1] = e[n + a + 1 + a % 2], cl[2] = e[n + a + 1 + (a + 1) % 2], oo(cl, r, i);
    }
  };
  function Tne(t, e) {
    e.classHierarchy.push("vtkWebGPUIndexBuffer"), t.buildIndexBuffer = (n) => {
      const r = n.cells, i = n.primitiveType, a = n.representation, s = n.cellOffset, o = r.getData(), l = o.length, c = xne(i), f = n.numberOfPoints, u = {
        provokedPointIds: new Uint8Array(f),
        extraPoints: 0,
        iboSize: 0,
        flatId: 0,
        iboId: 0,
        cellProvokedMap: new yne()
      };
      let h = null;
      a === ZT.POINTS || i === vl.Points ? h = H4.anythingToPoints : a === ZT.WIREFRAME || i === vl.Lines ? h = H4[`${c}ToWireframe`] : h = H4[`${c}ToSurface`], oo = Cne;
      let g = s || 0;
      for (let v = 0; v < l; ) u.cellProvokedMap.clear(), h(o[v], o, v + 1, g, u), v += o[v] + 1, g++;
      f <= 65535 ? u.flatIdToPointId = new Uint16Array(f + u.extraPoints) : u.flatIdToPointId = new Uint32Array(f + u.extraPoints), f + u.extraPoints < 36863 ? u.pointIdToFlatId = new Int16Array(f) : u.pointIdToFlatId = new Int32Array(f), f + u.extraPoints <= 65535 ? (u.ibo = new Uint16Array(u.iboSize), n.format = "uint16") : (u.ibo = new Uint32Array(u.iboSize), n.format = "uint32"), g <= 65535 ? u.flatIdToCellId = new Uint16Array(f + u.extraPoints) : u.flatIdToCellId = new Uint32Array(f + u.extraPoints), u.pointIdToFlatId.fill(-1), u.provokedPointIds.fill(0), oo = wne, g = s || 0;
      for (let v = 0; v < l; ) u.cellProvokedMap.clear(), h(o[v], o, v + 1, g, u), v += o[v] + 1, g++;
      delete u.provokedPointIds, delete u.pointIdToFlatId, n.nativeArray = u.ibo, e.flatIdToPointId = u.flatIdToPointId, e.flatIdToCellId = u.flatIdToCellId, e.flatSize = u.flatId, e.indexCount = u.iboId;
    };
  }
  const Sne = {
    flatIdToPointId: null,
    flatIdToCellId: null,
    flatSize: 0,
    indexCount: 0
  };
  function WO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Sne, n), p6.extend(t, e, n), H.setGet(t, e, [
      "flatIdToPointId",
      "flatIdToCellId",
      "flatSize",
      "indexCount"
    ]), Tne(t, e);
  }
  const Ane = H.newInstance(WO);
  var Ene = {
    newInstance: Ane,
    extend: WO,
    ...id
  };
  const { BufferUsage: ul } = id, { vtkErrorMacro: bne } = di, { VtkDataTypes: xc } = Tt, Dne = {};
  function Mne(t) {
    let e;
    switch (t.getDataType()) {
      case xc.UNSIGNED_CHAR:
        e = "uint8";
        break;
      case xc.FLOAT:
        e = "float32";
        break;
      case xc.UNSIGNED_INT:
        e = "uint32";
        break;
      case xc.INT:
        e = "sint32";
        break;
      case xc.DOUBLE:
        e = "float32";
        break;
      case xc.UNSIGNED_SHORT:
        e = "uint16";
        break;
      case xc.SHORT:
        e = "sin16";
        break;
      default:
        e = "float32";
        break;
    }
    switch (t.getNumberOfComponents()) {
      case 2:
        e += "x2";
        break;
      case 3:
        e.includes("32") || bne(`unsupported x3 type for ${e}`), e += "x3";
        break;
      case 4:
        e += "x4";
        break;
    }
    return e;
  }
  function JT(t, e, n, r, i) {
    const a = {}, s = t.getFlatSize();
    if (!s) return a;
    let o = [
      0,
      0,
      0,
      0
    ];
    i.shift && (i.shift.length ? o = i.shift : o.fill(i.shift));
    let l = [
      1,
      1,
      1,
      1
    ];
    i.scale && (i.scale.length ? l = i.scale : l.fill(i.scale));
    const c = Object.prototype.hasOwnProperty.call(i, "packExtra") ? i.packExtra : false;
    let f, u = 0;
    const h = n + (c ? 1 : 0), g = qu(r, s * h);
    let v = t.getFlatIdToPointId();
    i.cellData && (v = t.getFlatIdToCellId()), n === 1 ? f = function(y) {
      g[u++] = l[0] * e[y] + o[0];
    } : n === 2 ? f = function(y) {
      g[u++] = l[0] * e[y] + o[0], g[u++] = l[1] * e[y + 1] + o[1];
    } : n === 3 && !c ? f = function(y) {
      g[u++] = l[0] * e[y] + o[0], g[u++] = l[1] * e[y + 1] + o[1], g[u++] = l[2] * e[y + 2] + o[2];
    } : n === 3 && c ? f = function(y) {
      g[u++] = l[0] * e[y] + o[0], g[u++] = l[1] * e[y + 1] + o[1], g[u++] = l[2] * e[y + 2] + o[2], g[u++] = l[3] * 1 + o[3];
    } : n === 4 && (f = function(y) {
      g[u++] = l[0] * e[y] + o[0], g[u++] = l[1] * e[y + 1] + o[1], g[u++] = l[2] * e[y + 2] + o[2], g[u++] = l[3] * e[y + 3] + o[3];
    });
    for (let m = 0; m < s; m++) {
      const y = n * v[m];
      f(y);
    }
    return a.nativeArray = g, a;
  }
  function Rne(t, e, n, r) {
    const i = [
      t[r * 3] - t[n * 3],
      t[r * 3 + 1] - t[n * 3 + 1],
      t[r * 3 + 2] - t[n * 3 + 2]
    ], a = [
      t[e * 3] - t[n * 3],
      t[e * 3 + 1] - t[n * 3 + 1],
      t[e * 3 + 2] - t[n * 3 + 2]
    ], s = [];
    return Ns(i, a, s), Hc(s), s;
  }
  function One(t, e) {
    const n = e.getData(), r = t.getData();
    if (!r || !n) return null;
    const i = new Int8Array(t.getNumberOfCells() * 4), a = r.length;
    let s = 0;
    for (let o = 0; o < a; ) {
      const l = Rne(n, r[o + 1], r[o + 2], r[o + 3]);
      i[s++] = 127 * l[0], i[s++] = 127 * l[1], i[s++] = 127 * l[2], i[s++] = 127, o += r[o] + 1;
    }
    return i;
  }
  function Ine(t, e) {
    e.classHierarchy.push("vtkWebGPUBufferManager");
    function n(r) {
      r.dataArray && !r.nativeArray && (r.nativeArray = r.dataArray.getData());
      let i, a;
      if (r.usage === ul.Index && (i = Ene.newInstance({
        label: r.label
      }), i.setDevice(e.device), a = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST, i.buildIndexBuffer(r), i.createAndWrite(r.nativeArray, a), i.setArrayInformation([
        {
          format: r.format
        }
      ])), i || (i = p6.newInstance({
        label: r.label
      }), i.setDevice(e.device)), r.usage === ul.UniformArray && (a = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, i.createAndWrite(r.nativeArray, a)), r.usage === ul.Storage && (a = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, i.createAndWrite(r.nativeArray, a)), r.usage === ul.Texture && (a = GPUBufferUsage.COPY_SRC, i.createAndWrite(r.nativeArray, a)), r.usage === ul.PointArray) {
        a = GPUBufferUsage.VERTEX;
        const s = ui.getNativeTypeFromBufferFormat(r.format), o = JT(r.indexBuffer, r.dataArray.getData(), r.dataArray.getNumberOfComponents(), s, {
          packExtra: r.packExtra,
          shift: r.shift,
          scale: r.scale,
          cellData: r.cellData,
          cellOffset: r.cellOffset
        });
        i.createAndWrite(o.nativeArray, a), i.setStrideInBytes(ui.getByteStrideFromBufferFormat(r.format)), i.setArrayInformation([
          {
            offset: 0,
            format: r.format,
            interpolation: r.cellData ? "flat" : "perspective"
          }
        ]);
      }
      if (r.usage === ul.NormalsFromPoints) {
        a = GPUBufferUsage.VERTEX;
        const s = ui.getNativeTypeFromBufferFormat(r.format), o = One(r.cells, r.dataArray), l = JT(r.indexBuffer, o, 4, s, {
          cellData: true
        });
        i.createAndWrite(l.nativeArray, a), i.setStrideInBytes(ui.getByteStrideFromBufferFormat(r.format)), i.setArrayInformation([
          {
            offset: 0,
            format: r.format,
            interpolation: "flat"
          }
        ]);
      }
      return r.usage === ul.RawVertex && (a = GPUBufferUsage.VERTEX, i.createAndWrite(r.nativeArray, a), i.setStrideInBytes(ui.getByteStrideFromBufferFormat(r.format)), i.setArrayInformation([
        {
          offset: 0,
          format: r.format
        }
      ])), i.setSourceTime(r.time), i;
    }
    t.hasBuffer = (r) => e.device.hasCachedObject(r), t.getBuffer = (r) => r.hash ? e.device.getCachedObject(r.hash, n, r) : n(r), t.getBufferForPointArray = (r, i) => {
      const a = Mne(r), s = {
        hash: `${r.getMTime()}I${i.getMTime()}${a}`,
        usage: ul.PointArray,
        format: a,
        dataArray: r,
        indexBuffer: i
      };
      return t.getBuffer(s);
    }, t.getFullScreenQuadBuffer = () => {
      if (e.fullScreenQuadBuffer) return e.fullScreenQuadBuffer;
      e.fullScreenQuadBuffer = p6.newInstance(), e.fullScreenQuadBuffer.setDevice(e.device);
      const r = new Float32Array([
        -1,
        -1,
        0,
        1,
        -1,
        0,
        1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        1,
        0,
        -1,
        1,
        0
      ]);
      return e.fullScreenQuadBuffer.createAndWrite(r, GPUBufferUsage.VERTEX), e.fullScreenQuadBuffer.setStrideInBytes(12), e.fullScreenQuadBuffer.setArrayInformation([
        {
          offset: 0,
          format: "float32x3"
        }
      ]), e.fullScreenQuadBuffer;
    };
  }
  const Vne = {
    device: null,
    fullScreenQuadBuffer: null
  };
  function Nne(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Vne, n), _n(t, e), pr(t, e, [
      "device"
    ]), Ine(t, e);
  }
  pn(Nne);
  var tf = {
    ...Dne,
    ...id
  };
  const { BufferUsage: Lne } = tf, { vtkErrorMacro: J0 } = H;
  function Une(t, e) {
    e.classHierarchy.push("vtkWebGPUStorageBuffer"), t.addEntry = (n, r) => {
      if (e._bufferEntryNames.has(n)) {
        J0(`entry named ${n} already exists`);
        return;
      }
      e._bufferEntryNames.set(n, e.bufferEntries.length);
      const i = ui.getByteStrideFromShaderFormat(r);
      e.bufferEntries.push({
        name: n,
        type: r,
        sizeInBytes: i,
        offset: e.sizeInBytes,
        nativeType: ui.getNativeTypeFromShaderFormat(r)
      }), e.sizeInBytes += i;
    }, t.send = (n) => {
      if (!e._buffer) {
        const r = {
          nativeArray: e.Float32Array,
          usage: Lne.Storage,
          label: e.label
        };
        e._buffer = n.getBufferManager().getBuffer(r), e.bindGroupTime.modified(), e._sendTime.modified();
        return;
      }
      n.getHandle().queue.writeBuffer(e._buffer.getHandle(), 0, e.arrayBuffer, 0, e.sizeInBytes * e.numberOfInstances), e._sendTime.modified();
    }, t.createView = (n) => {
      n in e || (e.arrayBuffer || (e.arrayBuffer = new ArrayBuffer(e.sizeInBytes * e.numberOfInstances)), e[n] = H.newTypedArray(n, e.arrayBuffer));
    }, t.setValue = (n, r, i) => {
      const a = e._bufferEntryNames.get(n);
      if (a === void 0) {
        J0(`entry named ${n} not found in UBO`);
        return;
      }
      const s = e.bufferEntries[a];
      t.createView(s.nativeType);
      const o = e[s.nativeType];
      o[(s.offset + r * e.sizeInBytes) / o.BYTES_PER_ELEMENT] = i;
    }, t.setArray = (n, r, i) => {
      const a = e._bufferEntryNames.get(n);
      if (a === void 0) {
        J0(`entry named ${n} not found in UBO`);
        return;
      }
      const s = e.bufferEntries[a];
      t.createView(s.nativeType);
      const o = e[s.nativeType], l = (s.offset + r * e.sizeInBytes) / o.BYTES_PER_ELEMENT;
      for (let c = 0; c < i.length; c++) o[l + c] = i[c];
    }, t.setAllInstancesFromArray = (n, r) => {
      const i = e._bufferEntryNames.get(n);
      if (i === void 0) {
        J0(`entry named ${n} not found in UBO`);
        return;
      }
      const a = e.bufferEntries[i];
      t.createView(a.nativeType);
      const s = e[a.nativeType], o = r.length / e.numberOfInstances;
      for (let l = 0; l < e.numberOfInstances; l++) {
        const c = (a.offset + l * e.sizeInBytes) / s.BYTES_PER_ELEMENT;
        for (let f = 0; f < o; f++) s[c + f] = r[l * o + f];
      }
    }, t.setAllInstancesFromArrayColorToFloat = (n, r) => {
      const i = e._bufferEntryNames.get(n);
      if (i === void 0) {
        J0(`entry named ${n} not found in UBO`);
        return;
      }
      const a = e.bufferEntries[i];
      t.createView(a.nativeType);
      const s = e[a.nativeType], o = r.length / e.numberOfInstances;
      for (let l = 0; l < e.numberOfInstances; l++) {
        const c = (a.offset + l * e.sizeInBytes) / s.BYTES_PER_ELEMENT;
        for (let f = 0; f < o; f++) s[c + f] = r[l * o + f] / 255;
      }
    }, t.setAllInstancesFromArray3x3To4x4 = (n, r) => {
      const i = e._bufferEntryNames.get(n);
      if (i === void 0) {
        J0(`entry named ${n} not found in UBO`);
        return;
      }
      const a = e.bufferEntries[i];
      t.createView(a.nativeType);
      const s = e[a.nativeType], o = 9;
      for (let l = 0; l < e.numberOfInstances; l++) {
        const c = (a.offset + l * e.sizeInBytes) / s.BYTES_PER_ELEMENT;
        for (let f = 0; f < 3; f++) for (let u = 0; u < 3; u++) s[c + f * 4 + u] = r[l * o + f * 3 + u];
      }
    }, t.getSendTime = () => e._sendTime.getMTime(), t.getShaderCode = (n, r) => {
      const i = [
        `struct ${e.label}StructEntry
{`
      ];
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        i.push(`  ${s.name}: ${s.type},`);
      }
      return i.push(`
};
struct ${e.label}Struct
{
  values: array<${e.label}StructEntry>,
};
@binding(${n}) @group(${r}) var<storage, read> ${e.label}: ${e.label}Struct;
`), i.join(`
`);
    }, t.getBindGroupEntry = () => ({
      resource: {
        buffer: e._buffer.getHandle()
      }
    }), t.clearData = () => {
      e.numberOfInstances = 0, e.sizeInBytes = 0, e.bufferEntries = [], e._bufferEntryNames = /* @__PURE__ */ new Map(), e._buffer = null, delete e.arrayBuffer, delete e.Float32Array;
    };
  }
  const Fne = {
    bufferEntries: null,
    bufferEntryNames: null,
    sizeInBytes: 0,
    label: null,
    numberOfInstances: 1
  };
  function HO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Fne, n), H.obj(t, e), e._bufferEntryNames = /* @__PURE__ */ new Map(), e.bufferEntries = [], e._sendTime = {}, H.obj(e._sendTime, {
      mtime: 0
    }), e.bindGroupTime = {}, H.obj(e.bindGroupTime, {
      mtime: 0
    }), e.bindGroupLayoutEntry = e.bindGroupLayoutEntry || {
      buffer: {
        type: "read-only-storage"
      }
    }, H.get(t, e, [
      "bindGroupTime"
    ]), H.setGet(t, e, [
      "device",
      "bindGroupLayoutEntry",
      "label",
      "numberOfInstances",
      "sizeInBytes"
    ]), Une(t, e);
  }
  const Bne = H.newInstance(HO, "vtkWebGPUStorageBuffer");
  var _ne = {
    newInstance: Bne,
    extend: HO
  };
  const { BufferUsage: kne } = tf, { vtkErrorMacro: j4 } = H;
  function Pne(t, e) {
    e.classHierarchy.push("vtkWebGPUUniformBuffer"), t.addEntry = (n, r) => {
      if (e._bufferEntryNames.has(n)) {
        j4(`entry named ${n} already exists`);
        return;
      }
      e.sortDirty = true, e._bufferEntryNames.set(n, e.bufferEntries.length), e.bufferEntries.push({
        name: n,
        type: r,
        sizeInBytes: ui.getByteStrideFromShaderFormat(r),
        offset: -1,
        nativeType: ui.getNativeTypeFromShaderFormat(r),
        packed: false
      });
    }, t.sortBufferEntries = () => {
      if (!e.sortDirty) return;
      let n = 0;
      const r = [];
      let i = 4;
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        s.sizeInBytes % 16 === 0 && (i = Math.max(16, i)), s.sizeInBytes % 8 === 0 && (i = Math.max(8, i));
      }
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        s.packed === false && s.sizeInBytes % 16 === 0 && (s.packed = true, s.offset = n, r.push(s), n += s.sizeInBytes);
      }
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        if (s.packed === false && s.sizeInBytes === 12) for (let o = 0; o < e.bufferEntries.length; o++) {
          const l = e.bufferEntries[o];
          if (l.packed === false && l.sizeInBytes === 4) {
            s.packed = true, s.offset = n, r.push(s), n += s.sizeInBytes, l.packed = true, l.offset = n, r.push(l), n += l.sizeInBytes;
            break;
          }
        }
      }
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        if (!s.packed && s.sizeInBytes % 8 === 0) for (let o = a + 1; o < e.bufferEntries.length; o++) {
          const l = e.bufferEntries[o];
          if (!l.packed && l.sizeInBytes % 8 === 0) {
            s.packed = true, s.offset = n, r.push(s), n += s.sizeInBytes, l.packed = true, l.offset = n, r.push(l), n += l.sizeInBytes;
            break;
          }
        }
      }
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        if (!s.packed && s.sizeInBytes % 8 === 0) {
          let o = false;
          for (let l = 0; !o && l < e.bufferEntries.length; l++) {
            const c = e.bufferEntries[l];
            if (!c.packed && c.sizeInBytes === 4) for (let f = l + 1; f < e.bufferEntries.length; f++) {
              const u = e.bufferEntries[f];
              if (!u.packed && u.sizeInBytes === 4) {
                s.packed = true, s.offset = n, r.push(s), n += s.sizeInBytes, c.packed = true, c.offset = n, r.push(c), n += c.sizeInBytes, u.packed = true, u.offset = n, r.push(u), n += u.sizeInBytes, o = true;
                break;
              }
            }
          }
        }
      }
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        !s.packed && s.sizeInBytes > 4 && (s.packed = true, s.offset = n, r.push(s), n += s.sizeInBytes);
      }
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        s.packed || (s.packed = true, s.offset = n, r.push(s), n += s.sizeInBytes);
      }
      e.bufferEntries = r, e._bufferEntryNames.clear();
      for (let a = 0; a < e.bufferEntries.length; a++) e._bufferEntryNames.set(e.bufferEntries[a].name, a);
      e.sizeInBytes = n, e.sizeInBytes = i * Math.ceil(e.sizeInBytes / i), e.sortDirty = false;
    }, t.sendIfNeeded = (n) => {
      if (!e.UBO) {
        const r = {
          nativeArray: e.Float32Array,
          usage: kne.UniformArray,
          label: e.label
        };
        e.UBO = n.getBufferManager().getBuffer(r), e.bindGroupTime.modified(), e.sendDirty = false;
      }
      e.sendDirty && (n.getHandle().queue.writeBuffer(e.UBO.getHandle(), 0, e.arrayBuffer, 0, e.sizeInBytes), e.sendDirty = false), e.sendTime.modified();
    }, t.createView = (n) => {
      n in e || (e.arrayBuffer || (e.arrayBuffer = new ArrayBuffer(e.sizeInBytes)), e[n] = H.newTypedArray(n, e.arrayBuffer));
    }, t.setValue = (n, r) => {
      t.sortBufferEntries();
      const i = e._bufferEntryNames.get(n);
      if (i === void 0) {
        j4(`entry named ${n} not found in UBO`);
        return;
      }
      const a = e.bufferEntries[i];
      t.createView(a.nativeType);
      const s = e[a.nativeType];
      a.lastValue !== r && (s[a.offset / s.BYTES_PER_ELEMENT] = r, e.sendDirty = true), a.lastValue = r;
    }, t.setArray = (n, r) => {
      t.sortBufferEntries();
      const i = e._bufferEntryNames.get(n);
      if (i === void 0) {
        j4(`entry named ${n} not found in UBO`);
        return;
      }
      const a = e.bufferEntries[i];
      t.createView(a.nativeType);
      const s = e[a.nativeType];
      let o = false;
      for (let l = 0; l < r.length; l++) (!a.lastValue || a.lastValue[l] !== r[l]) && (s[a.offset / s.BYTES_PER_ELEMENT + l] = r[l], o = true);
      o && (e.sendDirty = true, a.lastValue = [
        ...r
      ]);
    }, t.getBindGroupEntry = () => ({
      resource: {
        buffer: e.UBO.getHandle()
      }
    }), t.getSendTime = () => e.sendTime.getMTime(), t.getShaderCode = (n, r) => {
      t.sortBufferEntries();
      const i = [
        `struct ${e.label}Struct
{`
      ];
      for (let a = 0; a < e.bufferEntries.length; a++) {
        const s = e.bufferEntries[a];
        i.push(`  ${s.name}: ${s.type},`);
      }
      return i.push(`};
@binding(${n}) @group(${r}) var<uniform> ${e.label}: ${e.label}Struct;`), i.join(`
`);
    };
  }
  const Gne = {
    bufferEntries: null,
    bufferEntryNames: null,
    sizeInBytes: 0,
    label: null,
    bindGroupLayoutEntry: null,
    bindGroupEntry: null
  };
  function jO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Gne, n), H.obj(t, e), e._bufferEntryNames = /* @__PURE__ */ new Map(), e.bufferEntries = [], e.bindGroupLayoutEntry = e.bindGroupLayoutEntry || {
      buffer: {
        type: "uniform"
      }
    }, e.sendTime = {}, H.obj(e.sendTime, {
      mtime: 0
    }), e.bindGroupTime = {}, H.obj(e.bindGroupTime, {
      mtime: 0
    }), e.sendDirty = true, e.sortDirty = true, H.get(t, e, [
      "binding",
      "bindGroupTime"
    ]), H.setGet(t, e, [
      "bindGroupLayoutEntry",
      "device",
      "label",
      "sizeInBytes"
    ]), Pne(t, e);
  }
  const zne = H.newInstance(jO, "vtkWebGPUUniformBuffer");
  var wu = {
    newInstance: zne,
    extend: jO
  };
  const { vtkDebugMacro: Wne } = di, $T = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`, Hne = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`, H2 = new Float64Array(16), eS = new Float64Array(16);
  function jne(t) {
    return t.getPositional() ? t.getConeAngle() >= 90 ? 0 : 2 : 1;
  }
  function Kne(t, e) {
    e.classHierarchy.push("vtkWebGPURenderer"), t.buildPass = (n) => {
      if (n) {
        if (!e.renderable) return;
        e.camera = e.renderable.getActiveCamera(), t.updateLights(), t.prepareNodes(), t.addMissingNode(e.camera), t.addMissingNodes(e.renderable.getViewPropsWithNestedProps()), t.removeUnusedNodes(), e.webgpuCamera = t.getViewNodeFor(e.camera), t.updateStabilizedMatrix();
      }
    }, t.updateStabilizedMatrix = () => {
      const n = e.camera.getClippingRange(), r = e.camera.getPositionByReference(), i = e.camera.getDirectionOfProjectionByReference(), a = [], s = [];
      so(s, i, 0.5 * (n[0] + n[1])), K1(a, r, s), o6(s, a, e.stabilizedCenter), iM(s) / (n[1] - n[0]) > e.recenterThreshold && (e.stabilizedCenter = a, e.stabilizedTime.modified());
    }, t.updateLights = () => {
      let n = 0;
      const r = e.renderable.getLightsByReference();
      for (let i = 0; i < r.length; ++i) r[i].getSwitch() > 0 && n++;
      return n || (Wne("No lights are on, creating one."), e.renderable.createLight()), n;
    }, t.updateUBO = () => {
      var _a3;
      const n = e.UBO.getSendTime();
      if (e._parent.getMTime() > n || t.getMTime() > n || e.camera.getMTime() > n || e.renderable.getMTime() > n) {
        const r = e.webgpuCamera.getKeyMatrices(t);
        e.UBO.setArray("WCVCMatrix", r.wcvc), e.UBO.setArray("SCPCMatrix", r.scpc), e.UBO.setArray("PCSCMatrix", r.pcsc), e.UBO.setArray("SCVCMatrix", r.scvc), e.UBO.setArray("VCPCMatrix", r.vcpc), e.UBO.setArray("WCVCNormals", r.normalMatrix), e.UBO.setValue("LightCount", e.renderable.getLights().length), e.UBO.setValue("MaxEnvironmentMipLevel", (_a3 = e.renderable.getEnvironmentTexture()) == null ? void 0 : _a3.getMipLevel()), e.UBO.setValue("BackgroundDiffuseStrength", e.renderable.getEnvironmentTextureDiffuseStrength()), e.UBO.setValue("BackgroundSpecularStrength", e.renderable.getEnvironmentTextureSpecularStrength());
        const i = t.getYInvertedTiledSizeAndOrigin();
        e.UBO.setArray("viewportSize", [
          i.usize,
          i.vsize
        ]), e.UBO.setValue("cameraParallel", e.camera.getParallelProjection());
        const a = e._parent.getDevice();
        e.UBO.sendIfNeeded(a);
      }
    }, t.updateSSBO = () => {
      const n = e.renderable.getLights(), r = e.webgpuCamera.getKeyMatrices(t);
      let i = `${e.renderable.getMTime()}`;
      for (let a = 0; a < n.length; a++) i += n[a].getMTime();
      if (i !== e.lightTimeString) {
        const a = new Float32Array(n.length * 4), s = new Float32Array(n.length * 4), o = new Float32Array(n.length * 4), l = new Float32Array(n.length * 4);
        for (let f = 0; f < n.length; f++) {
          const u = f * 4, h = n[f].getPosition();
          $t(h, h, r.wcvc), a[u] = h[0], a[u + 1] = h[1], a[u + 2] = h[2], a[u + 3] = 0, s[u] = -n[f].getDirection()[0], s[u + 1] = -n[f].getDirection()[1], s[u + 2] = -n[f].getDirection()[2], s[u + 3] = 0, o[u] = n[f].getColor()[0], o[u + 1] = n[f].getColor()[1], o[u + 2] = n[f].getColor()[2], o[u + 3] = n[f].getIntensity() * 5, l[u] = jne(n[f]), l[u + 1] = Math.cos(rr(n[f].getConeAngle())), l[u + 2] = Math.cos(rr(n[f].getConeAngle() + n[f].getConeFalloff())), l[u + 3] = 0;
        }
        e.SSBO.clearData(), e.SSBO.setNumberOfInstances(n.length), e.SSBO.addEntry("LightPos", "vec4<f32>"), e.SSBO.addEntry("LightDir", "vec4<f32>"), e.SSBO.addEntry("LightColor", "vec4<f32>"), e.SSBO.addEntry("LightData", "vec4<f32>"), e.SSBO.setAllInstancesFromArray("LightPos", a), e.SSBO.setAllInstancesFromArray("LightDir", s), e.SSBO.setAllInstancesFromArray("LightColor", o), e.SSBO.setAllInstancesFromArray("LightData", l);
        const c = e._parent.getDevice();
        e.SSBO.send(c);
      }
      e.lightTimeString = i;
    }, t.scissorAndViewport = (n) => {
      const r = t.getYInvertedTiledSizeAndOrigin();
      n.getHandle().setViewport(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize, 0, 1), n.getHandle().setScissorRect(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize);
    }, t.bindUBO = (n) => {
      n.activateBindGroup(e.bindGroup);
    }, t.opaquePass = (n) => {
      n ? (e.renderEncoder.begin(e._parent.getCommandEncoder()), t.updateUBO(), t.updateSSBO()) : (t.scissorAndViewport(e.renderEncoder), t.clear(), e.renderEncoder.end());
    }, t.clear = () => {
      var _a3;
      if (e.renderable.getTransparent() || e.suppressClear) return;
      const n = e._parent.getDevice();
      if (!e.clearFSQ) {
        e.clearFSQ = g6.newInstance(), e.clearFSQ.setDevice(n), e.clearFSQ.setPipelineHash("clearfsq"), e.clearFSQ.setFragmentShaderTemplate($T);
        const a = wu.newInstance({
          label: "mapperUBO"
        });
        a.addEntry("FSQMatrix", "mat4x4<f32>"), a.addEntry("BackgroundColor", "vec4<f32>"), e.clearFSQ.setUBO(a), e.backgroundTex = e.renderable.getEnvironmentTexture();
      }
      if (e.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && e.renderable.getUseEnvironmentTextureAsBackground() && ((_a3 = e.backgroundTex) == null ? void 0 : _a3.getImageLoaded())) {
        e.clearFSQ.setFragmentShaderTemplate(Hne);
        const a = wu.newInstance({
          label: "mapperUBO"
        });
        a.addEntry("FSQMatrix", "mat4x4<f32>"), a.addEntry("BackgroundColor", "vec4<f32>"), e.clearFSQ.setUBO(a);
        const s = n.getTextureManager().getTextureForVTKTexture(e.backgroundTex);
        if (s.getReady()) {
          const o = s.createView("EnvironmentTexture");
          e.clearFSQ.setTextureViews([
            o
          ]), e.backgroundTexLoaded = true;
          const l = e.backgroundTex.getInterpolate() ? "linear" : "nearest";
          o.addSampler(n, {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge",
            addressModeW: "repeat",
            minFilter: l,
            magFilter: l,
            mipmapFilter: "linear"
          });
        }
        e.clearFSQ.setPipelineHash("clearfsqwithtexture");
      } else if (e.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !e.renderable.getUseEnvironmentTextureAsBackground()) {
        e.clearFSQ = g6.newInstance(), e.clearFSQ.setDevice(n), e.clearFSQ.setPipelineHash("clearfsq"), e.clearFSQ.setFragmentShaderTemplate($T);
        const a = wu.newInstance({
          label: "mapperUBO"
        });
        a.addEntry("FSQMatrix", "mat4x4<f32>"), a.addEntry("BackgroundColor", "vec4<f32>"), e.clearFSQ.setUBO(a);
      }
      const r = e.webgpuCamera.getKeyMatrices(t), i = e.renderable.getBackgroundByReference();
      e.clearFSQ.getUBO().setArray("BackgroundColor", i), en(eS, r.normalMatrix), vp(H2, r.scvc, r.pcsc), vp(H2, eS, H2), e.clearFSQ.getUBO().setArray("FSQMatrix", H2), e.clearFSQ.getUBO().sendIfNeeded(n), e.clearFSQ.prepareAndDraw(e.renderEncoder);
    }, t.translucentPass = (n) => {
      n ? e.renderEncoder.begin(e._parent.getCommandEncoder()) : (t.scissorAndViewport(e.renderEncoder), e.renderEncoder.end());
    }, t.volumeDepthRangePass = (n) => {
      n ? e.renderEncoder.begin(e._parent.getCommandEncoder()) : (t.scissorAndViewport(e.renderEncoder), e.renderEncoder.end());
    }, t.getAspectRatio = () => {
      const n = e._parent.getSizeByReference(), r = e.renderable.getViewportByReference();
      return n[0] * (r[2] - r[0]) / ((r[3] - r[1]) * n[1]);
    }, t.convertToOpenGLDepth = (n) => e.webgpuCamera.convertToOpenGLDepth(n), t.getYInvertedTiledSizeAndOrigin = () => {
      const n = t.getTiledSizeAndOrigin(), r = e._parent.getSizeByReference();
      return n.lowerLeftV = r[1] - n.vsize - n.lowerLeftV, n;
    }, t.getTiledSizeAndOrigin = () => {
      const n = e.renderable.getViewportByReference(), r = [
        0,
        0,
        1,
        1
      ], i = n[0] - r[0], a = n[1] - r[1], s = e._parent.normalizedDisplayToDisplay(i, a), o = Math.round(s[0]), l = Math.round(s[1]), c = n[2] - r[0], f = n[3] - r[1], u = e._parent.normalizedDisplayToDisplay(c, f);
      let h = Math.round(u[0]) - o, g = Math.round(u[1]) - l;
      return h < 0 && (h = 0), g < 0 && (g = 0), {
        usize: h,
        vsize: g,
        lowerLeftU: o,
        lowerLeftV: l
      };
    }, t.getPropFromID = (n) => {
      for (let r = 0; r < e.children.length; r++) if ((e.children[r].getPropID ? e.children[r].getPropID() : -1) === n) return e.children[r];
      return null;
    }, t.getStabilizedTime = () => e.stabilizedTime.getMTime(), t.releaseGraphicsResources = () => {
      e.selector !== null && e.selector.releaseGraphicsResources();
    };
  }
  const Yne = {
    bindGroup: null,
    selector: null,
    renderEncoder: null,
    recenterThreshold: 20,
    suppressClear: false,
    stabilizedCenter: [
      0,
      0,
      0
    ]
  };
  function qne(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Yne, n), Rn.extend(t, e, n), e.UBO = wu.newInstance({
      label: "rendererUBO"
    }), e.UBO.addEntry("WCVCMatrix", "mat4x4<f32>"), e.UBO.addEntry("SCPCMatrix", "mat4x4<f32>"), e.UBO.addEntry("PCSCMatrix", "mat4x4<f32>"), e.UBO.addEntry("SCVCMatrix", "mat4x4<f32>"), e.UBO.addEntry("VCPCMatrix", "mat4x4<f32>"), e.UBO.addEntry("WCVCNormals", "mat4x4<f32>"), e.UBO.addEntry("viewportSize", "vec2<f32>"), e.UBO.addEntry("LightCount", "i32"), e.UBO.addEntry("MaxEnvironmentMipLevel", "f32"), e.UBO.addEntry("BackgroundDiffuseStrength", "f32"), e.UBO.addEntry("BackgroundSpecularStrength", "f32"), e.UBO.addEntry("cameraParallel", "u32"), e.SSBO = _ne.newInstance({
      label: "rendererLightSSBO"
    }), e.lightTimeString = "", e.bindGroup = NO.newInstance({
      label: "rendererBG"
    }), e.bindGroup.setBindables([
      e.UBO,
      e.SSBO
    ]), e.tmpMat4 = gt(new Float64Array(16)), e.stabilizedTime = {}, _n(e.stabilizedTime, {
      mtime: 0
    }), Wi(t, e, [
      "bindGroup",
      "stabilizedTime"
    ]), Xu(t, e, [
      "stabilizedCenter"
    ]), pr(t, e, [
      "renderEncoder",
      "selector",
      "suppressClear",
      "UBO"
    ]), Kne(t, e);
  }
  const Xne = pn(qne, "vtkWebGPURenderer");
  ka("vtkRenderer", Xne);
  function Zne(t, e) {
    e.classHierarchy.push("vtkWebGPUSampler"), t.create = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      e.device = n, e.options.addressModeU = r.addressModeU ? r.addressModeU : "clamp-to-edge", e.options.addressModeV = r.addressModeV ? r.addressModeV : "clamp-to-edge", e.options.addressModeW = r.addressModeW ? r.addressModeW : "clamp-to-edge", e.options.magFilter = r.magFilter ? r.magFilter : "nearest", e.options.minFilter = r.minFilter ? r.minFilter : "nearest", e.options.mipmapFilter = r.mipmapFilter ? r.mipmapFilter : "nearest", e.options.label = e.label, e.handle = e.device.getHandle().createSampler(e.options), e.bindGroupTime.modified();
    }, t.getShaderCode = (n, r) => `@binding(${n}) @group(${r}) var ${e.label}: sampler;`, t.getBindGroupEntry = () => ({
      resource: e.handle
    });
  }
  const Qne = {
    device: null,
    handle: null,
    label: null,
    options: null
  };
  function KO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Qne, n), H.obj(t, e), e.options = {}, e.bindGroupLayoutEntry = {
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      sampler: {}
    }, e.bindGroupTime = {}, H.obj(e.bindGroupTime, {
      mtime: 0
    }), H.get(t, e, [
      "bindGroupTime",
      "handle",
      "options"
    ]), H.setGet(t, e, [
      "bindGroupLayoutEntry",
      "device",
      "label"
    ]), Zne(t, e);
  }
  const Jne = H.newInstance(KO);
  var YO = {
    newInstance: Jne,
    extend: KO
  };
  const { SlicingMode: tS } = b5, $ne = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Image::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  //VTK::Image::Sample

  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);

//VTK::RenderEncoder::Impl

  return output;
}
`;
  function ere(t, e, n) {
    if (e.apply(t)) {
      const i = t.getIndependentComponents();
      return `${t.getMTime()}-${i}-${n}`;
    }
    return "0";
  }
  const da = new Float64Array(16), Ts = new Float64Array(16), j2 = new Float64Array(16), ro = new Float64Array(4), Rr = new Float64Array(4);
  function tre(t, e) {
    e.classHierarchy.push("vtkWebGPUImageMapper"), t.buildPass = (i) => {
      if (i) {
        e.WebGPUImageSlice = t.getFirstAncestorOfType("vtkWebGPUImageSlice"), e.WebGPURenderer = e.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getParent(), e.device = e.WebGPURenderWindow.getDevice();
        const a = e.WebGPURenderer.getRenderable();
        e.renderable.getSliceAtFocalPoint() && e.renderable.setSliceFromCamera(a.getActiveCamera());
      }
    }, t.translucentPass = (i) => {
      i && t.render();
    }, t.opaquePass = (i) => {
      i && t.render();
    }, t.render = () => {
      e.renderable.update(), e.currentInput = e.renderable.getInputData(), t.prepareToDraw(e.WebGPURenderer.getRenderEncoder()), e.renderEncoder.registerDrawCallback(e.pipeline, t.draw);
    }, t.computePipelineHash = () => {
      const i = e.currentInput.getExtent();
      i[0] === i[1] || i[2] === i[3] || i[4] === i[5] ? (e.dimensions = 2, e.pipelineHash = "img2") : (e.dimensions = 3, e.pipelineHash = "img3");
    }, t.updateUBO = () => {
      const i = e.UBO.getSendTime(), a = e.WebGPUImageSlice.getRenderable(), s = a.getMapper();
      if (t.getMTime() > i || e.renderable.getMTime() > i || a.getProperty().getMTime() > i) {
        const o = s.getInputData(), l = e.WebGPURenderer.getStabilizedCenterByReference();
        gt(da), $n(da, da, l);
        const c = a.getMatrix();
        en(Ts, c), Nr(Ts, Ts), tn(da, Ts, da);
        const f = o.getWorldToIndex();
        tn(da, f, da), Nr(j2, da), _8(Ts, [
          0.5,
          0.5,
          0.5
        ]), tn(da, Ts, da);
        const u = o.getDimensions();
        gt(Ts), Fl(Ts, Ts, [
          1 / u[0],
          1 / u[1],
          1 / u[2]
        ]), tn(da, Ts, da), e.UBO.setArray("SCTCMatrix", da);
        const h = e.currentInput.getExtent(), { ijkMode: g } = e.renderable.getClosestIJKAxis();
        let v = e.renderable.getSlice();
        g !== e.renderable.getSlicingMode() && (v = e.renderable.getSliceAtPosition(v));
        let m = 2, y = 0, w = 1;
        g === tS.I ? (m = 0, y = 1, w = 2) : g === tS.J && (m = 1, y = 2, w = 0), ro[m] = v, ro[y] = h[y * 2] - 0.5, ro[w] = h[w * 2] - 0.5, ro[3] = 1, Nc(ro, ro, j2), e.UBO.setArray("Origin", ro), Rr[m] = v, Rr[y] = h[y * 2 + 1] + 0.5, Rr[w] = h[w * 2] - 0.5, Rr[3] = 1, Nc(Rr, Rr, j2), gT(Rr, Rr, ro), Rr[3] = 1, e.UBO.setArray("Axis1", Rr), Rr[m] = v, Rr[y] = h[y * 2] - 0.5, Rr[w] = h[w * 2 + 1] + 0.5, Rr[3] = 1, Nc(Rr, Rr, j2), gT(Rr, Rr, ro), Rr[3] = 1, e.UBO.setArray("Axis2", Rr);
        const C = [
          1,
          1,
          1,
          1
        ], T = [
          0,
          0,
          0,
          0
        ], S = e.textureViews[0], E = S.getTexture().getScale(), b = S.getTexture().getNumberOfComponents();
        for (let D = 0; D < b; D++) {
          let R = a.getProperty().getColorWindow(), I = a.getProperty().getColorLevel();
          const L = a.getProperty().getRGBTransferFunction(0);
          if (L) {
            const N = L.getRange();
            R = N[1] - N[0], I = 0.5 * (N[1] + N[0]);
          }
          C[D] = E / R, T[D] = -I / R + 0.5;
        }
        e.UBO.setArray("cScale", C), e.UBO.setArray("cShift", T), e.UBO.sendIfNeeded(e.device);
      }
    }, t.updateLUTImage = () => {
      const i = e.WebGPUImageSlice.getRenderable().getProperty();
      t.getTextureViews()[0].getTexture().getNumberOfComponents();
      const s = 1, o = ere(i, i.getRGBTransferFunction, s);
      if (e.colorTextureString !== o) {
        e.numRows = s;
        const l = new Uint8ClampedArray(e.numRows * 2 * e.rowLength * 4);
        let c = i.getRGBTransferFunction();
        if (c) {
          const f = new Float32Array(e.rowLength * 3);
          for (let u = 0; u < s; u++) {
            c = i.getRGBTransferFunction(u);
            const h = c.getRange();
            c.getTable(h[0], h[1], e.rowLength, f, 1);
            for (let g = 0; g < e.rowLength; g++) {
              const v = u * e.rowLength * 8 + g * 4;
              l[v] = 255 * f[g * 3], l[v + 1] = 255 * f[g * 3 + 1], l[v + 2] = 255 * f[g * 3 + 2], l[v + 3] = 255;
              for (let m = 0; m < 4; m++) l[v + e.rowLength * 4 + m] = l[v + m];
            }
          }
        } else for (let f = 0; f < e.rowLength; ++f) {
          const u = 255 * f / (e.rowLength - 1);
          l[f * 4] = u, l[f * 4 + 1] = u, l[f * 4 + 2] = u, l[f * 4 + 3] = 255;
          for (let h = 0; h < 4; h++) l[f * 4 + e.rowLength * 4 + h] = l[f * 4 + h];
        }
        {
          const f = {
            nativeArray: l,
            width: e.rowLength,
            height: e.numRows * 2,
            depth: 1,
            format: "rgba8unorm"
          }, h = e.device.getTextureManager().getTexture(f).createView("tfunTexture");
          e.textureViews[1] = h;
        }
        e.colorTextureString = o;
      }
    };
    const n = t.updateBuffers;
    t.updateBuffers = () => {
      n();
      const i = e.device.getTextureManager().getTextureForImageData(e.currentInput), a = e.textureViews;
      if (!a[0] || a[0].getTexture() !== i) {
        const l = i.createView("imgTexture");
        a[0] = l;
      }
      t.updateLUTImage(), t.updateUBO();
      const o = e.WebGPUImageSlice.getRenderable().getProperty().getInterpolationType() === Bc.NEAREST ? "nearest" : "linear";
      (!e.clampSampler || o !== e.clampSampler.getOptions().minFilter) && (e.clampSampler = YO.newInstance({
        label: "clampSampler"
      }), e.clampSampler.create(e.device, {
        minFilter: o,
        magFilter: o
      }), e.additionalBindables = [
        e.clampSampler
      ]);
    };
    const r = t.getShaderReplacements();
    t.replaceShaderPosition = (i, a, s) => {
      const o = a.getShaderDescription("vertex");
      o.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
      let l = o.getCode();
      const c = [
        "var pos: vec4<f32> = mapperUBO.Origin +",
        "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;",
        "pos.w = 1.0;"
      ];
      e.dimensions === 2 ? c.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;") : c.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;"), c.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;"), l = Dn.substitute(l, "//VTK::Position::Impl", c).result, o.setCode(l);
    }, r.set("replaceShaderPosition", t.replaceShaderPosition), t.replaceShaderTCoord = (i, a, s) => {
      const o = a.getShaderDescription("vertex");
      e.dimensions === 2 ? o.addOutput("vec2<f32>", "tcoordVS") : o.addOutput("vec3<f32>", "tcoordVS");
    }, r.set("replaceShaderTCoord", t.replaceShaderTCoord), t.replaceShaderImage = (i, a, s) => {
      const o = a.getShaderDescription("fragment");
      let l = o.getCode();
      e.dimensions === 3 ? l = Dn.substitute(l, "//VTK::Image::Sample", [
        "    var computedColor: vec4<f32> =",
        "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);",
        "//VTK::Image::Sample"
      ]).result : l = Dn.substitute(l, "//VTK::Image::Sample", [
        "    var computedColor: vec4<f32> =",
        "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);",
        "//VTK::Image::Sample"
      ]).result, l = Dn.substitute(l, "//VTK::Image::Sample", [
        "    var coord: vec2<f32> =",
        "      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);",
        "    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);"
      ]).result, o.setCode(l);
    }, r.set("replaceShaderImage", t.replaceShaderImage);
  }
  const nre = {
    rowLength: 1024
  };
  function rre(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, nre, n), g6.extend(t, e, n), t.setFragmentShaderTemplate($ne), e.UBO = wu.newInstance({
      label: "mapperUBO"
    }), e.UBO.addEntry("SCTCMatrix", "mat4x4<f32>"), e.UBO.addEntry("Origin", "vec4<f32>"), e.UBO.addEntry("Axis2", "vec4<f32>"), e.UBO.addEntry("Axis1", "vec4<f32>"), e.UBO.addEntry("cScale", "vec4<f32>"), e.UBO.addEntry("cShift", "vec4<f32>"), e.lutBuildTime = {}, _n(e.lutBuildTime, {
      mtime: 0
    }), e.imagemat = gt(new Float64Array(16)), e.imagematinv = gt(new Float64Array(16)), e.VBOBuildTime = {}, _n(e.VBOBuildTime), tre(t, e);
  }
  const ire = pn(rre, "vtkWebGPUImageMapper");
  ka("vtkImageMapper", ire);
  function are(t, e) {
    e.classHierarchy.push("vtkWebGPUImageSlice"), t.buildPass = (n) => {
      if (!(!e.renderable || !e.renderable.getVisibility()) && n) {
        if (!e.renderable) return;
        e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow"), e.propID === void 0 && (e.propID = e.WebGPURenderWindow.getUniquePropID()), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes();
      }
    }, t.traverseOpaquePass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children.forEach((r) => {
        r.traverse(n);
      }), t.apply(n, false));
    }, t.traverseTranslucentPass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children.forEach((r) => {
        r.traverse(n);
      }), t.apply(n, false));
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
      }
    }, t.getBufferShift = (n) => (t.getKeyMatrices(n), e.bufferShift), t.getKeyMatrices = (n) => {
      if (Math.max(e.renderable.getMTime(), n.getStabilizedTime()) > e.keyMatricesTime.getMTime()) {
        e.renderable.computeMatrix();
        const r = e.renderable.getMatrix(), i = n.getStabilizedCenterByReference();
        e.bufferShift[0] = r[3] - i[0], e.bufferShift[1] = r[7] - i[1], e.bufferShift[2] = r[11] - i[2], en(e.keyMatrices.bcwc, r), e.renderable.getIsIdentity() ? gt(e.keyMatrices.normalMatrix) : (sr(e.keyMatrices.normalMatrix, e.keyMatrices.bcwc), e.keyMatrices.normalMatrix[3] = 0, e.keyMatrices.normalMatrix[7] = 0, e.keyMatrices.normalMatrix[11] = 0, Nr(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), en(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix)), $n(e.keyMatrices.bcwc, e.keyMatrices.bcwc, [
          -e.bufferShift[0],
          -e.bufferShift[1],
          -e.bufferShift[2]
        ]), $n(e.keyMatrices.bcsc, e.keyMatrices.bcwc, [
          -i[0],
          -i[1],
          -i[2]
        ]), e.keyMatricesTime.modified();
      }
      return e.keyMatrices;
    };
  }
  const sre = {
    bufferShift: void 0,
    keyMatrixTime: null,
    keyMatrices: null,
    propID: void 0
  };
  function ore(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, sre, n), Rn.extend(t, e, n), e.keyMatricesTime = {}, _n(e.keyMatricesTime, {
      mtime: 0
    }), e.keyMatrices = {
      normalMatrix: new Float64Array(16),
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    }, e.keyMatrixTime = {}, _n(e.keyMatrixTime, {
      mtime: 0
    }), e.keyMatrices = {
      mcwc: gt(new Float64Array(16))
    }, e.bufferShift = [
      0,
      0,
      0,
      0
    ], Wi(t, e, [
      "propID",
      "keyMatricesTime"
    ]), are(t, e);
  }
  const lre = pn(ore, "vtkWebGPUImageSlice");
  ka("vtkImageSlice", lre);
  function cre(t, e) {
    e.classHierarchy.push("vtkWebGPUVolume"), t.buildPass = (i) => {
      !e.renderable || !e.renderable.getVisibility() || i && (e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow"), e.propID === void 0 && (e.propID = e.WebGPURenderWindow.getUniquePropID()), e.renderable.getMapper().update());
    }, t.queryPass = (i, a) => {
      if (i) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        const s = e.renderable.getMapper().getBounds();
        if (!s || s.length !== 6 || s[0] > s[1]) return;
        a.addVolume(t);
      }
    };
    const n = new Float64Array(3), r = new Float64Array(3);
    t.getBoundingCubePoints = (i, a) => {
      const s = e.renderable.getMapper().getInputData();
      if (!s) return;
      const o = s.getExtent(), l = e.renderable.getMatrix();
      let c = 0;
      for (let f = 4; f < 6; f++) {
        n[2] = o[f];
        for (let u = 2; u < 4; u++) {
          n[1] = o[u];
          for (let h = 0; h < 2; h++) {
            n[0] = o[h], s.indexToWorld(n, r);
            let g = a + c * 3;
            i[g++] = l[0] * r[0] + l[1] * r[1] + l[2] * r[2] + l[3], i[g++] = l[4] * r[0] + l[5] * r[1] + l[6] * r[2] + l[7], i[g++] = l[8] * r[0] + l[9] * r[1] + l[10] * r[2] + l[11], c++;
          }
        }
      }
    }, t.getKeyMatrices = (i) => {
      if (Math.max(e.renderable.getMTime(), i.getStabilizedTime()) > e.keyMatricesTime.getMTime()) {
        e.renderable.computeMatrix();
        const a = e.renderable.getMatrix(), s = i.getStabilizedCenterByReference();
        en(e.keyMatrices.bcwc, a), $n(e.keyMatrices.bcsc, e.keyMatrices.bcwc, [
          -s[0],
          -s[1],
          -s[2]
        ]), e.keyMatricesTime.modified();
      }
      return e.keyMatrices;
    };
  }
  const ure = {
    propID: void 0,
    keyMatricesTime: null
  };
  function fre(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, ure, n), Rn.extend(t, e, n), e.keyMatricesTime = {}, H.obj(e.keyMatricesTime, {
      mtime: 0
    }), e.keyMatrices = {
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    }, H.get(t, e, [
      "propID",
      "keyMatricesTime"
    ]), cre(t, e);
  }
  const hre = H.newInstance(fre, "vtkWebGPUVolume");
  ka("vtkVolume", hre);
  function dre(t, e) {
    e.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper"), t.opaquePass = (n, r) => {
      e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getParent();
      const i = e.WebGPURenderer.getAspectRatio(), a = e.WebGPURenderer ? e.WebGPURenderer.getRenderable().getActiveCamera() : null, s = e.WebGPURenderer.getTiledSizeAndOrigin(), o = null;
      e.renderable.getUseZValues(), e.renderable.invokeCallback(e.renderable.getInputData(), a, i, s, o);
    };
  }
  const gre = {};
  function pre(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, gre, n), Rn.extend(t, e, n), dre(t, e);
  }
  const mre = H.newInstance(pre, "vtkWebGPUPixelSpaceCallbackMapper");
  ka("vtkPixelSpaceCallbackMapper", mre);
  var Q1 = {
    exports: {}
  };
  Q1.exports;
  var nS;
  function vre() {
    return nS || (nS = 1, (function(t, e) {
      var n = 200, r = "__lodash_hash_undefined__", i = 9007199254740991, a = "[object Arguments]", s = "[object Array]", o = "[object Boolean]", l = "[object Date]", c = "[object Error]", f = "[object Function]", u = "[object GeneratorFunction]", h = "[object Map]", g = "[object Number]", v = "[object Object]", m = "[object Promise]", y = "[object RegExp]", w = "[object Set]", C = "[object String]", T = "[object Symbol]", S = "[object WeakMap]", E = "[object ArrayBuffer]", b = "[object DataView]", D = "[object Float32Array]", R = "[object Float64Array]", I = "[object Int8Array]", O = "[object Int16Array]", L = "[object Int32Array]", N = "[object Uint8Array]", F = "[object Uint8ClampedArray]", V = "[object Uint16Array]", k = "[object Uint32Array]", _ = /[\\^$.*+?()[\]{}|]/g, K = /\w*$/, Z = /^\[object .+?Constructor\]$/, j = /^(?:0|[1-9]\d*)$/, B = {};
      B[a] = B[s] = B[E] = B[b] = B[o] = B[l] = B[D] = B[R] = B[I] = B[O] = B[L] = B[h] = B[g] = B[v] = B[y] = B[w] = B[C] = B[T] = B[N] = B[F] = B[V] = B[k] = true, B[c] = B[f] = B[S] = false;
      var Y = typeof ci == "object" && ci && ci.Object === Object && ci, X = typeof self == "object" && self && self.Object === Object && self, ie = Y || X || Function("return this")(), oe = e && !e.nodeType && e, he = oe && true && t && !t.nodeType && t, Le = he && he.exports === oe;
      function Je($, ue) {
        return $.set(ue[0], ue[1]), $;
      }
      function Pe($, ue) {
        return $.add(ue), $;
      }
      function ot($, ue) {
        for (var Te = -1, Xe = $ ? $.length : 0; ++Te < Xe && ue($[Te], Te, $) !== false; ) ;
        return $;
      }
      function vt($, ue) {
        for (var Te = -1, Xe = ue.length, Ut = $.length; ++Te < Xe; ) $[Ut + Te] = ue[Te];
        return $;
      }
      function wt($, ue, Te, Xe) {
        for (var Ut = -1, Wt = $ ? $.length : 0; ++Ut < Wt; ) Te = ue(Te, $[Ut], Ut, $);
        return Te;
      }
      function Qe($, ue) {
        for (var Te = -1, Xe = Array($); ++Te < $; ) Xe[Te] = ue(Te);
        return Xe;
      }
      function _t6($, ue) {
        return $ == null ? void 0 : $[ue];
      }
      function G($) {
        var ue = false;
        if ($ != null && typeof $.toString != "function") try {
          ue = !!($ + "");
        } catch {
        }
        return ue;
      }
      function Se($) {
        var ue = -1, Te = Array($.size);
        return $.forEach(function(Xe, Ut) {
          Te[++ue] = [
            Ut,
            Xe
          ];
        }), Te;
      }
      function xe($, ue) {
        return function(Te) {
          return $(ue(Te));
        };
      }
      function re($) {
        var ue = -1, Te = Array($.size);
        return $.forEach(function(Xe) {
          Te[++ue] = Xe;
        }), Te;
      }
      var ne = Array.prototype, ce = Function.prototype, Oe = Object.prototype, Ve = ie["__core-js_shared__"], de = (function() {
        var $ = /[^.]+$/.exec(Ve && Ve.keys && Ve.keys.IE_PROTO || "");
        return $ ? "Symbol(src)_1." + $ : "";
      })(), We = ce.toString, Ze = Oe.hasOwnProperty, Ge = Oe.toString, at = RegExp("^" + We.call(Ze).replace(_, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ut = Le ? ie.Buffer : void 0, it = ie.Symbol, fn = ie.Uint8Array, jt = xe(Object.getPrototypeOf, Object), mr = Object.create, Di = Oe.propertyIsEnumerable, mn = ne.splice, Wr = Object.getOwnPropertySymbols, Ur = ut ? ut.isBuffer : void 0, ye = xe(Object.keys, Object), ke = q(ie, "DataView"), rt = q(ie, "Map"), sn = q(ie, "Promise"), ti = q(ie, "Set"), lr = q(ie, "WeakMap"), vn = q(Object, "create"), xa = lt(ke), Mo = lt(rt), za = lt(sn), fs = lt(ti), Ro = lt(lr), Oo = it ? it.prototype : void 0, _s = Oo ? Oo.valueOf : void 0;
      function vr($) {
        var ue = -1, Te = $ ? $.length : 0;
        for (this.clear(); ++ue < Te; ) {
          var Xe = $[ue];
          this.set(Xe[0], Xe[1]);
        }
      }
      function yr() {
        this.__data__ = vn ? vn(null) : {};
      }
      function Fr($) {
        return this.has($) && delete this.__data__[$];
      }
      function na($) {
        var ue = this.__data__;
        if (vn) {
          var Te = ue[$];
          return Te === r ? void 0 : Te;
        }
        return Ze.call(ue, $) ? ue[$] : void 0;
      }
      function ks($) {
        var ue = this.__data__;
        return vn ? ue[$] !== void 0 : Ze.call(ue, $);
      }
      function ff($, ue) {
        var Te = this.__data__;
        return Te[$] = vn && ue === void 0 ? r : ue, this;
      }
      vr.prototype.clear = yr, vr.prototype.delete = Fr, vr.prototype.get = na, vr.prototype.has = ks, vr.prototype.set = ff;
      function ra($) {
        var ue = -1, Te = $ ? $.length : 0;
        for (this.clear(); ++ue < Te; ) {
          var Xe = $[ue];
          this.set(Xe[0], Xe[1]);
        }
      }
      function Io() {
        this.__data__ = [];
      }
      function wa($) {
        var ue = this.__data__, Te = Ha(ue, $);
        if (Te < 0) return false;
        var Xe = ue.length - 1;
        return Te == Xe ? ue.pop() : mn.call(ue, Te, 1), true;
      }
      function Vo($) {
        var ue = this.__data__, Te = Ha(ue, $);
        return Te < 0 ? void 0 : ue[Te][1];
      }
      function Wa($) {
        return Ha(this.__data__, $) > -1;
      }
      function ia($, ue) {
        var Te = this.__data__, Xe = Ha(Te, $);
        return Xe < 0 ? Te.push([
          $,
          ue
        ]) : Te[Xe][1] = ue, this;
      }
      ra.prototype.clear = Io, ra.prototype.delete = wa, ra.prototype.get = Vo, ra.prototype.has = Wa, ra.prototype.set = ia;
      function Mi($) {
        var ue = -1, Te = $ ? $.length : 0;
        for (this.clear(); ++ue < Te; ) {
          var Xe = $[ue];
          this.set(Xe[0], Xe[1]);
        }
      }
      function hs() {
        this.__data__ = {
          hash: new vr(),
          map: new (rt || ra)(),
          string: new vr()
        };
      }
      function cr($) {
        return P(this, $).delete($);
      }
      function c0($) {
        return P(this, $).get($);
      }
      function No($) {
        return P(this, $).has($);
      }
      function Ca($, ue) {
        return P(this, $).set($, ue), this;
      }
      Mi.prototype.clear = hs, Mi.prototype.delete = cr, Mi.prototype.get = c0, Mi.prototype.has = No, Mi.prototype.set = Ca;
      function ni($) {
        this.__data__ = new ra($);
      }
      function u0() {
        this.__data__ = new ra();
      }
      function Hl($) {
        return this.__data__.delete($);
      }
      function f0($) {
        return this.__data__.get($);
      }
      function hf($) {
        return this.__data__.has($);
      }
      function Ri($, ue) {
        var Te = this.__data__;
        if (Te instanceof ra) {
          var Xe = Te.__data__;
          if (!rt || Xe.length < n - 1) return Xe.push([
            $,
            ue
          ]), this;
          Te = this.__data__ = new Mi(Xe);
        }
        return Te.set($, ue), this;
      }
      ni.prototype.clear = u0, ni.prototype.delete = Hl, ni.prototype.get = f0, ni.prototype.has = hf, ni.prototype.set = Ri;
      function ds($, ue) {
        var Te = $e($) || Mt($) ? Qe($.length, String) : [], Xe = Te.length, Ut = !!Xe;
        for (var Wt in $) Ze.call($, Wt) && !(Ut && (Wt == "length" || Be(Wt, Xe))) && Te.push(Wt);
        return Te;
      }
      function Oi($, ue, Te) {
        var Xe = $[ue];
        (!(Ze.call($, ue) && At(Xe, Te)) || Te === void 0 && !(ue in $)) && ($[ue] = Te);
      }
      function Ha($, ue) {
        for (var Te = $.length; Te--; ) if (At($[Te][0], ue)) return Te;
        return -1;
      }
      function jl($, ue) {
        return $ && Uo(ue, nt(ue), $);
      }
      function aa($, ue, Te, Xe, Ut, Wt, nn) {
        var wn;
        if (Xe && (wn = Wt ? Xe($, Ut, Wt, nn) : Xe($)), wn !== void 0) return wn;
        if (!Qt($)) return $;
        var tr = $e($);
        if (tr) {
          if (wn = Ae($), !ue) return Gs($, wn);
        } else {
          var Xn = ge($), xr = Xn == f || Xn == u;
          if (Kt($)) return h0($, ue);
          if (Xn == v || Xn == a || xr && !Wt) {
            if (G($)) return Wt ? $ : {};
            if (wn = Ee(xr ? {} : $), !ue) return ps($, jl(wn, $));
          } else {
            if (!B[Xn]) return Wt ? $ : {};
            wn = De($, Xn, aa, ue);
          }
        }
        nn || (nn = new ni());
        var yi = nn.get($);
        if (yi) return yi;
        if (nn.set($, wn), !tr) var Ii = Te ? z($) : nt($);
        return ot(Ii || $, function(br, Yn) {
          Ii && (Yn = br, br = $[Yn]), Oi(wn, Yn, aa(br, ue, Te, Xe, Yn, $, nn));
        }), wn;
      }
      function Hi($) {
        return Qt($) ? mr($) : {};
      }
      function Ta($, ue, Te) {
        var Xe = ue($);
        return $e($) ? Xe : vt(Xe, Te($));
      }
      function Kl($) {
        return Ge.call($);
      }
      function gs($) {
        if (!Qt($) || _e11($)) return false;
        var ue = xt($) || G($) ? at : Z;
        return ue.test(lt($));
      }
      function mi($) {
        if (!et($)) return ye($);
        var ue = [];
        for (var Te in Object($)) Ze.call($, Te) && Te != "constructor" && ue.push(Te);
        return ue;
      }
      function h0($, ue) {
        if (ue) return $.slice();
        var Te = new $.constructor($.length);
        return $.copy(Te), Te;
      }
      function Yl($) {
        var ue = new $.constructor($.byteLength);
        return new fn(ue).set(new fn($)), ue;
      }
      function Lo($, ue) {
        var Te = ue ? Yl($.buffer) : $.buffer;
        return new $.constructor(Te, $.byteOffset, $.byteLength);
      }
      function d0($, ue, Te) {
        var Xe = ue ? Te(Se($), true) : Se($);
        return wt(Xe, Je, new $.constructor());
      }
      function Ps($) {
        var ue = new $.constructor($.source, K.exec($));
        return ue.lastIndex = $.lastIndex, ue;
      }
      function df($, ue, Te) {
        var Xe = ue ? Te(re($), true) : re($);
        return wt(Xe, Pe, new $.constructor());
      }
      function vi($) {
        return _s ? Object(_s.call($)) : {};
      }
      function ql($, ue) {
        var Te = ue ? Yl($.buffer) : $.buffer;
        return new $.constructor(Te, $.byteOffset, $.length);
      }
      function Gs($, ue) {
        var Te = -1, Xe = $.length;
        for (ue || (ue = Array(Xe)); ++Te < Xe; ) ue[Te] = $[Te];
        return ue;
      }
      function Uo($, ue, Te, Xe) {
        Te || (Te = {});
        for (var Ut = -1, Wt = ue.length; ++Ut < Wt; ) {
          var nn = ue[Ut], wn = void 0;
          Oi(Te, nn, wn === void 0 ? $[nn] : wn);
        }
        return Te;
      }
      function ps($, ue) {
        return Uo($, te($), ue);
      }
      function z($) {
        return Ta($, nt, te);
      }
      function P($, ue) {
        var Te = $.__data__;
        return Me(ue) ? Te[typeof ue == "string" ? "string" : "hash"] : Te.map;
      }
      function q($, ue) {
        var Te = _t6($, ue);
        return gs(Te) ? Te : void 0;
      }
      var te = Wr ? xe(Wr, Object) : Nn, ge = Kl;
      (ke && ge(new ke(new ArrayBuffer(1))) != b || rt && ge(new rt()) != h || sn && ge(sn.resolve()) != m || ti && ge(new ti()) != w || lr && ge(new lr()) != S) && (ge = function($) {
        var ue = Ge.call($), Te = ue == v ? $.constructor : void 0, Xe = Te ? lt(Te) : void 0;
        if (Xe) switch (Xe) {
          case xa:
            return b;
          case Mo:
            return h;
          case za:
            return m;
          case fs:
            return w;
          case Ro:
            return S;
        }
        return ue;
      });
      function Ae($) {
        var ue = $.length, Te = $.constructor(ue);
        return ue && typeof $[0] == "string" && Ze.call($, "index") && (Te.index = $.index, Te.input = $.input), Te;
      }
      function Ee($) {
        return typeof $.constructor == "function" && !et($) ? Hi(jt($)) : {};
      }
      function De($, ue, Te, Xe) {
        var Ut = $.constructor;
        switch (ue) {
          case E:
            return Yl($);
          case o:
          case l:
            return new Ut(+$);
          case b:
            return Lo($, Xe);
          case D:
          case R:
          case I:
          case O:
          case L:
          case N:
          case F:
          case V:
          case k:
            return ql($, Xe);
          case h:
            return d0($, Xe, Te);
          case g:
          case C:
            return new Ut($);
          case y:
            return Ps($);
          case w:
            return df($, Xe, Te);
          case T:
            return vi($);
        }
      }
      function Be($, ue) {
        return ue = ue ?? i, !!ue && (typeof $ == "number" || j.test($)) && $ > -1 && $ % 1 == 0 && $ < ue;
      }
      function Me($) {
        var ue = typeof $;
        return ue == "string" || ue == "number" || ue == "symbol" || ue == "boolean" ? $ !== "__proto__" : $ === null;
      }
      function _e11($) {
        return !!de && de in $;
      }
      function et($) {
        var ue = $ && $.constructor, Te = typeof ue == "function" && ue.prototype || Oe;
        return $ === Te;
      }
      function lt($) {
        if ($ != null) {
          try {
            return We.call($);
          } catch {
          }
          try {
            return $ + "";
          } catch {
          }
        }
        return "";
      }
      function St($) {
        return aa($, true, true);
      }
      function At($, ue) {
        return $ === ue || $ !== $ && ue !== ue;
      }
      function Mt($) {
        return It($) && Ze.call($, "callee") && (!Di.call($, "callee") || Ge.call($) == a);
      }
      var $e = Array.isArray;
      function Lt($) {
        return $ != null && on($.length) && !xt($);
      }
      function It($) {
        return Pt($) && Lt($);
      }
      var Kt = Ur || Xt;
      function xt($) {
        var ue = Qt($) ? Ge.call($) : "";
        return ue == f || ue == u;
      }
      function on($) {
        return typeof $ == "number" && $ > -1 && $ % 1 == 0 && $ <= i;
      }
      function Qt($) {
        var ue = typeof $;
        return !!$ && (ue == "object" || ue == "function");
      }
      function Pt($) {
        return !!$ && typeof $ == "object";
      }
      function nt($) {
        return Lt($) ? ds($) : mi($);
      }
      function Nn() {
        return [];
      }
      function Xt() {
        return false;
      }
      t.exports = St;
    })(Q1, Q1.exports)), Q1.exports;
  }
  var yre = vre();
  const Ar = t0(yre);
  function qO(t) {
    const { enableCacheOptimization: e } = Do(), n = Qu();
    e && n && je.addEventListenerOnce(ze.IMAGE_VOLUME_LOADING_COMPLETED, (i) => {
      if (i.detail.volumeId !== t) return;
      const a = Ke.getVolume(t);
      uy(a);
    });
  }
  function uy(t) {
    if (!(t instanceof Gl)) return;
    const e = t.getScalarData();
    t.imageCacheOffsetMap.size > 0 ? xre(t, e) : wre(t, e);
  }
  function xre(t, e) {
    t.imageCacheOffsetMap.forEach(({ offset: n }, r) => {
      const i = Ke.getImage(r);
      i && (XO(i, e, n), Ke.decrementImageCacheSize(i.sizeInBytes));
    });
  }
  function wre(t, e) {
    var _a3;
    let n = e;
    const r = t.imageIds.find((s) => Ke.getImage(s));
    if (!r) return;
    const i = Ke.getImage(r), a = ((_a3 = i.imageFrame) == null ? void 0 : _a3.pixelData) || i.getPixelData();
    e.constructor !== a.constructor && (n = new a.constructor(e.length), n.set(e)), t.imageIds.forEach((s) => {
      const o = Ke.getImage(s);
      if (!o) return;
      const c = t.getImageIdIndex(s) * o.getPixelData().byteLength;
      XO(o, n, c), Ke.decrementImageCacheSize(o.sizeInBytes);
    });
  }
  function XO(t, e, n) {
    const r = t.imageFrame ? t.imageFrame.pixelData : t.getPixelData(), i = new r.constructor(e.buffer, n, r.length);
    t.getPixelData = () => i, t.imageFrame && (t.imageFrame.pixelData = i), t.bufferView = {
      buffer: e.buffer,
      offset: n
    };
  }
  const Cre = Object.freeze(Object.defineProperty({
    __proto__: null,
    performCacheOptimizationForVolume: uy,
    setupCacheOptimizationEventListener: qO
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function Tre(t, e, n) {
    const r = Tt.newInstance({
      name: "Pixels",
      values: e,
      ...n
    });
    t.getPointData().setScalars(r);
  }
  function Sre(t, e, n) {
    e.forEach((r, i) => {
      const a = Tt.newInstance({
        name: `timePoint-${i}`,
        values: r,
        ...n
      });
      t.getPointData().addArray(a);
    }), t.getPointData().setActiveScalars("timePoint-0");
  }
  function ZO(t) {
    const { dimensions: e, metadata: n, spacing: r, direction: i, origin: a } = t, { PhotometricInterpretation: s } = n;
    let o = 1;
    s === "RGB" && (o = 3);
    const l = Bl.newInstance(), c = {
      numberOfComponents: o
    };
    if (l.setDimensions(e), l.setSpacing(r), l.setDirection(i), l.setOrigin(a), t.isDynamicVolume()) {
      const f = t.getScalarDataArrays();
      Sre(l, f, c);
    } else {
      const f = t.getScalarData();
      Tre(l, f, c);
    }
    return l;
  }
  const fy = {};
  let Are;
  function QO(t, e) {
    const n = t.indexOf(":"), r = t.substring(0, n);
    let i = fy[r];
    if (i == null) throw new Error(`No volume loader for scheme ${r} has been registered`);
    const a = i(t, e);
    return qO(t), a.promise.then(function(s) {
      qe(je, ze.VOLUME_LOADED, {
        volume: s
      });
    }, function(s) {
      const o = {
        volumeId: t,
        error: s
      };
      qe(je, ze.VOLUME_LOADED_FAILED, o);
    }), a;
  }
  function JO(t, e = {
    imageIds: []
  }) {
    if (t === void 0) throw new Error("loadVolume: parameter volumeId must not be undefined");
    let n = Ke.getVolumeLoadObject(t);
    return n !== void 0 ? n.promise : (n = QO(t, e), n.promise.then((r) => (r.imageData = ZO(r), r)));
  }
  async function m6(t, e) {
    if (t === void 0) throw new Error("createAndCacheVolume: parameter volumeId must not be undefined");
    let n = Ke.getVolumeLoadObject(t);
    return n !== void 0 || (n = QO(t, e), n.promise.then((r) => {
      r.imageData = ZO(r);
    }), Ke.putVolumeLoadObject(t, n).catch((r) => {
      throw r;
    })), n.promise;
  }
  async function Ere(t, e) {
    const n = Ke.getVolume(t);
    if (!n) throw new Error(`Cannot created derived volume: Referenced volume with id ${t} does not exist.`);
    let { volumeId: r } = e;
    const { targetBuffer: i } = e;
    r === void 0 && (r = gi());
    const { metadata: a, dimensions: s, spacing: o, origin: l, direction: c } = n, u = n.getScalarData().length, { volumeScalarData: h, numBytes: g } = eI(i, u), v = Tt.newInstance({
      name: "Pixels",
      numberOfComponents: 1,
      values: h
    }), m = Bl.newInstance();
    m.setDimensions(s), m.setSpacing(o), m.setDirection(c), m.setOrigin(l), m.getPointData().setScalars(v);
    const y = new Gl({
      volumeId: r,
      metadata: Ar(a),
      dimensions: [
        s[0],
        s[1],
        s[2]
      ],
      spacing: o,
      origin: l,
      direction: c,
      imageData: m,
      scalarData: h,
      sizeInBytes: g,
      imageIds: [],
      referencedVolumeId: t
    }), w = {
      promise: Promise.resolve(y)
    };
    return await Ke.putVolumeLoadObject(r, w), y;
  }
  function bre(t, e, n = false) {
    const { metadata: r, dimensions: i, spacing: a, origin: s, direction: o, targetBuffer: l } = t;
    let { scalarData: c } = t;
    const f = [
      "Uint8Array",
      "Float32Array",
      "Uint16Array",
      "Int16Array"
    ], u = i[0] * i[1] * i[2];
    if (!c || !f.includes(c.constructor.name)) {
      if (!(l == null ? void 0 : l.type) || !f.includes(l.type)) throw new Error("createLocalVolume: parameter scalarData must be provided and must be either Uint8Array, Float32Array, Uint16Array or Int16Array");
      ({ volumeScalarData: c } = eI(l, u));
    }
    e === void 0 && (e = gi());
    const h = Ke.getVolume(e);
    if (h) return h;
    const g = c ? c.buffer.byteLength : u * 4;
    if (!Ke.isCacheable(g)) throw new Error(ze.CACHE_SIZE_EXCEEDED);
    const m = Tt.newInstance({
      name: "Pixels",
      numberOfComponents: 1,
      values: c
    }), y = Bl.newInstance();
    y.setDimensions(i), y.setSpacing(a), y.setDirection(o), y.setOrigin(s), y.getPointData().setScalars(m);
    const w = new Gl({
      volumeId: e,
      metadata: Ar(r),
      dimensions: [
        i[0],
        i[1],
        i[2]
      ],
      spacing: a,
      origin: s,
      direction: o,
      imageData: y,
      scalarData: c,
      sizeInBytes: g,
      referencedImageIds: t.referencedImageIds || [],
      referencedVolumeId: t.referencedVolumeId,
      imageIds: t.imageIds || []
    });
    if (n) return w;
    const C = {
      promise: Promise.resolve(w)
    };
    return Ke.putVolumeLoadObject(e, C), w;
  }
  async function Dre(t, e, n = {}) {
    const { preventCache: r = false } = n;
    if (e === void 0) throw new Error("createAndCacheVolumeFromImages: parameter imageIds must not be undefined");
    if (t === void 0) throw new Error("createAndCacheVolumeFromImages: parameter volumeId must not be undefined");
    const i = Ke.getVolume(t);
    if (i) return Promise.resolve(i);
    const a = O5(e, t), s = a.imageIds.map((c, f) => Ke.getImageLoadObject(c).promise.then((h) => {
      const g = h.getPixelData(), v = f * h.rows * h.columns;
      a.scalarData.set(g, v);
    }));
    await Promise.all(s);
    const o = new Gl({
      ...a,
      referencedImageIds: e,
      ...n
    });
    uy(o);
    const l = {
      promise: Promise.resolve(o)
    };
    return r || Ke.putVolumeLoadObject(t, l), l.promise;
  }
  function Mre(t, e) {
    fy[t] = e;
  }
  function Rre() {
    return Object.keys(fy);
  }
  function Ore() {
    return Are.name;
  }
  async function Ire(t, e = {}) {
    return Ere(t, {
      ...e,
      targetBuffer: {
        type: "Uint8Array"
      }
    });
  }
  async function $O(t, e, n = false) {
    return t.scalarData || (t.scalarData = new Uint8Array(t.dimensions[0] * t.dimensions[1] * t.dimensions[2])), bre(t, e, n);
  }
  function eI(t, e) {
    const { useNorm16Texture: n } = Do().rendering, { TypedArrayConstructor: r, numBytes: i } = R5(t == null ? void 0 : t.type, e, {
      use16BitTexture: n,
      isVolumeBuffer: true
    });
    if (!Ke.isCacheable(i)) throw new Error(ze.CACHE_SIZE_EXCEEDED);
    let s;
    if ((t == null ? void 0 : t.sharedArrayBuffer) ?? Qu()) switch (t.type) {
      case "Float32Array":
        s = fh(e);
        break;
      case "Uint8Array":
        s = gp(e);
        break;
      case "Uint16Array":
        s = pp(e);
        break;
      case "Int16Array":
        s = pp(e);
        break;
      default:
        throw new Error("generateVolumeScalarData: SharedArrayBuffer is not supported for the specified target buffer type");
    }
    else s = new r(e);
    return {
      volumeScalarData: s,
      numBytes: i
    };
  }
  const nf = (t) => {
    const e = "volumeId:", n = t.includes(e) ? t.substring(e.length) : t, r = n.indexOf("sliceIndex=");
    return r === -1 ? n : n.substring(0, r - 1);
  }, Vre = 1 + Vl, Nre = (t, e) => e === t.substring(0, Math.min(t.length, e.length)), rS = (t) => !!Rre().find((e) => Nre(t.volumeId, e));
  function ad(t, e, n, r = false) {
    const { viewPlaneNormal: i } = e, a = t.getActors();
    if (!a || !a.length) return {
      spacingInNormalDirection: null,
      imageVolume: null,
      actorUID: null
    };
    const s = a.map((c) => {
      const f = c.referenceId ?? c.uid;
      return Ke.getVolume(f);
    }).filter((c) => !!c);
    if (n) {
      const c = nf(n), f = s.findIndex((v) => c.includes(v.volumeId)), u = s[f], { uid: h } = a[f], g = iS(u, i, t, r);
      return {
        imageVolume: u,
        spacingInNormalDirection: g,
        actorUID: h
      };
    }
    if (!s.length) return {
      spacingInNormalDirection: null,
      imageVolume: null,
      actorUID: null
    };
    const o = {
      spacingInNormalDirection: 1 / 0,
      imageVolume: null,
      actorUID: null
    }, l = s.find(rS);
    for (let c = 0; c < s.length; c++) {
      const f = s[c];
      if (l && !rS(f)) continue;
      const u = iS(f, i, t);
      u * Vre < o.spacingInNormalDirection && (o.spacingInNormalDirection = u, o.imageVolume = f, o.actorUID = a[c].uid);
    }
    return o;
  }
  function iS(t, e, n, r = false) {
    const { slabThickness: i } = n.getProperties();
    let a = i;
    return (!i || r === false) && (a = Vu(t, e)), a;
  }
  function tI(t) {
    const e = t.getMapper().getInputData(), n = e.extentToBounds(e.getExtent());
    return [
      [
        n[0],
        n[2],
        n[4]
      ],
      [
        n[0],
        n[2],
        n[5]
      ],
      [
        n[0],
        n[3],
        n[4]
      ],
      [
        n[0],
        n[3],
        n[5]
      ],
      [
        n[1],
        n[2],
        n[4]
      ],
      [
        n[1],
        n[2],
        n[5]
      ],
      [
        n[1],
        n[3],
        n[4]
      ],
      [
        n[1],
        n[3],
        n[5]
      ]
    ];
  }
  function Lre(t, e) {
    return !(t[0] < 0 || t[0] >= e[0] || t[1] < 0 || t[1] >= e[1] || t[2] < 0 || t[2] >= e[2]);
  }
  function Ure(t, e) {
    let n;
    e ? n = [
      _a(e)
    ] : n = Pl();
    const r = [];
    return n.forEach((i) => {
      const a = t.getActors(), s = i.getVolumeViewports();
      for (const o of s) {
        const l = o.getActors();
        if (l.length !== a.length) continue;
        a.every(({ uid: f }) => l.find((u) => f === u.uid)) && r.push(o);
      }
    }), r;
  }
  function nI(t, e) {
    let n;
    e ? n = [
      _a(e)
    ] : n = Pl();
    const r = [];
    return n.forEach((i) => {
      const s = i.getVolumeViewports().filter((o) => o.hasVolumeId(t));
      r.push(...s);
    }), r;
  }
  function wl(t, e) {
    return t.worldToIndex(e).map(Math.round);
  }
  function rI(t, e) {
    return t.indexToWorld(e);
  }
  const i0 = new _D("imageLoadPool");
  i0.grabDelay = 0;
  i0.setMaxSimultaneousRequests(ar.Interaction, 1e3);
  i0.setMaxSimultaneousRequests(ar.Thumbnail, 1e3);
  i0.setMaxSimultaneousRequests(ar.Prefetch, 1e3);
  const Fre = {};
  function aS(t, e) {
    const n = t.indexOf(":"), r = t.substring(0, n), i = Fre[r];
    if (i == null) throw new Error("loadImageFromImageLoader: no image loader for imageId");
    const a = i(t, e);
    return a.promise.then(function(s) {
      qe(je, ze.IMAGE_LOADED, {
        image: s
      });
    }, function(s) {
      const o = {
        imageId: t,
        error: s
      };
      qe(je, ze.IMAGE_LOAD_FAILED, o);
    }), a;
  }
  function Bre(t, e) {
    var _a3, _b3;
    if (e.ignoreCache) return aS(t, e);
    let n = Ke.getImageLoadObject(t);
    if (n !== void 0) return n;
    const r = Ke.getVolumeContainingImageId(t);
    if ((_b3 = (_a3 = r == null ? void 0 : r.volume) == null ? void 0 : _a3.loadStatus) == null ? void 0 : _b3.loaded) {
      const { volume: a, imageIdIndex: s } = r;
      return a instanceof Gl && (n = a.convertToCornerstoneImage(t, s)), n;
    }
    const i = Ke.getCachedImageBasedOnImageURI(t);
    return i ? (n = i.imageLoadObject, n) : (n = aS(t, e), n);
  }
  function Eh(t, e = {
    priority: 0,
    requestType: "prefetch"
  }) {
    if (t === void 0) throw new Error("loadAndCacheImage: parameter imageId must not be undefined");
    const n = Bre(t, e);
    return Ke.getImageLoadObject(t) || Ke.putImageLoadObject(t, n).catch((r) => {
      console.warn(r);
    }), n.promise;
  }
  function _re(t, e = {}, n = false) {
    if (t === void 0) throw new Error("createAndCacheDerivedImage: parameter imageId must not be undefined");
    e.imageId === void 0 && (e.imageId = `derived:${gi()}`);
    const { imageId: r, skipCreateBuffer: i, onCacheAdd: a } = e, s = Ct("imagePlaneModule", t), o = s.rows * s.columns, { TypedArrayConstructor: l } = R5(e.targetBufferType, o), c = new l(i ? 1 : o), f = r;
    [
      "imagePlaneModule",
      "generalSeriesModule"
    ].forEach((v) => {
      Nu.add(f, {
        type: v,
        metadata: Ct(v, t)
      });
    });
    const u = Ct("imagePixelModule", t);
    Nu.add(f, {
      type: "imagePixelModule",
      metadata: {
        ...u,
        bitsAllocated: 8,
        bitsStored: 8,
        highBit: 7,
        samplesPerPixel: 1,
        pixelRepresentation: 0
      }
    });
    const h = Pre({
      scalarData: c,
      onCacheAdd: a,
      skipCreateBuffer: i
    }, r, true), g = {
      promise: Promise.resolve(h)
    };
    return n || Ke.putImageLoadObject(f, g), g.promise;
  }
  function kre(t, e = {}) {
    if ((t == null ? void 0 : t.length) === 0) throw new Error("createAndCacheDerivedImages: parameter imageIds must be list of image Ids");
    const n = [], r = t.map((i) => {
      var _a3;
      const a = {
        imageId: ((_a3 = e.getDerivedImageId) == null ? void 0 : _a3.call(e, i)) || `derived:${gi()}`,
        ...e
      };
      return n.push(a.imageId), _re(i, a);
    });
    return {
      imageIds: n,
      promises: r
    };
  }
  function Pre(t, e, n = false) {
    var _a3;
    const r = Ct("imagePlaneModule", e), i = r.rows * r.columns, a = {
      imageId: e,
      intercept: 0,
      windowCenter: 0,
      windowWidth: 0,
      color: false,
      numComps: 1,
      slope: 1,
      minPixelValue: 0,
      maxPixelValue: 255,
      voiLUTFunction: void 0,
      rows: r.rows,
      columns: r.columns,
      getCanvas: void 0,
      height: r.rows,
      width: r.columns,
      rgba: void 0,
      columnPixelSpacing: r.columnPixelSpacing,
      rowPixelSpacing: r.rowPixelSpacing,
      invert: false
    };
    if (t.scalarData) {
      const o = t.scalarData;
      if (!(o instanceof Uint8Array || o instanceof Float32Array || o instanceof Uint16Array || o instanceof Int16Array)) throw new Error("To use createLocalVolume you should pass scalarData of type Uint8Array, Uint16Array, Int16Array or Float32Array");
      a.sizeInBytes = o.byteLength, a.getPixelData = () => o;
    } else if (t.skipCreateBuffer !== true) {
      const { numBytes: o, TypedArrayConstructor: l } = R5(t.targetBufferType, i), c = new l(i);
      a.sizeInBytes = o, a.getPixelData = () => c;
    }
    (_a3 = t.onCacheAdd) == null ? void 0 : _a3.call(t, a);
    const s = {
      promise: Promise.resolve(a)
    };
    return n || Ke.putImageLoadObject(a.imageId, s), a;
  }
  function Gre(t, e = {
    targetBufferType: "Uint8Array"
  }) {
    return kre(t, e);
  }
  const iI = "viewport-element", aI = "cornerstone-canvas", Dp = 1e-4;
  function zre(t) {
    const e = document.createElement("canvas");
    return e.style.position = "absolute", e.style.width = "100%", e.style.height = "100%", e.style.imageRendering = "pixelated", e.classList.add(aI), t.appendChild(e), e;
  }
  function Wre(t) {
    const e = document.createElement("div");
    return e.style.position = "relative", e.style.width = "100%", e.style.height = "100%", e.style.overflow = "hidden", e.classList.add(iI), t.appendChild(e), e;
  }
  function co(t) {
    const e = `canvas.${aI}`, n = `div.${iI}`, r = t.querySelector(n) || Wre(t), i = r.querySelector(e) || zre(r), a = r.getBoundingClientRect(), s = window.devicePixelRatio || 1, o = Math.ceil(a.width * s), l = Math.ceil(a.height * s);
    return i.width = o, i.height = l, i.style.width = (o + Dp) / s + "px", i.style.height = (l + Dp) / s + "px", i;
  }
  const sI = (t) => {
    var _a3, _b3;
    return ((_a3 = t.preScale) == null ? void 0 : _a3.scaled) && ((_b3 = t.preScale.scalingParameters) == null ? void 0 : _b3.suvbw);
  };
  function oI(t, e, n = void 0, r = "_thumbnails", i = {
    displayArea: {
      imageArea: [
        1,
        1
      ]
    }
  }) {
    if (!t || !(t instanceof HTMLCanvasElement)) throw new Error("canvas element is required");
    const a = !e.imageId, s = !a && e, o = a && e, c = `renderGPUViewport-${(s == null ? void 0 : s.imageId) || (o == null ? void 0 : o.volumeId)}`, f = document.createElement("div"), u = window.devicePixelRatio || 1;
    i.displayArea || (i.displayArea = {
      imageArea: [
        1,
        1
      ]
    });
    const h = t.width, g = t.height;
    f.style.width = `${h / u + Dp}px`, f.style.height = `${g / u + Dp}px`, f.style.visibility = "hidden", f.style.position = "absolute", document.body.appendChild(f);
    const v = c.split(":").join("-");
    f.setAttribute("viewport-id-for-remove", v);
    const m = co(f), y = _a(r) || new BI(r);
    let w = y.getViewport(c);
    if (!w) {
      const C = {
        viewportId: c,
        type: a ? Hn.ORTHOGRAPHIC : Hn.STACK,
        element: f,
        defaultOptions: {
          ...i,
          suppressEvents: true
        }
      };
      y.enableElement(C), w = y.getViewport(c);
    }
    return new Promise((C) => {
      let T = false, { viewReference: S } = i;
      const E = (b) => {
        if (T) return;
        if (S) {
          const N = S;
          S = null, w.setViewReference(N), w.render();
          return;
        }
        t.getContext("2d").drawImage(m, 0, 0, m.width, m.height, 0, 0, t.width, t.height);
        const R = w.canvasToWorld([
          0,
          0
        ]), I = w.canvasToWorld([
          m.width / u,
          0
        ]), O = w.canvasToWorld([
          0,
          m.height / u
        ]), L = 1;
        T = true, f.removeEventListener(ze.IMAGE_RENDERED, E), setTimeout(() => {
          y.disableElement(c), document.querySelectorAll(`[viewport-id-for-remove="${v}"]`).forEach((F) => {
            F.remove();
          });
        }, 0), C({
          origin: R,
          bottomLeft: O,
          topRight: I,
          thicknessMm: L
        });
      };
      f.addEventListener(ze.IMAGE_RENDERED, E), a ? w.setVolumes([
        o
      ], false, true) : w.renderImageObject(e), w.resetCamera(), n === "PT" && !sI(s) && w.setProperties({
        voiRange: {
          lower: s.minPixelValue,
          upper: s.maxPixelValue
        }
      }), w.render();
    });
  }
  const Hre = {
    viewport: {}
  };
  function jre() {
    return {
      tlhc: {
        x: 1,
        y: 1
      },
      brhc: {
        x: 1,
        y: 1
      },
      rowPixelSpacing: 1,
      columnPixelSpacing: 1,
      presentationSizeMode: "NONE"
    };
  }
  function Kre() {
    const t = jre();
    return Object.assign({}, {
      scale: 1,
      translation: {
        x: 0,
        y: 0
      },
      voi: {
        windowWidth: void 0,
        windowCenter: void 0
      },
      invert: false,
      pixelReplication: false,
      rotation: 0,
      hflip: false,
      vflip: false,
      modalityLUT: void 0,
      voiLUT: void 0,
      colormap: void 0,
      labelmap: false,
      displayedArea: t
    }, Hre.viewport);
  }
  function ph(t, e) {
    if (t == null) throw new Error(e);
  }
  function Yre(t) {
    return !(t == null || t === 0 || t === 180);
  }
  function lI(t, e = null) {
    return ph(t, "getImageSize: parameter image must not be undefined"), ph(t.width, "getImageSize: parameter image must have width"), ph(t.height, "getImageSize: parameter image must have height"), Yre(e) ? {
      height: t.width,
      width: t.height
    } : {
      width: t.width,
      height: t.height
    };
  }
  function hy(t, e, n = null) {
    ph(t, "getImageScale: parameter canvas must not be undefined"), ph(e, "getImageScale: parameter image must not be undefined");
    const r = lI(e, n), i = e.rowPixelSpacing || 1, a = e.columnPixelSpacing || 1;
    let s = 1, o = 1;
    i < a ? o = a / i : s = i / a;
    const l = t.height / r.height / s, c = t.width / r.width / o;
    return {
      verticalScale: l,
      horizontalScale: c,
      scaleFactor: Math.min(c, l)
    };
  }
  function cI(t, e, n, r) {
    if (t === void 0) throw new Error("getDefaultViewport: parameter canvas must not be undefined");
    if (e === void 0) return Kre();
    const i = hy(t, e, 0).scaleFactor;
    let a;
    return n === "PT" && e.isPreScaled ? a = {
      windowWidth: 5,
      windowCenter: 2.5
    } : e.windowWidth !== void 0 && e.windowCenter !== void 0 && (a = {
      windowWidth: Array.isArray(e.windowWidth) ? e.windowWidth[0] : e.windowWidth,
      windowCenter: Array.isArray(e.windowCenter) ? e.windowCenter[0] : e.windowCenter
    }), {
      scale: i,
      translation: {
        x: 0,
        y: 0
      },
      voi: a,
      invert: e.invert,
      pixelReplication: false,
      rotation: 0,
      hflip: false,
      vflip: false,
      modalityLUT: e.modalityLUT,
      modality: n,
      voiLUT: e.voiLUT,
      colormap: r !== void 0 ? r : e.colormap,
      displayedArea: {
        tlhc: {
          x: 1,
          y: 1
        },
        brhc: {
          x: e.columns,
          y: e.rows
        },
        rowPixelSpacing: e.rowPixelSpacing === void 0 ? 1 : e.rowPixelSpacing,
        columnPixelSpacing: e.columnPixelSpacing === void 0 ? 1 : e.columnPixelSpacing,
        presentationSizeMode: "NONE"
      }
    };
  }
  class rf {
    constructor() {
      this.reset();
    }
    getMatrix() {
      return this.m;
    }
    reset() {
      this.m = [
        1,
        0,
        0,
        1,
        0,
        0
      ];
    }
    clone() {
      const e = new rf();
      return e.m[0] = this.m[0], e.m[1] = this.m[1], e.m[2] = this.m[2], e.m[3] = this.m[3], e.m[4] = this.m[4], e.m[5] = this.m[5], e;
    }
    multiply(e) {
      const n = this.m[0] * e[0] + this.m[2] * e[1], r = this.m[1] * e[0] + this.m[3] * e[1], i = this.m[0] * e[2] + this.m[2] * e[3], a = this.m[1] * e[2] + this.m[3] * e[3], s = this.m[0] * e[4] + this.m[2] * e[5] + this.m[4], o = this.m[1] * e[4] + this.m[3] * e[5] + this.m[5];
      this.m[0] = n, this.m[1] = r, this.m[2] = i, this.m[3] = a, this.m[4] = s, this.m[5] = o;
    }
    invert() {
      const e = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), n = this.m[3] * e, r = -this.m[1] * e, i = -this.m[2] * e, a = this.m[0] * e, s = e * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), o = e * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      this.m[0] = n, this.m[1] = r, this.m[2] = i, this.m[3] = a, this.m[4] = s, this.m[5] = o;
    }
    rotate(e) {
      const n = Math.cos(e), r = Math.sin(e), i = this.m[0] * n + this.m[2] * r, a = this.m[1] * n + this.m[3] * r, s = this.m[0] * -r + this.m[2] * n, o = this.m[1] * -r + this.m[3] * n;
      this.m[0] = i, this.m[1] = a, this.m[2] = s, this.m[3] = o;
    }
    translate(e, n) {
      this.m[4] += this.m[0] * e + this.m[2] * n, this.m[5] += this.m[1] * e + this.m[3] * n;
    }
    scale(e, n) {
      this.m[0] *= e, this.m[1] *= e, this.m[2] *= n, this.m[3] *= n;
    }
    transformPoint(e) {
      const n = e[0], r = e[1];
      return [
        n * this.m[0] + r * this.m[2] + this.m[4],
        n * this.m[1] + r * this.m[3] + this.m[5]
      ];
    }
  }
  function bh(t, e) {
    const n = new rf();
    if (!t.viewport.displayedArea) return n;
    n.translate(t.canvas.width / 2, t.canvas.height / 2);
    const r = t.viewport.rotation;
    r !== 0 && n.rotate(r * Math.PI / 180);
    let i = t.viewport.scale, a = t.viewport.scale;
    const s = t.viewport.displayedArea.brhc.x - (t.viewport.displayedArea.tlhc.x - 1), o = t.viewport.displayedArea.brhc.y - (t.viewport.displayedArea.tlhc.y - 1);
    if (t.viewport.displayedArea.presentationSizeMode === "NONE") t.image.rowPixelSpacing < t.image.columnPixelSpacing ? i *= t.image.columnPixelSpacing / t.image.rowPixelSpacing : t.image.columnPixelSpacing < t.image.rowPixelSpacing && (a *= t.image.rowPixelSpacing / t.image.columnPixelSpacing);
    else if (i = t.viewport.displayedArea.columnPixelSpacing, a = t.viewport.displayedArea.rowPixelSpacing, t.viewport.displayedArea.presentationSizeMode === "SCALE TO FIT") {
      const l = t.canvas.height / (o * a), c = t.canvas.width / (s * i);
      i = a = Math.min(c, l), t.viewport.displayedArea.rowPixelSpacing < t.viewport.displayedArea.columnPixelSpacing ? i *= t.viewport.displayedArea.columnPixelSpacing / t.viewport.displayedArea.rowPixelSpacing : t.viewport.displayedArea.columnPixelSpacing < t.viewport.displayedArea.rowPixelSpacing && (a *= t.viewport.displayedArea.rowPixelSpacing / t.viewport.displayedArea.columnPixelSpacing);
    }
    return n.scale(i, a), r !== 0 && n.rotate(-r * Math.PI / 180), n.translate(t.viewport.translation.x, t.viewport.translation.y), r !== 0 && n.rotate(r * Math.PI / 180), t.viewport.hflip && n.scale(-1, 1), t.viewport.vflip && n.scale(1, -1), n.translate(-s / 2, -o / 2), n;
  }
  function qt() {
    return window.performance ? performance.now() : Date.now();
  }
  function qre(t, e) {
    return function(n) {
      const r = ((n - (e - 0.5)) / (t - 1) + 0.5) * 255;
      return Math.min(Math.max(r, 0), 255);
    };
  }
  function Xre(t) {
    const n = Math.max(...t.lut).toString(2).length - 8, r = t.lut[0] >> n, i = t.lut[t.lut.length - 1] >> n, a = t.firstValueMapped + t.lut.length - 1;
    return function(s) {
      return s < t.firstValueMapped ? r : s >= a ? i : t.lut[s - t.firstValueMapped] >> n;
    };
  }
  function uI(t, e, n) {
    return n ? Xre(n) : qre(t, e);
  }
  function Zre(t, e, n, r, i) {
    const a = t.maxPixelValue, s = t.minPixelValue, o = Math.min(s, 0);
    if (t.cachedLut === void 0) {
      const f = a - o + 1;
      t.cachedLut = {}, t.cachedLut.lutArray = new Uint8ClampedArray(f);
    }
    const l = t.cachedLut.lutArray, c = uI(Array.isArray(e) ? e[0] : e, Array.isArray(n) ? n[0] : n, i);
    if (r === true) for (let f = s; f <= a; f++) l[f + -o] = 255 - c(f);
    else for (let f = s; f <= a; f++) l[f + -o] = c(f);
    return l;
  }
  function Qre(t, e, n) {
    let r = qt();
    const i = t.getPixelData();
    t.stats.lastGetPixelDataTime = qt() - r;
    const a = t.minPixelValue;
    let s = 0, o = 0;
    const l = i.length;
    if (r = qt(), a < 0) for (; o < l; ) n[s++] = e[i[o++] + -a], n[s++] = e[i[o++] + -a], n[s] = e[i[o] + -a], o += 2, s += 2;
    else for (; o < l; ) n[s++] = e[i[o++]], n[s++] = e[i[o++]], n[s] = e[i[o]], o += 2, s += 2;
    t.stats.lastStoredPixelDataToCanvasImageDataTime = qt() - r;
  }
  function Jre(t, e, n) {
    let r = qt();
    const i = t.getPixelData();
    t.stats.lastGetPixelDataTime = qt() - r;
    const a = t.minPixelValue;
    let s = 0, o = 0;
    const l = i.length;
    if (r = qt(), a < 0) for (; o < l; ) n[s++] = e[i[o++] + -a], n[s++] = e[i[o++] + -a], n[s++] = e[i[o++] + -a], n[s++] = i[o++];
    else for (; o < l; ) n[s++] = e[i[o++]], n[s++] = e[i[o++]], n[s++] = e[i[o++]], n[s++] = i[o++];
    t.stats.lastStoredPixelDataToCanvasImageDataTime = qt() - r;
  }
  function dy(t, e, n) {
    if (t === void 0) throw new Error("setToPixelCoordinateSystem: parameter enabledElement must not be undefined");
    if (e === void 0) throw new Error("setToPixelCoordinateSystem: parameter context must not be undefined");
    const i = bh(t).getMatrix();
    e.setTransform(i[0], i[1], i[2], i[3], i[4], i[5]);
  }
  function gy(t, e) {
    const n = t.renderingTools.lastRenderedImageId, r = t.renderingTools.lastRenderedViewport;
    return e.imageId !== n || !r || r.windowCenter !== t.viewport.voi.windowCenter || r.windowWidth !== t.viewport.voi.windowWidth || r.invert !== t.viewport.invert || r.rotation !== t.viewport.rotation || r.hflip !== t.viewport.hflip || r.vflip !== t.viewport.vflip || r.modalityLUT !== t.viewport.modalityLUT || r.voiLUT !== t.viewport.voiLUT || r.colormap !== t.viewport.colormap;
  }
  function Mp(t, e) {
    const n = t.renderingTools.renderCanvas;
    n.width = e.width, n.height = e.height;
    const r = n.getContext("2d");
    r.fillStyle = "white", r.fillRect(0, 0, n.width, n.height);
    const i = r.getImageData(0, 0, e.width, e.height);
    t.renderingTools.renderCanvasContext = r, t.renderingTools.renderCanvasData = i;
  }
  function py(t) {
    const e = t.image.imageId, n = t.viewport, r = t.image.color;
    return t.renderingTools.lastRenderedImageId = e, t.renderingTools.lastRenderedIsColor = r, t.renderingTools.lastRenderedViewport = {
      windowCenter: n.voi.windowCenter,
      windowWidth: n.voi.windowWidth,
      invert: n.invert,
      rotation: n.rotation,
      hflip: n.hflip,
      vflip: n.vflip,
      modalityLUT: n.modalityLUT,
      voiLUT: n.voiLUT,
      colormap: n.colormap
    }, t.renderingTools;
  }
  function $re(t, e) {
    return t.cachedLut !== void 0 && t.cachedLut.windowCenter === e.voi.windowCenter && t.cachedLut.windowWidth === e.voi.windowWidth && t.cachedLut.invert === e.invert || (Zre(t, e.voi.windowWidth, e.voi.windowCenter, e.invert), t.cachedLut.windowWidth = e.voi.windowWidth, t.cachedLut.windowCenter = e.voi.windowCenter, t.cachedLut.invert = e.invert), t.cachedLut.lutArray;
  }
  function eie(t, e, n) {
    const r = t.renderingTools.lastRenderedIsColor === true;
    (!t.renderingTools.renderCanvas || !r) && (t.renderingTools.renderCanvas = document.createElement("canvas"));
    const i = t.renderingTools.renderCanvas, { windowWidth: a, windowCenter: s } = t.viewport.voi;
    if ((a === 256 || a === 255) && (s === 128 || s === 127) && t.viewport.invert === false && e.getCanvas && e.getCanvas()) return e.getCanvas();
    if (gy(t, e) === false && n !== true) return i;
    (i.width !== e.width || i.height !== e.height) && Mp(t, e);
    let o = qt();
    const l = $re(e, t.viewport);
    e.stats = e.stats || {}, e.stats.lastLutGenerateTime = qt() - o;
    const c = t.renderingTools.renderCanvasData, f = t.renderingTools.renderCanvasContext;
    return e.rgba ? Jre(e, l, c.data) : Qre(e, l, c.data), o = qt(), f.putImageData(c, 0, 0), e.stats.lastPutImageDataTime = qt() - o, i;
  }
  function tie(t, e) {
    if (t === void 0) throw new Error("renderColorImage: enabledElement parameter must not be undefined");
    const n = t.image;
    if (n === void 0) throw new Error("renderColorImage: image must be loaded before it can be drawn");
    const r = t.canvas.getContext("2d");
    r.setTransform(1, 0, 0, 1, 0, 0), r.fillStyle = "black", r.fillRect(0, 0, t.canvas.width, t.canvas.height), r.imageSmoothingEnabled = !t.viewport.pixelReplication, dy(t, r);
    const i = eie(t, n, e), a = t.viewport.displayedArea.tlhc.x - 1, s = t.viewport.displayedArea.tlhc.y - 1, o = t.viewport.displayedArea.brhc.x - a, l = t.viewport.displayedArea.brhc.y - s;
    r.drawImage(i, a, s, o, l, 0, 0, o, l), t.renderingTools = py(t);
  }
  function nie(t, e, n) {
    let r = qt();
    const i = t.getPixelData();
    t.stats.lastGetPixelDataTime = qt() - r;
    const a = i.length, s = t.minPixelValue;
    let o = 3, l = 0;
    if (r = qt(), i instanceof Int16Array) if (s < 0) for (; l < a; ) n[o] = e[i[l++] + -s], o += 4;
    else for (; l < a; ) n[o] = e[i[l++]], o += 4;
    else if (i instanceof Uint16Array) for (; l < a; ) n[o] = e[i[l++]], o += 4;
    else if (s < 0) for (; l < a; ) n[o] = e[i[l++] + -s], o += 4;
    else for (; l < a; ) n[o] = e[i[l++]], o += 4;
    t.stats.lastStoredPixelDataToCanvasImageDataTime = qt() - r;
  }
  function rie(t, e, n) {
    let r = qt();
    const i = t.getPixelData();
    t.stats.lastGetPixelDataTime = qt() - r;
    const a = i.length;
    let s = 3, o = 0;
    for (r = qt(); o < a; ) n[s] = e(i[o++]), s += 4;
    t.stats.lastStoredPixelDataToCanvasImageDataTime = qt() - r;
  }
  function iie(t, e, n) {
    let r = qt();
    const i = t.getPixelData();
    t.stats.lastGetPixelDataTime = qt() - r;
    const a = i.length, s = t.minPixelValue;
    let o = 0, l = 0, c;
    if (r = qt(), i instanceof Int16Array) if (s < 0) for (; l < a; ) c = e[i[l++] + -s], n[o++] = c, n[o++] = c, n[o++] = c, n[o++] = 255;
    else for (; l < a; ) c = e[i[l++]], n[o++] = c, n[o++] = c, n[o++] = c, n[o++] = 255;
    else if (i instanceof Uint16Array) for (; l < a; ) c = e[i[l++]], n[o++] = c, n[o++] = c, n[o++] = c, n[o++] = 255;
    else if (s < 0) for (; l < a; ) c = e[i[l++] + -s], n[o++] = c, n[o++] = c, n[o++] = c, n[o++] = 255;
    else for (; l < a; ) c = e[i[l++]], n[o++] = c, n[o++] = c, n[o++] = c, n[o++] = 255;
    t.stats.lastStoredPixelDataToCanvasImageDataTime = qt() - r;
  }
  function aie(t, e) {
    if (sie(t)) return;
    const n = e.maxPixelValue * e.slope + e.intercept, r = e.minPixelValue * e.slope + e.intercept, i = n - r, a = (n + r) / 2;
    t.voi === void 0 ? t.voi = {
      windowWidth: i,
      windowCenter: a
    } : (t.voi.windowWidth = i, t.voi.windowCenter = a);
  }
  function sie(t) {
    return t.voiLUT && t.voiLUT.lut && t.voiLUT.lut.length > 0 || t.voi.windowWidth !== void 0 && t.voi.windowCenter !== void 0;
  }
  function sS(t, e) {
    return !t && !e ? true : !t || !e ? false : t.id === e.id;
  }
  function oie(t, e) {
    return (n) => n * t + e;
  }
  function lie(t) {
    const e = t.lut[0], n = t.lut[t.lut.length - 1], r = t.firstValueMapped + t.lut.length;
    return (i) => i < t.firstValueMapped ? e : i >= r ? n : t.lut[i];
  }
  function cie(t, e, n) {
    return n ? lie(n) : oie(t, e);
  }
  function uie(t, e, n, r, i, a) {
    const s = t.maxPixelValue, o = t.minPixelValue, l = Math.min(o, 0);
    if (t.cachedLut === void 0) {
      const h = s - l + 1;
      t.cachedLut = {}, t.cachedLut.lutArray = new Uint8ClampedArray(h);
    }
    const c = t.cachedLut.lutArray, f = cie(t.slope, t.intercept, i), u = uI(e, n, a);
    if (t.isPreScaled) if (r === true) for (let h = o; h <= s; h++) c[h + -l] = 255 - u(h);
    else for (let h = o; h <= s; h++) c[h + -l] = u(h);
    else if (r === true) for (let h = o; h <= s; h++) c[h + -l] = 255 - u(f(h));
    else for (let h = o; h <= s; h++) c[h + -l] = u(f(h));
    return c;
  }
  function fI(t, e, n) {
    return t.cachedLut !== void 0 && t.cachedLut.windowCenter === e.voi.windowCenter && t.cachedLut.windowWidth === e.voi.windowWidth && sS(t.cachedLut.modalityLUT, e.modalityLUT) && sS(t.cachedLut.voiLUT, e.voiLUT) && t.cachedLut.invert === e.invert && n !== true || (aie(e, t), uie(t, e.voi.windowWidth, e.voi.windowCenter, e.invert, e.modalityLUT, e.voiLUT), t.cachedLut.windowWidth = e.voi.windowWidth, t.cachedLut.windowCenter = e.voi.windowCenter, t.cachedLut.invert = e.invert, t.cachedLut.voiLUT = e.voiLUT, t.cachedLut.modalityLUT = e.modalityLUT), t.cachedLut.lutArray;
  }
  function fie(t, e, n, r = true) {
    const i = t.renderingTools.lastRenderedIsColor === true;
    (!t.renderingTools.renderCanvas || i) && (t.renderingTools.renderCanvas = document.createElement("canvas"), Mp(t, e));
    const a = t.renderingTools.renderCanvas;
    if (gy(t, e) === false && n !== true) return a;
    (a.width !== e.width || a.height !== e.height) && Mp(t, e), e.stats = e.stats || {};
    const s = t.renderingTools.renderCanvasData, o = t.renderingTools.renderCanvasContext;
    let l = qt();
    e.stats.lastLutGenerateTime = qt() - l;
    const { viewport: c } = t;
    if (c.modality === "PT" && e.isPreScaled) {
      const { windowWidth: f, windowCenter: u } = c.voi, h = u - f / 2, m = 255 / (u + f / 2 - h);
      let y;
      c.invert ? y = (w) => 255 - (w - h) * m : y = (w) => (w - h) * m, rie(e, y, s.data);
    } else {
      const f = fI(e, c, n);
      r ? nie(e, f, s.data) : iie(e, f, s.data);
    }
    return l = qt(), o.putImageData(s, 0, 0), e.stats.lastPutImageDataTime = qt() - l, a;
  }
  function hie(t, e) {
    if (t === void 0) throw new Error("drawImage: enabledElement parameter must not be undefined");
    const n = t.image;
    if (n === void 0) throw new Error("drawImage: image must be loaded before it can be drawn");
    const r = t.canvas.getContext("2d");
    r.setTransform(1, 0, 0, 1, 0, 0), r.fillStyle = "black", r.fillRect(0, 0, t.canvas.width, t.canvas.height), r.imageSmoothingEnabled = !t.viewport.pixelReplication, dy(t, r);
    const i = fie(t, n, e), a = t.viewport.displayedArea.tlhc.x - 1, s = t.viewport.displayedArea.tlhc.y - 1, o = t.viewport.displayedArea.brhc.x - a, l = t.viewport.displayedArea.brhc.y - s;
    r.drawImage(i, a, s, o, l, 0, 0, o, l), t.renderingTools = py(t);
  }
  const v6 = 0, y6 = 1, die = 2;
  function gie(t, e, n) {
    if (t > 1) throw new Error("HSVToRGB expects hue < 1");
    const r = [];
    if (e === 0) return r[0] = n, r[1] = n, r[2] = n, r;
    const i = Math.floor(t * 6), a = 6 * t - i, s = n * (1 - e), o = n * (1 - e * a), l = n * (1 - e * (1 - a));
    switch (i) {
      case 0:
      case 6:
        r[0] = n, r[1] = l, r[2] = s;
        break;
      case 1:
        r[0] = o, r[1] = n, r[2] = s;
        break;
      case 2:
        r[0] = s, r[1] = n, r[2] = l;
        break;
      case 3:
        r[0] = s, r[1] = o, r[2] = n;
        break;
      case 4:
        r[0] = l, r[1] = s, r[2] = n;
        break;
      case 5:
        r[0] = n, r[1] = s, r[2] = o;
        break;
    }
    return r;
  }
  function pie(t, e) {
    let n;
    return t < e.Range[0] ? n = e.MaxIndex + v6 + 1.5 : t > e.Range[1] ? n = e.MaxIndex + y6 + 1.5 : n = (t + e.Shift) * e.Scale, Math.floor(n);
  }
  class my {
    constructor() {
      this.NumberOfColors = 256, this.Ramp = "linear", this.TableRange = [
        0,
        255
      ], this.HueRange = [
        0,
        0.66667
      ], this.SaturationRange = [
        1,
        1
      ], this.ValueRange = [
        1,
        1
      ], this.AlphaRange = [
        1,
        1
      ], this.NaNColor = [
        128,
        0,
        0,
        255
      ], this.BelowRangeColor = [
        0,
        0,
        0,
        255
      ], this.UseBelowRangeColor = true, this.AboveRangeColor = [
        255,
        255,
        255,
        255
      ], this.UseAboveRangeColor = true, this.InputRange = [
        0,
        255
      ], this.Table = [];
    }
    setNumberOfTableValues(e) {
      this.NumberOfColors = e;
    }
    setRamp(e) {
      this.Ramp = e;
    }
    setTableRange(e, n) {
      this.TableRange[0] = e, this.TableRange[1] = n;
    }
    setHueRange(e, n) {
      this.HueRange[0] = e, this.HueRange[1] = n;
    }
    setSaturationRange(e, n) {
      this.SaturationRange[0] = e, this.SaturationRange[1] = n;
    }
    setValueRange(e, n) {
      this.ValueRange[0] = e, this.ValueRange[1] = n;
    }
    setRange(e, n) {
      this.InputRange[0] = e, this.InputRange[1] = n;
    }
    setAlphaRange(e, n) {
      this.AlphaRange[0] = e, this.AlphaRange[1] = n;
    }
    getColor(e) {
      return this.mapValue(e);
    }
    build(e) {
      if (this.Table.length > 1 && !e) return;
      this.Table = [];
      const n = this.NumberOfColors - 1;
      let r, i, a, s;
      n ? (r = (this.HueRange[1] - this.HueRange[0]) / n, i = (this.SaturationRange[1] - this.SaturationRange[0]) / n, a = (this.ValueRange[1] - this.ValueRange[0]) / n, s = (this.AlphaRange[1] - this.AlphaRange[0]) / n) : r = i = a = s = 0;
      for (let o = 0; o <= n; o++) {
        const l = this.HueRange[0] + o * r, c = this.SaturationRange[0] + o * i, f = this.ValueRange[0] + o * a, u = this.AlphaRange[0] + o * s, h = gie(l, c, f), g = [
          0,
          0,
          0,
          0
        ];
        switch (this.Ramp) {
          case "scurve":
            g[0] = Math.floor(127.5 * (1 + Math.cos((1 - h[0]) * Math.PI))), g[1] = Math.floor(127.5 * (1 + Math.cos((1 - h[1]) * Math.PI))), g[2] = Math.floor(127.5 * (1 + Math.cos((1 - h[2]) * Math.PI))), g[3] = Math.floor(u * 255);
            break;
          case "linear":
            g[0] = Math.floor(h[0] * 255 + 0.5), g[1] = Math.floor(h[1] * 255 + 0.5), g[2] = Math.floor(h[2] * 255 + 0.5), g[3] = Math.floor(u * 255 + 0.5);
            break;
          case "sqrt":
            g[0] = Math.floor(Math.sqrt(h[0]) * 255 + 0.5), g[1] = Math.floor(Math.sqrt(h[1]) * 255 + 0.5), g[2] = Math.floor(Math.sqrt(h[2]) * 255 + 0.5), g[3] = Math.floor(Math.sqrt(u) * 255 + 0.5);
            break;
          default:
            throw new Error(`Invalid Ramp value (${this.Ramp})`);
        }
        this.Table.push(g);
      }
      this.buildSpecialColors();
    }
    buildSpecialColors() {
      const e = this.NumberOfColors, n = e + v6, r = e + y6, i = e + die;
      this.UseBelowRangeColor || e === 0 ? this.Table[n] = this.BelowRangeColor : this.Table[n] = this.Table[0], this.UseAboveRangeColor || e === 0 ? this.Table[r] = this.AboveRangeColor : this.Table[r] = this.Table[e - 1], this.Table[i] = this.NaNColor;
    }
    mapValue(e) {
      const n = this.getIndex(e);
      if (n < 0) return this.NaNColor;
      if (n === 0) {
        if (this.UseBelowRangeColor && e < this.TableRange[0]) return this.BelowRangeColor;
      } else if (n === this.NumberOfColors - 1 && this.UseAboveRangeColor && e > this.TableRange[1]) return this.AboveRangeColor;
      return this.Table[n];
    }
    getIndex(e) {
      const n = {
        Range: [],
        MaxIndex: this.NumberOfColors - 1,
        Shift: -this.TableRange[0],
        Scale: 1
      };
      if (this.TableRange[1] <= this.TableRange[0] ? n.Scale = Number.MAX_VALUE : n.Scale = n.MaxIndex / (this.TableRange[1] - this.TableRange[0]), n.Range[0] = this.TableRange[0], n.Range[1] = this.TableRange[1], isNaN(e)) return -1;
      let r = pie(e, n);
      return r === this.NumberOfColors + v6 ? r = 0 : r === this.NumberOfColors + y6 && (r = this.NumberOfColors - 1), r;
    }
    setTableValue(e, n) {
      if (arguments.length === 5 && (n = Array.prototype.slice.call(arguments, 1)), e < 0) throw new Error(`Can't set the table value for negative index (${e})`);
      e >= this.NumberOfColors && new Error(`Index ${e} is greater than the number of colors ${this.NumberOfColors}`), this.Table[e] = n, (e === 0 || e === this.NumberOfColors - 1) && this.buildSpecialColors();
    }
  }
  const oS = [
    0,
    0,
    0,
    0
  ];
  function mie(t, e, n) {
    n = n === null ? 100 : n;
    const r = (e - t) / (n - 1), i = [];
    for (; n-- > 0; ) i.push(t), t += r;
    return i[i.length - 1] = e, i;
  }
  function vie(t, e) {
    let n = 0, r = t.length - 1;
    for (; n <= r; ) {
      const i = n + Math.floor((r - n) / 2), a = t[i];
      if (a === e) return i;
      e < a ? r = i - 1 : n = i + 1;
    }
    return n;
  }
  function yie(t, e) {
    let n;
    const r = [], i = e.length;
    for (t.sort(function(a, s) {
      return a - s;
    }), n = 0; n < i; n++) r[n] = vie(t, e[n]);
    return r;
  }
  function K4(t, e, n) {
    let r;
    const i = [], a = [], s = [], o = [];
    for (n = n === null ? 1 : n, r = 0; r < e.length; r++) {
      const f = e[r];
      i.push((t - 1) * f[0]), a.push(f[1]), s.push(f[1]);
    }
    const l = mie(0, 1, t);
    for (r = 0; r < t; r++) l[r] = (t - 1) * Math.pow(l[r], n);
    const c = yie(i, l);
    for (r = 1; r < t - 1; r++) {
      const f = c[r], u = (l[r] - i[f - 1]) / (i[f] - i[f - 1]), h = a[f] - s[f - 1];
      o[r] = u * h + s[f - 1];
    }
    return o[0] = s[0], o[t - 1] = a[e.length - 1], o;
  }
  function xie(t, e, n) {
    let r;
    const i = [];
    e = e === null ? 256 : e, n = n === null ? 1 : n;
    const a = K4(e, t.red, n), s = K4(e, t.green, n), o = K4(e, t.blue, n);
    for (r = 0; r < e; r++) {
      const l = Math.round(a[r] * 255), c = Math.round(s[r] * 255), f = Math.round(o[r] * 255), u = [
        l,
        c,
        f,
        255
      ];
      i.push(u);
    }
    return i;
  }
  function hI(t, e) {
    let n = Hv[t];
    return n || (n = Hv[t] = e || {
      name: "",
      colors: []
    }), !n.colors && n.segmentedData && (n.colors = xie(n.segmentedData, n.numColors, n.gamma)), {
      getId() {
        return t;
      },
      getColorSchemeName() {
        return n.name;
      },
      setColorSchemeName(i) {
        n.name = i;
      },
      getNumberOfColors() {
        return n.colors.length;
      },
      setNumberOfColors(i) {
        for (; n.colors.length < i; ) n.colors.push(oS);
        n.colors.length = i;
      },
      getColor(i) {
        return this.isValidIndex(i) ? n.colors[i] : oS;
      },
      getColorRepeating(i) {
        const a = n.colors.length;
        return i = a ? i % a : 0, this.getColor(i);
      },
      setColor(i, a) {
        this.isValidIndex(i) && (n.colors[i] = a);
      },
      addColor(i) {
        n.colors.push(i);
      },
      insertColor(i, a) {
        this.isValidIndex(i) && n.colors.splice(i, 1, a);
      },
      removeColor(i) {
        this.isValidIndex(i) && n.colors.splice(i, 1);
      },
      clearColors() {
        n.colors = [];
      },
      buildLookupTable(i) {
        if (!i) return;
        const a = n.colors.length;
        i.setNumberOfTableValues(a);
        for (let s = 0; s < a; s++) i.setTableValue(s, n.colors[s]);
      },
      createLookupTable() {
        const i = new my();
        return this.buildLookupTable(i), i;
      },
      isValidIndex(i) {
        return i >= 0 && i < n.colors.length;
      }
    };
  }
  function wie(t, e, n, r) {
    let i = qt();
    const a = t.getPixelData();
    t.stats.lastGetPixelDataTime = qt() - i;
    const s = a.length, o = t.minPixelValue;
    let l = 0, c = 0, f, u, h;
    if (i = qt(), n instanceof my ? h = n.Table : h = n, o < 0) for (; c < s; ) f = e[a[c++] + -o], u = h[f], r[l++] = u[0], r[l++] = u[1], r[l++] = u[2], r[l++] = u[3];
    else for (; c < s; ) f = e[a[c++]], u = h[f], r[l++] = u[0], r[l++] = u[1], r[l++] = u[2], r[l++] = u[3];
    t.stats.lastStoredPixelDataToCanvasImageDataTime = qt() - i;
  }
  function Cie(t, e, n, r) {
    let i = qt();
    const a = t.getPixelData();
    t.stats.lastGetPixelDataTime = qt() - i;
    const s = a.length, o = t.minPixelValue;
    let l = 0, c = 0, f, u, h;
    if (i = qt(), n instanceof my ? h = n.Table : h = n, o < 0) for (; c < s; ) f = e(a[c++] + -o), u = h[f], r[l++] = u[0], r[l++] = u[1], r[l++] = u[2], r[l++] = u[3];
    else for (; c < s; ) f = e(a[c++]), u = h[f], r[l++] = u[0], r[l++] = u[1], r[l++] = u[2], r[l++] = u[3];
    t.stats.lastStoredPixelDataToCanvasImageDataTime = qt() - i;
  }
  function Tie(t, e, n) {
    t.renderingTools.renderCanvas || (t.renderingTools.renderCanvas = document.createElement("canvas"));
    const r = t.renderingTools.renderCanvas;
    let i = t.viewport.colormap || t.options.colormap;
    if (t.options && t.options.colormap && console.warn("enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead"), i && typeof i == "string" && (i = hI(i)), !i) throw new Error("renderPseudoColorImage: colormap not found.");
    const a = i.getId();
    if (gy(t, e) === false && n !== true && t.renderingTools.colormapId === a) return r;
    (r.width !== e.width || r.height !== e.height) && Mp(t, e);
    let s = qt();
    (!t.renderingTools.colorLUT || n || t.renderingTools.colormapId !== a) && (i.setNumberOfColors(256), t.renderingTools.colorLUT = i.createLookupTable(), t.renderingTools.colormapId = a);
    const o = t.renderingTools.renderCanvasData, l = t.renderingTools.renderCanvasContext, { viewport: c } = t, f = t.renderingTools.colorLUT;
    if (c.modality === "PT") {
      const { windowWidth: u, windowCenter: h } = c.voi, g = h - u / 2, y = 255 / (h + u / 2 - g);
      let w;
      c.invert ? w = (C) => t6(Math.floor(255 - (C - g) * y), 0, 255) : w = (C) => t6(Math.floor((C - g) * y), 0, 255), Cie(e, w, f, o.data);
    } else {
      const u = fI(e, t.viewport, n);
      e.stats = e.stats || {}, e.stats.lastLutGenerateTime = qt() - s, wie(e, u, f, o.data);
    }
    return s = qt(), l.putImageData(o, 0, 0), e.stats.lastPutImageDataTime = qt() - s, r;
  }
  function Sie(t, e) {
    if (t === void 0) throw new Error("drawImage: enabledElement parameter must not be undefined");
    const n = t.image;
    if (n === void 0) throw new Error("drawImage: image must be loaded before it can be drawn");
    const r = t.canvas.getContext("2d");
    r.setTransform(1, 0, 0, 1, 0, 0), r.fillStyle = "black", r.fillRect(0, 0, t.canvas.width, t.canvas.height), r.imageSmoothingEnabled = !t.viewport.pixelReplication, dy(t, r);
    const i = Tie(t, n, e), a = t.viewport.displayedArea.tlhc.x - 1, s = t.viewport.displayedArea.tlhc.y - 1, o = t.viewport.displayedArea.brhc.x - a, l = t.viewport.displayedArea.brhc.y - s;
    r.drawImage(i, a, s, o, l, 0, 0, o, l), t.renderingTools = py(t);
  }
  function dI(t, e) {
    const n = t.image;
    if (!t.canvas || !t.image) return;
    const r = qt();
    if (n.stats = {
      lastGetPixelDataTime: -1,
      lastStoredPixelDataToCanvasImageDataTime: -1,
      lastPutImageDataTime: -1,
      lastRenderTime: -1,
      lastLutGenerateTime: -1
    }, n) {
      let a = n.render;
      a || (t.viewport.colormap ? a = Sie : n.color ? a = tie : a = hie), a(t, e);
    }
    const i = qt() - r;
    n.stats.lastRenderTime = i, t.invalid = false, t.needsRedraw = false;
  }
  function gI(t, e, n, r, i) {
    if (e.volumeId) throw new Error("Unsupported volume rendering for CPU");
    const s = e, o = cI(t, s, n), l = {
      canvas: t,
      viewport: o,
      image: s,
      renderingTools: {}
    };
    l.transform = bh(l);
    const c = true;
    return new Promise((f, u) => {
      dI(l, c), f(null);
    });
  }
  function Aie(t) {
    const { canvas: e, imageId: n, viewReference: r, requestType: i = ar.Thumbnail, priority: a = -5, renderingEngineId: s = "_thumbnails", useCPURendering: o = false, thumbnail: l = false, imageAspect: c = false, viewportOptions: f } = t, u = r == null ? void 0 : r.volumeId, h = u && !n, g = r && f ? {
      ...f,
      viewReference: r
    } : f, v = o ? gI : oI;
    return new Promise((m, y) => {
      function w(b, D) {
        var _a3;
        const { modality: R } = Ct("generalSeriesModule", D) || {}, I = !h && b, O = h && b;
        I && (I.isPreScaled = I.isPreScaled || ((_a3 = I.preScale) == null ? void 0 : _a3.scaled)), l && (e.height = 256, e.width = 256), c && I && (e.width = I && e.height * I.width / I.height), e.style.width = `${e.width / devicePixelRatio}px`, e.style.height = `${e.height / devicePixelRatio}px`, O && o && y(new Error("CPU rendering of volume not supported")), v(e, b, R, s, g).then(m);
      }
      function C(b, D) {
        console.error(b, D), y(b);
      }
      function T(b, D, R) {
        return Eh(b, R).then((I) => {
          w.call(this, I, b);
        }, (I) => {
          C.call(this, I, b);
        });
      }
      const { useNorm16Texture: S } = Do().rendering, E = {
        targetBuffer: {
          type: S ? void 0 : "Float32Array"
        },
        preScale: {
          enabled: true
        },
        useRGBA: !!o,
        requestType: i
      };
      if (u) {
        const b = Ke.getVolume(u);
        b || y(new Error(`Volume id ${u} not found in cache`));
        const D = b.imageIds[0];
        w(b, D);
      } else i0.addRequest(T.bind(null, n, null, E), i, {
        imageId: n
      }, a);
    });
  }
  function Eie(t, e) {
    const n = Ct("imagePlaneModule", t);
    if (!n) throw new Error(`No imagePlaneModule found for imageId: ${t}`);
    const { columnCosines: r, rowCosines: i, imagePositionPatient: a } = n;
    let { columnPixelSpacing: s, rowPixelSpacing: o } = n;
    s || (s = 1), o || (o = 1);
    const l = He();
    Xr(l, a, r, -s / 2), Xr(l, l, i, -o / 2);
    const c = He();
    hi(c, e, l);
    const f = Bt(c, i), u = Bt(c, r);
    return [
      f / o,
      u / s
    ];
  }
  function bie(t, e) {
    const n = Ct("imagePlaneModule", t);
    if (!n) throw new Error(`No imagePlaneModule found for imageId: ${t}`);
    const { columnCosines: r, rowCosines: i, imagePositionPatient: a } = n;
    let { columnPixelSpacing: s, rowPixelSpacing: o } = n;
    s || (s = 1), o || (o = 1);
    const l = He();
    return Xr(l, a, i, o * (e[0] - 0.5)), Xr(l, l, r, s * (e[1] - 0.5)), Array.from(l);
  }
  const Die = Vl * Vl, Y4 = (t) => Math.abs(Math.abs(t) - 1) < Die, q4 = (t, e) => Y4(t[e]) || Y4(t[e + 1]) || Y4(t[e + 2]), Mie = (t) => q4(t, 0) && q4(t, 3) && q4(t, 6);
  function D5(t, e, n) {
    const r = t.getMapper().getInputData();
    let i;
    const a = r.getDirection();
    if (Mie(a)) i = tI(t);
    else {
      const [u, h, g] = r.getDimensions();
      i = [
        [
          0,
          0,
          0
        ],
        [
          u - 1,
          0,
          0
        ],
        [
          0,
          h - 1,
          0
        ],
        [
          u - 1,
          h - 1,
          0
        ],
        [
          0,
          0,
          g - 1
        ],
        [
          u - 1,
          0,
          g - 1
        ],
        [
          0,
          h - 1,
          g - 1
        ],
        [
          u - 1,
          h - 1,
          g - 1
        ]
      ].map((m) => r.indexToWorld(m));
    }
    const s = Lc.buildFromDegree().identity().rotateFromDirections(e, [
      1,
      0,
      0
    ]);
    i.forEach((u) => s.apply(u));
    const o = [
      ...n
    ];
    s.apply(o);
    const l = o[0];
    let c = 1 / 0, f = -1 / 0;
    for (let u = 0; u < 8; u++) {
      const h = i[u][0];
      h > f && (f = h), h < c && (c = h);
    }
    return {
      min: c,
      max: f,
      current: l,
      actor: t,
      viewPlaneNormal: e,
      focalPoint: n
    };
  }
  function pI(t, e, n = false) {
    const r = t.getCamera(), { focalPoint: i, viewPlaneNormal: a } = r, { spacingInNormalDirection: s, actorUID: o } = ad(t, r, e, n);
    if (!o) throw new Error(`Could not find image volume with id ${e} in the viewport`);
    const l = t.getActor(o);
    if (!l) return console.warn("No actor found for with actorUID of", o), null;
    const c = l.actor;
    return {
      sliceRange: D5(c, a, i),
      spacingInNormalDirection: s,
      camera: r
    };
  }
  function mh(t, e, n = false) {
    const { sliceRange: r, spacingInNormalDirection: i, camera: a } = pI(t, e, n), { min: s, max: o, current: l } = r, c = Math.round((o - s) / i), u = (l - s) / (o - s) * c, h = Math.round(u);
    return {
      numScrollSteps: c,
      currentStepIndex: h,
      sliceRangeInfo: {
        sliceRange: r,
        spacingInNormalDirection: i,
        camera: a
      }
    };
  }
  function Cu(t, e, n, r, i, a) {
    const { min: s, max: o, current: l } = n, c = He();
    hi(c, e, t);
    const f = Math.round((o - s) / i), h = (l - s) / (o - s) * f;
    let g = Math.round(h), v = [
      t[0] - r[0] * h * i,
      t[1] - r[1] * h * i,
      t[2] - r[2] * h * i
    ];
    g += a, g > f ? g = f : g < 0 && (g = 0);
    const m = g * i;
    v = [
      v[0] + r[0] * m,
      v[1] + r[1] * m,
      v[2] + r[2] * m
    ];
    const y = [
      v[0] + c[0],
      v[1] + c[1],
      v[2] + c[2]
    ];
    return {
      newFocalPoint: v,
      newPosition: y
    };
  }
  function Rp(t) {
    const e = t.getCamera(), { spacingInNormalDirection: n, imageVolume: r } = ad(t, e);
    if (!r) return;
    const { viewPlaneNormal: i, focalPoint: a } = e, s = t.getActors().find((v) => v.referenceId === r.volumeId || v.uid === r.volumeId);
    s || console.warn("No actor found for with actorUID of", r.volumeId);
    const o = s.actor, l = D5(o, i, a), { min: c, max: f, current: u } = l, h = Math.round((f - c) / n) + 1;
    let g = (u - c) / (f - c) * h;
    return g = Math.floor(g), g > h - 1 ? g = h - 1 : g < 0 && (g = 0), {
      numberOfSlices: h,
      imageIndex: g
    };
  }
  function fo(t) {
    return ea(t, "vtkVolume") || ea(t, "vtkImageSlice");
  }
  function ea(t, e) {
    return !!("isA" in t ? t : t.actor).isA(e);
  }
  function x6(t, e) {
    let n;
    e ? n = [
      _a(e)
    ] : n = Pl();
    const r = [];
    return n.forEach((i) => {
      i.getViewports().forEach((s) => {
        s.hasImageURI(t) && r.push(s);
      });
    }), r;
  }
  function Rie(t, e) {
    const n = Oie(t, e);
    return n ? n.index : null;
  }
  function Oie(t, e) {
    const n = e.getImageIds(), r = e.getCurrentImageIdIndex();
    if (n.length === 0) return null;
    const i = (l) => {
      const c = Iie(l);
      if (!c) return null;
      const f = RI(c.planeNormal, c.imagePositionPatient);
      return OI(f, t);
    }, a = {
      distance: i(n[r]) ?? 1 / 0,
      index: r
    }, s = n.slice(r + 1);
    for (let l = 0; l < s.length; l++) {
      const c = s[l], f = i(c);
      if (f !== null) if (f <= a.distance) a.distance = f, a.index = l + r + 1;
      else break;
    }
    const o = n.slice(0, r);
    for (let l = o.length - 1; l >= 0; l--) {
      const c = o[l], f = i(c);
      if (!(f === null || f === a.distance)) if (f < a.distance) a.distance = f, a.index = l;
      else break;
    }
    return a.distance === 1 / 0 ? null : a;
  }
  function Iie(t) {
    const e = Ct("imagePlaneModule", t);
    if (!e || !(e.rowCosines instanceof Array && e.rowCosines.length === 3) || !(e.columnCosines instanceof Array && e.columnCosines.length === 3) || !(e.imagePositionPatient instanceof Array && e.imagePositionPatient.length === 3)) return null;
    const { rowCosines: n, columnCosines: r, imagePositionPatient: i } = e, a = Ml(He(), ...n), s = Ml(He(), ...r), o = Vr(He(), a, s);
    return {
      rowCosines: n,
      columnCosines: r,
      imagePositionPatient: i,
      planeNormal: o
    };
  }
  function Vie(t, e) {
    const { imageData: n } = t.getImageData(), r = rI(n, e);
    return t.worldToCanvas(r);
  }
  function C1(t, e) {
    const { imageData: n } = t.getImageData(), r = t.canvasToWorld(e);
    return wl(n, r);
  }
  function Nie(t) {
    const { dimensions: e, scalarData: n } = t.getImageData(), { width: r, height: i } = t.getCanvas(), a = C1(t, [
      0,
      0
    ]), s = C1(t, [
      r - 1,
      0
    ]), o = C1(t, [
      0,
      i - 1
    ]), l = hi(He(), s, a), c = hi(He(), o, a), f = Vr(He(), l, c);
    Pr(l, l), Pr(c, c), Pr(f, f);
    const u = Math.max(Math.abs(l[0]), Math.abs(l[1]), Math.abs(l[2])), h = Math.max(Math.abs(c[0]), Math.abs(c[1]), Math.abs(c[2]));
    if (!xh(1, u) || !xh(1, h)) throw new Error("Livewire is not available for rotate/oblique viewports");
    const [g, v, m] = e, C = [
      [
        0,
        0,
        0
      ],
      [
        g - 1,
        0,
        0
      ],
      [
        0,
        v - 1,
        0
      ],
      [
        g - 1,
        v - 1,
        0
      ],
      [
        0,
        0,
        m - 1
      ],
      [
        g - 1,
        0,
        m - 1
      ],
      [
        0,
        v - 1,
        m - 1
      ],
      [
        g - 1,
        v - 1,
        m - 1
      ]
    ].map((_) => Vie(t, _)).reduce((_, K) => (_.minX = Math.min(_.minX, K[0]), _.minY = Math.min(_.minY, K[1]), _.maxX = Math.max(_.maxX, K[0]), _.maxY = Math.max(_.maxY, K[1]), _), {
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: -1 / 0,
      maxY: -1 / 0
    }), T = C1(t, [
      C.minX,
      C.minY
    ]), S = C1(t, [
      C.maxX,
      C.maxY
    ]), E = hi(He(), S, T), b = Qi(l[0], l[1], l[2], 0, c[0], c[1], c[2], 0, f[0], f[1], f[2], 0, T[0], T[1], T[2], 1), D = Ti(Yt(), b), R = Bt(l, E) + 1, I = Bt(c, E) + 1, O = n.constructor, L = new O(R * I), N = e[0] * e[1], F = ki(T), V = He();
    let k = 0;
    for (let _ = 0; _ < I; _++) {
      Du(V, F);
      for (let K = 0; K < R; K++) {
        const Z = V[2] * N + V[1] * e[0] + V[0];
        Z < n.length && (L[k] = n[Z]), k++, Ai(V, V, l);
      }
      Ai(F, F, c);
    }
    return {
      width: R,
      height: I,
      scalarData: L,
      sliceToIndexMatrix: b,
      indexToSliceMatrix: D
    };
  }
  const wc = {}, Op = {
    add: (t, e) => {
      const [n, r] = t, i = `${n}_${r}`;
      wc[i] || (wc[i] = {}), wc[i] = e;
    },
    get: (t, e, n) => {
      if (t !== "spatialRegistrationModule") return;
      const r = `${e}_${n}`;
      if (wc[r]) return wc[r];
      const i = `${n}_${e}`;
      if (wc[i]) return Ti(Yt(), wc[i]);
    }
  };
  ly(Op.get.bind(Op));
  const Lie = 0.05;
  function Uie(t, e) {
    const n = t.getCurrentImageId(), r = e.getCurrentImageId(), i = Ct("imagePlaneModule", n), a = Ct("imagePlaneModule", r);
    if (!i || !a) {
      console.log("Viewport spatial registration requires image plane module");
      return;
    }
    const { imageOrientationPatient: s } = a;
    if (!i.imageOrientationPatient.every((h, g) => Math.abs(h - s[g]) < Lie)) {
      console.log("Viewport spatial registration only supported for same orientation (hence translation only) for now", i == null ? void 0 : i.imageOrientationPatient, a == null ? void 0 : a.imageOrientationPatient);
      return;
    }
    const l = i.imagePositionPatient, c = a.imagePositionPatient, f = Ft(He(), l, c), u = A_(Yt(), f);
    Op.add([
      t.id,
      e.id
    ], u);
  }
  function Fie(t) {
    const { imageData: e, dimensions: n } = t.getImageData(), { canvas: r } = t, i = window.devicePixelRatio, a = [
      0,
      0
    ], s = [
      r.width / i,
      0
    ], o = [
      r.width / i,
      r.height / i
    ], l = [
      0,
      r.height / i
    ], c = t.canvasToWorld(a), f = t.canvasToWorld(s), u = t.canvasToWorld(o), h = t.canvasToWorld(l), g = e.worldToIndex(c), v = e.worldToIndex(f), m = e.worldToIndex(u), y = e.worldToIndex(h);
    return Bie({
      dimensions: n,
      imageData: e,
      topLeftImage: g,
      topRightImage: v,
      bottomRightImage: m,
      bottomLeftImage: y,
      topLeftWorld: c,
      topRightWorld: f,
      bottomRightWorld: u,
      bottomLeftWorld: h
    });
  }
  function Bie({ dimensions: t, imageData: e, topLeftImage: n, topRightImage: r, bottomRightImage: i, bottomLeftImage: a, topLeftWorld: s, topRightWorld: o, bottomRightWorld: l, bottomLeftWorld: c }) {
    const f = K2(n, t) ? s : e.indexToWorld([
      0,
      0,
      0
    ]), u = K2(r, t) ? o : e.indexToWorld([
      t[0] - 1,
      0,
      0
    ]), h = K2(i, t) ? l : e.indexToWorld([
      t[0] - 1,
      t[1] - 1,
      0
    ]), g = K2(a, t) ? c : e.indexToWorld([
      0,
      t[1] - 1,
      0
    ]);
    return [
      f,
      u,
      g,
      h
    ];
  }
  function K2(t, e) {
    return t[0] > 0 || t[0] < e[0] - 1 || t[1] > 0 || t[1] < e[1] - 1 || t[2] > 0 || t[2] < e[2] - 1;
  }
  function w6(t) {
    return Array.isArray(t) ? t.some((e) => Number.isNaN(e)) : Number.isNaN(t);
  }
  function mI(t, e) {
    const n = e.colorTransfer.split(" ").splice(1).map(parseFloat), { shiftRange: r } = _ie(n), i = r[0], a = r[1] - r[0], s = Ul.newInstance(), o = [];
    for (let S = 0; S < n.length; S += 4) {
      let E = n[S];
      const b = n[S + 1], D = n[S + 2], R = n[S + 3];
      E = (E - i) / a, o.push([
        E,
        b,
        D,
        R
      ]);
    }
    kie(o, r, s), t.getProperty().setRGBTransferFunction(0, s);
    const l = e.scalarOpacity.split(" ").splice(1).map(parseFloat), c = Iu.newInstance(), f = [];
    for (let S = 0; S < l.length; S += 2) {
      let E = l[S];
      const b = l[S + 1];
      E = (E - i) / a, f.push([
        E,
        b
      ]);
    }
    Pie(f, r, c);
    const u = t.getProperty();
    u.setScalarOpacity(0, c);
    const [h, g, v, m] = e.gradientOpacity.split(" ").splice(1).map(parseFloat);
    u.setUseGradientOpacity(0, true), u.setGradientOpacityMinimumValue(0, h), u.setGradientOpacityMinimumOpacity(0, g), u.setGradientOpacityMaximumValue(0, v), u.setGradientOpacityMaximumOpacity(0, m), e.interpolation === "1" && u.setInterpolationTypeToFastLinear(), u.setShade(e.shade === "1");
    const y = parseFloat(e.ambient), w = parseFloat(e.diffuse), C = parseFloat(e.specular), T = parseFloat(e.specularPower);
    u.setAmbient(y), u.setDiffuse(w), u.setSpecular(C), u.setSpecularPower(T);
  }
  function _ie(t) {
    let e = 1 / 0, n = -1 / 0;
    for (let i = 0; i < t.length; i += 4) e = Math.min(e, t[i]), n = Math.max(n, t[i]);
    const r = (n - e) / 2;
    return {
      shiftRange: [
        -r,
        r
      ],
      min: e,
      max: n
    };
  }
  function kie(t, e, n) {
    const r = e[1] - e[0], i = t.map(([a, s, o, l]) => [
      a * r + e[0],
      s,
      o,
      l
    ]);
    return n.removeAllPoints(), i.forEach(([a, s, o, l]) => n.addRGBPoint(a, s, o, l)), i;
  }
  function Pie(t, e, n) {
    const r = e[1] - e[0], i = t.map(([a, s]) => [
      a * r + e[0],
      s
    ]);
    return n.removeAllPoints(), i.forEach(([a, s]) => n.addPoint(a, s)), i;
  }
  let Gie = class J1 {
    constructor(e = {}) {
      this._dimensions = 3, this._length = 0, this._byteSize = 4, this.growSize = 128;
      const { initialSize: n = 1024, dimensions: r = 3, growSize: i = 128 } = e, a = n * r;
      this.growSize = i, this.array = new ArrayBuffer(a * this._byteSize), this.data = new Float32Array(this.array), this._dimensions = r;
    }
    forEach(e) {
      for (let n = 0; n < this._length; n++) e(this.getPoint(n), n);
    }
    get length() {
      return this._length;
    }
    get dimensions() {
      return this._dimensions;
    }
    get dimensionLength() {
      return this._length * this._dimensions;
    }
    getPoint(e) {
      if (e < 0 && (e += this._length), e < 0 || e >= this._length) return;
      const n = this._dimensions * e;
      return this.data.subarray(n, n + this._dimensions);
    }
    getPointArray(e) {
      const n = [];
      if (e < 0 && (e += this._length), e < 0 || e >= this._length) return;
      const r = this._dimensions * e;
      for (let i = 0; i < this._dimensions; i++) n.push(this.data[i + r]);
      return n;
    }
    grow(e = 1, n = this.growSize) {
      if (this.dimensionLength + e * this._dimensions <= this.data.length) return;
      const r = this.data.length + n, i = new ArrayBuffer(r * this._dimensions * this._byteSize), a = new Float32Array(i);
      a.set(this.data), this.data = a, this.array = i;
    }
    reverse() {
      const e = Math.floor(this._length / 2);
      for (let n = 0; n < e; n++) {
        const r = n * this._dimensions, i = (this._length - 1 - n) * this._dimensions;
        for (let a = 0; a < this._dimensions; a++) {
          const s = this.data[r + a];
          this.data[r + a] = this.data[i + a], this.data[i + a] = s;
        }
      }
    }
    push(e) {
      this.grow(1);
      const n = this.length * this._dimensions;
      for (let r = 0; r < this._dimensions; r++) this.data[r + n] = e[r];
      this._length++;
    }
    map(e) {
      const n = [];
      for (let r = 0; r < this._length; r++) n.push(e(this.getPoint(r), r));
      return n;
    }
    get points() {
      return this.map((e) => e);
    }
    toXYZ() {
      const e = {
        x: [],
        y: []
      };
      this._dimensions >= 3 && (e.z = []);
      const { x: n, y: r, z: i } = e;
      return this.forEach((a) => {
        n.push(a[0]), r.push(a[1]), i && i.push(a[2]);
      }), e;
    }
    static fromXYZ({ x: e, y: n, z: r }) {
      const i = J1.create3(e.length);
      let a = 0;
      for (let s = 0; s < e.length; s++) i.data[a++] = e[s], i.data[a++] = n[s], i.data[a++] = r ? r[s] : 0;
      return i._length = e.length, i;
    }
    subselect(e = 10, n = 0) {
      const r = new J1({
        initialSize: e,
        dimensions: this._dimensions
      });
      for (let i = 0; i < e; i++) {
        const a = (n + Math.floor(this.length * i / e)) % this.length;
        r.push(this.getPoint(a));
      }
      return r;
    }
    static create3(e = 128) {
      return new J1({
        initialSize: e,
        dimensions: 3
      });
    }
    static create2(e = 128) {
      return new J1({
        initialSize: e,
        dimensions: 2
      });
    }
  };
  const Ip = (t) => t && typeof t == "object" && Object.prototype.toString.call(t) !== "[object RegExp]" && Object.prototype.toString.call(t) !== "[object Date]", zie = (t) => Array.isArray(t) ? [] : {}, Dh = (t, e) => e && e.clone === true && Ip(t) ? zi(zie(t), t, e) : t, lS = (t, e, n) => {
    const r = t.slice();
    return e.forEach(function(i, a) {
      typeof r[a] > "u" ? r[a] = Dh(i, n) : Ip(i) ? r[a] = zi(t[a], i, n) : t.indexOf(i) === -1 && (r[a] = Dh(i, n));
    }), r;
  }, Wie = (t, e, n) => {
    const r = {};
    return Ip(t) && Object.keys(t).forEach(function(i) {
      r[i] = Dh(t[i], n);
    }), Object.keys(e).forEach(function(i) {
      !Ip(e[i]) || !t[i] ? r[i] = Dh(e[i], n) : r[i] = zi(t[i], e[i], n);
    }), r;
  }, zi = (t = {}, e = {}, n = void 0) => {
    const r = Array.isArray(e), a = (n || {
      arrayMerge: lS
    }).arrayMerge || lS;
    return r ? Array.isArray(t) ? a(t, e, n) : Dh(e, n) : Wie(t, e, n);
  };
  function vI(t) {
    const e = Ct("modalityLutModule", t) || {}, n = Ct("generalSeriesModule", t) || {}, { modality: r } = n, i = {
      rescaleSlope: e.rescaleSlope || 1,
      rescaleIntercept: e.rescaleIntercept ?? 0,
      modality: r
    }, a = Ct("scalingModule", t) || {};
    return {
      ...i,
      ...r === "PT" && {
        suvbw: a.suvbw,
        suvbsa: a.suvbsa,
        suvlbm: a.suvlbm
      }
    };
  }
  function Hie(t, e) {
    let n;
    if (e && e instanceof Uint8Array) n = "Uint8Array";
    else if (e instanceof Float32Array) n = "Float32Array";
    else if (e instanceof Int16Array) n = "Int16Array";
    else if (e instanceof Uint16Array) n = "Uint16Array";
    else throw new Error("Unsupported array type");
    return n;
  }
  function pt(t) {
    if (!t) return;
    const { viewportUid: e, renderingEngineUid: n } = t.dataset;
    return Pa(e, n);
  }
  function Pa(t, e) {
    if (!e || !t) return;
    const n = _a(e);
    if (!n || n.hasBeenDestroyed) return;
    const r = n.getViewport(t);
    if (!r) return;
    const i = r.getFrameOfReferenceUID();
    return {
      viewport: r,
      renderingEngine: n,
      viewportId: t,
      renderingEngineId: e,
      FrameOfReferenceUID: i
    };
  }
  function jie() {
    const t = [];
    return Pl().forEach((n) => {
      n.getViewports().forEach(({ element: i }) => {
        t.push(pt(i));
      });
    }), t;
  }
  function Kie(t) {
    const e = pt(t);
    if (!e) return;
    const { viewport: n } = e;
    if (!(n instanceof bo)) throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${n.type}`);
    return n.getCornerstoneImage();
  }
  function yI(t, e) {
    const { imagePositionPatient: n, imageOrientationPatient: r } = Ct("imagePlaneModule", t[0]);
    if (!e) {
      const v = Ue(r[0], r[1], r[2]), m = Ue(r[3], r[4], r[5]);
      e = He(), Vr(e, v, m);
    }
    const i = He(), a = t[0].split(":")[0] === "wadouri";
    Ml(i, n[0], n[1], n[2]);
    let s, o;
    function l(v) {
      const { imagePositionPatient: m } = Ct("imagePlaneModule", v), y = He();
      return hi(y, n, m), Bt(y, e);
    }
    if (a) {
      const v = [
        t[0],
        t[Math.floor(t.length / 2)]
      ];
      s = t;
      const m = l(v[0]), y = l(v[1]);
      m - y < 0 && s.reverse();
      const w = Ct("imagePlaneModule", v[1]);
      if (!w) throw new Error("Incomplete metadata required for volume construction.");
      const C = He();
      hi(C, n, w.imagePositionPatient);
      const T = Bt(C, e);
      o = Math.abs(T) / Math.floor(t.length / 2);
    } else {
      const v = t.map((y) => ({
        distance: l(y),
        imageId: y
      }));
      v.sort((y, w) => w.distance - y.distance), s = v.map((y) => y.imageId);
      const m = v.length;
      o = Math.abs(v[m - 1].distance - v[0].distance) / (m - 1);
    }
    const { imagePositionPatient: c, sliceThickness: f, spacingBetweenSlices: u } = Ct("imagePlaneModule", s[0]), { strictZSpacingForVolumeViewport: h } = Do().rendering;
    return o === 0 && !h && (f && u ? (console.log("Could not calculate zSpacing. Using spacingBetweenSlices"), o = u) : f ? (console.log("Could not calculate zSpacing and no spacingBetweenSlices. Using sliceThickness"), o = f) : (console.log("Could not calculate zSpacing. The VolumeViewport visualization is compromised. Setting zSpacing to 1 to render"), o = 1)), {
      zSpacing: o,
      origin: c,
      sortedImageIds: s
    };
  }
  function xI(t) {
    const e = t[0], { pixelRepresentation: n, bitsAllocated: r, bitsStored: i, highBit: a, photometricInterpretation: s, samplesPerPixel: o } = Ct("imagePixelModule", e), l = [], c = Ct("voiLutModule", e);
    let f;
    if (c) {
      const { windowWidth: C, windowCenter: T } = c;
      if (f = c == null ? void 0 : c.voiLUTFunction, Array.isArray(C)) for (let S = 0; S < C.length; S++) l.push({
        windowWidth: C[S],
        windowCenter: T[S]
      });
      else l.push({
        windowWidth: C,
        windowCenter: T
      });
    } else l.push({
      windowWidth: void 0,
      windowCenter: void 0
    });
    const { modality: u, seriesInstanceUID: h } = Ct("generalSeriesModule", e), { imageOrientationPatient: g, pixelSpacing: v, frameOfReferenceUID: m, columns: y, rows: w } = Ct("imagePlaneModule", e);
    return {
      BitsAllocated: r,
      BitsStored: i,
      SamplesPerPixel: o,
      HighBit: a,
      PhotometricInterpretation: s,
      PixelRepresentation: n,
      Modality: u,
      ImageOrientationPatient: g,
      PixelSpacing: v,
      FrameOfReferenceUID: m,
      Columns: y,
      Rows: w,
      voiLut: l,
      VOILUTFunction: f,
      SeriesInstanceUID: h
    };
  }
  let T1 = {};
  const Nu = {
    add: (t, e) => {
      Nu.addRaw(t, {
        ...e,
        metadata: structuredClone(e.metadata)
      });
    },
    addRaw: (t, e) => {
      const n = e.type;
      T1[t] || (T1[t] = {}), T1[t][n] = e.metadata;
    },
    get: (t, e) => {
      var _a3;
      return (_a3 = T1[e]) == null ? void 0 : _a3[t];
    },
    clear: () => {
      T1 = {};
    }
  };
  ly(Nu.get);
  function Yie(t) {
    const e = t[0], { modality: n, seriesInstanceUID: r } = Ct("generalSeriesModule", e), { imageOrientationPatient: i, pixelSpacing: a, frameOfReferenceUID: s, columns: o, rows: l } = Ct("imagePlaneModule", e), c = {
      modality: n,
      imageOrientationPatient: i,
      pixelSpacing: a,
      columns: o,
      rows: l,
      seriesInstanceUID: r
    };
    return t.every((u) => {
      const { modality: h, seriesInstanceUID: g } = Ct("generalSeriesModule", u), { imageOrientationPatient: v, pixelSpacing: m, columns: y, rows: w } = Ct("imagePlaneModule", u);
      return g === c.seriesInstanceUID && h === c.modality && y === c.columns && w === c.rows && zr(v, c.imageOrientationPatient) && zr(m, c.pixelSpacing);
    });
  }
  function M5(t, e) {
    const n = e.getPixelData();
    if (!t.getPointData) return;
    const r = t.getPointData().getScalars().getData();
    if (e.color && e.rgba) {
      const i = new Uint8Array(e.columns * e.rows * 3);
      for (let a = 0; a < e.columns * e.rows; a++) i[a * 3] = n[a * 4], i[a * 3 + 1] = n[a * 4 + 1], i[a * 3 + 2] = n[a * 4 + 2];
      e.rgba = false, e.getPixelData = () => i, r.set(i);
    } else r.set(n);
    t.modified();
  }
  class Mh {
    constructor(e) {
      this.name = e || "unknown";
    }
    static as(e) {
      if (e.iterator) return e.iterator;
      const n = new Mh("as iterator");
      return e.then((r) => {
        try {
          n.add(r, true);
        } catch (i) {
          n.reject(i);
        }
      }, (r) => n.reject(r)), n;
    }
    add(e, n = false) {
      this.nextValue = e, this.done || (this.done = n), this.waiting && (this.waiting.resolve(e), this.waiting = void 0);
    }
    resolve() {
      this.done = true, this.waiting && (this.waiting.resolve(this.nextValue), this.waiting = void 0);
    }
    reject(e) {
      var _a3;
      this.rejectReason = e, (_a3 = this.waiting) == null ? void 0 : _a3.reject(e);
    }
    getRecent() {
      if (this.rejectReason) throw this.rejectReason;
      return this.nextValue;
    }
    async *[Symbol.asyncIterator]() {
      for (; !this.done; ) {
        if (this.rejectReason) throw this.rejectReason;
        if (this.nextValue !== void 0 && (yield this.nextValue, this.done)) break;
        this.waiting || (this.waiting = {}, this.waiting.promise = new Promise((e, n) => {
          this.waiting.resolve = e, this.waiting.reject = n;
        })), await this.waiting.promise;
      }
      yield this.nextValue;
    }
    async forEach(e, n) {
      let r = 0;
      try {
        for await (const i of this) {
          const { done: a } = this;
          try {
            await e(i, a, r), r++;
          } catch (s) {
            if (!a) {
              console.warn("Caught exception in intermediate value", s);
              continue;
            }
            if (n) n(s, a);
            else throw s;
          }
        }
      } catch (i) {
        if (n) n(i, true);
        else throw i;
      }
    }
    generate(e, n) {
      return e(this, this.reject.bind(this)).then(() => {
        this.done || this.resolve();
      }, (r) => {
        this.reject(r), n ? n(r) : console.warn("Couldn't process because", r);
      });
    }
    async nextPromise() {
      for await (const e of this) if (e) return e;
      return this.nextValue;
    }
    async donePromise() {
      for await (const e of this) ;
      return this.nextValue;
    }
    getNextPromise() {
      const e = this.nextPromise();
      return e.iterator = this, e;
    }
    getDonePromise() {
      const e = this.donePromise();
      return e.iterator = this, e;
    }
  }
  function wI(t, e, n = 0) {
    const r = [];
    for (let i = n; i < t.length; i += e) r.push(i);
    return r;
  }
  const X4 = /* @__PURE__ */ new Map(), cS = "imageRetrieveConfiguration", Vp = {
    IMAGE_RETRIEVE_CONFIGURATION: cS,
    clear: () => {
      X4.clear();
    },
    add: (t, e) => {
      X4.set(t, e);
    },
    get: (t, ...e) => {
      if (t === cS) return e.map((n) => X4.get(n)).find((n) => n !== void 0);
    }
  };
  ly(Vp.get.bind(Vp));
  const qie = /* @__PURE__ */ new Set([
    "1.2.840.10008.1.2.4.100",
    "1.2.840.10008.1.2.4.100.1",
    "1.2.840.10008.1.2.4.101",
    "1.2.840.10008.1.2.4.101.1",
    "1.2.840.10008.1.2.4.102",
    "1.2.840.10008.1.2.4.102.1",
    "1.2.840.10008.1.2.4.103",
    "1.2.840.10008.1.2.4.103.1",
    "1.2.840.10008.1.2.4.104",
    "1.2.840.10008.1.2.4.104.1",
    "1.2.840.10008.1.2.4.105",
    "1.2.840.10008.1.2.4.105.1",
    "1.2.840.10008.1.2.4.106",
    "1.2.840.10008.1.2.4.106.1",
    "1.2.840.10008.1.2.4.107",
    "1.2.840.10008.1.2.4.108"
  ]);
  function Xie(t) {
    return t ? (Array.isArray(t) ? t : [
      t
    ]).find((n) => qie.has(n)) : false;
  }
  function R5(t, e, n = {}) {
    const { use16BitTexture: r = false, isVolumeBuffer: i = false } = n;
    switch (t) {
      case "Float32Array":
        return {
          numBytes: e * 4,
          TypedArrayConstructor: Float32Array
        };
      case "Uint8Array":
        return {
          numBytes: e,
          TypedArrayConstructor: Uint8Array
        };
      case "Uint16Array":
        return i ? r ? {
          numBytes: e * 2,
          TypedArrayConstructor: Uint16Array
        } : (console.warn("Uint16Array is not supported for volume rendering, switching back to Float32Array"), {
          numBytes: e * 4,
          TypedArrayConstructor: Float32Array
        }) : {
          numBytes: e * 2,
          TypedArrayConstructor: Uint16Array
        };
      case "Int16Array":
        return i ? r ? {
          numBytes: e * 2,
          TypedArrayConstructor: Int16Array
        } : (console.warn("Int16Array is not supported for volume rendering, switching back to Float32Array"), {
          numBytes: e * 4,
          TypedArrayConstructor: Float32Array
        }) : {
          numBytes: e * 2,
          TypedArrayConstructor: Int16Array
        };
      default:
        if (t) throw new Error("TargetBuffer should be Float32Array, Uint8Array, Uint16Array, or Int16Array");
        return {
          numBytes: e * 4,
          TypedArrayConstructor: Float32Array
        };
    }
  }
  const CI = (t) => Object.values(t).some((n) => typeof n == "number" && !Number.isInteger(n));
  function O5(t, e) {
    const { useNorm16Texture: n, preferSizeOverAccuracy: r } = Do().rendering, i = n || r, a = xI(t), s = Math.floor(t.length / 2), o = t[s], l = vI(o), c = l.rescaleIntercept < 0 || l.rescaleSlope < 0, f = CI(l), u = DK(), { BitsAllocated: h, PixelRepresentation: g, PhotometricInterpretation: v, ImageOrientationPatient: m, PixelSpacing: y, Columns: w, Rows: C } = a, T = Ue(m[0], m[1], m[2]), S = Ue(m[3], m[4], m[5]), E = He();
    Vr(E, T, S);
    const { zSpacing: b, origin: D, sortedImageIds: R } = yI(t, E), I = t.length, O = [
      y[1],
      y[0],
      b
    ], L = [
      w,
      C,
      I
    ], N = [
      ...T,
      ...S,
      ...E
    ], F = g === 1, V = v === "RGB" ? 3 : 1, k = Qu(), _ = L[0] * L[1] * L[2], K = (B) => {
      if (!Ke.isCacheable(B)) throw new Error(ze.CACHE_SIZE_EXCEEDED);
      Ke.decacheIfNecessaryUntilBytesAvailable(B);
    };
    let Z, j;
    switch (h) {
      case 8:
        if (F) throw new Error("8 Bit signed images are not yet supported by this plugin.");
        j = _ * V, K(j), Z = k ? gp(_ * V) : new Uint8Array(_ * V);
        break;
      case 16:
        if (!i || u && f) {
          j = _ * 4, Z = k ? fh(_) : new Float32Array(_);
          break;
        }
        if (j = _ * 2, F || c) {
          K(j), Z = k ? WD(_) : new Int16Array(_);
          break;
        }
        if (!F && !c) {
          K(j), Z = k ? pp(_) : new Uint16Array(_);
          break;
        }
        j = _ * 4, K(j), Z = k ? fh(_) : new Float32Array(_);
        break;
      case 24:
        j = _ * V, K(j), Z = k ? gp(_ * V) : new Uint8Array(_ * V);
        break;
      case 32:
        j = _ * 4, K(j), Z = k ? fh(_) : new Float32Array(_);
        break;
      default:
        throw new Error(`Bits allocated of ${h} is not defined to generate scalarData for the volume.`);
    }
    return {
      dimensions: L,
      spacing: O,
      origin: D,
      direction: N,
      scalarData: Z,
      sizeInBytes: j,
      metadata: a,
      imageIds: R,
      volumeId: e
    };
  }
  const { InterpolationType: $1, OpacityMode: Zie } = jR, { vtkErrorMacro: Z4 } = H, Gg = 4;
  function Qie(t, e) {
    e.classHierarchy.push("vtkVolumeProperty"), t.getMTime = () => {
      let i = e.mtime, a;
      for (let s = 0; s < Gg; s++) e.componentData[s].colorChannels === 1 ? e.componentData[s].grayTransferFunction && (a = e.componentData[s].grayTransferFunction.getMTime(), i = i > a ? i : a) : e.componentData[s].colorChannels === 3 && e.componentData[s].rGBTransferFunction && (a = e.componentData[s].rGBTransferFunction.getMTime(), i = i > a ? i : a), e.componentData[s].scalarOpacity && (a = e.componentData[s].scalarOpacity.getMTime(), i = i > a ? i : a), e.componentData[s].gradientOpacity && (e.componentData[s].disableGradientOpacity || (a = e.componentData[s].gradientOpacity.getMTime(), i = i > a ? i : a));
      return i;
    }, t.getColorChannels = (i) => i < 0 || i > 3 ? (Z4("Bad index - must be between 0 and 3"), 0) : e.componentData[i].colorChannels, t.setGrayTransferFunction = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, s = false;
      return e.componentData[i].grayTransferFunction !== a && (e.componentData[i].grayTransferFunction = a, s = true), e.componentData[i].colorChannels !== 1 && (e.componentData[i].colorChannels = 1, s = true), s && t.modified(), s;
    }, t.getGrayTransferFunction = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.componentData[i].grayTransferFunction === null && (e.componentData[i].grayTransferFunction = Iu.newInstance(), e.componentData[i].grayTransferFunction.addPoint(0, 0), e.componentData[i].grayTransferFunction.addPoint(1024, 1), e.componentData[i].colorChannels !== 1 && (e.componentData[i].colorChannels = 1), t.modified()), e.componentData[i].grayTransferFunction;
    }, t.setRGBTransferFunction = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, s = false;
      return e.componentData[i].rGBTransferFunction !== a && (e.componentData[i].rGBTransferFunction = a, s = true), e.componentData[i].colorChannels !== 3 && (e.componentData[i].colorChannels = 3, s = true), s && t.modified(), s;
    }, t.getRGBTransferFunction = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.componentData[i].rGBTransferFunction === null && (e.componentData[i].rGBTransferFunction = Ul.newInstance(), e.componentData[i].rGBTransferFunction.addRGBPoint(0, 0, 0, 0), e.componentData[i].rGBTransferFunction.addRGBPoint(1024, 1, 1, 1), e.componentData[i].colorChannels !== 3 && (e.componentData[i].colorChannels = 3), t.modified()), e.componentData[i].rGBTransferFunction;
    }, t.setScalarOpacity = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return e.componentData[i].scalarOpacity !== a ? (e.componentData[i].scalarOpacity = a, t.modified(), true) : false;
    }, t.getScalarOpacity = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.componentData[i].scalarOpacity === null && (e.componentData[i].scalarOpacity = Iu.newInstance(), e.componentData[i].scalarOpacity.addPoint(0, 1), e.componentData[i].scalarOpacity.addPoint(1024, 1), t.modified()), e.componentData[i].scalarOpacity;
    }, t.setComponentWeight = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      if (i < 0 || i >= Gg) return Z4("Invalid index"), false;
      const s = Math.min(1, Math.max(0, a));
      return e.componentData[i].componentWeight !== s ? (e.componentData[i].componentWeight = s, t.modified(), true) : false;
    }, t.getComponentWeight = function() {
      let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return i < 0 || i >= Gg ? (Z4("Invalid index"), 0) : e.componentData[i].componentWeight;
    }, t.setInterpolationTypeToNearest = () => t.setInterpolationType($1.NEAREST), t.setInterpolationTypeToLinear = () => t.setInterpolationType($1.LINEAR), t.setInterpolationTypeToFastLinear = () => t.setInterpolationType($1.FAST_LINEAR), t.getInterpolationTypeAsString = () => H.enumToString($1, e.interpolationType), [
      "useGradientOpacity",
      "scalarOpacityUnitDistance",
      "gradientOpacityMinimumValue",
      "gradientOpacityMinimumOpacity",
      "gradientOpacityMaximumValue",
      "gradientOpacityMaximumOpacity",
      "opacityMode",
      "forceNearestInterpolation"
    ].forEach((i) => {
      const a = H.capitalize(i);
      t[`set${a}`] = (s, o) => e.componentData[s][`${i}`] !== o ? (e.componentData[s][`${i}`] = o, t.modified(), true) : false;
    }), [
      "useGradientOpacity",
      "scalarOpacityUnitDistance",
      "gradientOpacityMinimumValue",
      "gradientOpacityMinimumOpacity",
      "gradientOpacityMaximumValue",
      "gradientOpacityMaximumOpacity",
      "opacityMode",
      "forceNearestInterpolation"
    ].forEach((i) => {
      const a = H.capitalize(i);
      t[`get${a}`] = (s) => e.componentData[s][`${i}`];
    });
  }
  const Jie = {
    colorMixPreset: null,
    independentComponents: true,
    interpolationType: $1.FAST_LINEAR,
    shade: false,
    ambient: 0.1,
    diffuse: 0.7,
    specular: 0.2,
    specularPower: 10,
    useLabelOutline: false,
    labelOutlineThickness: [
      1
    ],
    labelOutlineOpacity: 1
  };
  function $ie(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (Object.assign(e, Jie, n), H.obj(t, e), !e.componentData) {
      e.componentData = [];
      for (let r = 0; r < Gg; ++r) e.componentData.push({
        colorChannels: 1,
        grayTransferFunction: null,
        rGBTransferFunction: null,
        scalarOpacity: null,
        scalarOpacityUnitDistance: 1,
        opacityMode: Zie.FRACTIONAL,
        gradientOpacityMinimumValue: 0,
        gradientOpacityMinimumOpacity: 0,
        gradientOpacityMaximumValue: 1,
        gradientOpacityMaximumOpacity: 1,
        useGradientOpacity: false,
        componentWeight: 1,
        forceNearestInterpolation: false
      });
    }
    H.setGet(t, e, [
      "colorMixPreset",
      "independentComponents",
      "interpolationType",
      "shade",
      "ambient",
      "diffuse",
      "specular",
      "specularPower",
      "useLabelOutline",
      "labelOutlineOpacity"
    ]), H.setGetArray(t, e, [
      "labelOutlineThickness"
    ]), Qie(t, e);
  }
  const eae = H.newInstance($ie, "vtkVolumeProperty");
  var tae = {
    newInstance: eae,
    ...jR
  };
  const { vtkDebugMacro: nae } = H;
  function rae(t, e) {
    e.classHierarchy.push("vtkVolume"), t.getVolumes = () => t, t.makeProperty = tae.newInstance, t.getProperty = () => (e.property === null && (e.property = t.makeProperty()), e.property), t.getBounds = () => {
      if (e.mapper === null) return e.bounds;
      const n = e.mapper.getBounds();
      if (!n || n.length !== 6) return n;
      if (n[0] > n[1]) return e.mapperBounds = n.concat(), e.bounds = [
        1,
        -1,
        1,
        -1,
        1,
        -1
      ], e.boundsMTime.modified(), n;
      const r = (i) => i[0].map((a, s) => i.map((o) => o[s]));
      if (!e.mapperBounds || !r([
        n,
        e.mapperBounds
      ]).reduce((i, a) => i && a[0] === a[1], true) || t.getMTime() > e.boundsMTime.getMTime()) {
        nae("Recomputing bounds..."), e.mapperBounds = n.map((s) => s);
        const i = [];
        En.getCorners(n, i), t.computeMatrix();
        const a = new Float64Array(16);
        en(a, e.matrix), i.forEach((s) => $t(s, s, a)), e.bounds[0] = e.bounds[2] = e.bounds[4] = Number.MAX_VALUE, e.bounds[1] = e.bounds[3] = e.bounds[5] = -Number.MAX_VALUE, e.bounds = e.bounds.map((s, o) => o % 2 === 0 ? i.reduce((l, c) => l > c[o / 2] ? c[o / 2] : l, s) : i.reduce((l, c) => l < c[(o - 1) / 2] ? c[(o - 1) / 2] : l, s)), e.boundsMTime.modified();
      }
      return e.bounds;
    }, t.getMTime = () => {
      let n = e.mtime;
      if (e.property !== null) {
        const r = e.property.getMTime();
        n = r > n ? r : n;
      }
      return n;
    }, t.getRedrawMTime = () => {
      let n = e.mtime;
      if (e.mapper !== null) {
        let r = e.mapper.getMTime();
        n = r > n ? r : n, e.mapper.getInput() !== null && (e.mapper.getInputAlgorithm().update(), r = e.mapper.getInput().getMTime(), n = r > n ? r : n);
      }
      return n;
    };
  }
  const iae = {
    mapper: null,
    property: null,
    bounds: [
      1,
      -1,
      1,
      -1,
      1,
      -1
    ]
  };
  function TI(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, iae, n), oy.extend(t, e, n), e.boundsMTime = {}, H.obj(e.boundsMTime), H.set(t, e, [
      "property"
    ]), H.setGet(t, e, [
      "mapper"
    ]), H.getArray(t, e, [
      "bounds"
    ], 6), rae(t, e);
  }
  const aae = H.newInstance(TI, "vtkVolume");
  var sae = {
    newInstance: aae,
    extend: TI
  };
  function oae(t, e) {
    const n = bee.newInstance();
    Do().rendering.preferSizeOverAccuracy && n.setPreferSizeOverAccuracy(true), n.setInputData(t);
    const r = t.getSpacing(), i = (r[0] + r[1] + r[2]) / 6;
    return n.setMaximumSamplesPerRay(4e3), n.setSampleDistance(i), n.setScalarTexture(e), n;
  }
  const lae = 0, cae = ar.Prefetch;
  async function vy(t, e, n) {
    var _a3;
    let r = fae(e);
    !r && ((_a3 = e == null ? void 0 : e.imageIds) == null ? void 0 : _a3.length) && (r = await hae(e, n), r = uae(e, r)), !((r == null ? void 0 : r.lower) === 0 && (r == null ? void 0 : r.upper) === 0 || (r == null ? void 0 : r.lower) === void 0 || (r == null ? void 0 : r.upper) === void 0) && t.getProperty().getRGBTransferFunction(0).setMappingRange(r.lower, r.upper);
  }
  function uae(t, e) {
    const n = t.imageIds, r = Math.floor(n.length / 2), i = n[r], a = Ct("generalSeriesModule", i) || {};
    return gae(a.modality, t) ? {
      lower: 0,
      upper: 5
    } : e;
  }
  function fae(t) {
    var _a3;
    const { imageIds: e, metadata: n } = t;
    let r;
    if (e.length) {
      const i = Math.floor(e.length / 2), a = e[i], s = Ct("voiLutModule", a);
      if (s && s.windowWidth && s.windowCenter) {
        const { windowWidth: o, windowCenter: l } = s;
        r = {
          windowWidth: Array.isArray(o) ? o[0] : o,
          windowCenter: Array.isArray(l) ? l[0] : l
        };
      }
    } else r = (_a3 = n == null ? void 0 : n.voiLut) == null ? void 0 : _a3[0];
    if (r) {
      const { lower: i, upper: a } = lh(Number(r.windowWidth), Number(r.windowCenter));
      return {
        lower: i,
        upper: a
      };
    }
  }
  async function hae(t, e) {
    var _a3;
    const { imageIds: n } = t, r = t.getScalarData(), i = Math.floor(n.length / 2), a = t.imageIds[i], s = Ct("generalSeriesModule", a) || {}, { modality: o } = s, l = Ct("modalityLutModule", a) || {}, c = n.length, f = r.byteLength / c, u = r.length / c, h = r.BYTES_PER_ELEMENT, g = {
      rescaleSlope: l.rescaleSlope,
      rescaleIntercept: l.rescaleIntercept,
      modality: o
    };
    let v;
    if (o === "PT") {
      const E = Ct("scalingModule", a);
      E && (v = {
        ...g,
        suvbw: E.suvbw
      });
    }
    const m = i * f, y = {
      targetBuffer: {
        type: e ? void 0 : "Float32Array"
      },
      priority: lae,
      requestType: cae,
      useNativeDataType: e,
      preScale: {
        enabled: true,
        scalingParameters: v
      }
    };
    let w = Ke.getImage(a);
    ((_a3 = t.referencedImageIds) == null ? void 0 : _a3.length) || (w = await Eh(a, {
      ...y,
      ignoreCache: true
    }));
    const C = w ? w.getPixelData() : dae(t, m, h, u), { min: T, max: S } = V8(C);
    return {
      lower: T,
      upper: S
    };
  }
  function dae(t, e, n, r) {
    const { scalarData: i } = t, { buffer: a } = i;
    i.BYTES_PER_ELEMENT !== n && (e *= i.BYTES_PER_ELEMENT / n);
    const s = i.constructor, o = new s(r), l = new s(a, e, r);
    return o.set(l), o;
  }
  function gae(t, e) {
    var _a3;
    return !(t !== "PT" || !e.isPreScaled || !((_a3 = e.scaling) == null ? void 0 : _a3.PT.suvbw));
  }
  async function uS(t, e, n, r = false, i = false) {
    const { volumeId: a, callback: s, blendMode: o } = t, l = await JO(a);
    if (!l) throw new Error(`imageVolume with id: ${l.volumeId} does not exist`);
    const { imageData: c, vtkOpenGLTexture: f } = l, u = oae(c, f);
    o && u.setBlendMode(o);
    const h = sae.newInstance();
    return h.setMapper(u), c.getPointData().getScalars().getNumberOfComponents() === 3 && h.getProperty().setIndependentComponents(false), await vy(h, l, i), s && s({
      volumeActor: h,
      volumeId: a
    }), r || pae(e, n, h, a), h;
  }
  function pae(t, e, n, r) {
    const i = n.getProperty().getRGBTransferFunction(0).getRange(), a = {
      viewportId: e,
      range: {
        lower: i[0],
        upper: i[1]
      },
      volumeId: r
    };
    qe(t, ze.VOI_MODIFIED, a);
  }
  var mae = [
    {
      Name: "KAAMS",
      IndexedColors: [
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        1,
        0.63,
        0.63,
        1,
        0.67,
        0.5,
        0.33,
        1,
        0.5,
        0.75,
        0.53,
        0.35,
        0.7,
        1,
        0.75,
        0.5
      ],
      Annotations: [
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11
      ]
    },
    {
      ColorSpace: "Diverging",
      Name: "Cool to Warm",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0.23137254902,
        0.298039215686,
        0.752941176471,
        0.5,
        0.865,
        0.865,
        0.865,
        1,
        0.705882352941,
        0.0156862745098,
        0.149019607843
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Cool to Warm (Extended)",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        0,
        0,
        0.34902,
        0.03125,
        0.039216,
        0.062745,
        0.380392,
        0.0625,
        0.062745,
        0.117647,
        0.411765,
        0.09375,
        0.090196,
        0.184314,
        0.45098,
        0.125,
        0.12549,
        0.262745,
        0.501961,
        0.15625,
        0.160784,
        0.337255,
        0.541176,
        0.1875,
        0.2,
        0.396078,
        0.568627,
        0.21875,
        0.239216,
        0.454902,
        0.6,
        0.25,
        0.286275,
        0.521569,
        0.65098,
        0.28125,
        0.337255,
        0.592157,
        0.701961,
        0.3125,
        0.388235,
        0.654902,
        0.74902,
        0.34375,
        0.466667,
        0.737255,
        0.819608,
        0.375,
        0.572549,
        0.819608,
        0.878431,
        0.40625,
        0.654902,
        0.866667,
        0.909804,
        0.4375,
        0.752941,
        0.917647,
        0.941176,
        0.46875,
        0.823529,
        0.956863,
        0.968627,
        0.5,
        0.988235,
        0.960784,
        0.901961,
        0.5,
        0.941176,
        0.984314,
        0.988235,
        0.52,
        0.988235,
        0.945098,
        0.85098,
        0.54,
        0.980392,
        0.898039,
        0.784314,
        0.5625,
        0.968627,
        0.835294,
        0.698039,
        0.59375,
        0.94902,
        0.733333,
        0.588235,
        0.625,
        0.929412,
        0.65098,
        0.509804,
        0.65625,
        0.909804,
        0.564706,
        0.435294,
        0.6875,
        0.878431,
        0.458824,
        0.352941,
        0.71875,
        0.839216,
        0.388235,
        0.286275,
        0.75,
        0.760784,
        0.294118,
        0.211765,
        0.78125,
        0.701961,
        0.211765,
        0.168627,
        0.8125,
        0.65098,
        0.156863,
        0.129412,
        0.84375,
        0.6,
        0.094118,
        0.094118,
        0.875,
        0.54902,
        0.066667,
        0.098039,
        0.90625,
        0.501961,
        0.05098,
        0.12549,
        0.9375,
        0.45098,
        0.054902,
        0.172549,
        0.96875,
        0.4,
        0.054902,
        0.192157,
        1,
        0.34902,
        0.070588,
        0.211765
      ]
    },
    {
      ColorSpace: "Diverging",
      Name: "Warm to Cool",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0.705882352941,
        0.0156862745098,
        0.149019607843,
        0.5,
        0.865,
        0.865,
        0.865,
        1,
        0.23137254902,
        0.298039215686,
        0.752941176471
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Warm to Cool (Extended)",
      NanColor: [
        0.250004,
        0,
        0
      ],
      RGBPoints: [
        0,
        0.34902,
        0,
        0.129412,
        0.025,
        0.4,
        392157e-8,
        0.101961,
        0.05,
        0.470588,
        0.0156863,
        0.0901961,
        0.075,
        0.54902,
        0.027451,
        0.0705882,
        0.1,
        0.619608,
        0.0627451,
        0.0431373,
        0.125,
        0.690196,
        0.12549,
        0.0627451,
        0.15,
        0.741176,
        0.184314,
        0.0745098,
        0.175,
        0.788235,
        0.266667,
        0.0941176,
        0.2,
        0.811765,
        0.345098,
        0.113725,
        0.225,
        0.831373,
        0.411765,
        0.133333,
        0.25,
        0.85098,
        0.47451,
        0.145098,
        0.275,
        0.870588,
        0.54902,
        0.156863,
        0.3,
        0.878431,
        0.619608,
        0.168627,
        0.325,
        0.890196,
        0.658824,
        0.196078,
        0.35,
        0.909804,
        0.717647,
        0.235294,
        0.375,
        0.929412,
        0.776471,
        0.278431,
        0.395522,
        0.94902,
        0.823529,
        0.321569,
        0.418905,
        0.968627,
        0.87451,
        0.407843,
        0.444278,
        0.980392,
        0.917647,
        0.509804,
        0.470149,
        0.988235,
        0.956863,
        0.643137,
        0.483582,
        0.992157,
        0.964706,
        0.713725,
        0.499,
        0.988235,
        0.980392,
        0.870588,
        0.5,
        1,
        1,
        1,
        0.501,
        0.913725,
        0.988235,
        0.937255,
        0.516418,
        0.827451,
        0.980392,
        0.886275,
        0.531343,
        0.764706,
        0.980392,
        0.866667,
        0.546766,
        0.658824,
        0.980392,
        0.843137,
        0.564179,
        0.572549,
        0.964706,
        0.835294,
        0.587562,
        0.423529,
        0.941176,
        0.87451,
        0.60597,
        0.262745,
        0.901961,
        0.862745,
        0.629851,
        0.0705882,
        0.854902,
        0.870588,
        0.651741,
        0.0509804,
        0.8,
        0.85098,
        0.681592,
        0.0235294,
        0.709804,
        0.831373,
        0.712935,
        0.0313725,
        0.615686,
        0.811765,
        0.75,
        0.0313725,
        0.537255,
        0.788235,
        0.775,
        0.0392157,
        0.466667,
        0.768627,
        0.8,
        0.0509804,
        0.396078,
        0.741176,
        0.825,
        0.054902,
        0.317647,
        0.709804,
        0.85,
        0.054902,
        0.243137,
        0.678431,
        0.875,
        0.0431373,
        0.164706,
        0.639216,
        0.9,
        0.0313725,
        0.0980392,
        0.6,
        0.925,
        0.0392157,
        0.0392157,
        0.560784,
        0.95,
        0.105882,
        0.0509804,
        0.509804,
        0.975,
        0.113725,
        0.0235294,
        0.45098,
        1,
        0.12549,
        0,
        0.380392
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Rainbow Desaturated",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0.278431372549,
        0.278431372549,
        0.858823529412,
        0.143,
        0,
        0,
        0.360784313725,
        0.285,
        0,
        1,
        1,
        0.429,
        0,
        0.501960784314,
        0,
        0.571,
        1,
        1,
        0,
        0.714,
        1,
        0.380392156863,
        0,
        0.857,
        0.419607843137,
        0,
        0,
        1,
        0.878431372549,
        0.301960784314,
        0.301960784314
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Cold and Hot",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0,
        1,
        1,
        0.45,
        0,
        0,
        1,
        0.5,
        0,
        0,
        0.501960784314,
        0.55,
        1,
        0,
        0,
        1,
        1,
        1,
        0
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Black-Body Radiation",
      NanColor: [
        0,
        0.498039215686,
        1
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        0.4,
        0.901960784314,
        0,
        0,
        0.8,
        0.901960784314,
        0.901960784314,
        0,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "X Ray",
      NanColor: [
        1,
        0,
        0
      ],
      RGBPoints: [
        0,
        1,
        1,
        1,
        1,
        0,
        0,
        0
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Grayscale",
      NanColor: [
        1,
        0,
        0
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "BkRd",
      NanColor: [
        0,
        1,
        1
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        0
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "BkGn",
      NanColor: [
        1,
        0,
        1
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        0
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "BkBu",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "BkMa",
      NanColor: [
        0,
        1,
        0
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "BkCy",
      NanColor: [
        0,
        1,
        1
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Black, Blue and White",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        0.333,
        0,
        0,
        0.501960784314,
        0.666,
        0,
        0.501960784314,
        1,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Black, Orange and White",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        0.333,
        0.501960784314,
        0,
        0,
        0.666,
        1,
        0.501960784314,
        0,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Linear YGB 1211g",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        1,
        0.988235,
        0.968627,
        0.02,
        1,
        0.952941,
        0.878431,
        0.05,
        0.968627,
        0.905882,
        0.776471,
        0.1,
        0.94902,
        0.898039,
        0.647059,
        0.15,
        0.901961,
        0.878431,
        0.556863,
        0.2,
        0.847059,
        0.858824,
        0.482353,
        0.25,
        0.690196,
        0.819608,
        0.435294,
        0.3,
        0.513725,
        0.768627,
        0.384314,
        0.35,
        0.337255,
        0.721569,
        0.337255,
        0.4,
        0.278431,
        0.658824,
        0.392157,
        0.45,
        0.231373,
        0.639216,
        0.435294,
        0.5,
        0.203922,
        0.6,
        0.486275,
        0.55,
        0.172549,
        0.568627,
        0.537255,
        0.6,
        0.141176,
        0.517647,
        0.54902,
        0.65,
        0.133333,
        0.458824,
        0.541176,
        0.7,
        0.12549,
        0.396078,
        0.529412,
        0.75,
        0.117647,
        0.321569,
        0.521569,
        0.8,
        0.121569,
        0.258824,
        0.509804,
        0.85,
        0.133333,
        0.227451,
        0.501961,
        0.9,
        0.145098,
        0.192157,
        0.490196,
        0.95,
        0.188235,
        0.164706,
        0.470588,
        1,
        0.258824,
        0.196078,
        0.439216
      ]
    },
    {
      ColorSpace: "CIELAB",
      Creator: "Francesca Samsel",
      Name: "Linear Green (Gr4L)",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        0.054902,
        0.109804,
        0.121569,
        0.05,
        0.07451,
        0.172549,
        0.180392,
        0.1,
        0.086275,
        0.231373,
        0.219608,
        0.15,
        0.094118,
        0.278431,
        0.25098,
        0.2,
        0.109804,
        0.34902,
        0.278431,
        0.25,
        0.113725,
        0.4,
        0.278431,
        0.3,
        0.117647,
        0.45098,
        0.270588,
        0.35,
        0.117647,
        0.490196,
        0.243137,
        0.4,
        0.113725,
        0.521569,
        0.203922,
        0.45,
        0.109804,
        0.54902,
        0.152941,
        0.5,
        0.082353,
        0.588235,
        0.082353,
        0.55,
        0.109804,
        0.631373,
        0.05098,
        0.6,
        0.211765,
        0.678431,
        0.082353,
        0.65,
        0.317647,
        0.721569,
        0.113725,
        0.7,
        0.431373,
        0.760784,
        0.160784,
        0.75,
        0.556863,
        0.8,
        0.239216,
        0.8,
        0.666667,
        0.839216,
        0.294118,
        0.85,
        0.784314,
        0.878431,
        0.396078,
        0.9,
        0.886275,
        0.921569,
        0.533333,
        0.95,
        0.960784,
        0.94902,
        0.670588,
        1,
        1,
        0.984314,
        0.901961
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Linear Blue (8_31f)",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        0.960784,
        1,
        0.980392,
        0.05,
        0.815686,
        0.960784,
        0.913725,
        0.1,
        0.670588,
        0.929412,
        0.870588,
        0.15,
        0.556863,
        0.901961,
        0.843137,
        0.2,
        0.478431,
        0.870588,
        0.823529,
        0.25,
        0.439216,
        0.831373,
        0.803922,
        0.3,
        0.4,
        0.8,
        0.788235,
        0.35,
        0.376471,
        0.768627,
        0.768627,
        0.4,
        0.34902,
        0.709804,
        0.729412,
        0.45,
        0.32549,
        0.654902,
        0.690196,
        0.5,
        0.301961,
        0.607843,
        0.658824,
        0.55,
        0.247059,
        0.545098,
        0.619608,
        0.6,
        0.239216,
        0.494118,
        0.580392,
        0.65,
        0.227451,
        0.439216,
        0.541176,
        0.7,
        0.227451,
        0.403922,
        0.521569,
        0.75,
        0.231373,
        0.368627,
        0.501961,
        0.8,
        0.227451,
        0.321569,
        0.470588,
        0.85,
        0.219608,
        0.282353,
        0.439216,
        0.9,
        0.192157,
        0.235294,
        0.4,
        0.95,
        0.160784,
        0.184314,
        0.34902,
        1,
        0.133333,
        0.12549,
        0.301961
      ]
    },
    {
      ColorSpace: "HSV",
      Name: "Blue to Red Rainbow",
      NanColor: [
        0.498039215686,
        0.498039215686,
        0.498039215686
      ],
      RGBPoints: [
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0
      ]
    },
    {
      ColorSpace: "HSV",
      Name: "Red to Blue Rainbow",
      NanColor: [
        0.498039215686,
        0.498039215686,
        0.498039215686
      ],
      RGBPoints: [
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Rainbow Blended White",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        1,
        1,
        1,
        0.17,
        0,
        0,
        1,
        0.34,
        0,
        1,
        1,
        0.5,
        0,
        1,
        0,
        0.67,
        1,
        1,
        0,
        0.84,
        1,
        0,
        0,
        1,
        0.878431372549,
        0,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Rainbow Blended Grey",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0.317647058824,
        0.341176470588,
        0.43137254902,
        0.17,
        0,
        0,
        1,
        0.34,
        0,
        1,
        1,
        0.5,
        0,
        1,
        0,
        0.67,
        1,
        1,
        0,
        0.84,
        1,
        0,
        0,
        1,
        0.878431372549,
        0,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Rainbow Blended Black",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0,
        0,
        0,
        0.17,
        0,
        0,
        1,
        0.34,
        0,
        1,
        1,
        0.5,
        0,
        1,
        0,
        0.67,
        1,
        1,
        0,
        0.84,
        1,
        0,
        0,
        1,
        0.878431372549,
        0,
        1
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Blue to Yellow",
      NanColor: [
        1,
        0,
        0
      ],
      RGBPoints: [
        0,
        0.0392156862745,
        0.0392156862745,
        0.949019607843,
        1,
        0.949019607843,
        0.949019607843,
        0.0392156862745
      ]
    },
    {
      ColorSpace: "HSV",
      Name: "blot",
      RGBPoints: [
        0,
        0,
        0,
        1,
        0.166,
        0,
        0,
        1,
        0.167,
        1,
        0,
        1,
        0.332,
        1,
        0,
        1,
        0.333,
        0,
        1,
        1,
        0.5,
        0,
        1,
        1,
        0.501,
        0,
        1,
        0,
        0.666,
        0,
        1,
        0,
        0.667,
        1,
        1,
        0,
        0.832,
        1,
        1,
        0,
        0.833,
        1,
        0,
        0,
        1,
        1,
        0,
        0
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "CIELab Blue to Red",
      NanColor: [
        1,
        1,
        0
      ],
      RGBPoints: [
        0,
        0,
        0.6,
        0.749019607843,
        1,
        0.76862745098,
        0.466666666667,
        0.341176470588
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "jet",
      RGBPoints: [
        -1,
        0,
        0,
        0.5625,
        -0.777778,
        0,
        0,
        1,
        -0.269841,
        0,
        1,
        1,
        -0.015873,
        0.5,
        1,
        0.5,
        0.238095,
        1,
        1,
        0,
        0.746032,
        1,
        0,
        0,
        1,
        0.5,
        0,
        0
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "rainbow",
      RGBPoints: [
        -1,
        0,
        0,
        1,
        -0.5,
        0,
        1,
        1,
        0,
        0,
        1,
        0,
        0.5,
        1,
        1,
        0,
        1,
        1,
        0,
        0
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_rainbow_bright",
      RGBPoints: [
        -1,
        0.32549,
        0.14902,
        0.960784,
        -0.866221,
        0.297047,
        0.375586,
        0.963836,
        -0.732441,
        0.180302,
        0.536818,
        0.964627,
        -0.598662,
        0.1302,
        0.649207,
        0.929647,
        -0.464883,
        0.0445143,
        0.749654,
        0.855998,
        -0.331104,
        0.0271325,
        0.830713,
        0.721527,
        -0.197324,
        0.259504,
        0.866145,
        0.543555,
        -0.0635452,
        0.428364,
        0.890725,
        0.329819,
        0.0702341,
        0.568503,
        0.898508,
        0.187623,
        0.204013,
        0.738259,
        0.890317,
        0.0825461,
        0.337793,
        0.84546,
        0.86136,
        0.0147555,
        0.471572,
        0.912191,
        0.808018,
        0,
        0.605351,
        0.962848,
        0.710445,
        0,
        0.73913,
        0.999469,
        0.600258,
        0.0176284,
        0.87291,
        0.994156,
        0.445975,
        0.193912,
        1,
        0.980407,
        0.247105,
        0.262699
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_rainbow_dark",
      RGBPoints: [
        -1,
        0,
        0,
        0.423499,
        -0.866221,
        0,
        0.119346,
        0.529237,
        -0.732441,
        0,
        0.238691,
        0.634976,
        -0.598662,
        0,
        0.346852,
        0.68788,
        -0.464883,
        0,
        0.45022,
        0.718141,
        -0.331104,
        0,
        0.553554,
        0.664839,
        -0.197324,
        0,
        0.651082,
        0.519303,
        -0.0635452,
        0.115841,
        0.72479,
        0.352857,
        0.0702341,
        0.326771,
        0.781195,
        0.140187,
        0.204013,
        0.522765,
        0.798524,
        0.0284624,
        0.337793,
        0.703162,
        0.788685,
        885756e-8,
        0.471572,
        0.845118,
        0.751133,
        0,
        0.605351,
        0.955734,
        0.690825,
        0,
        0.73913,
        0.995402,
        0.567916,
        0.0618524,
        0.87291,
        0.987712,
        0.403398,
        0.164851,
        1,
        0.980407,
        0.247105,
        0.262699
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "nic_CubicL",
      RGBPoints: [
        -1,
        0.479965,
        0.0118108,
        0.5307,
        -0.87451,
        0.522213,
        0.0551282,
        0.706919,
        -0.74902,
        0.50839,
        0.237278,
        0.867764,
        -0.623529,
        0.451617,
        0.373834,
        0.987255,
        -0.498039,
        0.39365,
        0.497255,
        0.97506,
        -0.372549,
        0.328631,
        0.599639,
        0.891843,
        -0.247059,
        0.250043,
        0.690286,
        0.778553,
        -0.121569,
        0.249656,
        0.764905,
        0.645857,
        392157e-8,
        0.297954,
        0.821466,
        0.50449,
        0.129412,
        0.337509,
        0.872595,
        0.358447,
        0.254902,
        0.430011,
        0.913789,
        0.297079,
        0.380392,
        0.587191,
        0.931381,
        0.333353,
        0.505882,
        0.727937,
        0.93591,
        0.353742,
        0.631373,
        0.826403,
        0.921081,
        0.365066,
        0.756863,
        0.893201,
        0.846317,
        0.372662,
        0.882353,
        0.965347,
        0.73884,
        0.378506,
        1,
        0.983235,
        0.597451,
        0.366856
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "nic_CubicYF",
      RGBPoints: [
        -1,
        0.5151,
        0.0482,
        0.6697,
        -0.87451,
        0.520711,
        0.168955,
        0.800574,
        -0.74902,
        0.493694,
        0.278596,
        0.911824,
        -0.623529,
        0.440026,
        0.369475,
        0.984978,
        -0.498039,
        0.398932,
        0.457593,
        0.987053,
        -0.372549,
        0.350651,
        0.540644,
        0.929608,
        -0.247059,
        0.298827,
        0.615625,
        0.857729,
        -0.121569,
        0.239928,
        0.685061,
        0.769531,
        392157e-8,
        0.228832,
        0.739349,
        0.673287,
        0.129412,
        0.263297,
        0.78608,
        0.569988,
        0.254902,
        0.298107,
        0.828337,
        0.460214,
        0.380392,
        0.33092,
        0.864071,
        0.352674,
        0.505882,
        0.38306,
        0.898169,
        0.287309,
        0.631373,
        0.49023,
        0.917481,
        0.307961,
        0.756863,
        0.62372,
        0.926026,
        0.332309,
        0.882353,
        0.717458,
        0.92527,
        0.342476,
        1,
        0.8,
        0.9255,
        0.3529
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "gist_earth",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.239216,
        0.027451,
        0.415686,
        -0.74902,
        0.0901961,
        0.254902,
        0.556863,
        -0.623529,
        0.0941176,
        0.352941,
        0.54902,
        -0.498039,
        0.105882,
        0.435294,
        0.533333,
        -0.372549,
        0.12549,
        0.52549,
        0.501961,
        -0.247059,
        0.156863,
        0.596078,
        0.443137,
        -0.121569,
        0.196078,
        0.65098,
        0.380392,
        392157e-8,
        0.282353,
        0.717647,
        0.301961,
        0.129412,
        0.466667,
        0.772549,
        0.27451,
        0.254902,
        0.678431,
        0.784314,
        0.309804,
        0.380392,
        0.901961,
        0.756863,
        0.376471,
        0.505882,
        0.992157,
        0.705882,
        0.521569,
        0.631373,
        1,
        0.721569,
        0.701961,
        0.756863,
        1,
        0.784314,
        0.784314,
        0.882353,
        1,
        0.866667,
        0.866667,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "2hot",
      RGBPoints: [
        -1,
        0.0416667,
        0,
        0,
        -0.873016,
        0.208333,
        0,
        0,
        -0.746032,
        0.375,
        0,
        0,
        -0.619048,
        0.541667,
        0,
        0,
        -0.492063,
        0.708333,
        0,
        0,
        -0.365079,
        0.854137,
        0,
        0,
        -0.238095,
        0.937488,
        0.039062,
        0,
        -0.111111,
        1,
        0.208333,
        0,
        0.015873,
        1,
        0.375,
        0,
        0.142857,
        1,
        0.541667,
        0,
        0.269841,
        1,
        0.708333,
        0,
        0.396825,
        1,
        0.858805,
        0.03125,
        0.52381,
        1,
        0.947392,
        0.15625,
        0.650794,
        1,
        1,
        0.3125,
        0.777778,
        1,
        1,
        0.5625,
        0.904762,
        1,
        1,
        0.8125,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_red2yellow_BW",
      RGBPoints: [
        -1,
        754296e-12,
        0,
        109827e-10,
        -0.87451,
        0.18285,
        0.0264094,
        0,
        -0.74902,
        0.3066,
        0,
        0,
        -0.623529,
        0.422841,
        0,
        0,
        -0.498039,
        0.522945,
        0,
        0,
        -0.372549,
        0.605721,
        0,
        0,
        -0.247059,
        0.672502,
        0.14168,
        0,
        -0.121569,
        0.728167,
        0.244025,
        0,
        392157e-8,
        0.781215,
        0.333454,
        0,
        0.129412,
        0.825,
        0.423586,
        0,
        0.254902,
        0.855893,
        0.516793,
        0,
        0.380392,
        0.880491,
        0.608846,
        0,
        0.505882,
        0.910305,
        0.695505,
        0,
        0.631373,
        0.94109,
        0.779067,
        0.223528,
        0.756863,
        0.967873,
        0.858572,
        0.473521,
        0.882353,
        0.986815,
        0.933211,
        0.751583,
        1,
        1,
        1,
        0.999997
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_marine2gold_BW",
      RGBPoints: [
        -1,
        111641e-12,
        0,
        162551e-11,
        -0.87451,
        0.0413146,
        0.0619808,
        0.209857,
        -0.74902,
        0.0185557,
        0.101341,
        0.350684,
        -0.623529,
        486405e-8,
        0.149847,
        0.461054,
        -0.498039,
        0.0836345,
        0.210845,
        0.517906,
        -0.372549,
        0.173222,
        0.276134,
        0.541793,
        -0.247059,
        0.259857,
        0.343877,
        0.535869,
        -0.121569,
        0.362299,
        0.408124,
        0.504293,
        392157e-8,
        0.468266,
        0.468276,
        0.468257,
        0.129412,
        0.582781,
        0.527545,
        0.374914,
        0.254902,
        0.691591,
        0.585251,
        0.274266,
        0.380392,
        0.784454,
        0.645091,
        0.247332,
        0.505882,
        0.862299,
        0.710383,
        0.27518,
        0.631373,
        0.920863,
        0.782923,
        0.351563,
        0.756863,
        0.955792,
        0.859699,
        0.533541,
        0.882353,
        0.976162,
        0.93433,
        0.780671,
        1,
        1,
        1,
        0.999983
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_blue2gold_BW",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.0742735,
        0.0440331,
        0.230013,
        -0.74902,
        0.125276,
        0.0258685,
        0.415826,
        -0.623529,
        0.143879,
        0.0163031,
        0.591346,
        -0.498039,
        0.212261,
        0.0627855,
        0.705239,
        -0.372549,
        0.306048,
        0.141178,
        0.763636,
        -0.247059,
        0.391537,
        0.232286,
        0.773263,
        -0.121569,
        0.461734,
        0.336633,
        0.708321,
        392157e-8,
        0.54209,
        0.427581,
        0.590007,
        0.129412,
        0.61704,
        0.508623,
        0.460978,
        0.254902,
        0.702703,
        0.579586,
        0.309117,
        0.380392,
        0.790336,
        0.644811,
        0.170397,
        0.505882,
        0.870173,
        0.710733,
        0.117134,
        0.631373,
        0.93656,
        0.781991,
        0.157144,
        0.756863,
        0.965672,
        0.862068,
        0.409836,
        0.882353,
        0.985751,
        0.936296,
        0.714162,
        1,
        1,
        1,
        0.999999
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_sapphire2gold_BW",
      RGBPoints: [
        -1,
        0.107704,
        0.107708,
        0.107694,
        -0.87451,
        0.1851,
        0.112354,
        0.308554,
        -0.74902,
        0.236782,
        0.114233,
        0.48788,
        -0.623529,
        0.28296,
        0.126187,
        0.639464,
        -0.498039,
        0.344787,
        0.171643,
        0.739713,
        -0.372549,
        0.413325,
        0.242371,
        0.76913,
        -0.247059,
        0.481863,
        0.3131,
        0.719841,
        -0.121569,
        0.550402,
        0.383829,
        0.612222,
        392157e-8,
        0.61894,
        0.454558,
        0.51126,
        0.129412,
        0.687478,
        0.525287,
        0.39993,
        0.254902,
        0.756017,
        0.596016,
        0.289923,
        0.380392,
        0.824555,
        0.666745,
        0.255498,
        0.505882,
        0.892979,
        0.736822,
        0.27696,
        0.631373,
        0.938851,
        0.804966,
        0.351734,
        0.756863,
        0.966491,
        0.874853,
        0.53572,
        0.882353,
        0.982105,
        0.94153,
        0.782579,
        1,
        1,
        1,
        0.999986
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_red2purple_BW",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.167793,
        0.0166271,
        0.0431278,
        -0.74902,
        0.262608,
        0.0107595,
        0.0791181,
        -0.623529,
        0.351902,
        0.0101858,
        0.100926,
        -0.498039,
        0.441257,
        0.0160835,
        0.131919,
        -0.372549,
        0.5221,
        0.0555972,
        0.195625,
        -0.247059,
        0.593852,
        0.104294,
        0.310234,
        -0.121569,
        0.654628,
        0.158115,
        0.448486,
        392157e-8,
        0.707443,
        0.220914,
        0.570253,
        0.129412,
        0.749504,
        0.293268,
        0.67897,
        0.254902,
        0.781587,
        0.370517,
        0.779269,
        0.380392,
        0.809951,
        0.451099,
        0.855831,
        0.505882,
        0.84424,
        0.531462,
        0.900451,
        0.631373,
        0.865174,
        0.620901,
        0.91606,
        0.756863,
        0.875041,
        0.714054,
        0.910284,
        0.882353,
        0.880764,
        0.80554,
        0.896276,
        1,
        0.887572,
        0.887591,
        0.887556
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_purple2pink_BW",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.117562,
        0.0291202,
        0.175876,
        -0.74902,
        0.178368,
        0.0458476,
        0.285454,
        -0.623529,
        0.237731,
        0.0680173,
        0.387717,
        -0.498039,
        0.300877,
        0.0956291,
        0.484802,
        -0.372549,
        0.370929,
        0.136858,
        0.554985,
        -0.247059,
        0.449033,
        0.189273,
        0.58863,
        -0.121569,
        0.529971,
        0.245796,
        0.598587,
        392157e-8,
        0.609914,
        0.300643,
        0.610244,
        0.129412,
        0.697079,
        0.351286,
        0.616371,
        0.254902,
        0.785858,
        0.401991,
        0.617376,
        0.380392,
        0.862517,
        0.45745,
        0.64463,
        0.505882,
        0.91359,
        0.525462,
        0.705336,
        0.631373,
        0.932583,
        0.61064,
        0.767412,
        0.756863,
        0.922478,
        0.706966,
        0.817522,
        0.882353,
        0.901302,
        0.803071,
        0.856311,
        1,
        0.887571,
        0.887591,
        0.887549
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_pbj_lin",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.091821,
        0.0611476,
        0.10617,
        -0.74902,
        0.160311,
        0.0900022,
        0.192713,
        -0.623529,
        0.22484,
        0.12126,
        0.272128,
        -0.498039,
        0.291263,
        0.157469,
        0.340828,
        -0.372549,
        0.360015,
        0.200388,
        0.388903,
        -0.247059,
        0.437497,
        0.250058,
        0.387201,
        -0.121569,
        0.512636,
        0.304969,
        0.355955,
        392157e-8,
        0.582603,
        0.360874,
        0.33488,
        0.129412,
        0.655126,
        0.416374,
        0.306351,
        0.254902,
        0.725889,
        0.473329,
        0.279051,
        0.380392,
        0.778125,
        0.537928,
        0.302697,
        0.505882,
        0.815894,
        0.606931,
        0.382431,
        0.631373,
        0.839159,
        0.679308,
        0.497608,
        0.756863,
        0.854748,
        0.751666,
        0.631792,
        0.882353,
        0.869483,
        0.822508,
        0.768592,
        1,
        0.887572,
        0.887589,
        0.887565
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_blue2green_muted",
      RGBPoints: [
        -1,
        0.107704,
        0.107708,
        0.107695,
        -0.87451,
        0.141522,
        0.13066,
        0.270741,
        -0.74902,
        0.180123,
        0.146119,
        0.42308,
        -0.623529,
        0.210161,
        0.169674,
        0.551795,
        -0.498039,
        0.239701,
        0.212939,
        0.634969,
        -0.372549,
        0.253916,
        0.282947,
        0.653641,
        -0.247059,
        0.242791,
        0.366933,
        0.608521,
        -0.121569,
        0.226302,
        0.446776,
        0.52693,
        392157e-8,
        0.236237,
        0.514689,
        0.458798,
        0.129412,
        0.274641,
        0.577589,
        0.376069,
        0.254902,
        0.349625,
        0.633993,
        0.288131,
        0.380392,
        0.4437,
        0.683677,
        0.260497,
        0.505882,
        0.536247,
        0.731214,
        0.285424,
        0.631373,
        0.628472,
        0.777128,
        0.349151,
        0.756863,
        0.718259,
        0.819287,
        0.496825,
        0.882353,
        0.804768,
        0.856164,
        0.703299,
        1,
        0.887571,
        0.887591,
        0.887548
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_blue2green_BW",
      RGBPoints: [
        -1,
        363578e-12,
        0,
        529374e-11,
        -0.87451,
        0.0539915,
        0.0577948,
        0.212806,
        -0.74902,
        0.0620393,
        0.0758942,
        0.388959,
        -0.623529,
        0.0697499,
        0.102032,
        0.54177,
        -0.498039,
        0.113295,
        0.156156,
        0.64334,
        -0.372549,
        0.152047,
        0.243196,
        0.670283,
        -0.247059,
        0.158096,
        0.344084,
        0.622864,
        -0.121569,
        0.151142,
        0.43922,
        0.532767,
        392157e-8,
        0.17155,
        0.521588,
        0.457719,
        0.129412,
        0.225861,
        0.599141,
        0.363997,
        0.254902,
        0.32328,
        0.67007,
        0.259083,
        0.380392,
        0.442344,
        0.733697,
        0.223754,
        0.505882,
        0.558409,
        0.794941,
        0.257411,
        0.631373,
        0.673875,
        0.854344,
        0.340822,
        0.756863,
        0.787244,
        0.909326,
        0.524717,
        0.882353,
        0.896483,
        0.958063,
        0.775914,
        1,
        1,
        1,
        0.999982
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GREEN-WHITE_LINEAR",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0,
        0.062745,
        0,
        -0.74902,
        0,
        0.12549,
        0,
        -0.623529,
        0,
        0.188235,
        0,
        -0.498039,
        0,
        0.25098,
        0,
        -0.372549,
        0,
        0.313725,
        0,
        -0.247059,
        0,
        0.376471,
        0,
        -0.121569,
        0.094118,
        0.439216,
        0,
        392157e-8,
        0.196078,
        0.501961,
        0,
        0.129412,
        0.294118,
        0.564706,
        0,
        0.254902,
        0.396078,
        0.627451,
        0,
        0.380392,
        0.498039,
        0.690196,
        0,
        0.505882,
        0.6,
        0.752941,
        0.145098,
        0.631373,
        0.701961,
        0.815686,
        0.364706,
        0.756863,
        0.8,
        0.878431,
        0.580392,
        0.882353,
        0.901961,
        0.941176,
        0.796078,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_green2yellow_BW",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0,
        0.105542,
        0.0603919,
        -0.74902,
        0,
        0.159454,
        0.104148,
        -0.623529,
        0,
        0.219502,
        0.15542,
        -0.498039,
        0,
        0.282276,
        0.203811,
        -0.372549,
        0,
        0.346331,
        0.235652,
        -0.247059,
        0,
        0.411765,
        0.235428,
        -0.121569,
        0,
        0.477177,
        0.217977,
        392157e-8,
        0.0593644,
        0.541635,
        0.21361,
        0.129412,
        0.233081,
        0.604722,
        0.210591,
        0.254902,
        0.369803,
        0.664942,
        0.226536,
        0.380392,
        0.498446,
        0.722367,
        0.288237,
        0.505882,
        0.601929,
        0.782244,
        0.380815,
        0.631373,
        0.703207,
        0.840497,
        0.512134,
        0.756863,
        0.803186,
        0.896433,
        0.674462,
        0.882353,
        0.903834,
        0.950266,
        0.846715,
        1,
        1,
        1,
        0.999981
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "blue2cyan",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0,
        0.152941,
        0.364706,
        -0.74902,
        0,
        0.254902,
        0.470588,
        -0.623529,
        0,
        0.34902,
        0.572549,
        -0.498039,
        0,
        0.443137,
        0.670588,
        -0.372549,
        0,
        0.537255,
        0.772549,
        -0.247059,
        0,
        0.627451,
        0.870588,
        -0.121569,
        0,
        0.717647,
        0.964706,
        392157e-8,
        0.0784314,
        0.772549,
        1,
        0.129412,
        0.207843,
        0.858824,
        1,
        0.254902,
        0.32549,
        0.941176,
        1,
        0.380392,
        0.45098,
        1,
        1,
        0.505882,
        0.560784,
        1,
        1,
        0.631373,
        0.662745,
        1,
        1,
        0.756863,
        0.760784,
        1,
        1,
        0.882353,
        0.870588,
        1,
        1,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_blue2cyan_BW",
      RGBPoints: [
        -1,
        405298e-12,
        0,
        59012e-10,
        -0.87451,
        0.0207526,
        0.0740933,
        0.18093,
        -0.74902,
        0,
        0.121033,
        0.30343,
        -0.623529,
        0,
        0.166892,
        0.416095,
        -0.498039,
        0,
        0.216768,
        0.524796,
        -0.372549,
        0.0164769,
        0.275471,
        0.608585,
        -0.247059,
        0.0544527,
        0.344824,
        0.659267,
        -0.121569,
        0.0880643,
        0.419118,
        0.688675,
        392157e-8,
        0.127938,
        0.492556,
        0.720256,
        0.129412,
        0.149476,
        0.566946,
        0.756918,
        0.254902,
        0.188961,
        0.641333,
        0.792122,
        0.380392,
        0.245482,
        0.715336,
        0.827609,
        0.505882,
        0.329216,
        0.786235,
        0.874761,
        0.631373,
        0.453558,
        0.852803,
        0.918466,
        0.756863,
        0.626281,
        0.910493,
        0.954,
        0.882353,
        0.82257,
        0.958709,
        0.980146,
        1,
        1,
        1,
        0.999989
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_blue_BW",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.0425591,
        0.0763529,
        0.150682,
        -0.74902,
        0.0569472,
        0.119154,
        0.275403,
        -0.623529,
        0.0635978,
        0.164772,
        0.395427,
        -0.498039,
        0.0774342,
        0.213851,
        0.510014,
        -0.372549,
        0.106815,
        0.267034,
        0.615102,
        -0.247059,
        0.122093,
        0.324649,
        0.720068,
        -0.121569,
        0.160851,
        0.387068,
        0.806956,
        392157e-8,
        0.213754,
        0.453516,
        0.878012,
        0.129412,
        0.26722,
        0.524656,
        0.932436,
        0.254902,
        0.326844,
        0.599279,
        0.968038,
        0.380392,
        0.403403,
        0.674712,
        0.984784,
        0.505882,
        0.499703,
        0.745519,
        1,
        0.631373,
        0.615055,
        0.813983,
        1,
        0.756863,
        0.74405,
        0.879228,
        1,
        0.882353,
        0.877909,
        0.941913,
        1,
        1,
        1,
        1,
        0.999996
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "BLUE-WHITE",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0,
        0,
        0.082353,
        -0.74902,
        0,
        0,
        0.168627,
        -0.623529,
        0,
        0,
        0.254902,
        -0.498039,
        0,
        0,
        0.337255,
        -0.372549,
        0,
        0,
        0.423529,
        -0.247059,
        0,
        0,
        0.509804,
        -0.121569,
        0,
        0.101961,
        0.592157,
        392157e-8,
        0,
        0.203922,
        0.678431,
        0.129412,
        0,
        0.301961,
        0.764706,
        0.254902,
        0,
        0.403922,
        0.85098,
        0.380392,
        0,
        0.505882,
        0.933333,
        0.505882,
        0,
        0.603922,
        1,
        0.631373,
        0.254902,
        0.705882,
        1,
        0.756863,
        0.509804,
        0.807843,
        1,
        0.882353,
        0.764706,
        0.905882,
        1,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_purple_BW",
      RGBPoints: [
        -1,
        4264e-11,
        0,
        620844e-12,
        -0.87451,
        0.100579,
        0.0593111,
        0.145666,
        -0.74902,
        0.167794,
        0.0889224,
        0.254953,
        -0.623529,
        0.231446,
        0.123339,
        0.360511,
        -0.498039,
        0.296699,
        0.163027,
        0.461278,
        -0.372549,
        0.363211,
        0.209286,
        0.55306,
        -0.247059,
        0.431136,
        0.260776,
        0.637195,
        -0.121569,
        0.498202,
        0.320012,
        0.705799,
        392157e-8,
        0.567456,
        0.380459,
        0.778091,
        0.129412,
        0.629381,
        0.445284,
        0.8448,
        0.254902,
        0.688373,
        0.517374,
        0.895694,
        0.380392,
        0.74891,
        0.590906,
        0.93976,
        0.505882,
        0.805017,
        0.667956,
        0.977626,
        0.631373,
        0.850914,
        0.752618,
        0.992396,
        0.756863,
        0.89724,
        0.838454,
        0.994093,
        0.882353,
        0.948461,
        0.922603,
        0.994449,
        1,
        1,
        1,
        0.999967
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_magenta_BW",
      RGBPoints: [
        -1,
        0,
        0,
        254023e-10,
        -0.87451,
        0.128696,
        0.0456782,
        0.11635,
        -0.74902,
        0.228133,
        0.0476299,
        0.201452,
        -0.623529,
        0.327273,
        0.0374065,
        0.282107,
        -0.498039,
        0.420953,
        0.0408166,
        0.35709,
        -0.372549,
        0.511562,
        0.0642203,
        0.430511,
        -0.247059,
        0.599552,
        0.102686,
        0.504257,
        -0.121569,
        0.684646,
        0.150536,
        0.579429,
        392157e-8,
        0.765817,
        0.205978,
        0.656062,
        0.129412,
        0.839176,
        0.27229,
        0.731807,
        0.254902,
        0.89536,
        0.357594,
        0.797309,
        0.380392,
        0.930238,
        0.457825,
        0.846984,
        0.505882,
        0.945921,
        0.564536,
        0.880571,
        0.631373,
        0.948995,
        0.670753,
        0.902279,
        0.756863,
        0.947124,
        0.772819,
        0.918171,
        0.882353,
        0.947265,
        0.869424,
        0.934352,
        1,
        0.954719,
        0.95475,
        0.954726
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "magenta",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.364706,
        0,
        0.152941,
        -0.74902,
        0.470588,
        0,
        0.254902,
        -0.623529,
        0.572549,
        0,
        0.34902,
        -0.498039,
        0.670588,
        0,
        0.443137,
        -0.372549,
        0.772549,
        0,
        0.537255,
        -0.247059,
        0.870588,
        0,
        0.627451,
        -0.121569,
        0.964706,
        0,
        0.717647,
        392157e-8,
        1,
        0.0784314,
        0.772549,
        0.129412,
        1,
        0.207843,
        0.858824,
        0.254902,
        1,
        0.32549,
        0.941176,
        0.380392,
        1,
        0.45098,
        1,
        0.505882,
        1,
        0.560784,
        1,
        0.631373,
        1,
        0.662745,
        1,
        0.756863,
        1,
        0.760784,
        1,
        0.882353,
        1,
        0.870588,
        1,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "RED-PURPLE",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.188235,
        0,
        7843e-6,
        -0.74902,
        0.345098,
        0,
        0.035294,
        -0.623529,
        0.439216,
        0,
        0.098039,
        -0.498039,
        0.533333,
        0,
        0.152941,
        -0.372549,
        0.627451,
        0.015686,
        0.211765,
        -0.247059,
        0.721569,
        0.031373,
        0.266667,
        -0.121569,
        0.8,
        0.047059,
        0.329412,
        392157e-8,
        0.862745,
        0.047059,
        0.403922,
        0.129412,
        0.941176,
        0.062745,
        0.466667,
        0.254902,
        0.988235,
        0.078431,
        0.54902,
        0.380392,
        0.988235,
        0.141176,
        0.643137,
        0.505882,
        0.988235,
        0.25098,
        0.729412,
        0.631373,
        0.988235,
        0.376471,
        0.811765,
        0.756863,
        0.988235,
        0.54902,
        0.886275,
        0.882353,
        0.988235,
        0.752941,
        0.952941,
        1,
        0.996078,
        0.996078,
        0.996078
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_red_BW",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.147204,
        0.0480135,
        0.0401815,
        -0.74902,
        0.253411,
        0.0617478,
        0.0301333,
        -0.623529,
        0.356059,
        0.0746331,
        0.0446897,
        -0.498039,
        0.457731,
        0.0934935,
        0.0636931,
        -0.372549,
        0.557199,
        0.122714,
        0.0860013,
        -0.247059,
        0.665179,
        0.144238,
        0.105585,
        -0.121569,
        0.763833,
        0.187056,
        0.138326,
        392157e-8,
        0.847035,
        0.254558,
        0.189407,
        0.129412,
        0.905663,
        0.345937,
        0.258215,
        0.254902,
        0.941431,
        0.447111,
        0.346277,
        0.380392,
        0.962608,
        0.546927,
        0.457571,
        0.505882,
        0.987833,
        0.637276,
        0.569944,
        0.631373,
        0.994202,
        0.732176,
        0.687958,
        0.756863,
        0.993304,
        0.826268,
        0.800567,
        0.882353,
        0.994413,
        0.917205,
        0.906393,
        1,
        1,
        1,
        0.999979
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "RED_TEMPERATURE",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.090196,
        0,
        0,
        -0.74902,
        0.180392,
        0,
        0,
        -0.623529,
        0.270588,
        0,
        0,
        -0.498039,
        0.360784,
        0,
        0,
        -0.372549,
        0.45098,
        0,
        0,
        -0.247059,
        0.545098,
        0,
        0,
        -0.121569,
        0.635294,
        0,
        0,
        392157e-8,
        0.72549,
        0.058824,
        0,
        0.129412,
        0.815686,
        0.176471,
        0,
        0.254902,
        0.905882,
        0.294118,
        0,
        0.380392,
        1,
        0.411765,
        0,
        0.505882,
        1,
        0.533333,
        0.027451,
        0.631373,
        1,
        0.65098,
        0.27451,
        0.756863,
        1,
        0.768627,
        0.521569,
        0.882353,
        1,
        0.886275,
        0.768627,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_orange_BW",
      RGBPoints: [
        -1,
        0,
        0,
        253806e-10,
        -0.87451,
        0.135871,
        0.0593824,
        0,
        -0.74902,
        0.224328,
        0.0907216,
        0,
        -0.623529,
        0.318083,
        0.119647,
        0,
        -0.498039,
        0.414443,
        0.150246,
        0,
        -0.372549,
        0.511077,
        0.184884,
        0,
        -0.247059,
        0.605501,
        0.226033,
        0,
        -0.121569,
        0.695274,
        0.275491,
        0,
        392157e-8,
        0.777826,
        0.334445,
        0,
        0.129412,
        0.851498,
        0.402441,
        0,
        0.254902,
        0.915899,
        0.47759,
        602975e-9,
        0.380392,
        0.971984,
        0.557882,
        0.0361443,
        0.505882,
        1,
        0.641287,
        0.135967,
        0.631373,
        1,
        0.725198,
        0.27997,
        0.756863,
        1,
        0.808205,
        0.438135,
        0.882353,
        1,
        0.89306,
        0.587036,
        1,
        1,
        0.977928,
        0.721599
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "heated_object",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.34902,
        0.0862745,
        0,
        -0.74902,
        0.45098,
        0.172549,
        0,
        -0.623529,
        0.52549,
        0.231373,
        0,
        -0.498039,
        0.580392,
        0.278431,
        0,
        -0.372549,
        0.623529,
        0.313725,
        0,
        -0.247059,
        0.670588,
        0.352941,
        0,
        -0.121569,
        0.717647,
        0.392157,
        0,
        392157e-8,
        0.772549,
        0.439216,
        0,
        0.129412,
        0.839216,
        0.494118,
        0,
        0.254902,
        0.901961,
        0.541176,
        0,
        0.380392,
        0.968627,
        0.6,
        0,
        0.505882,
        1,
        0.658824,
        0,
        0.631373,
        1,
        0.721569,
        0,
        0.756863,
        1,
        0.827451,
        0.298039,
        0.882353,
        1,
        0.976471,
        0.72549,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_gold_BW",
      RGBPoints: [
        -1,
        0,
        0,
        190933e-10,
        -0.87451,
        0.128363,
        0.0636265,
        0,
        -0.74902,
        0.193795,
        0.111057,
        0,
        -0.623529,
        0.25976,
        0.15987,
        0,
        -0.498039,
        0.328546,
        0.210589,
        0,
        -0.372549,
        0.399726,
        0.26332,
        0,
        -0.247059,
        0.472969,
        0.318261,
        0,
        -0.121569,
        0.546245,
        0.375827,
        0,
        392157e-8,
        0.61745,
        0.436719,
        0,
        0.129412,
        0.685545,
        0.501113,
        0,
        0.254902,
        0.749578,
        0.568799,
        0,
        0.380392,
        0.80962,
        0.6394,
        0,
        0.505882,
        0.865572,
        0.712699,
        0.10257,
        0.631373,
        0.917709,
        0.787569,
        0.233665,
        0.756863,
        0.966914,
        0.863138,
        0.369608,
        0.882353,
        1,
        0.939405,
        0.496104,
        1,
        0.999225,
        1,
        0.612275
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_brown_BW",
      RGBPoints: [
        -1,
        33216e-11,
        0,
        483629e-11,
        -0.87451,
        0.14693,
        0.0518172,
        0,
        -0.74902,
        0.225806,
        0.0814996,
        0,
        -0.623529,
        0.301681,
        0.111452,
        0,
        -0.498039,
        0.370487,
        0.150664,
        0,
        -0.372549,
        0.43108,
        0.199477,
        0,
        -0.247059,
        0.4849,
        0.255107,
        0,
        -0.121569,
        0.536798,
        0.313486,
        0,
        392157e-8,
        0.59286,
        0.371167,
        0,
        0.129412,
        0.653119,
        0.428135,
        0,
        0.254902,
        0.714589,
        0.485917,
        0.0379541,
        0.380392,
        0.774667,
        0.54565,
        0.116634,
        0.505882,
        0.831222,
        0.608047,
        0.183895,
        0.631373,
        0.880305,
        0.674199,
        0.260298,
        0.756863,
        0.922314,
        0.742472,
        0.367086,
        0.882353,
        0.959408,
        0.811222,
        0.497258,
        1,
        0.993548,
        0.875183,
        0.622093
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "copper_Matlab",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.0784314,
        0.0501961,
        0.0313725,
        -0.74902,
        0.156863,
        0.100392,
        0.0627451,
        -0.623529,
        0.235294,
        0.150588,
        0.0941176,
        -0.498039,
        0.313725,
        0.200784,
        0.12549,
        -0.372549,
        0.392157,
        0.25098,
        0.156863,
        -0.247059,
        0.470588,
        0.301176,
        0.188235,
        -0.121569,
        0.54902,
        0.351373,
        0.219608,
        392157e-8,
        0.627451,
        0.401569,
        0.25098,
        0.129412,
        0.705882,
        0.451765,
        0.282353,
        0.254902,
        0.784314,
        0.501961,
        0.313725,
        0.380392,
        0.862745,
        0.552157,
        0.345098,
        0.505882,
        0.941176,
        0.602353,
        0.376471,
        0.631373,
        1,
        0.652549,
        0.407843,
        0.756863,
        1,
        0.702745,
        0.439216,
        0.882353,
        1,
        0.752941,
        0.470588,
        1,
        1,
        0.8,
        0.5
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "pink_Matlab",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.312416,
        0.204524,
        0.204524,
        -0.74902,
        0.441822,
        0.289241,
        0.289241,
        -0.623529,
        0.54112,
        0.354246,
        0.354246,
        -0.498039,
        0.624831,
        0.409048,
        0.409048,
        -0.372549,
        0.698582,
        0.45733,
        0.45733,
        -0.247059,
        0.764404,
        0.502282,
        0.500979,
        -0.121569,
        0.791292,
        0.591516,
        0.54112,
        392157e-8,
        0.817297,
        0.66895,
        0.578481,
        0.129412,
        0.842499,
        0.738308,
        0.613572,
        0.254902,
        0.866968,
        0.801687,
        0.646762,
        0.380392,
        0.890766,
        0.86041,
        0.678329,
        0.505882,
        0.913944,
        0.913944,
        0.711254,
        0.631373,
        0.936549,
        0.936549,
        0.79459,
        0.756863,
        0.958621,
        0.958621,
        0.869979,
        0.882353,
        0.980196,
        0.980196,
        0.939336,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "bone_Matlab",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.054902,
        0.054902,
        0.075817,
        -0.74902,
        0.109804,
        0.109804,
        0.151634,
        -0.623529,
        0.164706,
        0.164706,
        0.227451,
        -0.498039,
        0.219608,
        0.219608,
        0.303268,
        -0.372549,
        0.27451,
        0.27451,
        0.379085,
        -0.247059,
        0.329412,
        0.329902,
        0.454412,
        -0.121569,
        0.384314,
        0.405719,
        0.509314,
        392157e-8,
        0.439216,
        0.481536,
        0.564216,
        0.129412,
        0.494118,
        0.557353,
        0.619118,
        0.254902,
        0.54902,
        0.63317,
        0.67402,
        0.380392,
        0.603922,
        0.708987,
        0.728922,
        0.505882,
        0.660294,
        0.783824,
        0.783824,
        0.631373,
        0.746569,
        0.838725,
        0.838725,
        0.756863,
        0.832843,
        0.893627,
        0.893627,
        0.882353,
        0.919118,
        0.948529,
        0.948529,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "gray_Matlab",
      RGBPoints: [
        -1,
        0,
        0,
        0,
        -0.87451,
        0.0627451,
        0.0627451,
        0.0627451,
        -0.74902,
        0.12549,
        0.12549,
        0.12549,
        -0.623529,
        0.188235,
        0.188235,
        0.188235,
        -0.498039,
        0.25098,
        0.25098,
        0.25098,
        -0.372549,
        0.313725,
        0.313725,
        0.313725,
        -0.247059,
        0.376471,
        0.376471,
        0.376471,
        -0.121569,
        0.439216,
        0.439216,
        0.439216,
        392157e-8,
        0.501961,
        0.501961,
        0.501961,
        0.129412,
        0.564706,
        0.564706,
        0.564706,
        0.254902,
        0.627451,
        0.627451,
        0.627451,
        0.380392,
        0.690196,
        0.690196,
        0.690196,
        0.505882,
        0.752941,
        0.752941,
        0.752941,
        0.631373,
        0.815686,
        0.815686,
        0.815686,
        0.756863,
        0.878431,
        0.878431,
        0.878431,
        0.882353,
        0.941176,
        0.941176,
        0.941176,
        1,
        1,
        1,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Purples",
      RGBPoints: [
        -1,
        0.247059,
        0,
        0.490196,
        -0.87451,
        0.288397,
        0.07677,
        0.525629,
        -0.74902,
        0.32975,
        0.153587,
        0.561092,
        -0.623529,
        0.373057,
        0.236263,
        0.600461,
        -0.498039,
        0.416363,
        0.319,
        0.639923,
        -0.372549,
        0.459669,
        0.405613,
        0.685198,
        -0.247059,
        0.503345,
        0.491534,
        0.730058,
        -0.121569,
        0.562399,
        0.54862,
        0.757616,
        392157e-8,
        0.621453,
        0.606075,
        0.785544,
        0.129412,
        0.680508,
        0.674971,
        0.824914,
        0.254902,
        0.739562,
        0.743406,
        0.863899,
        0.380392,
        0.798616,
        0.800492,
        0.893426,
        0.505882,
        0.85684,
        0.856655,
        0.922491,
        0.631373,
        0.898178,
        0.894056,
        0.942176,
        0.756863,
        0.938654,
        0.930919,
        0.961646,
        0.882353,
        0.964245,
        0.958478,
        0.977393,
        1,
        0.988235,
        0.984314,
        0.992157
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Blues",
      RGBPoints: [
        -1,
        0.031373,
        0.188235,
        0.419608,
        -0.87451,
        0.031373,
        0.253195,
        0.516063,
        -0.74902,
        0.031757,
        0.318139,
        0.612149,
        -0.623529,
        0.080969,
        0.38113,
        0.661361,
        -0.498039,
        0.130427,
        0.444152,
        0.710327,
        -0.372549,
        0.195386,
        0.509112,
        0.743791,
        -0.247059,
        0.260715,
        0.573841,
        0.777209,
        -0.121569,
        0.341423,
        0.628958,
        0.808704,
        392157e-8,
        0.422745,
        0.684075,
        0.839892,
        0.129412,
        0.523137,
        0.739193,
        0.861546,
        0.254902,
        0.622684,
        0.793464,
        0.883429,
        0.380392,
        0.701423,
        0.826928,
        0.910988,
        0.505882,
        0.778685,
        0.8603,
        0.937993,
        0.631373,
        0.825928,
        0.891795,
        0.953741,
        0.756863,
        0.87328,
        0.923291,
        0.969489,
        0.882353,
        0.922491,
        0.954787,
        0.985236,
        1,
        0.968627,
        0.984314,
        1
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Greens",
      RGBPoints: [
        -1,
        0,
        0.266667,
        0.105882,
        -0.87451,
        0,
        0.347374,
        0.139346,
        -0.74902,
        538e-6,
        0.427912,
        0.172933,
        -0.623529,
        0.069435,
        0.486967,
        0.222145,
        -0.498039,
        0.138178,
        0.546082,
        0.271326,
        -0.372549,
        0.197232,
        0.609073,
        0.31857,
        -0.247059,
        0.257255,
        0.671742,
        0.365859,
        -0.121569,
        0.357647,
        0.720953,
        0.415071,
        392157e-8,
        0.45767,
        0.769919,
        0.465021,
        0.129412,
        0.546251,
        0.811257,
        0.537855,
        0.254902,
        0.634295,
        0.852211,
        0.610688,
        0.380392,
        0.709097,
        0.883706,
        0.683522,
        0.505882,
        0.78316,
        0.914833,
        0.755894,
        0.631373,
        0.842215,
        0.938454,
        0.818885,
        0.756863,
        0.899977,
        0.961538,
        0.880692,
        0.882353,
        0.935409,
        0.975317,
        0.92203,
        1,
        0.968627,
        0.988235,
        0.960784
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "PuBu",
      RGBPoints: [
        -1,
        0.301961,
        0,
        0.294118,
        -0.87451,
        0.404321,
        0.029527,
        0.390573,
        -0.74902,
        0.50599,
        0.059592,
        0.486782,
        -0.623529,
        0.519769,
        0.158016,
        0.551742,
        -0.498039,
        0.533456,
        0.256194,
        0.616301,
        -0.372549,
        0.54133,
        0.33887,
        0.655671,
        -0.247059,
        0.54902,
        0.421592,
        0.695087,
        -0.121569,
        0.54902,
        0.506236,
        0.736424,
        392157e-8,
        0.550127,
        0.590573,
        0.777701,
        0.129412,
        0.585559,
        0.665375,
        0.81707,
        0.254902,
        0.622145,
        0.739023,
        0.855825,
        0.380392,
        0.687105,
        0.784298,
        0.879446,
        0.505882,
        0.752065,
        0.829758,
        0.903253,
        0.631373,
        0.817024,
        0.87897,
        0.930811,
        0.756863,
        0.880907,
        0.927213,
        0.957832,
        0.882353,
        0.926182,
        0.958708,
        0.975548,
        1,
        0.968627,
        0.988235,
        0.992157
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "BuPu",
      RGBPoints: [
        -1,
        7843e-6,
        0.219608,
        0.345098,
        -0.87451,
        0.01178,
        0.286536,
        0.449427,
        -0.74902,
        0.015702,
        0.35328,
        0.553479,
        -0.623529,
        0.01767,
        0.396586,
        0.622376,
        -0.498039,
        0.021115,
        0.4402,
        0.690688,
        -0.372549,
        0.11757,
        0.503191,
        0.722184,
        -0.247059,
        0.214625,
        0.565859,
        0.753633,
        -0.121569,
        0.336671,
        0.615071,
        0.78316,
        392157e-8,
        0.457978,
        0.663975,
        0.812503,
        0.129412,
        0.556401,
        0.703345,
        0.836125,
        0.254902,
        0.65421,
        0.742714,
        0.859669,
        0.380392,
        0.736886,
        0.782084,
        0.881323,
        0.505882,
        0.81827,
        0.821638,
        0.903068,
        0.631373,
        0.873387,
        0.864944,
        0.92669,
        0.756863,
        0.927536,
        0.907605,
        0.949988,
        0.882353,
        0.964937,
        0.9391,
        0.967705,
        1,
        1,
        0.968627,
        0.984314
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "BuGn",
      RGBPoints: [
        -1,
        0.031373,
        0.25098,
        0.505882,
        -0.87451,
        0.031373,
        0.329719,
        0.590527,
        -0.74902,
        0.031911,
        0.408397,
        0.674787,
        -0.623529,
        0.100807,
        0.479262,
        0.710219,
        -0.498039,
        0.169704,
        0.550219,
        0.745744,
        -0.372549,
        0.238601,
        0.62699,
        0.787082,
        -0.247059,
        0.307958,
        0.703114,
        0.826759,
        -0.121569,
        0.39654,
        0.752326,
        0.797232,
        392157e-8,
        0.485121,
        0.801046,
        0.767705,
        0.129412,
        0.573702,
        0.83451,
        0.738178,
        0.254902,
        0.661592,
        0.867743,
        0.711034,
        0.380392,
        0.732457,
        0.895302,
        0.74253,
        0.505882,
        0.801845,
        0.922307,
        0.774579,
        0.631373,
        0.841215,
        0.938055,
        0.817885,
        0.756863,
        0.880907,
        0.95391,
        0.861084,
        0.882353,
        0.926182,
        0.971626,
        0.902422,
        1,
        0.968627,
        0.988235,
        0.941176
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GnBu",
      RGBPoints: [
        -1,
        0,
        0.266667,
        0.105882,
        -0.87451,
        0,
        0.347374,
        0.139346,
        -0.74902,
        538e-6,
        0.427912,
        0.172933,
        -0.623529,
        0.069435,
        0.486967,
        0.222145,
        -0.498039,
        0.138178,
        0.546175,
        0.272095,
        -0.372549,
        0.197232,
        0.615071,
        0.368551,
        -0.247059,
        0.256609,
        0.683276,
        0.464867,
        -0.121569,
        0.329443,
        0.722645,
        0.555417,
        392157e-8,
        0.403137,
        0.762138,
        0.645413,
        0.129412,
        0.503529,
        0.805444,
        0.718247,
        0.254902,
        0.603922,
        0.848597,
        0.790465,
        0.380392,
        0.704314,
        0.887966,
        0.847551,
        0.505882,
        0.802307,
        0.926321,
        0.903714,
        0.631373,
        0.851519,
        0.944037,
        0.941115,
        0.756863,
        0.899977,
        0.961538,
        0.976901,
        0.882353,
        0.935409,
        0.975317,
        0.984775,
        1,
        0.968627,
        0.988235,
        0.992157
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GnBuPu",
      RGBPoints: [
        -1,
        3922e-6,
        0.27451,
        0.211765,
        -0.87451,
        3922e-6,
        0.349312,
        0.280661,
        -0.74902,
        3937e-6,
        0.423852,
        0.349773,
        -0.623529,
        5905e-6,
        0.46519,
        0.446228,
        -0.498039,
        9443e-6,
        0.506344,
        0.542837,
        -0.372549,
        0.111803,
        0.535871,
        0.649135,
        -0.247059,
        0.214025,
        0.565859,
        0.753633,
        -0.121569,
        0.310481,
        0.615071,
        0.78316,
        392157e-8,
        0.407797,
        0.663975,
        0.812503,
        0.129412,
        0.531811,
        0.703345,
        0.836125,
        0.254902,
        0.65421,
        0.742714,
        0.859669,
        0.380392,
        0.736886,
        0.782084,
        0.881323,
        0.505882,
        0.81827,
        0.821176,
        0.902884,
        0.631373,
        0.873387,
        0.854641,
        0.922568,
        0.756863,
        0.927536,
        0.888535,
        0.942361,
        0.882353,
        0.964937,
        0.929873,
        0.964014,
        1,
        1,
        0.968627,
        0.984314
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "BuGnYl",
      RGBPoints: [
        -1,
        0.031373,
        0.113725,
        0.345098,
        -0.87451,
        0.088458,
        0.159,
        0.463206,
        -0.74902,
        0.145052,
        0.204567,
        0.5807,
        -0.623529,
        0.139146,
        0.287243,
        0.620069,
        -0.498039,
        0.13318,
        0.370196,
        0.659562,
        -0.372549,
        0.123337,
        0.470588,
        0.706805,
        -0.247059,
        0.115386,
        0.570335,
        0.753126,
        -0.121569,
        0.186251,
        0.643168,
        0.761,
        392157e-8,
        0.258716,
        0.71514,
        0.768074,
        0.129412,
        0.380761,
        0.760415,
        0.750358,
        0.254902,
        0.503576,
        0.806075,
        0.732795,
        0.380392,
        0.645306,
        0.861192,
        0.719016,
        0.505882,
        0.783899,
        0.91511,
        0.705606,
        0.631373,
        0.858701,
        0.944637,
        0.6997,
        0.756863,
        0.931349,
        0.973303,
        0.698424,
        0.882353,
        0.966782,
        0.987082,
        0.777163,
        1,
        1,
        1,
        0.85098
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "PuRd",
      RGBPoints: [
        -1,
        0.286275,
        0,
        0.415686,
        -0.87451,
        0.38273,
        1968e-6,
        0.441276,
        -0.74902,
        0.479231,
        3922e-6,
        0.466774,
        -0.623529,
        0.581592,
        3922e-6,
        0.480554,
        -0.498039,
        0.683799,
        549e-5,
        0.494887,
        -0.372549,
        0.776317,
        0.105882,
        0.544098,
        -0.247059,
        0.867866,
        0.206321,
        0.592618,
        -0.121569,
        0.919047,
        0.308681,
        0.612303,
        392157e-8,
        0.968812,
        0.411226,
        0.632603,
        0.129412,
        0.974717,
        0.519493,
        0.671972,
        0.254902,
        0.980546,
        0.626451,
        0.71065,
        0.380392,
        0.984483,
        0.701253,
        0.732303,
        0.505882,
        0.988328,
        0.77504,
        0.755617,
        0.631373,
        0.990296,
        0.828189,
        0.812703,
        0.756863,
        0.992372,
        0.880907,
        0.869035,
        0.882353,
        0.996309,
        0.926182,
        0.912341,
        1,
        1,
        0.968627,
        0.952941
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "RdPu",
      RGBPoints: [
        -1,
        0.403922,
        0,
        0.121569,
        -0.87451,
        0.500377,
        0,
        0.192434,
        -0.74902,
        0.596909,
        277e-6,
        0.263037,
        -0.623529,
        0.703206,
        0.035709,
        0.300438,
        -0.498039,
        0.808612,
        0.071296,
        0.338854,
        -0.372549,
        0.857824,
        0.116571,
        0.441215,
        -0.247059,
        0.905513,
        0.163552,
        0.54293,
        -0.121569,
        0.889765,
        0.281661,
        0.617732,
        392157e-8,
        0.873156,
        0.39897,
        0.691611,
        0.129412,
        0.82985,
        0.491488,
        0.736886,
        0.254902,
        0.789081,
        0.583237,
        0.781853,
        0.380392,
        0.810734,
        0.656071,
        0.819254,
        0.505882,
        0.833126,
        0.729181,
        0.85684,
        0.631373,
        0.870527,
        0.80792,
        0.898178,
        0.756863,
        0.907605,
        0.884398,
        0.938331,
        0.882353,
        0.9391,
        0.921799,
        0.958016,
        1,
        0.968627,
        0.956863,
        0.976471
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Oranges",
      RGBPoints: [
        -1,
        0.498039,
        0.152941,
        0.015686,
        -0.87451,
        0.57481,
        0.182468,
        0.013718,
        -0.74902,
        0.651765,
        0.212042,
        0.011734,
        -0.623529,
        0.752157,
        0.247474,
        7797e-6,
        -0.498039,
        0.851719,
        0.283368,
        4475e-6,
        -0.372549,
        0.898962,
        0.348328,
        0.039908,
        -0.247059,
        0.945652,
        0.413426,
        0.076401,
        -0.121569,
        0.969273,
        0.484291,
        0.157109,
        392157e-8,
        0.992157,
        0.554971,
        0.238185,
        0.129412,
        0.992157,
        0.619931,
        0.330704,
        0.254902,
        0.992157,
        0.684967,
        0.423837,
        0.380392,
        0.992157,
        0.751895,
        0.532103,
        0.505882,
        0.992249,
        0.817716,
        0.639354,
        0.631373,
        0.994218,
        0.861023,
        0.725967,
        0.756863,
        0.996186,
        0.903576,
        0.810965,
        0.882353,
        0.998155,
        0.933103,
        0.868051,
        1,
        1,
        0.960784,
        0.921569
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Reds",
      RGBPoints: [
        -1,
        0.403922,
        0,
        0.05098,
        -0.87451,
        0.525967,
        0.029527,
        0.066728,
        -0.74902,
        0.647643,
        0.058962,
        0.082476,
        -0.623529,
        0.722445,
        0.076678,
        0.098224,
        -0.498039,
        0.797186,
        0.095194,
        0.114187,
        -0.372549,
        0.868051,
        0.164091,
        0.143714,
        -0.247059,
        0.937809,
        0.233541,
        0.173933,
        -0.121569,
        0.96143,
        0.326059,
        0.232987,
        392157e-8,
        0.984375,
        0.418147,
        0.292657,
        0.129412,
        0.986344,
        0.496886,
        0.371396,
        0.254902,
        0.988235,
        0.575702,
        0.450673,
        0.380392,
        0.988235,
        0.656409,
        0.543191,
        0.505882,
        0.98842,
        0.736747,
        0.635894,
        0.631373,
        0.992357,
        0.809581,
        0.732349,
        0.756863,
        0.996186,
        0.880692,
        0.826759,
        0.882353,
        0.998155,
        0.92203,
        0.885813,
        1,
        1,
        0.960784,
        0.941176
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "RdOr",
      RGBPoints: [
        -1,
        0.498039,
        0,
        0,
        -0.87451,
        0.6004,
        0,
        0,
        -0.74902,
        0.702514,
        738e-6,
        477e-6,
        -0.623529,
        0.773379,
        0.095225,
        0.061499,
        -0.498039,
        0.843875,
        0.189865,
        0.12283,
        -0.372549,
        0.891119,
        0.294195,
        0.203537,
        -0.247059,
        0.937855,
        0.397924,
        0.283137,
        -0.121569,
        0.963445,
        0.476663,
        0.316601,
        392157e-8,
        0.988297,
        0.555771,
        0.351665,
        0.129412,
        0.990265,
        0.646321,
        0.436309,
        0.254902,
        0.992157,
        0.735256,
        0.519646,
        0.380392,
        0.992157,
        0.784468,
        0.570827,
        0.505882,
        0.992249,
        0.833218,
        0.623483,
        0.631373,
        0.994218,
        0.872587,
        0.706159,
        0.756863,
        0.996186,
        0.911419,
        0.788189,
        0.882353,
        0.998155,
        0.940946,
        0.859054,
        1,
        1,
        0.968627,
        0.92549
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "BrOrYl",
      RGBPoints: [
        -1,
        0.4,
        0.145098,
        0.023529,
        -0.87451,
        0.500392,
        0.174625,
        0.019592,
        -0.74902,
        0.600784,
        0.204291,
        0.015656,
        -0.623529,
        0.701176,
        0.251534,
        0.011719,
        -0.498039,
        0.800984,
        0.299146,
        8397e-6,
        -0.372549,
        0.863975,
        0.370012,
        0.043829,
        -0.247059,
        0.926321,
        0.441107,
        0.0794,
        -0.121569,
        0.961753,
        0.521815,
        0.120738,
        392157e-8,
        0.996078,
        0.602645,
        0.163122,
        0.129412,
        0.996078,
        0.68729,
        0.237924,
        0.254902,
        0.996078,
        0.771011,
        0.314879,
        0.380392,
        0.996078,
        0.832034,
        0.444798,
        0.505882,
        0.996171,
        0.892042,
        0.572595,
        0.631373,
        0.998139,
        0.931411,
        0.65724,
        0.756863,
        1,
        0.969489,
        0.741669,
        0.882353,
        1,
        0.985236,
        0.822376,
        1,
        1,
        1,
        0.898039
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "RdOrYl",
      RGBPoints: [
        -1,
        0.501961,
        0,
        0.14902,
        -0.87451,
        0.622038,
        0,
        0.14902,
        -0.74902,
        0.741761,
        4e-4,
        0.148866,
        -0.623529,
        0.816563,
        0.05158,
        0.129181,
        -0.498039,
        0.890965,
        0.10356,
        0.110235,
        -0.372549,
        0.940177,
        0.205921,
        0.137793,
        -0.247059,
        0.988281,
        0.308789,
        0.165536,
        -0.121569,
        0.99025,
        0.432803,
        0.200969,
        392157e-8,
        0.992218,
        0.555217,
        0.236278,
        0.129412,
        0.994187,
        0.628051,
        0.267774,
        0.254902,
        0.996078,
        0.701038,
        0.301269,
        0.380392,
        0.996078,
        0.777809,
        0.383945,
        0.505882,
        0.996171,
        0.852826,
        0.466621,
        0.631373,
        0.998139,
        0.892195,
        0.549296,
        0.756863,
        1,
        0.931349,
        0.632188,
        0.882353,
        1,
        0.966782,
        0.7188,
        1,
        1,
        1,
        0.8
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "CIELab_blue2red",
      RGBPoints: [
        -1,
        0,
        0.6,
        0.74902,
        1,
        0.76863,
        0.46667,
        0.34118
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "blue2yellow",
      RGBPoints: [
        -1,
        0,
        0,
        1,
        0,
        0.5,
        0.5,
        0.5,
        1,
        1,
        1,
        0
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_blue2gold",
      RGBPoints: [
        -1,
        0.175119,
        0.0438468,
        1,
        -0.874016,
        0.22383,
        0.159771,
        0.94557,
        -0.748031,
        0.27254,
        0.233611,
        0.891216,
        -0.622047,
        0.321251,
        0.296526,
        0.836857,
        -0.496063,
        0.369962,
        0.354296,
        0.782359,
        -0.370079,
        0.418672,
        0.409139,
        0.72754,
        -0.244094,
        0.467383,
        0.462152,
        0.672148,
        -0.11811,
        0.51609,
        0.51396,
        0.615825,
        787402e-8,
        0.572863,
        0.55452,
        0.559172,
        0.133858,
        0.630269,
        0.593822,
        0.517729,
        0.259843,
        0.689588,
        0.624668,
        0.47446,
        0.385827,
        0.745394,
        0.656113,
        0.428638,
        0.511811,
        0.798624,
        0.688104,
        0.379105,
        0.637795,
        0.849926,
        0.720593,
        0.323834,
        0.76378,
        0.899765,
        0.753543,
        0.258657,
        0.889764,
        0.948487,
        0.78692,
        0.171778,
        1,
        0.990413,
        0.816451,
        729848e-8
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_blue2yellow",
      RGBPoints: [
        -1,
        0.0830122,
        0,
        0.495617,
        -0.87451,
        0.141973,
        0.0551288,
        0.57363,
        -0.74902,
        0.193048,
        0.110258,
        0.604561,
        -0.623529,
        0.234231,
        0.165386,
        0.57643,
        -0.498039,
        0.275413,
        0.220515,
        0.548299,
        -0.372549,
        0.316596,
        0.275644,
        0.520169,
        -0.247059,
        0.357778,
        0.330773,
        0.492038,
        -0.121569,
        0.398961,
        0.385901,
        0.463908,
        392157e-8,
        0.449929,
        0.438487,
        0.426815,
        0.129412,
        0.511572,
        0.488299,
        0.379944,
        0.254902,
        0.581222,
        0.53603,
        0.325741,
        0.380392,
        0.650871,
        0.583761,
        0.271538,
        0.505882,
        0.720521,
        0.631493,
        0.217335,
        0.631373,
        0.79017,
        0.679224,
        0.163132,
        0.756863,
        0.85982,
        0.726955,
        0.108929,
        0.882353,
        0.910254,
        0.774159,
        0.14112,
        1,
        0.927513,
        0.81759,
        0.306289
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_cyan2orange",
      RGBPoints: [
        -1,
        0.0471513,
        0.213874,
        0.414329,
        -0.87451,
        0.0674702,
        0.256648,
        0.439027,
        -0.74902,
        0.0959957,
        0.299331,
        0.462089,
        -0.623529,
        0.132428,
        0.341872,
        0.483212,
        -0.498039,
        0.188743,
        0.38277,
        0.500597,
        -0.372549,
        0.268511,
        0.420229,
        0.512179,
        -0.247059,
        0.352945,
        0.455602,
        0.519101,
        -0.121569,
        0.43893,
        0.489368,
        0.521538,
        392157e-8,
        0.522445,
        0.522495,
        0.522436,
        0.129412,
        0.600089,
        0.555682,
        0.53205,
        0.254902,
        0.67988,
        0.587981,
        0.539163,
        0.380392,
        0.761011,
        0.619586,
        0.544439,
        0.505882,
        0.84278,
        0.650741,
        0.548567,
        0.631373,
        0.910713,
        0.687347,
        0.557822,
        0.756863,
        0.952232,
        0.734972,
        0.577775,
        0.882353,
        0.975642,
        0.789858,
        0.604868,
        1,
        0.990752,
        0.843643,
        0.632857
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_purple2green",
      RGBPoints: [
        -1,
        0.235006,
        0.0483128,
        0.530899,
        -0.87451,
        0.302968,
        0.108419,
        0.552391,
        -0.74902,
        0.360241,
        0.166059,
        0.569502,
        -0.623529,
        0.406746,
        0.226782,
        0.579373,
        -0.498039,
        0.444073,
        0.28964,
        0.582094,
        -0.372549,
        0.473648,
        0.353774,
        0.577947,
        -0.247059,
        0.497636,
        0.418154,
        0.567911,
        -0.121569,
        0.519086,
        0.481741,
        0.553968,
        392157e-8,
        0.542884,
        0.542914,
        0.542875,
        0.129412,
        0.566303,
        0.603989,
        0.527499,
        0.254902,
        0.595218,
        0.662965,
        0.516857,
        0.380392,
        0.628641,
        0.720701,
        0.510673,
        0.505882,
        0.665373,
        0.777849,
        0.508165,
        0.631373,
        0.704182,
        0.834921,
        0.508303,
        0.756863,
        0.743846,
        0.892328,
        0.50999,
        0.882353,
        0.783158,
        0.950422,
        0.512181,
        1,
        0.818617,
        1,
        0.513888
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_purple2green_dark",
      RGBPoints: [
        -1,
        0.107656,
        0,
        0.428682,
        -0.87451,
        0.1924,
        0,
        0.449799,
        -0.74902,
        0.255118,
        0.0648939,
        0.466726,
        -0.623529,
        0.304256,
        0.133066,
        0.476703,
        -0.498039,
        0.343202,
        0.19716,
        0.479793,
        -0.372549,
        0.373876,
        0.260353,
        0.476241,
        -0.247059,
        0.398497,
        0.322872,
        0.466953,
        -0.121569,
        0.420016,
        0.384252,
        0.453785,
        392157e-8,
        0.44319,
        0.443216,
        0.443186,
        0.129412,
        0.465553,
        0.502139,
        0.428233,
        0.254902,
        0.492959,
        0.559151,
        0.417591,
        0.380392,
        0.524654,
        0.615092,
        0.411016,
        0.505882,
        0.55959,
        0.670583,
        0.40779,
        0.631373,
        0.596614,
        0.726102,
        0.406948,
        0.756863,
        0.634544,
        0.782032,
        0.407439,
        0.882353,
        0.672183,
        0.838703,
        0.408237,
        1,
        0.706131,
        0.892759,
        0.408452
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "coolwarm",
      RGBPoints: [
        -1,
        0.229806,
        0.298718,
        0.753683,
        -0.875,
        0.303869,
        0.406535,
        0.844959,
        -0.75,
        0.383013,
        0.509419,
        0.917388,
        -0.625,
        0.466667,
        0.604563,
        0.968155,
        -0.5,
        0.552953,
        0.688929,
        0.995376,
        -0.375,
        0.639176,
        0.7596,
        0.998151,
        -0.25,
        0.722193,
        0.813953,
        0.976575,
        -0.125,
        0.798692,
        0.849786,
        0.931689,
        0,
        0.865395,
        0.86541,
        0.865396,
        0.125,
        0.924128,
        0.827385,
        0.774508,
        0.25,
        0.958853,
        0.769768,
        0.678008,
        0.375,
        0.969954,
        0.694267,
        0.579375,
        0.5,
        0.958003,
        0.602842,
        0.481776,
        0.625,
        0.923945,
        0.497309,
        0.38797,
        0.75,
        0.869187,
        0.378313,
        0.300267,
        0.875,
        0.795632,
        0.241284,
        0.220526,
        1,
        0.705673,
        0.0155562,
        0.150233
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "BuRd",
      RGBPoints: [
        -1,
        0.019608,
        0.188235,
        0.380392,
        -0.87451,
        0.088504,
        0.321107,
        0.564937,
        -0.74902,
        0.163399,
        0.444983,
        0.697501,
        -0.623529,
        0.247059,
        0.555709,
        0.754095,
        -0.498039,
        0.420684,
        0.676432,
        0.818685,
        -0.372549,
        0.606459,
        0.789773,
        0.880277,
        -0.247059,
        0.761476,
        0.868512,
        0.924567,
        -0.121569,
        0.878047,
        0.925721,
        0.951942,
        392157e-8,
        0.969089,
        0.966474,
        0.964937,
        0.129412,
        0.983852,
        0.897578,
        0.846828,
        0.254902,
        0.982468,
        0.800692,
        0.706113,
        0.380392,
        0.960323,
        0.66782,
        0.536332,
        0.505882,
        0.894579,
        0.503806,
        0.399769,
        0.631373,
        0.81707,
        0.33218,
        0.281046,
        0.756863,
        0.728489,
        0.155017,
        0.197386,
        0.882353,
        0.576932,
        0.055363,
        0.14925,
        1,
        0.403922,
        0,
        0.121569
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Spectral_lowBlue",
      RGBPoints: [
        -1,
        0.368627,
        0.309804,
        0.635294,
        -0.87451,
        0.260361,
        0.450058,
        0.70173,
        -0.74902,
        0.248058,
        0.591311,
        0.717186,
        -0.623529,
        0.376009,
        0.734025,
        0.658132,
        -0.498039,
        0.537947,
        0.814764,
        0.64506,
        -0.372549,
        0.702345,
        0.879585,
        0.636678,
        -0.247059,
        0.84752,
        0.938639,
        0.607151,
        -0.121569,
        0.940408,
        0.976163,
        0.656055,
        392157e-8,
        0.999923,
        0.997616,
        0.745021,
        0.129412,
        0.997463,
        0.921338,
        0.61707,
        0.254902,
        0.995002,
        0.824606,
        0.499885,
        0.380392,
        0.992541,
        0.701576,
        0.39654,
        0.505882,
        0.973472,
        0.547405,
        0.318108,
        0.631373,
        0.937793,
        0.398539,
        0.270127,
        0.756863,
        0.861515,
        0.282891,
        0.299654,
        0.882353,
        0.746482,
        0.144637,
        0.288812,
        1,
        0.619608,
        3922e-6,
        0.258824
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GnRP",
      RGBPoints: [
        -1,
        0,
        0.266667,
        0.105882,
        -0.87451,
        0.066436,
        0.394617,
        0.174779,
        -0.74902,
        0.168858,
        0.524567,
        0.25767,
        -0.623529,
        0.323875,
        0.657439,
        0.361015,
        -0.498039,
        0.504883,
        0.772318,
        0.506344,
        -0.372549,
        0.678431,
        0.870127,
        0.654902,
        -0.247059,
        0.803922,
        0.921799,
        0.780392,
        -0.121569,
        0.897116,
        0.951942,
        0.882814,
        392157e-8,
        0.967397,
        0.965936,
        0.967474,
        0.129412,
        0.928028,
        0.879815,
        0.930565,
        0.254902,
        0.866052,
        0.780777,
        0.882891,
        0.380392,
        0.77501,
        0.665129,
        0.821376,
        0.505882,
        0.675663,
        0.537024,
        0.737024,
        0.631373,
        0.57847,
        0.396155,
        0.645982,
        0.756863,
        0.492349,
        0.223914,
        0.547559,
        0.882353,
        0.375548,
        0.096886,
        0.423299,
        1,
        0.25098,
        0,
        0.294118
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GYPi",
      RGBPoints: [
        -1,
        0.152941,
        0.392157,
        0.098039,
        -0.87451,
        0.246444,
        0.505344,
        0.117724,
        -0.74902,
        0.351942,
        0.614533,
        0.161399,
        -0.623529,
        0.474971,
        0.717878,
        0.240138,
        -0.498039,
        0.611995,
        0.811226,
        0.392849,
        -0.372549,
        0.746328,
        0.893118,
        0.565321,
        -0.247059,
        0.859516,
        0.94233,
        0.747405,
        -0.121569,
        0.928105,
        0.96386,
        0.875663,
        392157e-8,
        0.969089,
        0.966859,
        0.968012,
        0.129412,
        0.983852,
        0.910265,
        0.948328,
        0.254902,
        0.979239,
        0.833218,
        0.914648,
        0.380392,
        0.949712,
        0.729873,
        0.862976,
        0.505882,
        0.905652,
        0.58293,
        0.763552,
        0.631373,
        0.85521,
        0.410073,
        0.652211,
        0.756863,
        0.793695,
        0.183699,
        0.531642,
        0.882353,
        0.683737,
        0.063899,
        0.420761,
        1,
        0.556863,
        3922e-6,
        0.321569
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GnYlRd",
      RGBPoints: [
        -1,
        0,
        0.407843,
        0.215686,
        -0.87451,
        0.063975,
        0.525952,
        0.277201,
        -0.74902,
        0.177932,
        0.633064,
        0.332718,
        -0.623529,
        0.364937,
        0.724106,
        0.379469,
        -0.498039,
        0.527951,
        0.797155,
        0.40223,
        -0.372549,
        0.678431,
        0.862822,
        0.433449,
        -0.247059,
        0.803922,
        0.916955,
        0.514648,
        -0.121569,
        0.909419,
        0.961861,
        0.625067,
        392157e-8,
        0.999923,
        0.997616,
        0.745021,
        0.129412,
        0.997463,
        0.921338,
        0.61707,
        0.254902,
        0.995002,
        0.824606,
        0.499885,
        0.380392,
        0.992541,
        0.701576,
        0.39654,
        0.505882,
        0.973472,
        0.547405,
        0.318108,
        0.631373,
        0.939023,
        0.389927,
        0.245521,
        0.756863,
        0.867666,
        0.239831,
        0.176624,
        0.882353,
        0.762399,
        0.110727,
        0.151326,
        1,
        0.647059,
        0,
        0.14902
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GBBr",
      RGBPoints: [
        -1,
        0,
        0.235294,
        0.188235,
        -0.87451,
        2461e-6,
        0.338639,
        0.301423,
        -0.74902,
        0.055902,
        0.448981,
        0.417609,
        -0.623529,
        0.183852,
        0.56955,
        0.538178,
        -0.498039,
        0.357785,
        0.700115,
        0.660746,
        -0.372549,
        0.540177,
        0.819531,
        0.77624,
        -0.247059,
        0.714879,
        0.890888,
        0.864821,
        -0.121569,
        0.851134,
        0.934564,
        0.922645,
        392157e-8,
        0.960861,
        0.959785,
        0.95694,
        0.129412,
        0.963322,
        0.927797,
        0.83391,
        0.254902,
        0.939946,
        0.868897,
        0.68935,
        0.380392,
        0.883353,
        0.775394,
        0.517109,
        0.505882,
        0.808074,
        0.625836,
        0.324106,
        0.631373,
        0.717647,
        0.476355,
        0.15494,
        0.756863,
        0.592157,
        0.358247,
        0.06882,
        0.882353,
        0.458593,
        0.26436,
        0.031142,
        1,
        0.329412,
        0.188235,
        0.019608
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "PuOr",
      RGBPoints: [
        -1,
        0.498039,
        0.231373,
        0.031373,
        -0.87451,
        0.62599,
        0.30273,
        0.026451,
        -0.74902,
        0.746943,
        0.387082,
        0.037524,
        -0.623529,
        0.85767,
        0.490427,
        0.071972,
        -0.498039,
        0.936409,
        0.617762,
        0.236371,
        -0.372549,
        0.992695,
        0.743099,
        0.43291,
        -0.247059,
        0.995156,
        0.841523,
        0.63714,
        -0.121569,
        0.985313,
        0.913802,
        0.813687,
        392157e-8,
        0.966244,
        0.966398,
        0.967705,
        0.129412,
        0.889965,
        0.89504,
        0.938178,
        0.254902,
        0.806151,
        0.804306,
        0.894656,
        0.380392,
        0.712649,
        0.688658,
        0.833141,
        0.505882,
        0.594233,
        0.554325,
        0.744637,
        0.631373,
        0.474894,
        0.404229,
        0.652364,
        0.756863,
        0.366628,
        0.217224,
        0.563783,
        0.882353,
        0.266436,
        0.089965,
        0.434833,
        1,
        0.176471,
        0,
        0.294118
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "PRGn",
      RGBPoints: [
        -1,
        0.25098,
        0,
        0.294118,
        -0.87451,
        0.383852,
        0.103345,
        0.431911,
        -0.74902,
        0.497732,
        0.234679,
        0.55371,
        -0.623529,
        0.583852,
        0.40692,
        0.652134,
        -0.498039,
        0.681968,
        0.545175,
        0.742561,
        -0.372549,
        0.7807,
        0.672357,
        0.825221,
        -0.247059,
        0.871742,
        0.788005,
        0.886736,
        -0.121569,
        0.930488,
        0.885198,
        0.932872,
        392157e-8,
        0.966321,
        0.968089,
        0.965859,
        0.129412,
        0.892503,
        0.950865,
        0.877278,
        0.254902,
        0.796078,
        0.91857,
        0.772549,
        0.380392,
        0.670588,
        0.866897,
        0.647059,
        0.505882,
        0.493195,
        0.765398,
        0.496655,
        0.631373,
        0.314187,
        0.649135,
        0.354556,
        0.756863,
        0.15917,
        0.516263,
        0.251211,
        0.882353,
        0.062284,
        0.386621,
        0.170473,
        1,
        0,
        0.266667,
        0.105882
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "PiYG",
      RGBPoints: [
        -1,
        0.556863,
        3922e-6,
        0.321569,
        -0.87451,
        0.692195,
        0.067897,
        0.427374,
        -0.74902,
        0.797539,
        0.197847,
        0.539177,
        -0.623529,
        0.859054,
        0.424221,
        0.659746,
        -0.498039,
        0.908574,
        0.592618,
        0.770319,
        -0.372549,
        0.951557,
        0.736332,
        0.866205,
        -0.247059,
        0.981084,
        0.839677,
        0.917878,
        -0.121569,
        0.98293,
        0.913802,
        0.949558,
        392157e-8,
        0.96732,
        0.968474,
        0.965629,
        0.129412,
        0.92549,
        0.963552,
        0.869666,
        0.254902,
        0.852441,
        0.939254,
        0.736025,
        0.380392,
        0.739254,
        0.890042,
        0.553941,
        0.505882,
        0.60323,
        0.805536,
        0.382238,
        0.631373,
        0.467282,
        0.711419,
        0.235217,
        0.756863,
        0.344252,
        0.608074,
        0.156478,
        0.882353,
        0.2406,
        0.49827,
        0.116494,
        1,
        0.152941,
        0.392157,
        0.098039
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "OrPu",
      RGBPoints: [
        -1,
        0.176471,
        0,
        0.294118,
        -0.87451,
        0.272434,
        0.095963,
        0.444214,
        -0.74902,
        0.373395,
        0.228912,
        0.56932,
        -0.623529,
        0.481661,
        0.415917,
        0.657901,
        -0.498039,
        0.601922,
        0.562937,
        0.750481,
        -0.372549,
        0.718493,
        0.695886,
        0.836986,
        -0.247059,
        0.811995,
        0.811534,
        0.898501,
        -0.121569,
        0.894733,
        0.8995,
        0.940023,
        392157e-8,
        0.969166,
        0.966859,
        0.963629,
        0.129412,
        0.98639,
        0.910265,
        0.803691,
        0.254902,
        0.995002,
        0.835371,
        0.624375,
        0.380392,
        0.992541,
        0.736947,
        0.420146,
        0.505882,
        0.931949,
        0.609458,
        0.224221,
        0.631373,
        0.85075,
        0.483968,
        0.069819,
        0.756863,
        0.740023,
        0.380623,
        0.035371,
        0.882353,
        0.617993,
        0.29827,
        0.026759,
        1,
        0.498039,
        0.231373,
        0.031373
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "BrBG",
      RGBPoints: [
        -1,
        0.329412,
        0.188235,
        0.019608,
        -0.87451,
        0.467205,
        0.269435,
        0.031911,
        -0.74902,
        0.6,
        0.365629,
        0.074202,
        -0.623529,
        0.72549,
        0.483737,
        0.160323,
        -0.498039,
        0.812995,
        0.635832,
        0.336409,
        -0.372549,
        0.88689,
        0.781238,
        0.527874,
        -0.247059,
        0.943483,
        0.87474,
        0.700115,
        -0.121569,
        0.963168,
        0.929796,
        0.841599,
        392157e-8,
        0.957247,
        0.959938,
        0.959554,
        0.129412,
        0.84406,
        0.932872,
        0.920185,
        0.254902,
        0.70396,
        0.886428,
        0.859285,
        0.380392,
        0.529258,
        0.815071,
        0.770704,
        0.505882,
        0.346251,
        0.691811,
        0.653057,
        0.631373,
        0.175855,
        0.562015,
        0.530642,
        0.756863,
        0.047905,
        0.441446,
        0.410073,
        0.882353,
        2307e-6,
        0.33218,
        0.294348,
        1,
        0,
        0.235294,
        0.188235
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "GyRd",
      RGBPoints: [
        -1,
        0.101961,
        0.101961,
        0.101961,
        -0.87451,
        0.227451,
        0.227451,
        0.227451,
        -0.74902,
        0.359939,
        0.359939,
        0.359939,
        -0.623529,
        0.502653,
        0.502653,
        0.502653,
        -0.498039,
        0.631373,
        0.631373,
        0.631373,
        -0.372549,
        0.749865,
        0.749865,
        0.749865,
        -0.247059,
        0.843368,
        0.843368,
        0.843368,
        -0.121569,
        0.926105,
        0.926105,
        0.926105,
        392157e-8,
        0.999846,
        0.997232,
        0.995694,
        0.129412,
        0.994925,
        0.908651,
        0.857901,
        0.254902,
        0.982468,
        0.800692,
        0.706113,
        0.380392,
        0.960323,
        0.66782,
        0.536332,
        0.505882,
        0.894579,
        0.503806,
        0.399769,
        0.631373,
        0.81707,
        0.33218,
        0.281046,
        0.756863,
        0.728489,
        0.155017,
        0.197386,
        0.882353,
        0.576932,
        0.055363,
        0.14925,
        1,
        0.403922,
        0,
        0.121569
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_divHi_purpleGreen",
      RGBPoints: [
        -1,
        0.297553,
        0,
        0.489074,
        -0.87451,
        0.40259,
        0.151146,
        0.567754,
        -0.74902,
        0.516038,
        0.284843,
        0.658231,
        -0.623529,
        0.629783,
        0.423646,
        0.750938,
        -0.498039,
        0.735198,
        0.563697,
        0.835956,
        -0.372549,
        0.82408,
        0.695541,
        0.903582,
        -0.247059,
        0.889091,
        0.807454,
        0.944862,
        -0.121569,
        0.92334,
        0.886917,
        0.951839,
        392157e-8,
        0.921045,
        0.921084,
        0.921003,
        0.129412,
        0.877324,
        0.907455,
        0.845381,
        0.254902,
        0.797649,
        0.849713,
        0.734695,
        0.380392,
        0.691646,
        0.75964,
        0.600532,
        0.505882,
        0.568981,
        0.649159,
        0.453807,
        0.631373,
        0.438945,
        0.529756,
        0.304259,
        0.756863,
        0.30973,
        0.412001,
        0.158303,
        0.882353,
        0.187078,
        0.305111,
        251458e-8,
        1,
        0.101655,
        0.220836,
        0
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_divHi_purpleGreen_dim",
      RGBPoints: [
        -1,
        0.404088,
        0.131038,
        0.592767,
        -0.87451,
        0.486469,
        0.230957,
        0.651243,
        -0.74902,
        0.575165,
        0.339335,
        0.717723,
        -0.623529,
        0.662741,
        0.454332,
        0.784263,
        -0.498039,
        0.742071,
        0.570213,
        0.842918,
        -0.372549,
        0.806935,
        0.678992,
        0.886227,
        -0.247059,
        0.852219,
        0.771315,
        0.90763,
        -0.121569,
        0.873345,
        0.837327,
        0.901572,
        392157e-8,
        0.866783,
        0.86682,
        0.866745,
        0.129412,
        0.82839,
        0.858225,
        0.796812,
        0.254902,
        0.762578,
        0.814287,
        0.700202,
        0.380392,
        0.676429,
        0.744229,
        0.585735,
        0.505882,
        0.577033,
        0.65732,
        0.461526,
        0.631373,
        0.47128,
        0.562476,
        0.33476,
        0.756863,
        0.365461,
        0.467957,
        0.21076,
        0.882353,
        0.264758,
        0.381138,
        0.0878313,
        1,
        0.182591,
        0.312249,
        0
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_divLow_icePeach",
      RGBPoints: [
        -1,
        0.480048,
        0.817441,
        0.998056,
        -0.87451,
        0.425898,
        0.726921,
        0.883187,
        -0.74902,
        0.366682,
        0.629445,
        0.761936,
        -0.623529,
        0.308756,
        0.531002,
        0.640217,
        -0.498039,
        0.258021,
        0.43705,
        0.523433,
        -0.372549,
        0.219244,
        0.352381,
        0.416348,
        -0.247059,
        0.195127,
        0.281032,
        0.322979,
        -0.121569,
        0.186286,
        0.22627,
        0.246525,
        392157e-8,
        0.192352,
        0.19236,
        0.192364,
        0.129412,
        0.255927,
        0.214469,
        0.191756,
        0.254902,
        0.340459,
        0.254426,
        0.206666,
        0.380392,
        0.444655,
        0.309315,
        0.234029,
        0.505882,
        0.565353,
        0.376004,
        0.270969,
        0.631373,
        0.697917,
        0.450748,
        0.314293,
        0.756863,
        0.836657,
        0.529064,
        0.360227,
        0.882353,
        0.972695,
        0.614884,
        0.413123,
        1,
        1,
        0.705904,
        0.472699
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_divLow_purpleGreen",
      RGBPoints: [
        -1,
        0.956034,
        0.666487,
        0.952663,
        -0.87451,
        0.874457,
        0.572698,
        0.936352,
        -0.74902,
        0.753465,
        0.488253,
        0.909063,
        -0.623529,
        0.63309,
        0.413507,
        0.763833,
        -0.498039,
        0.514491,
        0.345878,
        0.620015,
        -0.372549,
        0.405008,
        0.288141,
        0.484376,
        -0.247059,
        0.311388,
        0.241986,
        0.363556,
        -0.121569,
        0.238722,
        0.209044,
        0.263449,
        392157e-8,
        0.192352,
        0.192366,
        0.192362,
        0.129412,
        0.200379,
        0.233201,
        0.168618,
        0.254902,
        0.230151,
        0.291737,
        0.165227,
        0.380392,
        0.279481,
        0.366076,
        0.178607,
        0.505882,
        0.344927,
        0.453267,
        0.205703,
        0.631373,
        0.421554,
        0.549449,
        0.242643,
        0.756863,
        0.503334,
        0.649999,
        0.284377,
        0.882353,
        0.583497,
        0.749672,
        0.324969,
        1,
        0.650705,
        0.837228,
        0.356264
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Haze_green",
      RGBPoints: [
        -1,
        1,
        0.835294,
        0.886275,
        -0.87451,
        0.937255,
        0.756863,
        0.870443,
        -0.74902,
        0.875817,
        0.666376,
        0.857807,
        -0.623529,
        0.778359,
        0.583007,
        0.808134,
        -0.498039,
        0.676253,
        0.494118,
        0.745098,
        -0.372549,
        0.561365,
        0.390123,
        0.682353,
        -0.247059,
        0.438344,
        0.262745,
        0.621496,
        -0.121569,
        0.321133,
        0.141031,
        0.558751,
        392157e-8,
        0.203922,
        0.0217865,
        0.495861,
        0.129412,
        0.265505,
        0.129412,
        0.433261,
        0.254902,
        0.311692,
        0.255338,
        0.37008,
        0.380392,
        0.356282,
        0.377342,
        0.310821,
        0.505882,
        0.39971,
        0.488889,
        0.258243,
        0.631373,
        0.442556,
        0.604357,
        0.205519,
        0.756863,
        0.48671,
        0.71968,
        0.152941,
        0.882353,
        0.529847,
        0.830356,
        0.100944,
        1,
        0.572549,
        0.933333,
        0.054902
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Haze_lime",
      RGBPoints: [
        -1,
        0.704034,
        0.784196,
        1,
        -0.87451,
        0.633111,
        0.691418,
        0.956078,
        -0.74902,
        0.564021,
        0.600606,
        0.912157,
        -0.623529,
        0.496827,
        0.51189,
        0.868235,
        -0.498039,
        0.43157,
        0.425416,
        0.824314,
        -0.372549,
        0.368248,
        0.341347,
        0.780392,
        -0.247059,
        0.306767,
        0.259855,
        0.736471,
        -0.121569,
        0.246862,
        0.181069,
        0.692549,
        392157e-8,
        0.191619,
        0.109542,
        0.648627,
        0.129412,
        0.257404,
        0.194031,
        0.604706,
        0.254902,
        0.321794,
        0.278775,
        0.560784,
        0.380392,
        0.387909,
        0.364617,
        0.516863,
        0.505882,
        0.456569,
        0.451881,
        0.472941,
        0.631373,
        0.527424,
        0.540773,
        0.42902,
        0.756863,
        0.599759,
        0.631427,
        0.385098,
        0.882353,
        0.673065,
        0.723898,
        0.341176,
        1,
        0.742751,
        0.812252,
        0.3
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "Haze",
      RGBPoints: [
        -1,
        1,
        0.835294,
        0.996078,
        -392157e-8,
        0.023529,
        0.141176,
        0.498039,
        392157e-8,
        0.015686,
        0.137255,
        0.494118,
        1,
        0.984314,
        0.764706,
        0
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "Haze_cyan",
      RGBPoints: [
        -1,
        0.956863,
        1,
        0.835294,
        -0.87451,
        0.933188,
        0.921714,
        0.760784,
        -0.74902,
        0.870588,
        0.803486,
        0.671605,
        -0.623529,
        0.807843,
        0.684096,
        0.583297,
        -0.498039,
        0.745098,
        0.569208,
        0.494118,
        -0.372549,
        0.682353,
        0.437763,
        0.390123,
        -0.247059,
        0.621496,
        0.288163,
        0.262745,
        -0.121569,
        0.558751,
        0.144517,
        0.141031,
        392157e-8,
        0.495861,
        0.0217865,
        0.0413943,
        0.129412,
        0.433261,
        0.137255,
        0.129412,
        0.254902,
        0.37008,
        0.263181,
        0.255338,
        0.380392,
        0.306318,
        0.381845,
        0.372694,
        0.505882,
        0.243137,
        0.503994,
        0.494263,
        0.631373,
        0.180392,
        0.629484,
        0.619753,
        0.756863,
        0.117647,
        0.754975,
        0.747131,
        0.882353,
        0.054902,
        0.876398,
        0.866812,
        1,
        0,
        0.988235,
        0.976471
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "nic_Edge",
      RGBPoints: [
        -1,
        0.191208,
        0.191208,
        0.191208,
        -0.87451,
        0.239484,
        545035e-8,
        0.614821,
        -0.74902,
        0.220593,
        0.0617459,
        0.863547,
        -0.623529,
        0.17509,
        0.278988,
        0.97794,
        -0.498039,
        0.143526,
        0.576069,
        0.998553,
        -0.372549,
        0.166456,
        0.871883,
        0.96594,
        -0.247059,
        0.376202,
        0.993555,
        0.981833,
        -0.121569,
        0.681996,
        0.991297,
        0.999239,
        392157e-8,
        0.954172,
        0.952734,
        0.94374,
        0.129412,
        0.999735,
        0.99301,
        0.662896,
        0.254902,
        0.979399,
        0.991466,
        0.357973,
        0.380392,
        0.968771,
        0.854967,
        0.162659,
        0.505882,
        0.999245,
        0.556697,
        0.144323,
        0.631373,
        0.973959,
        0.26223,
        0.177946,
        0.756863,
        0.852358,
        0.0526707,
        0.222974,
        0.882353,
        0.593889,
        912724e-8,
        0.238855,
        1,
        0.191208,
        0.191208,
        0.191208
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_iceFire_H",
      RGBPoints: [
        -1,
        405432e-12,
        0,
        590122e-11,
        -0.87451,
        0,
        0.120401,
        0.302675,
        -0.74902,
        0,
        0.216583,
        0.524574,
        -0.623529,
        0.0552475,
        0.345025,
        0.6595,
        -0.498039,
        0.128047,
        0.492588,
        0.720288,
        -0.372549,
        0.188955,
        0.641309,
        0.792092,
        -0.247059,
        0.327673,
        0.784935,
        0.873434,
        -0.121569,
        0.60824,
        0.892164,
        0.935547,
        392157e-8,
        0.881371,
        0.912178,
        0.818099,
        0.129412,
        0.951407,
        0.835621,
        0.449279,
        0.254902,
        0.904481,
        0.690489,
        0,
        0.380392,
        0.85407,
        0.510864,
        0,
        0.505882,
        0.777093,
        0.33018,
        88199e-8,
        0.631373,
        0.672862,
        0.139087,
        269398e-8,
        0.756863,
        0.508815,
        0,
        0,
        0.882353,
        0.299417,
        366289e-9,
        547829e-9,
        1,
        0.0157519,
        332021e-8,
        455569e-13
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "erdc_iceFire_L",
      RGBPoints: [
        -1,
        0.870485,
        0.913768,
        0.832905,
        -0.87451,
        0.586919,
        0.887865,
        0.934003,
        -0.74902,
        0.31583,
        0.776442,
        0.867858,
        -0.623529,
        0.18302,
        0.632034,
        0.787722,
        -0.498039,
        0.117909,
        0.484134,
        0.713825,
        -0.372549,
        0.0507239,
        0.335979,
        0.654741,
        -0.247059,
        0,
        0.209874,
        0.511832,
        -0.121569,
        0,
        0.114689,
        0.28935,
        392157e-8,
        0.0157519,
        332021e-8,
        455569e-13,
        0.129412,
        0.312914,
        0,
        0,
        0.254902,
        0.520865,
        0,
        0,
        0.380392,
        0.680105,
        0.15255,
        25996e-7,
        0.505882,
        0.785109,
        0.339479,
        797922e-9,
        0.631373,
        0.857354,
        0.522494,
        0,
        0.756863,
        0.910974,
        0.699774,
        0,
        0.882353,
        0.951921,
        0.842817,
        0.478545,
        1,
        0.881371,
        0.912178,
        0.818099
      ]
    },
    {
      ColorSpace: "RGB",
      Name: "hsv",
      RGBPoints: [
        -1,
        1,
        0,
        0,
        -0.666666,
        1,
        0,
        1,
        -0.333333,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0.33333,
        0,
        1,
        0,
        0.66666,
        1,
        1,
        0,
        1,
        1,
        0,
        0
      ]
    },
    {
      ColorSpace: "Lab",
      Name: "hue_L60",
      RGBPoints: [
        -1,
        0.964784,
        0.400592,
        0.349549,
        -0.87451,
        0.964915,
        0.372498,
        0.53785,
        -0.74902,
        0.892353,
        0.401039,
        0.759569,
        -0.623529,
        0.79263,
        0.446956,
        0.903017,
        -0.498039,
        0.682208,
        0.49954,
        0.966673,
        -0.372549,
        0.56392,
        0.553082,
        0.968836,
        -0.247059,
        0.442031,
        0.606396,
        0.901601,
        -0.121569,
        0.305499,
        0.65701,
        0.765784,
        392157e-8,
        0.197251,
        0.687914,
        0.620914,
        0.129412,
        0.193882,
        0.701887,
        0.472654,
        0.254902,
        0.249866,
        0.706123,
        0.320005,
        0.380392,
        0.35132,
        0.697417,
        0.202919,
        0.505882,
        0.498097,
        0.669467,
        0.125232,
        0.631373,
        0.637477,
        0.626239,
        0.107431,
        0.756863,
        0.762115,
        0.56872,
        0.155812,
        0.882353,
        0.889434,
        0.481116,
        0.240445,
        1,
        0.964784,
        0.400592,
        0.349549
      ]
    },
    {
      IndexedColors: [
        0,
        0,
        0,
        0.8941176470588236,
        0.1019607843137255,
        0.1098039215686274,
        0.2156862745098039,
        0.4941176470588236,
        0.7215686274509804,
        0.3019607843137255,
        0.6862745098039216,
        0.2901960784313726,
        0.596078431372549,
        0.3058823529411765,
        0.6392156862745098,
        1,
        0.4980392156862745,
        0,
        0.6509803921568628,
        0.3372549019607843,
        0.1568627450980392
      ],
      Name: "Spectrum",
      NanColor: [
        0.6509803921568628,
        0.3372549019607843,
        0.1568627450980392
      ]
    },
    {
      IndexedColors: [
        0.4745098039215686,
        0.09019607843137255,
        0.09019607843137255,
        0.7098039215686275,
        0.00392156862745098,
        0.00392156862745098,
        0.9372549019607843,
        0.2784313725490196,
        0.09803921568627451,
        0.9764705882352941,
        0.5137254901960784,
        0.1411764705882353,
        1,
        0.7058823529411765,
        0,
        1,
        0.8980392156862745,
        0.02352941176470588
      ],
      Name: "Warm",
      NanColor: [
        1,
        0.8980392156862745,
        0.02352941176470588
      ]
    },
    {
      IndexedColors: [
        0.4588235294117647,
        0.6941176470588235,
        0.00392156862745098,
        0.3450980392156863,
        0.5019607843137255,
        0.1607843137254902,
        0.3137254901960784,
        0.8431372549019608,
        0.7490196078431373,
        0.1098039215686274,
        0.5843137254901961,
        0.803921568627451,
        0.2313725490196079,
        0.407843137254902,
        0.6705882352941176,
        0.6039215686274509,
        0.407843137254902,
        1,
        0.3725490196078431,
        0.2,
        0.5019607843137255
      ],
      Name: "Cool",
      NanColor: [
        0.3725490196078431,
        0.2,
        0.5019607843137255
      ]
    },
    {
      IndexedColors: [
        0.2313725490196079,
        0.407843137254902,
        0.6705882352941176,
        0.1098039215686274,
        0.5843137254901961,
        0.803921568627451,
        0.3058823529411765,
        0.8509803921568627,
        0.9176470588235294,
        0.4509803921568628,
        0.6039215686274509,
        0.8352941176470589,
        0.2588235294117647,
        0.2392156862745098,
        0.6627450980392157,
        0.3137254901960784,
        0.3294117647058823,
        0.5294117647058824,
        0.06274509803921569,
        0.1647058823529412,
        0.3215686274509804
      ],
      Name: "Blues",
      NanColor: [
        0.06274509803921569,
        0.1647058823529412,
        0.3215686274509804
      ]
    },
    {
      IndexedColors: [
        0.1098039215686274,
        0.5843137254901961,
        0.803921568627451,
        0.2313725490196079,
        0.407843137254902,
        0.6705882352941176,
        0.4,
        0.2431372549019608,
        0.7176470588235294,
        0.6352941176470588,
        0.3294117647058823,
        0.8117647058823529,
        0.8705882352941177,
        0.3803921568627451,
        0.807843137254902,
        0.8627450980392157,
        0.3803921568627451,
        0.5843137254901961,
        0.2392156862745098,
        0.06274509803921569,
        0.3215686274509804
      ],
      Name: "Wild Flower",
      NanColor: [
        0.2392156862745098,
        0.06274509803921569,
        0.3215686274509804
      ]
    },
    {
      IndexedColors: [
        0.396078431372549,
        0.4862745098039216,
        0.2156862745098039,
        0.4588235294117647,
        0.6941176470588235,
        0.00392156862745098,
        0.6980392156862745,
        0.7294117647058823,
        0.1882352941176471,
        1,
        0.8980392156862745,
        0.02352941176470588,
        1,
        0.7058823529411765,
        0,
        0.9764705882352941,
        0.5137254901960784,
        0.1411764705882353
      ],
      Name: "Citrus",
      NanColor: [
        0.9764705882352941,
        0.5137254901960784,
        0.1411764705882353
      ]
    },
    {
      IndexedColors: [
        0.4980392156862745,
        0.2313725490196079,
        0.03137254901960784,
        0.7019607843137254,
        0.3450980392156863,
        0.02352941176470588,
        0.8784313725490196,
        0.5098039215686274,
        0.0784313725490196,
        0.9921568627450981,
        0.7215686274509804,
        0.3882352941176471,
        0.996078431372549,
        0.8784313725490196,
        0.7137254901960784,
        0.9686274509803922,
        0.9686274509803922,
        0.9686274509803922,
        0.8470588235294118,
        0.8549019607843137,
        0.9215686274509803,
        0.6980392156862745,
        0.6705882352941176,
        0.8235294117647058,
        0.5019607843137255,
        0.4509803921568628,
        0.6745098039215687,
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333,
        0.1764705882352941,
        0,
        0.2941176470588235
      ],
      Name: "Brewer Diverging Purple-Orange (11)",
      NanColor: [
        0.1764705882352941,
        0,
        0.2941176470588235
      ]
    },
    {
      IndexedColors: [
        0.4980392156862745,
        0.2313725490196079,
        0.03137254901960784,
        0.7019607843137254,
        0.3450980392156863,
        0.02352941176470588,
        0.8784313725490196,
        0.5098039215686274,
        0.0784313725490196,
        0.9921568627450981,
        0.7215686274509804,
        0.3882352941176471,
        0.996078431372549,
        0.8784313725490196,
        0.7137254901960784,
        0.8470588235294118,
        0.8549019607843137,
        0.9215686274509803,
        0.6980392156862745,
        0.6705882352941176,
        0.8235294117647058,
        0.5019607843137255,
        0.4509803921568628,
        0.6745098039215687,
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333,
        0.1764705882352941,
        0,
        0.2941176470588235
      ],
      Name: "Brewer Diverging Purple-Orange (10)",
      NanColor: [
        0.1764705882352941,
        0,
        0.2941176470588235
      ]
    },
    {
      IndexedColors: [
        0.7019607843137254,
        0.3450980392156863,
        0.02352941176470588,
        0.8784313725490196,
        0.5098039215686274,
        0.0784313725490196,
        0.9921568627450981,
        0.7215686274509804,
        0.3882352941176471,
        0.996078431372549,
        0.8784313725490196,
        0.7137254901960784,
        0.9686274509803922,
        0.9686274509803922,
        0.9686274509803922,
        0.8470588235294118,
        0.8549019607843137,
        0.9215686274509803,
        0.6980392156862745,
        0.6705882352941176,
        0.8235294117647058,
        0.5019607843137255,
        0.4509803921568628,
        0.6745098039215687,
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ],
      Name: "Brewer Diverging Purple-Orange (9)",
      NanColor: [
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ]
    },
    {
      IndexedColors: [
        0.7019607843137254,
        0.3450980392156863,
        0.02352941176470588,
        0.8784313725490196,
        0.5098039215686274,
        0.0784313725490196,
        0.9921568627450981,
        0.7215686274509804,
        0.3882352941176471,
        0.996078431372549,
        0.8784313725490196,
        0.7137254901960784,
        0.8470588235294118,
        0.8549019607843137,
        0.9215686274509803,
        0.6980392156862745,
        0.6705882352941176,
        0.8235294117647058,
        0.5019607843137255,
        0.4509803921568628,
        0.6745098039215687,
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ],
      Name: "Brewer Diverging Purple-Orange (8)",
      NanColor: [
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ]
    },
    {
      IndexedColors: [
        0.7019607843137254,
        0.3450980392156863,
        0.02352941176470588,
        0.9450980392156862,
        0.6392156862745098,
        0.2509803921568627,
        0.996078431372549,
        0.8784313725490196,
        0.7137254901960784,
        0.9686274509803922,
        0.9686274509803922,
        0.9686274509803922,
        0.8470588235294118,
        0.8549019607843137,
        0.9215686274509803,
        0.6,
        0.5568627450980392,
        0.7647058823529411,
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ],
      Name: "Brewer Diverging Purple-Orange (7)",
      NanColor: [
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ]
    },
    {
      IndexedColors: [
        0.7019607843137254,
        0.3450980392156863,
        0.02352941176470588,
        0.9450980392156862,
        0.6392156862745098,
        0.2509803921568627,
        0.996078431372549,
        0.8784313725490196,
        0.7137254901960784,
        0.8470588235294118,
        0.8549019607843137,
        0.9215686274509803,
        0.6,
        0.5568627450980392,
        0.7647058823529411,
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ],
      Name: "Brewer Diverging Purple-Orange (6)",
      NanColor: [
        0.3294117647058823,
        0.1529411764705882,
        0.5333333333333333
      ]
    },
    {
      IndexedColors: [
        0.9019607843137255,
        0.3803921568627451,
        0.00392156862745098,
        0.9921568627450981,
        0.7215686274509804,
        0.3882352941176471,
        0.9686274509803922,
        0.9686274509803922,
        0.9686274509803922,
        0.6980392156862745,
        0.6705882352941176,
        0.8235294117647058,
        0.3686274509803922,
        0.2352941176470588,
        0.6
      ],
      Name: "Brewer Diverging Purple-Orange (5)",
      NanColor: [
        0.3686274509803922,
        0.2352941176470588,
        0.6
      ]
    },
    {
      IndexedColors: [
        0.9019607843137255,
        0.3803921568627451,
        0.00392156862745098,
        0.9921568627450981,
        0.7215686274509804,
        0.3882352941176471,
        0.6980392156862745,
        0.6705882352941176,
        0.8235294117647058,
        0.3686274509803922,
        0.2352941176470588,
        0.6
      ],
      Name: "Brewer Diverging Purple-Orange (4)",
      NanColor: [
        0.3686274509803922,
        0.2352941176470588,
        0.6
      ]
    },
    {
      IndexedColors: [
        0.9450980392156862,
        0.6392156862745098,
        0.2509803921568627,
        0.9686274509803922,
        0.9686274509803922,
        0.9686274509803922,
        0.6,
        0.5568627450980392,
        0.7647058823529411
      ],
      Name: "Brewer Diverging Purple-Orange (3)",
      NanColor: [
        0.6,
        0.5568627450980392,
        0.7647058823529411
      ]
    },
    {
      IndexedColors: [
        0.6196078431372549,
        0.00392156862745098,
        0.2588235294117647,
        0.8352941176470589,
        0.2431372549019608,
        0.3098039215686275,
        0.9568627450980393,
        0.4274509803921568,
        0.2627450980392157,
        0.9921568627450981,
        0.6823529411764706,
        0.3803921568627451,
        0.996078431372549,
        0.8784313725490196,
        0.5450980392156862,
        1,
        1,
        0.7490196078431373,
        0.9019607843137255,
        0.9607843137254902,
        0.596078431372549,
        0.6705882352941176,
        0.8666666666666667,
        0.6431372549019608,
        0.4,
        0.7607843137254902,
        0.6470588235294118,
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353,
        0.3686274509803922,
        0.3098039215686275,
        0.6352941176470588
      ],
      Name: "Brewer Diverging Spectral (11)",
      NanColor: [
        0.3686274509803922,
        0.3098039215686275,
        0.6352941176470588
      ]
    },
    {
      IndexedColors: [
        0.6196078431372549,
        0.00392156862745098,
        0.2588235294117647,
        0.8352941176470589,
        0.2431372549019608,
        0.3098039215686275,
        0.9568627450980393,
        0.4274509803921568,
        0.2627450980392157,
        0.9921568627450981,
        0.6823529411764706,
        0.3803921568627451,
        0.996078431372549,
        0.8784313725490196,
        0.5450980392156862,
        0.9019607843137255,
        0.9607843137254902,
        0.596078431372549,
        0.6705882352941176,
        0.8666666666666667,
        0.6431372549019608,
        0.4,
        0.7607843137254902,
        0.6470588235294118,
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353,
        0.3686274509803922,
        0.3098039215686275,
        0.6352941176470588
      ],
      Name: "Brewer Diverging Spectral (10)",
      NanColor: [
        0.3686274509803922,
        0.3098039215686275,
        0.6352941176470588
      ]
    },
    {
      IndexedColors: [
        0.8352941176470589,
        0.2431372549019608,
        0.3098039215686275,
        0.9568627450980393,
        0.4274509803921568,
        0.2627450980392157,
        0.9921568627450981,
        0.6823529411764706,
        0.3803921568627451,
        0.996078431372549,
        0.8784313725490196,
        0.5450980392156862,
        1,
        1,
        0.7490196078431373,
        0.9019607843137255,
        0.9607843137254902,
        0.596078431372549,
        0.6705882352941176,
        0.8666666666666667,
        0.6431372549019608,
        0.4,
        0.7607843137254902,
        0.6470588235294118,
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ],
      Name: "Brewer Diverging Spectral (9)",
      NanColor: [
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ]
    },
    {
      IndexedColors: [
        0.8352941176470589,
        0.2431372549019608,
        0.3098039215686275,
        0.9568627450980393,
        0.4274509803921568,
        0.2627450980392157,
        0.9921568627450981,
        0.6823529411764706,
        0.3803921568627451,
        0.996078431372549,
        0.8784313725490196,
        0.5450980392156862,
        0.9019607843137255,
        0.9607843137254902,
        0.596078431372549,
        0.6705882352941176,
        0.8666666666666667,
        0.6431372549019608,
        0.4,
        0.7607843137254902,
        0.6470588235294118,
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ],
      Name: "Brewer Diverging Spectral (8)",
      NanColor: [
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ]
    },
    {
      IndexedColors: [
        0.8352941176470589,
        0.2431372549019608,
        0.3098039215686275,
        0.9882352941176471,
        0.5529411764705883,
        0.3490196078431372,
        0.996078431372549,
        0.8784313725490196,
        0.5450980392156862,
        1,
        1,
        0.7490196078431373,
        0.9019607843137255,
        0.9607843137254902,
        0.596078431372549,
        0.6,
        0.8352941176470589,
        0.5803921568627451,
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ],
      Name: "Brewer Diverging Spectral (7)",
      NanColor: [
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ]
    },
    {
      IndexedColors: [
        0.8352941176470589,
        0.2431372549019608,
        0.3098039215686275,
        0.9882352941176471,
        0.5529411764705883,
        0.3490196078431372,
        0.996078431372549,
        0.8784313725490196,
        0.5450980392156862,
        0.9019607843137255,
        0.9607843137254902,
        0.596078431372549,
        0.6,
        0.8352941176470589,
        0.5803921568627451,
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ],
      Name: "Brewer Diverging Spectral (6)",
      NanColor: [
        0.196078431372549,
        0.5333333333333333,
        0.7411764705882353
      ]
    },
    {
      IndexedColors: [
        0.8431372549019608,
        0.09803921568627451,
        0.1098039215686274,
        0.9921568627450981,
        0.6823529411764706,
        0.3803921568627451,
        1,
        1,
        0.7490196078431373,
        0.6705882352941176,
        0.8666666666666667,
        0.6431372549019608,
        0.1686274509803922,
        0.5137254901960784,
        0.7294117647058823
      ],
      Name: "Brewer Diverging Spectral (5)",
      NanColor: [
        0.1686274509803922,
        0.5137254901960784,
        0.7294117647058823
      ]
    },
    {
      IndexedColors: [
        0.8431372549019608,
        0.09803921568627451,
        0.1098039215686274,
        0.9921568627450981,
        0.6823529411764706,
        0.3803921568627451,
        0.6705882352941176,
        0.8666666666666667,
        0.6431372549019608,
        0.1686274509803922,
        0.5137254901960784,
        0.7294117647058823
      ],
      Name: "Brewer Diverging Spectral (4)",
      NanColor: [
        0.1686274509803922,
        0.5137254901960784,
        0.7294117647058823
      ]
    },
    {
      IndexedColors: [
        0.9882352941176471,
        0.5529411764705883,
        0.3490196078431372,
        1,
        1,
        0.7490196078431373,
        0.6,
        0.8352941176470589,
        0.5803921568627451
      ],
      Name: "Brewer Diverging Spectral (3)",
      NanColor: [
        0.6,
        0.8352941176470589,
        0.5803921568627451
      ]
    },
    {
      IndexedColors: [
        0.3294117647058823,
        0.1882352941176471,
        0.0196078431372549,
        0.5490196078431373,
        0.3176470588235294,
        0.0392156862745098,
        0.7490196078431373,
        0.5058823529411764,
        0.1764705882352941,
        0.8745098039215686,
        0.7607843137254902,
        0.4901960784313725,
        0.9647058823529412,
        0.9098039215686274,
        0.7647058823529411,
        0.9607843137254902,
        0.9607843137254902,
        0.9607843137254902,
        0.7803921568627451,
        0.9176470588235294,
        0.8980392156862745,
        0.5019607843137255,
        0.803921568627451,
        0.7568627450980392,
        0.207843137254902,
        0.592156862745098,
        0.5607843137254902,
        0.00392156862745098,
        0.4,
        0.3686274509803922,
        0,
        0.2352941176470588,
        0.1882352941176471
      ],
      Name: "Brewer Diverging Brown-Blue-Green (11)",
      NanColor: [
        0,
        0.2352941176470588,
        0.1882352941176471
      ]
    },
    {
      IndexedColors: [
        0.3294117647058823,
        0.1882352941176471,
        0.0196078431372549,
        0.5490196078431373,
        0.3176470588235294,
        0.0392156862745098,
        0.7490196078431373,
        0.5058823529411764,
        0.1764705882352941,
        0.8745098039215686,
        0.7607843137254902,
        0.4901960784313725,
        0.9647058823529412,
        0.9098039215686274,
        0.7647058823529411,
        0.7803921568627451,
        0.9176470588235294,
        0.8980392156862745,
        0.5019607843137255,
        0.803921568627451,
        0.7568627450980392,
        0.207843137254902,
        0.592156862745098,
        0.5607843137254902,
        0.00392156862745098,
        0.4,
        0.3686274509803922,
        0,
        0.2352941176470588,
        0.1882352941176471
      ],
      Name: "Brewer Diverging Brown-Blue-Green (10)",
      NanColor: [
        0,
        0.2352941176470588,
        0.1882352941176471
      ]
    },
    {
      IndexedColors: [
        0.5490196078431373,
        0.3176470588235294,
        0.0392156862745098,
        0.7490196078431373,
        0.5058823529411764,
        0.1764705882352941,
        0.8745098039215686,
        0.7607843137254902,
        0.4901960784313725,
        0.9647058823529412,
        0.9098039215686274,
        0.7647058823529411,
        0.9607843137254902,
        0.9607843137254902,
        0.9607843137254902,
        0.7803921568627451,
        0.9176470588235294,
        0.8980392156862745,
        0.5019607843137255,
        0.803921568627451,
        0.7568627450980392,
        0.207843137254902,
        0.592156862745098,
        0.5607843137254902,
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ],
      Name: "Brewer Diverging Brown-Blue-Green (9)",
      NanColor: [
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ]
    },
    {
      IndexedColors: [
        0.5490196078431373,
        0.3176470588235294,
        0.0392156862745098,
        0.7490196078431373,
        0.5058823529411764,
        0.1764705882352941,
        0.8745098039215686,
        0.7607843137254902,
        0.4901960784313725,
        0.9647058823529412,
        0.9098039215686274,
        0.7647058823529411,
        0.7803921568627451,
        0.9176470588235294,
        0.8980392156862745,
        0.5019607843137255,
        0.803921568627451,
        0.7568627450980392,
        0.207843137254902,
        0.592156862745098,
        0.5607843137254902,
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ],
      Name: "Brewer Diverging Brown-Blue-Green (8)",
      NanColor: [
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ]
    },
    {
      IndexedColors: [
        0.5490196078431373,
        0.3176470588235294,
        0.0392156862745098,
        0.8470588235294118,
        0.7019607843137254,
        0.396078431372549,
        0.9647058823529412,
        0.9098039215686274,
        0.7647058823529411,
        0.9607843137254902,
        0.9607843137254902,
        0.9607843137254902,
        0.7803921568627451,
        0.9176470588235294,
        0.8980392156862745,
        0.3529411764705883,
        0.7058823529411765,
        0.6745098039215687,
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ],
      Name: "Brewer Diverging Brown-Blue-Green (7)",
      NanColor: [
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ]
    },
    {
      IndexedColors: [
        0.5490196078431373,
        0.3176470588235294,
        0.0392156862745098,
        0.8470588235294118,
        0.7019607843137254,
        0.396078431372549,
        0.9647058823529412,
        0.9098039215686274,
        0.7647058823529411,
        0.7803921568627451,
        0.9176470588235294,
        0.8980392156862745,
        0.3529411764705883,
        0.7058823529411765,
        0.6745098039215687,
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ],
      Name: "Brewer Diverging Brown-Blue-Green (6)",
      NanColor: [
        0.00392156862745098,
        0.4,
        0.3686274509803922
      ]
    },
    {
      IndexedColors: [
        0.6509803921568628,
        0.3803921568627451,
        0.1019607843137255,
        0.8745098039215686,
        0.7607843137254902,
        0.4901960784313725,
        0.9607843137254902,
        0.9607843137254902,
        0.9607843137254902,
        0.5019607843137255,
        0.803921568627451,
        0.7568627450980392,
        0.00392156862745098,
        0.5215686274509804,
        0.4431372549019608
      ],
      Name: "Brewer Diverging Brown-Blue-Green (5)",
      NanColor: [
        0.00392156862745098,
        0.5215686274509804,
        0.4431372549019608
      ]
    },
    {
      IndexedColors: [
        0.6509803921568628,
        0.3803921568627451,
        0.1019607843137255,
        0.8745098039215686,
        0.7607843137254902,
        0.4901960784313725,
        0.5019607843137255,
        0.803921568627451,
        0.7568627450980392,
        0.00392156862745098,
        0.5215686274509804,
        0.4431372549019608
      ],
      Name: "Brewer Diverging Brown-Blue-Green (4)",
      NanColor: [
        0.00392156862745098,
        0.5215686274509804,
        0.4431372549019608
      ]
    },
    {
      IndexedColors: [
        0.8470588235294118,
        0.7019607843137254,
        0.396078431372549,
        0.9607843137254902,
        0.9607843137254902,
        0.9607843137254902,
        0.3529411764705883,
        0.7058823529411765,
        0.6745098039215687
      ],
      Name: "Brewer Diverging Brown-Blue-Green (3)",
      NanColor: [
        0.3529411764705883,
        0.7058823529411765,
        0.6745098039215687
      ]
    },
    {
      IndexedColors: [
        0.9686274509803922,
        0.9882352941176471,
        0.9921568627450981,
        0.8980392156862745,
        0.9607843137254902,
        0.9764705882352941,
        0.8,
        0.9254901960784314,
        0.9019607843137255,
        0.6,
        0.8470588235294118,
        0.788235294117647,
        0.4,
        0.7607843137254902,
        0.6431372549019608,
        0.2549019607843137,
        0.6823529411764706,
        0.4627450980392157,
        0.1372549019607843,
        0.5450980392156862,
        0.2705882352941176,
        0,
        0.4274509803921568,
        0.1725490196078431,
        0,
        0.2666666666666667,
        0.1058823529411765
      ],
      Name: "Brewer Sequential Blue-Green (9)",
      NanColor: [
        0,
        0.2666666666666667,
        0.1058823529411765
      ]
    },
    {
      IndexedColors: [
        0.9686274509803922,
        0.9882352941176471,
        0.9921568627450981,
        0.8980392156862745,
        0.9607843137254902,
        0.9764705882352941,
        0.8,
        0.9254901960784314,
        0.9019607843137255,
        0.6,
        0.8470588235294118,
        0.788235294117647,
        0.4,
        0.7607843137254902,
        0.6431372549019608,
        0.2549019607843137,
        0.6823529411764706,
        0.4627450980392157,
        0.1372549019607843,
        0.5450980392156862,
        0.2705882352941176,
        0,
        0.3450980392156863,
        0.1411764705882353
      ],
      Name: "Brewer Sequential Blue-Green (8)",
      NanColor: [
        0,
        0.3450980392156863,
        0.1411764705882353
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.8,
        0.9254901960784314,
        0.9019607843137255,
        0.8,
        0.9254901960784314,
        0.9019607843137255,
        0.4,
        0.7607843137254902,
        0.6431372549019608,
        0.2549019607843137,
        0.6823529411764706,
        0.4627450980392157,
        0.1372549019607843,
        0.5450980392156862,
        0.2705882352941176,
        0,
        0.3450980392156863,
        0.1411764705882353
      ],
      Name: "Brewer Sequential Blue-Green (7)",
      NanColor: [
        0,
        0.3450980392156863,
        0.1411764705882353
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.8,
        0.9254901960784314,
        0.9019607843137255,
        0.6,
        0.8470588235294118,
        0.788235294117647,
        0.4,
        0.7607843137254902,
        0.6431372549019608,
        0.1725490196078431,
        0.6352941176470588,
        0.3725490196078431,
        0,
        0.4274509803921568,
        0.1725490196078431
      ],
      Name: "Brewer Sequential Blue-Green (6)",
      NanColor: [
        0,
        0.4274509803921568,
        0.1725490196078431
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.6980392156862745,
        0.8862745098039215,
        0.8862745098039215,
        0.4,
        0.7607843137254902,
        0.6431372549019608,
        0.1725490196078431,
        0.6352941176470588,
        0.3725490196078431,
        0,
        0.4274509803921568,
        0.1725490196078431
      ],
      Name: "Brewer Sequential Blue-Green (5)",
      NanColor: [
        0,
        0.4274509803921568,
        0.1725490196078431
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.6980392156862745,
        0.8862745098039215,
        0.8862745098039215,
        0.4,
        0.7607843137254902,
        0.6431372549019608,
        0.1372549019607843,
        0.5450980392156862,
        0.2705882352941176
      ],
      Name: "Brewer Sequential Blue-Green (4)",
      NanColor: [
        0.1372549019607843,
        0.5450980392156862,
        0.2705882352941176
      ]
    },
    {
      IndexedColors: [
        0.8980392156862745,
        0.9607843137254902,
        0.9764705882352941,
        0.6,
        0.8470588235294118,
        0.788235294117647,
        0.1725490196078431,
        0.6352941176470588,
        0.3725490196078431
      ],
      Name: "Brewer Sequential Blue-Green (3)",
      NanColor: [
        0.1725490196078431,
        0.6352941176470588,
        0.3725490196078431
      ]
    },
    {
      IndexedColors: [
        1,
        1,
        0.8980392156862745,
        1,
        0.9686274509803922,
        0.7372549019607844,
        0.996078431372549,
        0.8901960784313725,
        0.5686274509803921,
        0.996078431372549,
        0.7686274509803922,
        0.3098039215686275,
        0.996078431372549,
        0.6,
        0.1607843137254902,
        0.9254901960784314,
        0.4392156862745098,
        0.0784313725490196,
        0.8,
        0.2980392156862745,
        0.00784313725490196,
        0.6,
        0.203921568627451,
        0.01568627450980392,
        0.4,
        0.1450980392156863,
        0.02352941176470588
      ],
      Name: "Brewer Sequential Yellow-Orange-Brown (9)",
      NanColor: [
        0.4,
        0.1450980392156863,
        0.02352941176470588
      ]
    },
    {
      IndexedColors: [
        1,
        1,
        0.8980392156862745,
        1,
        0.9686274509803922,
        0.7372549019607844,
        0.996078431372549,
        0.8901960784313725,
        0.5686274509803921,
        0.996078431372549,
        0.7686274509803922,
        0.3098039215686275,
        0.996078431372549,
        0.6,
        0.1607843137254902,
        0.9254901960784314,
        0.4392156862745098,
        0.0784313725490196,
        0.8,
        0.2980392156862745,
        0.00784313725490196,
        0.5490196078431373,
        0.1764705882352941,
        0.01568627450980392
      ],
      Name: "Brewer Sequential Yellow-Orange-Brown (8)",
      NanColor: [
        0.5490196078431373,
        0.1764705882352941,
        0.01568627450980392
      ]
    },
    {
      IndexedColors: [
        1,
        1,
        0.8313725490196079,
        0.996078431372549,
        0.8901960784313725,
        0.5686274509803921,
        0.996078431372549,
        0.7686274509803922,
        0.3098039215686275,
        0.996078431372549,
        0.6,
        0.1607843137254902,
        0.9254901960784314,
        0.4392156862745098,
        0.0784313725490196,
        0.8,
        0.2980392156862745,
        0.00784313725490196,
        0.5490196078431373,
        0.1764705882352941,
        0.01568627450980392
      ],
      Name: "Brewer Sequential Yellow-Orange-Brown (7)",
      NanColor: [
        0.5490196078431373,
        0.1764705882352941,
        0.01568627450980392
      ]
    },
    {
      IndexedColors: [
        1,
        1,
        0.8313725490196079,
        0.996078431372549,
        0.8901960784313725,
        0.5686274509803921,
        0.996078431372549,
        0.7686274509803922,
        0.3098039215686275,
        0.996078431372549,
        0.6,
        0.1607843137254902,
        0.8509803921568627,
        0.3725490196078431,
        0.05490196078431372,
        0.6,
        0.203921568627451,
        0.01568627450980392
      ],
      Name: "Brewer Sequential Yellow-Orange-Brown (6)",
      NanColor: [
        0.6,
        0.203921568627451,
        0.01568627450980392
      ]
    },
    {
      IndexedColors: [
        1,
        1,
        0.8313725490196079,
        0.996078431372549,
        0.8509803921568627,
        0.5568627450980392,
        0.996078431372549,
        0.6,
        0.1607843137254902,
        0.8509803921568627,
        0.3725490196078431,
        0.05490196078431372,
        0.6,
        0.203921568627451,
        0.01568627450980392
      ],
      Name: "Brewer Sequential Yellow-Orange-Brown (5)",
      NanColor: [
        0.6,
        0.203921568627451,
        0.01568627450980392
      ]
    },
    {
      IndexedColors: [
        1,
        1,
        0.8313725490196079,
        0.996078431372549,
        0.8509803921568627,
        0.5568627450980392,
        0.996078431372549,
        0.6,
        0.1607843137254902,
        0.8,
        0.2980392156862745,
        0.00784313725490196
      ],
      Name: "Brewer Sequential Yellow-Orange-Brown (4)",
      NanColor: [
        0.8,
        0.2980392156862745,
        0.00784313725490196
      ]
    },
    {
      IndexedColors: [
        1,
        0.9686274509803922,
        0.7372549019607844,
        0.996078431372549,
        0.7686274509803922,
        0.3098039215686275,
        0.8509803921568627,
        0.3725490196078431,
        0.05490196078431372
      ],
      Name: "Brewer Sequential Yellow-Orange-Brown (3)",
      NanColor: [
        0.8509803921568627,
        0.3725490196078431,
        0.05490196078431372
      ]
    },
    {
      IndexedColors: [
        0.9686274509803922,
        0.9882352941176471,
        0.9921568627450981,
        0.8784313725490196,
        0.9254901960784314,
        0.9568627450980393,
        0.7490196078431373,
        0.8274509803921568,
        0.9019607843137255,
        0.6196078431372549,
        0.7372549019607844,
        0.8549019607843137,
        0.5490196078431373,
        0.5882352941176471,
        0.7764705882352941,
        0.5490196078431373,
        0.4196078431372549,
        0.6941176470588235,
        0.5333333333333333,
        0.2549019607843137,
        0.615686274509804,
        0.5058823529411764,
        0.05882352941176471,
        0.4862745098039216,
        0.3019607843137255,
        0,
        0.2941176470588235
      ],
      Name: "Brewer Sequential Blue-Purple (9)",
      NanColor: [
        0.3019607843137255,
        0,
        0.2941176470588235
      ]
    },
    {
      IndexedColors: [
        0.9686274509803922,
        0.9882352941176471,
        0.9921568627450981,
        0.8784313725490196,
        0.9254901960784314,
        0.9568627450980393,
        0.7490196078431373,
        0.8274509803921568,
        0.9019607843137255,
        0.6196078431372549,
        0.7372549019607844,
        0.8549019607843137,
        0.5490196078431373,
        0.5882352941176471,
        0.7764705882352941,
        0.5490196078431373,
        0.4196078431372549,
        0.6941176470588235,
        0.5333333333333333,
        0.2549019607843137,
        0.615686274509804,
        0.4313725490196079,
        0.00392156862745098,
        0.4196078431372549
      ],
      Name: "Brewer Sequential Blue-Purple (8)",
      NanColor: [
        0.4313725490196079,
        0.00392156862745098,
        0.4196078431372549
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.7490196078431373,
        0.8274509803921568,
        0.9019607843137255,
        0.6196078431372549,
        0.7372549019607844,
        0.8549019607843137,
        0.5490196078431373,
        0.5882352941176471,
        0.7764705882352941,
        0.5490196078431373,
        0.4196078431372549,
        0.6941176470588235,
        0.5333333333333333,
        0.2549019607843137,
        0.615686274509804,
        0.4313725490196079,
        0.00392156862745098,
        0.4196078431372549
      ],
      Name: "Brewer Sequential Blue-Purple (7)",
      NanColor: [
        0.4313725490196079,
        0.00392156862745098,
        0.4196078431372549
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.7490196078431373,
        0.8274509803921568,
        0.9019607843137255,
        0.6196078431372549,
        0.7372549019607844,
        0.8549019607843137,
        0.5490196078431373,
        0.5882352941176471,
        0.7764705882352941,
        0.5333333333333333,
        0.3372549019607843,
        0.6549019607843137,
        0.5058823529411764,
        0.05882352941176471,
        0.4862745098039216
      ],
      Name: "Brewer Sequential Blue-Purple (6)",
      NanColor: [
        0.5058823529411764,
        0.05882352941176471,
        0.4862745098039216
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.7019607843137254,
        0.803921568627451,
        0.8901960784313725,
        0.5490196078431373,
        0.5882352941176471,
        0.7764705882352941,
        0.5333333333333333,
        0.3372549019607843,
        0.6549019607843137,
        0.5058823529411764,
        0.05882352941176471,
        0.4862745098039216
      ],
      Name: "Brewer Sequential Blue-Purple (5)",
      NanColor: [
        0.5058823529411764,
        0.05882352941176471,
        0.4862745098039216
      ]
    },
    {
      IndexedColors: [
        0.9294117647058824,
        0.9725490196078431,
        0.984313725490196,
        0.7019607843137254,
        0.803921568627451,
        0.8901960784313725,
        0.5490196078431373,
        0.5882352941176471,
        0.7764705882352941,
        0.5333333333333333,
        0.2549019607843137,
        0.615686274509804
      ],
      Name: "Brewer Sequential Blue-Purple (4)",
      NanColor: [
        0.5333333333333333,
        0.2549019607843137,
        0.615686274509804
      ]
    },
    {
      IndexedColors: [
        0.8784313725490196,
        0.9254901960784314,
        0.9568627450980393,
        0.6196078431372549,
        0.7372549019607844,
        0.8549019607843137,
        0.5333333333333333,
        0.3372549019607843,
        0.6549019607843137
      ],
      Name: "Brewer Sequential Blue-Purple (3)",
      NanColor: [
        0.5333333333333333,
        0.3372549019607843,
        0.6549019607843137
      ]
    },
    {
      IndexedColors: [
        0.4980392156862745,
        0.788235294117647,
        0.4980392156862745,
        0.7450980392156863,
        0.6823529411764706,
        0.8313725490196079,
        0.9921568627450981,
        0.7529411764705882,
        0.5254901960784314,
        1,
        1,
        0.6,
        0.2196078431372549,
        0.4235294117647059,
        0.6901960784313725,
        0.9411764705882353,
        0.00784313725490196,
        0.4980392156862745,
        0.7490196078431373,
        0.3568627450980392,
        0.09019607843137255,
        0.4,
        0.4,
        0.4
      ],
      Name: "Brewer Qualitative Accent",
      NanColor: [
        0.4,
        0.4,
        0.4
      ]
    },
    {
      IndexedColors: [
        0.1058823529411765,
        0.6196078431372549,
        0.4666666666666667,
        0.8509803921568627,
        0.3725490196078431,
        0.00784313725490196,
        0.4588235294117647,
        0.4392156862745098,
        0.7019607843137254,
        0.9058823529411765,
        0.1607843137254902,
        0.5411764705882353,
        0.4,
        0.6509803921568628,
        0.1176470588235294,
        0.9019607843137255,
        0.6705882352941176,
        0.00784313725490196,
        0.6509803921568628,
        0.4627450980392157,
        0.1137254901960784,
        0.4,
        0.4,
        0.4
      ],
      Name: "Brewer Qualitative Dark2",
      NanColor: [
        0.4,
        0.4,
        0.4
      ]
    },
    {
      IndexedColors: [
        0.4,
        0.7607843137254902,
        0.6470588235294118,
        0.9882352941176471,
        0.5529411764705883,
        0.3843137254901961,
        0.5529411764705883,
        0.6274509803921569,
        0.796078431372549,
        0.9058823529411765,
        0.5411764705882353,
        0.7647058823529411,
        0.6509803921568628,
        0.8470588235294118,
        0.3294117647058823,
        1,
        0.8509803921568627,
        0.1843137254901961,
        0.8980392156862745,
        0.7686274509803922,
        0.5803921568627451,
        0.7019607843137254,
        0.7019607843137254,
        0.7019607843137254
      ],
      Name: "Brewer Qualitative Set2",
      NanColor: [
        0.7019607843137254,
        0.7019607843137254,
        0.7019607843137254
      ]
    },
    {
      IndexedColors: [
        0.7019607843137254,
        0.8862745098039215,
        0.803921568627451,
        0.9921568627450981,
        0.803921568627451,
        0.6745098039215687,
        0.796078431372549,
        0.8352941176470589,
        0.9098039215686274,
        0.9568627450980393,
        0.792156862745098,
        0.8941176470588236,
        0.9019607843137255,
        0.9607843137254902,
        0.788235294117647,
        1,
        0.9490196078431372,
        0.6823529411764706,
        0.9450980392156862,
        0.8862745098039215,
        0.8,
        0.8,
        0.8,
        0.8
      ],
      Name: "Brewer Qualitative Pastel2",
      NanColor: [
        0.8,
        0.8,
        0.8
      ]
    },
    {
      IndexedColors: [
        0.984313725490196,
        0.7058823529411765,
        0.6823529411764706,
        0.7019607843137254,
        0.803921568627451,
        0.8901960784313725,
        0.8,
        0.9215686274509803,
        0.7725490196078432,
        0.8705882352941177,
        0.796078431372549,
        0.8941176470588236,
        0.996078431372549,
        0.8509803921568627,
        0.6509803921568628,
        1,
        1,
        0.8,
        0.8980392156862745,
        0.8470588235294118,
        0.7411764705882353,
        0.9921568627450981,
        0.8549019607843137,
        0.9254901960784314,
        0.9490196078431372,
        0.9490196078431372,
        0.9490196078431372
      ],
      Name: "Brewer Qualitative Pastel1",
      NanColor: [
        0.9490196078431372,
        0.9490196078431372,
        0.9490196078431372
      ]
    },
    {
      IndexedColors: [
        0.8941176470588236,
        0.1019607843137255,
        0.1098039215686274,
        0.2156862745098039,
        0.4941176470588236,
        0.7215686274509804,
        0.3019607843137255,
        0.6862745098039216,
        0.2901960784313726,
        0.596078431372549,
        0.3058823529411765,
        0.6392156862745098,
        1,
        0.4980392156862745,
        0,
        1,
        1,
        0.2,
        0.6509803921568628,
        0.3372549019607843,
        0.1568627450980392,
        0.9686274509803922,
        0.5058823529411764,
        0.7490196078431373,
        0.6,
        0.6,
        0.6
      ],
      Name: "Brewer Qualitative Set1",
      NanColor: [
        0.6,
        0.6,
        0.6
      ]
    },
    {
      IndexedColors: [
        0.6509803921568628,
        0.807843137254902,
        0.8901960784313725,
        0.1215686274509804,
        0.4705882352941176,
        0.7058823529411765,
        0.6980392156862745,
        0.8745098039215686,
        0.5411764705882353,
        0.2,
        0.6274509803921569,
        0.1725490196078431,
        0.984313725490196,
        0.6039215686274509,
        0.6,
        0.8901960784313725,
        0.1019607843137255,
        0.1098039215686274,
        0.9921568627450981,
        0.7490196078431373,
        0.4352941176470588,
        1,
        0.4980392156862745,
        0,
        0.792156862745098,
        0.6980392156862745,
        0.8392156862745098,
        0.4156862745098039,
        0.2392156862745098,
        0.6039215686274509,
        1,
        1,
        0.6
      ],
      Name: "Brewer Qualitative Paired",
      NanColor: [
        1,
        1,
        0.6
      ]
    },
    {
      IndexedColors: [
        0.5529411764705883,
        0.8274509803921568,
        0.7803921568627451,
        1,
        1,
        0.7019607843137254,
        0.7450980392156863,
        0.7294117647058823,
        0.8549019607843137,
        0.984313725490196,
        0.5019607843137255,
        0.4470588235294118,
        0.5019607843137255,
        0.6941176470588235,
        0.8274509803921568,
        0.9921568627450981,
        0.7058823529411765,
        0.3843137254901961,
        0.7019607843137254,
        0.8705882352941177,
        0.4117647058823529,
        0.9882352941176471,
        0.803921568627451,
        0.8980392156862745,
        0.8509803921568627,
        0.8509803921568627,
        0.8509803921568627,
        0.7372549019607844,
        0.5019607843137255,
        0.7411764705882353,
        0.8,
        0.9215686274509803,
        0.7725490196078432,
        1,
        0.9294117647058824,
        0.4352941176470588
      ],
      Name: "Brewer Qualitative Set3",
      NanColor: [
        1,
        0.9294117647058824,
        0.4352941176470588
      ]
    },
    {
      IndexedColors: [
        1,
        0,
        0,
        1,
        0.862745,
        0,
        0,
        0.695201,
        0
      ],
      Name: "Traffic Lights",
      NanColor: [
        0.803922,
        0,
        0.803922
      ]
    },
    {
      IndexedColors: [
        0.908659,
        0.604013,
        0.581857,
        1,
        0.862745,
        0,
        0,
        0.695201,
        0
      ],
      Name: "Traffic Lights For Deuteranopes",
      NanColor: [
        0.803922,
        0,
        0.803922
      ]
    },
    {
      IndexedColors: [
        0.4196078431372549,
        0,
        0.07058823529411765,
        0.9019607843137255,
        0.9411764705882353,
        0.0196078431372549,
        0.01568627450980392,
        0.6196078431372549,
        0.00784313725490196
      ],
      Name: "Traffic Lights For Deuteranopes 2",
      NanColor: [
        0.803922,
        0,
        0.803922
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Muted Blue-Green",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        0.109804,
        0.27451,
        0.301961,
        0.02,
        0.129412,
        0.309804,
        0.341176,
        0.05,
        0.14902,
        0.341176,
        0.380392,
        0.1,
        0.188235,
        0.403922,
        0.458824,
        0.15,
        0.227451,
        0.447059,
        0.521569,
        0.2,
        0.290196,
        0.494118,
        0.588235,
        0.25,
        0.368627,
        0.552941,
        0.670588,
        0.3,
        0.458824,
        0.619608,
        0.74902,
        0.35,
        0.588235,
        0.713725,
        0.85098,
        0.4,
        0.72549,
        0.815686,
        0.941176,
        0.45,
        0.831373,
        0.882353,
        0.980392,
        0.475,
        0.909804,
        0.933333,
        1,
        0.5,
        0.980392,
        0.984314,
        1,
        0.5,
        0.996078,
        1,
        0.94902,
        0.5,
        1,
        1,
        0.980392,
        0.5,
        0.980392,
        0.984314,
        1,
        0.525,
        0.972549,
        0.988235,
        0.890196,
        0.55,
        0.917647,
        0.960784,
        0.835294,
        0.6,
        0.835294,
        0.921569,
        0.772549,
        0.65,
        0.768627,
        0.901961,
        0.737255,
        0.7,
        0.670588,
        0.831373,
        0.654902,
        0.75,
        0.576471,
        0.760784,
        0.584314,
        0.8,
        0.498039,
        0.678431,
        0.521569,
        0.85,
        0.392157,
        0.560784,
        0.427451,
        0.9,
        0.294118,
        0.45098,
        0.333333,
        0.95,
        0.211765,
        0.34902,
        0.254902,
        1,
        0.152941,
        0.278431,
        0.196078
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Green-Blue Asymmetric Divergent (62Blbc)",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        0.121569,
        0.2,
        0.145098,
        0.05,
        0.196078,
        0.301961,
        0.223529,
        0.1,
        0.258824,
        0.4,
        0.278431,
        0.2,
        0.341176,
        0.54902,
        0.341176,
        0.25,
        0.419608,
        0.619608,
        0.376471,
        0.3,
        0.545098,
        0.701961,
        0.392157,
        0.35,
        0.643137,
        0.780392,
        0.403922,
        0.4,
        0.729412,
        0.819608,
        0.45098,
        0.45,
        0.811765,
        0.870588,
        0.521569,
        0.5,
        0.898039,
        0.909804,
        0.564706,
        0.55,
        0.941176,
        0.92549,
        0.686275,
        0.6,
        0.960784,
        0.94902,
        0.776471,
        0.64,
        1,
        1,
        1,
        0.65,
        0.890196,
        0.988235,
        0.972549,
        0.7,
        0.721569,
        0.894118,
        0.901961,
        0.75,
        0.631373,
        0.823529,
        0.839216,
        0.8,
        0.517647,
        0.662745,
        0.701961,
        0.85,
        0.384314,
        0.494118,
        0.54902,
        0.9,
        0.298039,
        0.360784,
        0.45098,
        0.95,
        0.223529,
        0.25098,
        0.34902,
        0.99,
        0.156863,
        0.172549,
        0.25098,
        1,
        0.137255,
        0.137255,
        0.188235
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Asymmtrical Earth Tones (6_21b)",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        0.141176,
        0.14902,
        0.2,
        0.05,
        0.215686,
        0.258824,
        0.321569,
        0.1,
        0.243137,
        0.368627,
        0.380392,
        0.15,
        0.27451,
        0.439216,
        0.4,
        0.2,
        0.32549,
        0.501961,
        0.384314,
        0.25,
        0.403922,
        0.6,
        0.419608,
        0.3,
        0.486275,
        0.701961,
        0.454902,
        0.35,
        0.556863,
        0.74902,
        0.494118,
        0.4,
        0.670588,
        0.8,
        0.545098,
        0.5,
        0.854902,
        0.901961,
        0.631373,
        0.55,
        0.92549,
        0.941176,
        0.694118,
        0.6,
        0.960784,
        0.94902,
        0.776471,
        0.65,
        0.988235,
        0.968627,
        0.909804,
        0.7,
        0.839216,
        0.815686,
        0.772549,
        0.75,
        0.701961,
        0.662745,
        0.615686,
        0.8,
        0.6,
        0.529412,
        0.478431,
        0.85,
        0.501961,
        0.403922,
        0.360784,
        0.9,
        0.439216,
        0.313725,
        0.290196,
        1,
        0.301961,
        0.164706,
        0.176471
      ]
    },
    {
      ColorSpace: "Lab",
      Creator: "Francesca Samsel",
      Name: "Yellow 15",
      NanColor: [
        0.25,
        0,
        0
      ],
      RGBPoints: [
        0,
        1,
        1,
        0.988235,
        2e-3,
        1,
        1,
        0.988235,
        0.05,
        0.984314,
        0.988235,
        0.843137,
        0.1,
        0.988235,
        0.988235,
        0.741176,
        0.15,
        0.980392,
        0.968627,
        0.654902,
        0.2,
        0.980392,
        0.945098,
        0.576471,
        0.25,
        0.968627,
        0.905882,
        0.486275,
        0.3,
        0.968627,
        0.862745,
        0.388235,
        0.35,
        0.960784,
        0.803922,
        0.286275,
        0.4,
        0.94902,
        0.741176,
        0.219608,
        0.45,
        0.941176,
        0.678431,
        0.14902,
        0.5,
        0.929412,
        0.607843,
        0.094118,
        0.55,
        0.921569,
        0.545098,
        0.054902,
        0.6,
        0.909804,
        0.486275,
        0.035294,
        0.65,
        0.890196,
        0.411765,
        0.019608,
        0.7,
        0.8,
        0.305882,
        0,
        0.75,
        0.760784,
        0.239216,
        0,
        0.8,
        0.678431,
        0.180392,
        0.011765,
        0.85,
        0.6,
        0.121569,
        0.023529,
        0.9,
        0.501961,
        0.054902,
        0.031373,
        0.95,
        0.4,
        0.039216,
        0.058824,
        1,
        0.301961,
        0.047059,
        0.090196
      ]
    },
    {
      ColorSpace: "Diverging",
      Name: "Magma (matplotlib)",
      NanColor: [
        0,
        1,
        0
      ],
      Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
      License: "CC0",
      Creator: "Nathaniel J. Smith & Stefan van der Walt",
      RGBPoints: [
        0,
        1462e-6,
        466e-6,
        0.013866,
        3922e-6,
        2258e-6,
        1295e-6,
        0.018331,
        7843e-6,
        3279e-6,
        2305e-6,
        0.023708,
        0.011765,
        4512e-6,
        349e-5,
        0.029965,
        0.015686,
        595e-5,
        4843e-6,
        0.03713,
        0.019608,
        7588e-6,
        6356e-6,
        0.044973,
        0.023529,
        9426e-6,
        8022e-6,
        0.052844,
        0.027451,
        0.011465,
        9828e-6,
        0.06075,
        0.031373,
        0.013708,
        0.011771,
        0.068667,
        0.035294,
        0.016156,
        0.01384,
        0.076603,
        0.039216,
        0.018815,
        0.016026,
        0.084584,
        0.043137,
        0.021692,
        0.01832,
        0.09261,
        0.047059,
        0.024792,
        0.020715,
        0.100676,
        0.05098,
        0.028123,
        0.023201,
        0.108787,
        0.054902,
        0.031696,
        0.025765,
        0.116965,
        0.058824,
        0.03552,
        0.028397,
        0.125209,
        0.062745,
        0.039608,
        0.03109,
        0.133515,
        0.066667,
        0.04383,
        0.03383,
        0.141886,
        0.070588,
        0.048062,
        0.036607,
        0.150327,
        0.07451,
        0.05232,
        0.039407,
        0.158841,
        0.078431,
        0.056615,
        0.04216,
        0.167446,
        0.082353,
        0.060949,
        0.044794,
        0.176129,
        0.086275,
        0.06533,
        0.047318,
        0.184892,
        0.090196,
        0.069764,
        0.049726,
        0.193735,
        0.094118,
        0.074257,
        0.052017,
        0.20266,
        0.098039,
        0.078815,
        0.054184,
        0.211667,
        0.101961,
        0.083446,
        0.056225,
        0.220755,
        0.105882,
        0.088155,
        0.058133,
        0.229922,
        0.109804,
        0.092949,
        0.059904,
        0.239164,
        0.113725,
        0.097833,
        0.061531,
        0.248477,
        0.117647,
        0.102815,
        0.06301,
        0.257854,
        0.121569,
        0.107899,
        0.064335,
        0.267289,
        0.12549,
        0.113094,
        0.065492,
        0.276784,
        0.129412,
        0.118405,
        0.066479,
        0.286321,
        0.133333,
        0.123833,
        0.067295,
        0.295879,
        0.137255,
        0.12938,
        0.067935,
        0.305443,
        0.141176,
        0.135053,
        0.068391,
        0.315,
        0.145098,
        0.140858,
        0.068654,
        0.324538,
        0.14902,
        0.146785,
        0.068738,
        0.334011,
        0.152941,
        0.152839,
        0.068637,
        0.343404,
        0.156863,
        0.159018,
        0.068354,
        0.352688,
        0.160784,
        0.165308,
        0.067911,
        0.361816,
        0.164706,
        0.171713,
        0.067305,
        0.370771,
        0.168627,
        0.178212,
        0.066576,
        0.379497,
        0.172549,
        0.184801,
        0.065732,
        0.387973,
        0.176471,
        0.19146,
        0.064818,
        0.396152,
        0.180392,
        0.198177,
        0.063862,
        0.404009,
        0.184314,
        0.204935,
        0.062907,
        0.411514,
        0.188235,
        0.211718,
        0.061992,
        0.418647,
        0.192157,
        0.218512,
        0.061158,
        0.425392,
        0.196078,
        0.225302,
        0.060445,
        0.431742,
        0.2,
        0.232077,
        0.059889,
        0.437695,
        0.203922,
        0.238826,
        0.059517,
        0.443256,
        0.207843,
        0.245543,
        0.059352,
        0.448436,
        0.211765,
        0.25222,
        0.059415,
        0.453248,
        0.215686,
        0.258857,
        0.059706,
        0.45771,
        0.219608,
        0.265447,
        0.060237,
        0.46184,
        0.223529,
        0.271994,
        0.060994,
        0.46566,
        0.227451,
        0.278493,
        0.061978,
        0.46919,
        0.231373,
        0.284951,
        0.063168,
        0.472451,
        0.235294,
        0.291366,
        0.064553,
        0.475462,
        0.239216,
        0.29774,
        0.066117,
        0.478243,
        0.243137,
        0.304081,
        0.067835,
        0.480812,
        0.247059,
        0.310382,
        0.069702,
        0.483186,
        0.25098,
        0.316654,
        0.07169,
        0.48538,
        0.254902,
        0.322899,
        0.073782,
        0.487408,
        0.258824,
        0.329114,
        0.075972,
        0.489287,
        0.262745,
        0.335308,
        0.078236,
        0.491024,
        0.266667,
        0.341482,
        0.080564,
        0.492631,
        0.270588,
        0.347636,
        0.082946,
        0.494121,
        0.27451,
        0.353773,
        0.085373,
        0.495501,
        0.278431,
        0.359898,
        0.087831,
        0.496778,
        0.282353,
        0.366012,
        0.090314,
        0.49796,
        0.286275,
        0.372116,
        0.092816,
        0.499053,
        0.290196,
        0.378211,
        0.095332,
        0.500067,
        0.294118,
        0.384299,
        0.097855,
        0.501002,
        0.298039,
        0.390384,
        0.100379,
        0.501864,
        0.301961,
        0.396467,
        0.102902,
        0.502658,
        0.305882,
        0.402548,
        0.10542,
        0.503386,
        0.309804,
        0.408629,
        0.10793,
        0.504052,
        0.313725,
        0.414709,
        0.110431,
        0.504662,
        0.317647,
        0.420791,
        0.11292,
        0.505215,
        0.321569,
        0.426877,
        0.115395,
        0.505714,
        0.32549,
        0.432967,
        0.117855,
        0.50616,
        0.329412,
        0.439062,
        0.120298,
        0.506555,
        0.333333,
        0.445163,
        0.122724,
        0.506901,
        0.337255,
        0.451271,
        0.125132,
        0.507198,
        0.341176,
        0.457386,
        0.127522,
        0.507448,
        0.345098,
        0.463508,
        0.129893,
        0.507652,
        0.34902,
        0.46964,
        0.132245,
        0.507809,
        0.352941,
        0.47578,
        0.134577,
        0.507921,
        0.356863,
        0.481929,
        0.136891,
        0.507989,
        0.360784,
        0.488088,
        0.139186,
        0.508011,
        0.364706,
        0.494258,
        0.141462,
        0.507988,
        0.368627,
        0.500438,
        0.143719,
        0.50792,
        0.372549,
        0.506629,
        0.145958,
        0.507806,
        0.376471,
        0.512831,
        0.148179,
        0.507648,
        0.380392,
        0.519045,
        0.150383,
        0.507443,
        0.384314,
        0.52527,
        0.152569,
        0.507192,
        0.388235,
        0.531507,
        0.154739,
        0.506895,
        0.392157,
        0.537755,
        0.156894,
        0.506551,
        0.396078,
        0.544015,
        0.159033,
        0.506159,
        0.4,
        0.550287,
        0.161158,
        0.505719,
        0.403922,
        0.556571,
        0.163269,
        0.50523,
        0.407843,
        0.562866,
        0.165368,
        0.504692,
        0.411765,
        0.569172,
        0.167454,
        0.504105,
        0.415686,
        0.57549,
        0.16953,
        0.503466,
        0.419608,
        0.581819,
        0.171596,
        0.502777,
        0.423529,
        0.588158,
        0.173652,
        0.502035,
        0.427451,
        0.594508,
        0.175701,
        0.501241,
        0.431373,
        0.600868,
        0.177743,
        0.500394,
        0.435294,
        0.607238,
        0.179779,
        0.499492,
        0.439216,
        0.613617,
        0.181811,
        0.498536,
        0.443137,
        0.620005,
        0.18384,
        0.497524,
        0.447059,
        0.626401,
        0.185867,
        0.496456,
        0.45098,
        0.632805,
        0.187893,
        0.495332,
        0.454902,
        0.639216,
        0.189921,
        0.49415,
        0.458824,
        0.645633,
        0.191952,
        0.49291,
        0.462745,
        0.652056,
        0.193986,
        0.491611,
        0.466667,
        0.658483,
        0.196027,
        0.490253,
        0.470588,
        0.664915,
        0.198075,
        0.488836,
        0.47451,
        0.671349,
        0.200133,
        0.487358,
        0.478431,
        0.677786,
        0.202203,
        0.485819,
        0.482353,
        0.684224,
        0.204286,
        0.484219,
        0.486275,
        0.690661,
        0.206384,
        0.482558,
        0.490196,
        0.697098,
        0.208501,
        0.480835,
        0.494118,
        0.703532,
        0.210638,
        0.479049,
        0.498039,
        0.709962,
        0.212797,
        0.477201,
        0.501961,
        0.716387,
        0.214982,
        0.47529,
        0.505882,
        0.722805,
        0.217194,
        0.473316,
        0.509804,
        0.729216,
        0.219437,
        0.471279,
        0.513725,
        0.735616,
        0.221713,
        0.46918,
        0.517647,
        0.742004,
        0.224025,
        0.467018,
        0.521569,
        0.748378,
        0.226377,
        0.464794,
        0.52549,
        0.754737,
        0.228772,
        0.462509,
        0.529412,
        0.761077,
        0.231214,
        0.460162,
        0.533333,
        0.767398,
        0.233705,
        0.457755,
        0.537255,
        0.773695,
        0.236249,
        0.455289,
        0.541176,
        0.779968,
        0.238851,
        0.452765,
        0.545098,
        0.786212,
        0.241514,
        0.450184,
        0.54902,
        0.792427,
        0.244242,
        0.447543,
        0.552941,
        0.798608,
        0.24704,
        0.444848,
        0.556863,
        0.804752,
        0.249911,
        0.442102,
        0.560784,
        0.810855,
        0.252861,
        0.439305,
        0.564706,
        0.816914,
        0.255895,
        0.436461,
        0.568627,
        0.822926,
        0.259016,
        0.433573,
        0.572549,
        0.828886,
        0.262229,
        0.430644,
        0.576471,
        0.834791,
        0.26554,
        0.427671,
        0.580392,
        0.840636,
        0.268953,
        0.424666,
        0.584314,
        0.846416,
        0.272473,
        0.421631,
        0.588235,
        0.852126,
        0.276106,
        0.418573,
        0.592157,
        0.857763,
        0.279857,
        0.415496,
        0.596078,
        0.86332,
        0.283729,
        0.412403,
        0.6,
        0.868793,
        0.287728,
        0.409303,
        0.603922,
        0.874176,
        0.291859,
        0.406205,
        0.607843,
        0.879464,
        0.296125,
        0.403118,
        0.611765,
        0.884651,
        0.30053,
        0.400047,
        0.615686,
        0.889731,
        0.305079,
        0.397002,
        0.619608,
        0.8947,
        0.309773,
        0.393995,
        0.623529,
        0.899552,
        0.314616,
        0.391037,
        0.627451,
        0.904281,
        0.31961,
        0.388137,
        0.631373,
        0.908884,
        0.324755,
        0.385308,
        0.635294,
        0.913354,
        0.330052,
        0.382563,
        0.639216,
        0.917689,
        0.3355,
        0.379915,
        0.643137,
        0.921884,
        0.341098,
        0.377376,
        0.647059,
        0.925937,
        0.346844,
        0.374959,
        0.65098,
        0.929845,
        0.352734,
        0.372677,
        0.654902,
        0.933606,
        0.358764,
        0.370541,
        0.658824,
        0.937221,
        0.364929,
        0.368567,
        0.662745,
        0.940687,
        0.371224,
        0.366762,
        0.666667,
        0.944006,
        0.377643,
        0.365136,
        0.670588,
        0.94718,
        0.384178,
        0.363701,
        0.67451,
        0.95021,
        0.39082,
        0.362468,
        0.678431,
        0.953099,
        0.397563,
        0.361438,
        0.682353,
        0.955849,
        0.4044,
        0.360619,
        0.686275,
        0.958464,
        0.411324,
        0.360014,
        0.690196,
        0.960949,
        0.418323,
        0.35963,
        0.694118,
        0.96331,
        0.42539,
        0.359469,
        0.698039,
        0.965549,
        0.432519,
        0.359529,
        0.701961,
        0.967671,
        0.439703,
        0.35981,
        0.705882,
        0.96968,
        0.446936,
        0.360311,
        0.709804,
        0.971582,
        0.45421,
        0.36103,
        0.713725,
        0.973381,
        0.46152,
        0.361965,
        0.717647,
        0.975082,
        0.468861,
        0.363111,
        0.721569,
        0.97669,
        0.476226,
        0.364466,
        0.72549,
        0.97821,
        0.483612,
        0.366025,
        0.729412,
        0.979645,
        0.491014,
        0.367783,
        0.733333,
        0.981,
        0.498428,
        0.369734,
        0.737255,
        0.982279,
        0.505851,
        0.371874,
        0.741176,
        0.983485,
        0.51328,
        0.374198,
        0.745098,
        0.984622,
        0.520713,
        0.376698,
        0.74902,
        0.985693,
        0.528148,
        0.379371,
        0.752941,
        0.9867,
        0.535582,
        0.38221,
        0.756863,
        0.987646,
        0.543015,
        0.38521,
        0.760784,
        0.988533,
        0.550446,
        0.388365,
        0.764706,
        0.989363,
        0.557873,
        0.391671,
        0.768627,
        0.990138,
        0.565296,
        0.395122,
        0.772549,
        0.990871,
        0.572706,
        0.398714,
        0.776471,
        0.991558,
        0.580107,
        0.402441,
        0.780392,
        0.992196,
        0.587502,
        0.406299,
        0.784314,
        0.992785,
        0.594891,
        0.410283,
        0.788235,
        0.993326,
        0.602275,
        0.41439,
        0.792157,
        0.993834,
        0.609644,
        0.418613,
        0.796078,
        0.994309,
        0.616999,
        0.42295,
        0.8,
        0.994738,
        0.62435,
        0.427397,
        0.803922,
        0.995122,
        0.631696,
        0.431951,
        0.807843,
        0.99548,
        0.639027,
        0.436607,
        0.811765,
        0.99581,
        0.646344,
        0.441361,
        0.815686,
        0.996096,
        0.653659,
        0.446213,
        0.819608,
        0.996341,
        0.660969,
        0.45116,
        0.823529,
        0.99658,
        0.668256,
        0.456192,
        0.827451,
        0.996775,
        0.675541,
        0.461314,
        0.831373,
        0.996925,
        0.682828,
        0.466526,
        0.835294,
        0.997077,
        0.690088,
        0.471811,
        0.839216,
        0.997186,
        0.697349,
        0.477182,
        0.843137,
        0.997254,
        0.704611,
        0.482635,
        0.847059,
        0.997325,
        0.711848,
        0.488154,
        0.85098,
        0.997351,
        0.719089,
        0.493755,
        0.854902,
        0.997351,
        0.726324,
        0.499428,
        0.858824,
        0.997341,
        0.733545,
        0.505167,
        0.862745,
        0.997285,
        0.740772,
        0.510983,
        0.866667,
        0.997228,
        0.747981,
        0.516859,
        0.870588,
        0.997138,
        0.75519,
        0.522806,
        0.87451,
        0.997019,
        0.762398,
        0.528821,
        0.878431,
        0.996898,
        0.769591,
        0.534892,
        0.882353,
        0.996727,
        0.776795,
        0.541039,
        0.886275,
        0.996571,
        0.783977,
        0.547233,
        0.890196,
        0.996369,
        0.791167,
        0.553499,
        0.894118,
        0.996162,
        0.798348,
        0.55982,
        0.898039,
        0.995932,
        0.805527,
        0.566202,
        0.901961,
        0.99568,
        0.812706,
        0.572645,
        0.905882,
        0.995424,
        0.819875,
        0.57914,
        0.909804,
        0.995131,
        0.827052,
        0.585701,
        0.913725,
        0.994851,
        0.834213,
        0.592307,
        0.917647,
        0.994524,
        0.841387,
        0.598983,
        0.921569,
        0.994222,
        0.84854,
        0.605696,
        0.92549,
        0.993866,
        0.855711,
        0.612482,
        0.929412,
        0.993545,
        0.862859,
        0.619299,
        0.933333,
        0.99317,
        0.870024,
        0.626189,
        0.937255,
        0.992831,
        0.877168,
        0.633109,
        0.941176,
        0.99244,
        0.88433,
        0.640099,
        0.945098,
        0.992089,
        0.89147,
        0.647116,
        0.94902,
        0.991688,
        0.898627,
        0.654202,
        0.952941,
        0.991332,
        0.905763,
        0.661309,
        0.956863,
        0.99093,
        0.912915,
        0.668481,
        0.960784,
        0.99057,
        0.920049,
        0.675675,
        0.964706,
        0.990175,
        0.927196,
        0.682926,
        0.968627,
        0.989815,
        0.934329,
        0.690198,
        0.972549,
        0.989434,
        0.94147,
        0.697519,
        0.976471,
        0.989077,
        0.948604,
        0.704863,
        0.980392,
        0.988717,
        0.955742,
        0.712242,
        0.984314,
        0.988367,
        0.962878,
        0.719649,
        0.988235,
        0.988033,
        0.970012,
        0.727077,
        0.992157,
        0.987691,
        0.977154,
        0.734536,
        0.996078,
        0.987387,
        0.984288,
        0.742002,
        1,
        0.987053,
        0.991438,
        0.749504
      ]
    },
    {
      ColorSpace: "Diverging",
      Name: "Inferno (matplotlib)",
      NanColor: [
        0,
        1,
        0
      ],
      Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
      License: "CC0",
      Creator: "Nathaniel J. Smith & Stefan van der Walt",
      RGBPoints: [
        0,
        1462e-6,
        466e-6,
        0.013866,
        3922e-6,
        2267e-6,
        127e-5,
        0.01857,
        7843e-6,
        3299e-6,
        2249e-6,
        0.024239,
        0.011765,
        4547e-6,
        3392e-6,
        0.030909,
        0.015686,
        6006e-6,
        4692e-6,
        0.038558,
        0.019608,
        7676e-6,
        6136e-6,
        0.046836,
        0.023529,
        9561e-6,
        7713e-6,
        0.055143,
        0.027451,
        0.011663,
        9417e-6,
        0.06346,
        0.031373,
        0.013995,
        0.011225,
        0.071862,
        0.035294,
        0.016561,
        0.013136,
        0.080282,
        0.039216,
        0.019373,
        0.015133,
        0.088767,
        0.043137,
        0.022447,
        0.017199,
        0.097327,
        0.047059,
        0.025793,
        0.019331,
        0.10593,
        0.05098,
        0.029432,
        0.021503,
        0.114621,
        0.054902,
        0.033385,
        0.023702,
        0.123397,
        0.058824,
        0.037668,
        0.025921,
        0.132232,
        0.062745,
        0.042253,
        0.028139,
        0.141141,
        0.066667,
        0.046915,
        0.030324,
        0.150164,
        0.070588,
        0.051644,
        0.032474,
        0.159254,
        0.07451,
        0.056449,
        0.034569,
        0.168414,
        0.078431,
        0.06134,
        0.03659,
        0.177642,
        0.082353,
        0.066331,
        0.038504,
        0.186962,
        0.086275,
        0.071429,
        0.040294,
        0.196354,
        0.090196,
        0.076637,
        0.041905,
        0.205799,
        0.094118,
        0.081962,
        0.043328,
        0.215289,
        0.098039,
        0.087411,
        0.044556,
        0.224813,
        0.101961,
        0.09299,
        0.045583,
        0.234358,
        0.105882,
        0.098702,
        0.046402,
        0.243904,
        0.109804,
        0.104551,
        0.047008,
        0.25343,
        0.113725,
        0.110536,
        0.047399,
        0.262912,
        0.117647,
        0.116656,
        0.047574,
        0.272321,
        0.121569,
        0.122908,
        0.047536,
        0.281624,
        0.12549,
        0.129285,
        0.047293,
        0.290788,
        0.129412,
        0.135778,
        0.046856,
        0.299776,
        0.133333,
        0.142378,
        0.046242,
        0.308553,
        0.137255,
        0.149073,
        0.045468,
        0.317085,
        0.141176,
        0.15585,
        0.044559,
        0.325338,
        0.145098,
        0.162689,
        0.043554,
        0.333277,
        0.14902,
        0.169575,
        0.042489,
        0.340874,
        0.152941,
        0.176493,
        0.041402,
        0.348111,
        0.156863,
        0.183429,
        0.040329,
        0.354971,
        0.160784,
        0.190367,
        0.039309,
        0.361447,
        0.164706,
        0.197297,
        0.0384,
        0.367535,
        0.168627,
        0.204209,
        0.037632,
        0.373238,
        0.172549,
        0.211095,
        0.03703,
        0.378563,
        0.176471,
        0.217949,
        0.036615,
        0.383522,
        0.180392,
        0.224763,
        0.036405,
        0.388129,
        0.184314,
        0.231538,
        0.036405,
        0.3924,
        0.188235,
        0.238273,
        0.036621,
        0.396353,
        0.192157,
        0.244967,
        0.037055,
        0.400007,
        0.196078,
        0.25162,
        0.037705,
        0.403378,
        0.2,
        0.258234,
        0.038571,
        0.406485,
        0.203922,
        0.26481,
        0.039647,
        0.409345,
        0.207843,
        0.271347,
        0.040922,
        0.411976,
        0.211765,
        0.27785,
        0.042353,
        0.414392,
        0.215686,
        0.284321,
        0.043933,
        0.416608,
        0.219608,
        0.290763,
        0.045644,
        0.418637,
        0.223529,
        0.297178,
        0.04747,
        0.420491,
        0.227451,
        0.303568,
        0.049396,
        0.422182,
        0.231373,
        0.309935,
        0.051407,
        0.423721,
        0.235294,
        0.316282,
        0.05349,
        0.425116,
        0.239216,
        0.32261,
        0.055634,
        0.426377,
        0.243137,
        0.328921,
        0.057827,
        0.427511,
        0.247059,
        0.335217,
        0.06006,
        0.428524,
        0.25098,
        0.3415,
        0.062325,
        0.429425,
        0.254902,
        0.347771,
        0.064616,
        0.430217,
        0.258824,
        0.354032,
        0.066925,
        0.430906,
        0.262745,
        0.360284,
        0.069247,
        0.431497,
        0.266667,
        0.366529,
        0.071579,
        0.431994,
        0.270588,
        0.372768,
        0.073915,
        0.4324,
        0.27451,
        0.379001,
        0.076253,
        0.432719,
        0.278431,
        0.385228,
        0.078591,
        0.432955,
        0.282353,
        0.391453,
        0.080927,
        0.433109,
        0.286275,
        0.397674,
        0.083257,
        0.433183,
        0.290196,
        0.403894,
        0.08558,
        0.433179,
        0.294118,
        0.410113,
        0.087896,
        0.433098,
        0.298039,
        0.416331,
        0.090203,
        0.432943,
        0.301961,
        0.422549,
        0.092501,
        0.432714,
        0.305882,
        0.428768,
        0.09479,
        0.432412,
        0.309804,
        0.434987,
        0.097069,
        0.432039,
        0.313725,
        0.441207,
        0.099338,
        0.431594,
        0.317647,
        0.447428,
        0.101597,
        0.43108,
        0.321569,
        0.453651,
        0.103848,
        0.430498,
        0.32549,
        0.459875,
        0.106089,
        0.429846,
        0.329412,
        0.4661,
        0.108322,
        0.429125,
        0.333333,
        0.472328,
        0.110547,
        0.428334,
        0.337255,
        0.478558,
        0.112764,
        0.427475,
        0.341176,
        0.484789,
        0.114974,
        0.426548,
        0.345098,
        0.491022,
        0.117179,
        0.425552,
        0.34902,
        0.497257,
        0.119379,
        0.424488,
        0.352941,
        0.503493,
        0.121575,
        0.423356,
        0.356863,
        0.50973,
        0.123769,
        0.422156,
        0.360784,
        0.515967,
        0.12596,
        0.420887,
        0.364706,
        0.522206,
        0.12815,
        0.419549,
        0.368627,
        0.528444,
        0.130341,
        0.418142,
        0.372549,
        0.534683,
        0.132534,
        0.416667,
        0.376471,
        0.54092,
        0.134729,
        0.415123,
        0.380392,
        0.547157,
        0.136929,
        0.413511,
        0.384314,
        0.553392,
        0.139134,
        0.411829,
        0.388235,
        0.559624,
        0.141346,
        0.410078,
        0.392157,
        0.565854,
        0.143567,
        0.408258,
        0.396078,
        0.572081,
        0.145797,
        0.406369,
        0.4,
        0.578304,
        0.148039,
        0.404411,
        0.403922,
        0.584521,
        0.150294,
        0.402385,
        0.407843,
        0.590734,
        0.152563,
        0.40029,
        0.411765,
        0.59694,
        0.154848,
        0.398125,
        0.415686,
        0.603139,
        0.157151,
        0.395891,
        0.419608,
        0.60933,
        0.159474,
        0.393589,
        0.423529,
        0.615513,
        0.161817,
        0.391219,
        0.427451,
        0.621685,
        0.164184,
        0.388781,
        0.431373,
        0.627847,
        0.166575,
        0.386276,
        0.435294,
        0.633998,
        0.168992,
        0.383704,
        0.439216,
        0.640135,
        0.171438,
        0.381065,
        0.443137,
        0.64626,
        0.173914,
        0.378359,
        0.447059,
        0.652369,
        0.176421,
        0.375586,
        0.45098,
        0.658463,
        0.178962,
        0.372748,
        0.454902,
        0.66454,
        0.181539,
        0.369846,
        0.458824,
        0.670599,
        0.184153,
        0.366879,
        0.462745,
        0.676638,
        0.186807,
        0.363849,
        0.466667,
        0.682656,
        0.189501,
        0.360757,
        0.470588,
        0.688653,
        0.192239,
        0.357603,
        0.47451,
        0.694627,
        0.195021,
        0.354388,
        0.478431,
        0.700576,
        0.197851,
        0.351113,
        0.482353,
        0.7065,
        0.200728,
        0.347777,
        0.486275,
        0.712396,
        0.203656,
        0.344383,
        0.490196,
        0.718264,
        0.206636,
        0.340931,
        0.494118,
        0.724103,
        0.20967,
        0.337424,
        0.498039,
        0.729909,
        0.212759,
        0.333861,
        0.501961,
        0.735683,
        0.215906,
        0.330245,
        0.505882,
        0.741423,
        0.219112,
        0.326576,
        0.509804,
        0.747127,
        0.222378,
        0.322856,
        0.513725,
        0.752794,
        0.225706,
        0.319085,
        0.517647,
        0.758422,
        0.229097,
        0.315266,
        0.521569,
        0.76401,
        0.232554,
        0.311399,
        0.52549,
        0.769556,
        0.236077,
        0.307485,
        0.529412,
        0.775059,
        0.239667,
        0.303526,
        0.533333,
        0.780517,
        0.243327,
        0.299523,
        0.537255,
        0.785929,
        0.247056,
        0.295477,
        0.541176,
        0.791293,
        0.250856,
        0.29139,
        0.545098,
        0.796607,
        0.254728,
        0.287264,
        0.54902,
        0.801871,
        0.258674,
        0.283099,
        0.552941,
        0.807082,
        0.262692,
        0.278898,
        0.556863,
        0.812239,
        0.266786,
        0.274661,
        0.560784,
        0.817341,
        0.270954,
        0.27039,
        0.564706,
        0.822386,
        0.275197,
        0.266085,
        0.568627,
        0.827372,
        0.279517,
        0.26175,
        0.572549,
        0.832299,
        0.283913,
        0.257383,
        0.576471,
        0.837165,
        0.288385,
        0.252988,
        0.580392,
        0.841969,
        0.292933,
        0.248564,
        0.584314,
        0.846709,
        0.297559,
        0.244113,
        0.588235,
        0.851384,
        0.30226,
        0.239636,
        0.592157,
        0.855992,
        0.307038,
        0.235133,
        0.596078,
        0.860533,
        0.311892,
        0.230606,
        0.6,
        0.865006,
        0.316822,
        0.226055,
        0.603922,
        0.869409,
        0.321827,
        0.221482,
        0.607843,
        0.873741,
        0.326906,
        0.216886,
        0.611765,
        0.878001,
        0.33206,
        0.212268,
        0.615686,
        0.882188,
        0.337287,
        0.207628,
        0.619608,
        0.886302,
        0.342586,
        0.202968,
        0.623529,
        0.890341,
        0.347957,
        0.198286,
        0.627451,
        0.894305,
        0.353399,
        0.193584,
        0.631373,
        0.898192,
        0.358911,
        0.18886,
        0.635294,
        0.902003,
        0.364492,
        0.184116,
        0.639216,
        0.905735,
        0.37014,
        0.17935,
        0.643137,
        0.90939,
        0.375856,
        0.174563,
        0.647059,
        0.912966,
        0.381636,
        0.169755,
        0.65098,
        0.916462,
        0.387481,
        0.164924,
        0.654902,
        0.919879,
        0.393389,
        0.16007,
        0.658824,
        0.923215,
        0.399359,
        0.155193,
        0.662745,
        0.92647,
        0.405389,
        0.150292,
        0.666667,
        0.929644,
        0.411479,
        0.145367,
        0.670588,
        0.932737,
        0.417627,
        0.140417,
        0.67451,
        0.935747,
        0.423831,
        0.13544,
        0.678431,
        0.938675,
        0.430091,
        0.130438,
        0.682353,
        0.941521,
        0.436405,
        0.125409,
        0.686275,
        0.944285,
        0.442772,
        0.120354,
        0.690196,
        0.946965,
        0.449191,
        0.115272,
        0.694118,
        0.949562,
        0.45566,
        0.110164,
        0.698039,
        0.952075,
        0.462178,
        0.105031,
        0.701961,
        0.954506,
        0.468744,
        0.099874,
        0.705882,
        0.956852,
        0.475356,
        0.094695,
        0.709804,
        0.959114,
        0.482014,
        0.089499,
        0.713725,
        0.961293,
        0.488716,
        0.084289,
        0.717647,
        0.963387,
        0.495462,
        0.079073,
        0.721569,
        0.965397,
        0.502249,
        0.073859,
        0.72549,
        0.967322,
        0.509078,
        0.068659,
        0.729412,
        0.969163,
        0.515946,
        0.063488,
        0.733333,
        0.970919,
        0.522853,
        0.058367,
        0.737255,
        0.97259,
        0.529798,
        0.053324,
        0.741176,
        0.974176,
        0.53678,
        0.048392,
        0.745098,
        0.975677,
        0.543798,
        0.043618,
        0.74902,
        0.977092,
        0.55085,
        0.03905,
        0.752941,
        0.978422,
        0.557937,
        0.034931,
        0.756863,
        0.979666,
        0.565057,
        0.031409,
        0.760784,
        0.980824,
        0.572209,
        0.028508,
        0.764706,
        0.981895,
        0.579392,
        0.02625,
        0.768627,
        0.982881,
        0.586606,
        0.024661,
        0.772549,
        0.983779,
        0.593849,
        0.02377,
        0.776471,
        0.984591,
        0.601122,
        0.023606,
        0.780392,
        0.985315,
        0.608422,
        0.024202,
        0.784314,
        0.985952,
        0.61575,
        0.025592,
        0.788235,
        0.986502,
        0.623105,
        0.027814,
        0.792157,
        0.986964,
        0.630485,
        0.030908,
        0.796078,
        0.987337,
        0.63789,
        0.034916,
        0.8,
        0.987622,
        0.64532,
        0.039886,
        0.803922,
        0.987819,
        0.652773,
        0.045581,
        0.807843,
        0.987926,
        0.66025,
        0.05175,
        0.811765,
        0.987945,
        0.667748,
        0.058329,
        0.815686,
        0.987874,
        0.675267,
        0.065257,
        0.819608,
        0.987714,
        0.682807,
        0.072489,
        0.823529,
        0.987464,
        0.690366,
        0.07999,
        0.827451,
        0.987124,
        0.697944,
        0.087731,
        0.831373,
        0.986694,
        0.70554,
        0.095694,
        0.835294,
        0.986175,
        0.713153,
        0.103863,
        0.839216,
        0.985566,
        0.720782,
        0.112229,
        0.843137,
        0.984865,
        0.728427,
        0.120785,
        0.847059,
        0.984075,
        0.736087,
        0.129527,
        0.85098,
        0.983196,
        0.743758,
        0.138453,
        0.854902,
        0.982228,
        0.751442,
        0.147565,
        0.858824,
        0.981173,
        0.759135,
        0.156863,
        0.862745,
        0.980032,
        0.766837,
        0.166353,
        0.866667,
        0.978806,
        0.774545,
        0.176037,
        0.870588,
        0.977497,
        0.782258,
        0.185923,
        0.87451,
        0.976108,
        0.789974,
        0.196018,
        0.878431,
        0.974638,
        0.797692,
        0.206332,
        0.882353,
        0.973088,
        0.805409,
        0.216877,
        0.886275,
        0.971468,
        0.813122,
        0.227658,
        0.890196,
        0.969783,
        0.820825,
        0.238686,
        0.894118,
        0.968041,
        0.828515,
        0.249972,
        0.898039,
        0.966243,
        0.836191,
        0.261534,
        0.901961,
        0.964394,
        0.843848,
        0.273391,
        0.905882,
        0.962517,
        0.851476,
        0.285546,
        0.909804,
        0.960626,
        0.859069,
        0.29801,
        0.913725,
        0.95872,
        0.866624,
        0.31082,
        0.917647,
        0.956834,
        0.874129,
        0.323974,
        0.921569,
        0.954997,
        0.881569,
        0.337475,
        0.92549,
        0.953215,
        0.888942,
        0.351369,
        0.929412,
        0.951546,
        0.896226,
        0.365627,
        0.933333,
        0.950018,
        0.903409,
        0.380271,
        0.937255,
        0.948683,
        0.910473,
        0.395289,
        0.941176,
        0.947594,
        0.917399,
        0.410665,
        0.945098,
        0.946809,
        0.924168,
        0.426373,
        0.94902,
        0.946392,
        0.930761,
        0.442367,
        0.952941,
        0.946403,
        0.937159,
        0.458592,
        0.956863,
        0.946903,
        0.943348,
        0.47497,
        0.960784,
        0.947937,
        0.949318,
        0.491426,
        0.964706,
        0.949545,
        0.955063,
        0.50786,
        0.968627,
        0.95174,
        0.960587,
        0.524203,
        0.972549,
        0.954529,
        0.965896,
        0.540361,
        0.976471,
        0.957896,
        0.971003,
        0.556275,
        0.980392,
        0.961812,
        0.975924,
        0.571925,
        0.984314,
        0.966249,
        0.980678,
        0.587206,
        0.988235,
        0.971162,
        0.985282,
        0.602154,
        0.992157,
        0.976511,
        0.989753,
        0.61676,
        0.996078,
        0.982257,
        0.994109,
        0.631017,
        1,
        0.988362,
        0.998364,
        0.644924
      ]
    },
    {
      ColorSpace: "Diverging",
      Name: "Plasma (matplotlib)",
      NanColor: [
        0,
        1,
        0
      ],
      Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
      License: "CC0",
      Creator: "Nathaniel J. Smith & Stefan van der Walt",
      RGBPoints: [
        0,
        0.050383,
        0.029803,
        0.527975,
        3922e-6,
        0.063536,
        0.028426,
        0.533124,
        7843e-6,
        0.075353,
        0.027206,
        0.538007,
        0.011765,
        0.086222,
        0.026125,
        0.542658,
        0.015686,
        0.096379,
        0.025165,
        0.547103,
        0.019608,
        0.10598,
        0.024309,
        0.551368,
        0.023529,
        0.115124,
        0.023556,
        0.555468,
        0.027451,
        0.123903,
        0.022878,
        0.559423,
        0.031373,
        0.132381,
        0.022258,
        0.56325,
        0.035294,
        0.140603,
        0.021687,
        0.566959,
        0.039216,
        0.148607,
        0.021154,
        0.570562,
        0.043137,
        0.156421,
        0.020651,
        0.574065,
        0.047059,
        0.16407,
        0.020171,
        0.577478,
        0.05098,
        0.171574,
        0.019706,
        0.580806,
        0.054902,
        0.17895,
        0.019252,
        0.584054,
        0.058824,
        0.186213,
        0.018803,
        0.587228,
        0.062745,
        0.193374,
        0.018354,
        0.59033,
        0.066667,
        0.200445,
        0.017902,
        0.593364,
        0.070588,
        0.207435,
        0.017442,
        0.596333,
        0.07451,
        0.21435,
        0.016973,
        0.599239,
        0.078431,
        0.221197,
        0.016497,
        0.602083,
        0.082353,
        0.227983,
        0.016007,
        0.604867,
        0.086275,
        0.234715,
        0.015502,
        0.607592,
        0.090196,
        0.241396,
        0.014979,
        0.610259,
        0.094118,
        0.248032,
        0.014439,
        0.612868,
        0.098039,
        0.254627,
        0.013882,
        0.615419,
        0.101961,
        0.261183,
        0.013308,
        0.617911,
        0.105882,
        0.267703,
        0.012716,
        0.620346,
        0.109804,
        0.274191,
        0.012109,
        0.622722,
        0.113725,
        0.280648,
        0.011488,
        0.625038,
        0.117647,
        0.287076,
        0.010855,
        0.627295,
        0.121569,
        0.293478,
        0.010213,
        0.62949,
        0.12549,
        0.299855,
        9561e-6,
        0.631624,
        0.129412,
        0.30621,
        8902e-6,
        0.633694,
        0.133333,
        0.312543,
        8239e-6,
        0.6357,
        0.137255,
        0.318856,
        7576e-6,
        0.63764,
        0.141176,
        0.32515,
        6915e-6,
        0.639512,
        0.145098,
        0.331426,
        6261e-6,
        0.641316,
        0.14902,
        0.337683,
        5618e-6,
        0.643049,
        0.152941,
        0.343925,
        4991e-6,
        0.64471,
        0.156863,
        0.35015,
        4382e-6,
        0.646298,
        0.160784,
        0.356359,
        3798e-6,
        0.64781,
        0.164706,
        0.362553,
        3243e-6,
        0.649245,
        0.168627,
        0.368733,
        2724e-6,
        0.650601,
        0.172549,
        0.374897,
        2245e-6,
        0.651876,
        0.176471,
        0.381047,
        1814e-6,
        0.653068,
        0.180392,
        0.387183,
        1434e-6,
        0.654177,
        0.184314,
        0.393304,
        1114e-6,
        0.655199,
        0.188235,
        0.399411,
        859e-6,
        0.656133,
        0.192157,
        0.405503,
        678e-6,
        0.656977,
        0.196078,
        0.41158,
        577e-6,
        0.65773,
        0.2,
        0.417642,
        564e-6,
        0.65839,
        0.203922,
        0.423689,
        646e-6,
        0.658956,
        0.207843,
        0.429719,
        831e-6,
        0.659425,
        0.211765,
        0.435734,
        1127e-6,
        0.659797,
        0.215686,
        0.441732,
        154e-5,
        0.660069,
        0.219608,
        0.447714,
        208e-5,
        0.66024,
        0.223529,
        0.453677,
        2755e-6,
        0.66031,
        0.227451,
        0.459623,
        3574e-6,
        0.660277,
        0.231373,
        0.46555,
        4545e-6,
        0.660139,
        0.235294,
        0.471457,
        5678e-6,
        0.659897,
        0.239216,
        0.477344,
        698e-5,
        0.659549,
        0.243137,
        0.48321,
        846e-5,
        0.659095,
        0.247059,
        0.489055,
        0.010127,
        0.658534,
        0.25098,
        0.494877,
        0.01199,
        0.657865,
        0.254902,
        0.500678,
        0.014055,
        0.657088,
        0.258824,
        0.506454,
        0.016333,
        0.656202,
        0.262745,
        0.512206,
        0.018833,
        0.655209,
        0.266667,
        0.517933,
        0.021563,
        0.654109,
        0.270588,
        0.523633,
        0.024532,
        0.652901,
        0.27451,
        0.529306,
        0.027747,
        0.651586,
        0.278431,
        0.534952,
        0.031217,
        0.650165,
        0.282353,
        0.54057,
        0.03495,
        0.64864,
        0.286275,
        0.546157,
        0.038954,
        0.64701,
        0.290196,
        0.551715,
        0.043136,
        0.645277,
        0.294118,
        0.557243,
        0.047331,
        0.643443,
        0.298039,
        0.562738,
        0.051545,
        0.641509,
        0.301961,
        0.568201,
        0.055778,
        0.639477,
        0.305882,
        0.573632,
        0.060028,
        0.637349,
        0.309804,
        0.579029,
        0.064296,
        0.635126,
        0.313725,
        0.584391,
        0.068579,
        0.632812,
        0.317647,
        0.589719,
        0.072878,
        0.630408,
        0.321569,
        0.595011,
        0.07719,
        0.627917,
        0.32549,
        0.600266,
        0.081516,
        0.625342,
        0.329412,
        0.605485,
        0.085854,
        0.622686,
        0.333333,
        0.610667,
        0.090204,
        0.619951,
        0.337255,
        0.615812,
        0.094564,
        0.61714,
        0.341176,
        0.620919,
        0.098934,
        0.614257,
        0.345098,
        0.625987,
        0.103312,
        0.611305,
        0.34902,
        0.631017,
        0.107699,
        0.608287,
        0.352941,
        0.636008,
        0.112092,
        0.605205,
        0.356863,
        0.640959,
        0.116492,
        0.602065,
        0.360784,
        0.645872,
        0.120898,
        0.598867,
        0.364706,
        0.650746,
        0.125309,
        0.595617,
        0.368627,
        0.65558,
        0.129725,
        0.592317,
        0.372549,
        0.660374,
        0.134144,
        0.588971,
        0.376471,
        0.665129,
        0.138566,
        0.585582,
        0.380392,
        0.669845,
        0.142992,
        0.582154,
        0.384314,
        0.674522,
        0.147419,
        0.578688,
        0.388235,
        0.67916,
        0.151848,
        0.575189,
        0.392157,
        0.683758,
        0.156278,
        0.57166,
        0.396078,
        0.688318,
        0.160709,
        0.568103,
        0.4,
        0.69284,
        0.165141,
        0.564522,
        0.403922,
        0.697324,
        0.169573,
        0.560919,
        0.407843,
        0.701769,
        0.174005,
        0.557296,
        0.411765,
        0.706178,
        0.178437,
        0.553657,
        0.415686,
        0.710549,
        0.182868,
        0.550004,
        0.419608,
        0.714883,
        0.187299,
        0.546338,
        0.423529,
        0.719181,
        0.191729,
        0.542663,
        0.427451,
        0.723444,
        0.196158,
        0.538981,
        0.431373,
        0.72767,
        0.200586,
        0.535293,
        0.435294,
        0.731862,
        0.205013,
        0.531601,
        0.439216,
        0.736019,
        0.209439,
        0.527908,
        0.443137,
        0.740143,
        0.213864,
        0.524216,
        0.447059,
        0.744232,
        0.218288,
        0.520524,
        0.45098,
        0.748289,
        0.222711,
        0.516834,
        0.454902,
        0.752312,
        0.227133,
        0.513149,
        0.458824,
        0.756304,
        0.231555,
        0.509468,
        0.462745,
        0.760264,
        0.235976,
        0.505794,
        0.466667,
        0.764193,
        0.240396,
        0.502126,
        0.470588,
        0.76809,
        0.244817,
        0.498465,
        0.47451,
        0.771958,
        0.249237,
        0.494813,
        0.478431,
        0.775796,
        0.253658,
        0.491171,
        0.482353,
        0.779604,
        0.258078,
        0.487539,
        0.486275,
        0.783383,
        0.2625,
        0.483918,
        0.490196,
        0.787133,
        0.266922,
        0.480307,
        0.494118,
        0.790855,
        0.271345,
        0.476706,
        0.498039,
        0.794549,
        0.27577,
        0.473117,
        0.501961,
        0.798216,
        0.280197,
        0.469538,
        0.505882,
        0.801855,
        0.284626,
        0.465971,
        0.509804,
        0.805467,
        0.289057,
        0.462415,
        0.513725,
        0.809052,
        0.293491,
        0.45887,
        0.517647,
        0.812612,
        0.297928,
        0.455338,
        0.521569,
        0.816144,
        0.302368,
        0.451816,
        0.52549,
        0.819651,
        0.306812,
        0.448306,
        0.529412,
        0.823132,
        0.311261,
        0.444806,
        0.533333,
        0.826588,
        0.315714,
        0.441316,
        0.537255,
        0.830018,
        0.320172,
        0.437836,
        0.541176,
        0.833422,
        0.324635,
        0.434366,
        0.545098,
        0.836801,
        0.329105,
        0.430905,
        0.54902,
        0.840155,
        0.33358,
        0.427455,
        0.552941,
        0.843484,
        0.338062,
        0.424013,
        0.556863,
        0.846788,
        0.342551,
        0.420579,
        0.560784,
        0.850066,
        0.347048,
        0.417153,
        0.564706,
        0.853319,
        0.351553,
        0.413734,
        0.568627,
        0.856547,
        0.356066,
        0.410322,
        0.572549,
        0.85975,
        0.360588,
        0.406917,
        0.576471,
        0.862927,
        0.365119,
        0.403519,
        0.580392,
        0.866078,
        0.36966,
        0.400126,
        0.584314,
        0.869203,
        0.374212,
        0.396738,
        0.588235,
        0.872303,
        0.378774,
        0.393355,
        0.592157,
        0.875376,
        0.383347,
        0.389976,
        0.596078,
        0.878423,
        0.387932,
        0.3866,
        0.6,
        0.881443,
        0.392529,
        0.383229,
        0.603922,
        0.884436,
        0.397139,
        0.37986,
        0.607843,
        0.887402,
        0.401762,
        0.376494,
        0.611765,
        0.89034,
        0.406398,
        0.37313,
        0.615686,
        0.89325,
        0.411048,
        0.369768,
        0.619608,
        0.896131,
        0.415712,
        0.366407,
        0.623529,
        0.898984,
        0.420392,
        0.363047,
        0.627451,
        0.901807,
        0.425087,
        0.359688,
        0.631373,
        0.904601,
        0.429797,
        0.356329,
        0.635294,
        0.907365,
        0.434524,
        0.35297,
        0.639216,
        0.910098,
        0.439268,
        0.34961,
        0.643137,
        0.9128,
        0.444029,
        0.346251,
        0.647059,
        0.915471,
        0.448807,
        0.34289,
        0.65098,
        0.918109,
        0.453603,
        0.339529,
        0.654902,
        0.920714,
        0.458417,
        0.336166,
        0.658824,
        0.923287,
        0.463251,
        0.332801,
        0.662745,
        0.925825,
        0.468103,
        0.329435,
        0.666667,
        0.928329,
        0.472975,
        0.326067,
        0.670588,
        0.930798,
        0.477867,
        0.322697,
        0.67451,
        0.933232,
        0.48278,
        0.319325,
        0.678431,
        0.93563,
        0.487712,
        0.315952,
        0.682353,
        0.93799,
        0.492667,
        0.312575,
        0.686275,
        0.940313,
        0.497642,
        0.309197,
        0.690196,
        0.942598,
        0.502639,
        0.305816,
        0.694118,
        0.944844,
        0.507658,
        0.302433,
        0.698039,
        0.947051,
        0.512699,
        0.299049,
        0.701961,
        0.949217,
        0.517763,
        0.295662,
        0.705882,
        0.951344,
        0.52285,
        0.292275,
        0.709804,
        0.953428,
        0.52796,
        0.288883,
        0.713725,
        0.95547,
        0.533093,
        0.28549,
        0.717647,
        0.957469,
        0.53825,
        0.282096,
        0.721569,
        0.959424,
        0.543431,
        0.278701,
        0.72549,
        0.961336,
        0.548636,
        0.275305,
        0.729412,
        0.963203,
        0.553865,
        0.271909,
        0.733333,
        0.965024,
        0.559118,
        0.268513,
        0.737255,
        0.966798,
        0.564396,
        0.265118,
        0.741176,
        0.968526,
        0.5697,
        0.261721,
        0.745098,
        0.970205,
        0.575028,
        0.258325,
        0.74902,
        0.971835,
        0.580382,
        0.254931,
        0.752941,
        0.973416,
        0.585761,
        0.25154,
        0.756863,
        0.974947,
        0.591165,
        0.248151,
        0.760784,
        0.976428,
        0.596595,
        0.244767,
        0.764706,
        0.977856,
        0.602051,
        0.241387,
        0.768627,
        0.979233,
        0.607532,
        0.238013,
        0.772549,
        0.980556,
        0.613039,
        0.234646,
        0.776471,
        0.981826,
        0.618572,
        0.231287,
        0.780392,
        0.983041,
        0.624131,
        0.227937,
        0.784314,
        0.984199,
        0.629718,
        0.224595,
        0.788235,
        0.985301,
        0.63533,
        0.221265,
        0.792157,
        0.986345,
        0.640969,
        0.217948,
        0.796078,
        0.987332,
        0.646633,
        0.214648,
        0.8,
        0.98826,
        0.652325,
        0.211364,
        0.803922,
        0.989128,
        0.658043,
        0.2081,
        0.807843,
        0.989935,
        0.663787,
        0.204859,
        0.811765,
        0.990681,
        0.669558,
        0.201642,
        0.815686,
        0.991365,
        0.675355,
        0.198453,
        0.819608,
        0.991985,
        0.681179,
        0.195295,
        0.823529,
        0.992541,
        0.68703,
        0.19217,
        0.827451,
        0.993032,
        0.692907,
        0.189084,
        0.831373,
        0.993456,
        0.69881,
        0.186041,
        0.835294,
        0.993814,
        0.704741,
        0.183043,
        0.839216,
        0.994103,
        0.710698,
        0.180097,
        0.843137,
        0.994324,
        0.716681,
        0.177208,
        0.847059,
        0.994474,
        0.722691,
        0.174381,
        0.85098,
        0.994553,
        0.728728,
        0.171622,
        0.854902,
        0.994561,
        0.734791,
        0.168938,
        0.858824,
        0.994495,
        0.74088,
        0.166335,
        0.862745,
        0.994355,
        0.746995,
        0.163821,
        0.866667,
        0.994141,
        0.753137,
        0.161404,
        0.870588,
        0.993851,
        0.759304,
        0.159092,
        0.87451,
        0.993482,
        0.765499,
        0.156891,
        0.878431,
        0.993033,
        0.77172,
        0.154808,
        0.882353,
        0.992505,
        0.777967,
        0.152855,
        0.886275,
        0.991897,
        0.784239,
        0.151042,
        0.890196,
        0.991209,
        0.790537,
        0.149377,
        0.894118,
        0.990439,
        0.796859,
        0.14787,
        0.898039,
        0.989587,
        0.803205,
        0.146529,
        0.901961,
        0.988648,
        0.809579,
        0.145357,
        0.905882,
        0.987621,
        0.815978,
        0.144363,
        0.909804,
        0.986509,
        0.822401,
        0.143557,
        0.913725,
        0.985314,
        0.828846,
        0.142945,
        0.917647,
        0.984031,
        0.835315,
        0.142528,
        0.921569,
        0.982653,
        0.841812,
        0.142303,
        0.92549,
        0.98119,
        0.848329,
        0.142279,
        0.929412,
        0.979644,
        0.854866,
        0.142453,
        0.933333,
        0.977995,
        0.861432,
        0.142808,
        0.937255,
        0.976265,
        0.868016,
        0.143351,
        0.941176,
        0.974443,
        0.874622,
        0.144061,
        0.945098,
        0.97253,
        0.88125,
        0.144923,
        0.94902,
        0.970533,
        0.887896,
        0.145919,
        0.952941,
        0.968443,
        0.894564,
        0.147014,
        0.956863,
        0.966271,
        0.901249,
        0.14818,
        0.960784,
        0.964021,
        0.90795,
        0.14937,
        0.964706,
        0.961681,
        0.914672,
        0.15052,
        0.968627,
        0.959276,
        0.921407,
        0.151566,
        0.972549,
        0.956808,
        0.928152,
        0.152409,
        0.976471,
        0.954287,
        0.934908,
        0.152921,
        0.980392,
        0.951726,
        0.941671,
        0.152925,
        0.984314,
        0.949151,
        0.948435,
        0.152178,
        0.988235,
        0.946602,
        0.95519,
        0.150328,
        0.992157,
        0.944152,
        0.961916,
        0.146861,
        0.996078,
        0.941896,
        0.96859,
        0.140956,
        1,
        0.940015,
        0.975158,
        0.131326
      ]
    },
    {
      ColorSpace: "Diverging",
      Name: "Viridis (matplotlib)",
      NanColor: [
        1,
        0,
        0
      ],
      Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
      License: "CC0",
      Creator: "Eric Firing",
      RGBPoints: [
        0,
        0.267004,
        4874e-6,
        0.329415,
        3922e-6,
        0.26851,
        9605e-6,
        0.335427,
        7843e-6,
        0.269944,
        0.014625,
        0.341379,
        0.011765,
        0.271305,
        0.019942,
        0.347269,
        0.015686,
        0.272594,
        0.025563,
        0.353093,
        0.019608,
        0.273809,
        0.031497,
        0.358853,
        0.023529,
        0.274952,
        0.037752,
        0.364543,
        0.027451,
        0.276022,
        0.044167,
        0.370164,
        0.031373,
        0.277018,
        0.050344,
        0.375715,
        0.035294,
        0.277941,
        0.056324,
        0.381191,
        0.039216,
        0.278791,
        0.062145,
        0.386592,
        0.043137,
        0.279566,
        0.067836,
        0.391917,
        0.047059,
        0.280267,
        0.073417,
        0.397163,
        0.05098,
        0.280894,
        0.078907,
        0.402329,
        0.054902,
        0.281446,
        0.08432,
        0.407414,
        0.058824,
        0.281924,
        0.089666,
        0.412415,
        0.062745,
        0.282327,
        0.094955,
        0.417331,
        0.066667,
        0.282656,
        0.100196,
        0.42216,
        0.070588,
        0.28291,
        0.105393,
        0.426902,
        0.07451,
        0.283091,
        0.110553,
        0.431554,
        0.078431,
        0.283197,
        0.11568,
        0.436115,
        0.082353,
        0.283229,
        0.120777,
        0.440584,
        0.086275,
        0.283187,
        0.125848,
        0.44496,
        0.090196,
        0.283072,
        0.130895,
        0.449241,
        0.094118,
        0.282884,
        0.13592,
        0.453427,
        0.098039,
        0.282623,
        0.140926,
        0.457517,
        0.101961,
        0.28229,
        0.145912,
        0.46151,
        0.105882,
        0.281887,
        0.150881,
        0.465405,
        0.109804,
        0.281412,
        0.155834,
        0.469201,
        0.113725,
        0.280868,
        0.160771,
        0.472899,
        0.117647,
        0.280255,
        0.165693,
        0.476498,
        0.121569,
        0.279574,
        0.170599,
        0.479997,
        0.12549,
        0.278826,
        0.17549,
        0.483397,
        0.129412,
        0.278012,
        0.180367,
        0.486697,
        0.133333,
        0.277134,
        0.185228,
        0.489898,
        0.137255,
        0.276194,
        0.190074,
        0.493001,
        0.141176,
        0.275191,
        0.194905,
        0.496005,
        0.145098,
        0.274128,
        0.199721,
        0.498911,
        0.14902,
        0.273006,
        0.20452,
        0.501721,
        0.152941,
        0.271828,
        0.209303,
        0.504434,
        0.156863,
        0.270595,
        0.214069,
        0.507052,
        0.160784,
        0.269308,
        0.218818,
        0.509577,
        0.164706,
        0.267968,
        0.223549,
        0.512008,
        0.168627,
        0.26658,
        0.228262,
        0.514349,
        0.172549,
        0.265145,
        0.232956,
        0.516599,
        0.176471,
        0.263663,
        0.237631,
        0.518762,
        0.180392,
        0.262138,
        0.242286,
        0.520837,
        0.184314,
        0.260571,
        0.246922,
        0.522828,
        0.188235,
        0.258965,
        0.251537,
        0.524736,
        0.192157,
        0.257322,
        0.25613,
        0.526563,
        0.196078,
        0.255645,
        0.260703,
        0.528312,
        0.2,
        0.253935,
        0.265254,
        0.529983,
        0.203922,
        0.252194,
        0.269783,
        0.531579,
        0.207843,
        0.250425,
        0.27429,
        0.533103,
        0.211765,
        0.248629,
        0.278775,
        0.534556,
        0.215686,
        0.246811,
        0.283237,
        0.535941,
        0.219608,
        0.244972,
        0.287675,
        0.53726,
        0.223529,
        0.243113,
        0.292092,
        0.538516,
        0.227451,
        0.241237,
        0.296485,
        0.539709,
        0.231373,
        0.239346,
        0.300855,
        0.540844,
        0.235294,
        0.237441,
        0.305202,
        0.541921,
        0.239216,
        0.235526,
        0.309527,
        0.542944,
        0.243137,
        0.233603,
        0.313828,
        0.543914,
        0.247059,
        0.231674,
        0.318106,
        0.544834,
        0.25098,
        0.229739,
        0.322361,
        0.545706,
        0.254902,
        0.227802,
        0.326594,
        0.546532,
        0.258824,
        0.225863,
        0.330805,
        0.547314,
        0.262745,
        0.223925,
        0.334994,
        0.548053,
        0.266667,
        0.221989,
        0.339161,
        0.548752,
        0.270588,
        0.220057,
        0.343307,
        0.549413,
        0.27451,
        0.21813,
        0.347432,
        0.550038,
        0.278431,
        0.21621,
        0.351535,
        0.550627,
        0.282353,
        0.214298,
        0.355619,
        0.551184,
        0.286275,
        0.212395,
        0.359683,
        0.55171,
        0.290196,
        0.210503,
        0.363727,
        0.552206,
        0.294118,
        0.208623,
        0.367752,
        0.552675,
        0.298039,
        0.206756,
        0.371758,
        0.553117,
        0.301961,
        0.204903,
        0.375746,
        0.553533,
        0.305882,
        0.203063,
        0.379716,
        0.553925,
        0.309804,
        0.201239,
        0.38367,
        0.554294,
        0.313725,
        0.19943,
        0.387607,
        0.554642,
        0.317647,
        0.197636,
        0.391528,
        0.554969,
        0.321569,
        0.19586,
        0.395433,
        0.555276,
        0.32549,
        0.1941,
        0.399323,
        0.555565,
        0.329412,
        0.192357,
        0.403199,
        0.555836,
        0.333333,
        0.190631,
        0.407061,
        0.556089,
        0.337255,
        0.188923,
        0.41091,
        0.556326,
        0.341176,
        0.187231,
        0.414746,
        0.556547,
        0.345098,
        0.185556,
        0.41857,
        0.556753,
        0.34902,
        0.183898,
        0.422383,
        0.556944,
        0.352941,
        0.182256,
        0.426184,
        0.55712,
        0.356863,
        0.180629,
        0.429975,
        0.557282,
        0.360784,
        0.179019,
        0.433756,
        0.55743,
        0.364706,
        0.177423,
        0.437527,
        0.557565,
        0.368627,
        0.175841,
        0.44129,
        0.557685,
        0.372549,
        0.174274,
        0.445044,
        0.557792,
        0.376471,
        0.172719,
        0.448791,
        0.557885,
        0.380392,
        0.171176,
        0.45253,
        0.557965,
        0.384314,
        0.169646,
        0.456262,
        0.55803,
        0.388235,
        0.168126,
        0.459988,
        0.558082,
        0.392157,
        0.166617,
        0.463708,
        0.558119,
        0.396078,
        0.165117,
        0.467423,
        0.558141,
        0.4,
        0.163625,
        0.471133,
        0.558148,
        0.403922,
        0.162142,
        0.474838,
        0.55814,
        0.407843,
        0.160665,
        0.47854,
        0.558115,
        0.411765,
        0.159194,
        0.482237,
        0.558073,
        0.415686,
        0.157729,
        0.485932,
        0.558013,
        0.419608,
        0.15627,
        0.489624,
        0.557936,
        0.423529,
        0.154815,
        0.493313,
        0.55784,
        0.427451,
        0.153364,
        0.497,
        0.557724,
        0.431373,
        0.151918,
        0.500685,
        0.557587,
        0.435294,
        0.150476,
        0.504369,
        0.55743,
        0.439216,
        0.149039,
        0.508051,
        0.55725,
        0.443137,
        0.147607,
        0.511733,
        0.557049,
        0.447059,
        0.14618,
        0.515413,
        0.556823,
        0.45098,
        0.144759,
        0.519093,
        0.556572,
        0.454902,
        0.143343,
        0.522773,
        0.556295,
        0.458824,
        0.141935,
        0.526453,
        0.555991,
        0.462745,
        0.140536,
        0.530132,
        0.555659,
        0.466667,
        0.139147,
        0.533812,
        0.555298,
        0.470588,
        0.13777,
        0.537492,
        0.554906,
        0.47451,
        0.136408,
        0.541173,
        0.554483,
        0.478431,
        0.135066,
        0.544853,
        0.554029,
        0.482353,
        0.133743,
        0.548535,
        0.553541,
        0.486275,
        0.132444,
        0.552216,
        0.553018,
        0.490196,
        0.131172,
        0.555899,
        0.552459,
        0.494118,
        0.129933,
        0.559582,
        0.551864,
        0.498039,
        0.128729,
        0.563265,
        0.551229,
        0.501961,
        0.127568,
        0.566949,
        0.550556,
        0.505882,
        0.126453,
        0.570633,
        0.549841,
        0.509804,
        0.125394,
        0.574318,
        0.549086,
        0.513725,
        0.124395,
        0.578002,
        0.548287,
        0.517647,
        0.123463,
        0.581687,
        0.547445,
        0.521569,
        0.122606,
        0.585371,
        0.546557,
        0.52549,
        0.121831,
        0.589055,
        0.545623,
        0.529412,
        0.121148,
        0.592739,
        0.544641,
        0.533333,
        0.120565,
        0.596422,
        0.543611,
        0.537255,
        0.120092,
        0.600104,
        0.54253,
        0.541176,
        0.119738,
        0.603785,
        0.5414,
        0.545098,
        0.119512,
        0.607464,
        0.540218,
        0.54902,
        0.119423,
        0.611141,
        0.538982,
        0.552941,
        0.119483,
        0.614817,
        0.537692,
        0.556863,
        0.119699,
        0.61849,
        0.536347,
        0.560784,
        0.120081,
        0.622161,
        0.534946,
        0.564706,
        0.120638,
        0.625828,
        0.533488,
        0.568627,
        0.12138,
        0.629492,
        0.531973,
        0.572549,
        0.122312,
        0.633153,
        0.530398,
        0.576471,
        0.123444,
        0.636809,
        0.528763,
        0.580392,
        0.12478,
        0.640461,
        0.527068,
        0.584314,
        0.126326,
        0.644107,
        0.525311,
        0.588235,
        0.128087,
        0.647749,
        0.523491,
        0.592157,
        0.130067,
        0.651384,
        0.521608,
        0.596078,
        0.132268,
        0.655014,
        0.519661,
        0.6,
        0.134692,
        0.658636,
        0.517649,
        0.603922,
        0.137339,
        0.662252,
        0.515571,
        0.607843,
        0.14021,
        0.665859,
        0.513427,
        0.611765,
        0.143303,
        0.669459,
        0.511215,
        0.615686,
        0.146616,
        0.67305,
        0.508936,
        0.619608,
        0.150148,
        0.676631,
        0.506589,
        0.623529,
        0.153894,
        0.680203,
        0.504172,
        0.627451,
        0.157851,
        0.683765,
        0.501686,
        0.631373,
        0.162016,
        0.687316,
        0.499129,
        0.635294,
        0.166383,
        0.690856,
        0.496502,
        0.639216,
        0.170948,
        0.694384,
        0.493803,
        0.643137,
        0.175707,
        0.6979,
        0.491033,
        0.647059,
        0.180653,
        0.701402,
        0.488189,
        0.65098,
        0.185783,
        0.704891,
        0.485273,
        0.654902,
        0.19109,
        0.708366,
        0.482284,
        0.658824,
        0.196571,
        0.711827,
        0.479221,
        0.662745,
        0.202219,
        0.715272,
        0.476084,
        0.666667,
        0.20803,
        0.718701,
        0.472873,
        0.670588,
        0.214,
        0.722114,
        0.469588,
        0.67451,
        0.220124,
        0.725509,
        0.466226,
        0.678431,
        0.226397,
        0.728888,
        0.462789,
        0.682353,
        0.232815,
        0.732247,
        0.459277,
        0.686275,
        0.239374,
        0.735588,
        0.455688,
        0.690196,
        0.24607,
        0.73891,
        0.452024,
        0.694118,
        0.252899,
        0.742211,
        0.448284,
        0.698039,
        0.259857,
        0.745492,
        0.444467,
        0.701961,
        0.266941,
        0.748751,
        0.440573,
        0.705882,
        0.274149,
        0.751988,
        0.436601,
        0.709804,
        0.281477,
        0.755203,
        0.432552,
        0.713725,
        0.288921,
        0.758394,
        0.428426,
        0.717647,
        0.296479,
        0.761561,
        0.424223,
        0.721569,
        0.304148,
        0.764704,
        0.419943,
        0.72549,
        0.311925,
        0.767822,
        0.415586,
        0.729412,
        0.319809,
        0.770914,
        0.411152,
        0.733333,
        0.327796,
        0.77398,
        0.40664,
        0.737255,
        0.335885,
        0.777018,
        0.402049,
        0.741176,
        0.344074,
        0.780029,
        0.397381,
        0.745098,
        0.35236,
        0.783011,
        0.392636,
        0.74902,
        0.360741,
        0.785964,
        0.387814,
        0.752941,
        0.369214,
        0.788888,
        0.382914,
        0.756863,
        0.377779,
        0.791781,
        0.377939,
        0.760784,
        0.386433,
        0.794644,
        0.372886,
        0.764706,
        0.395174,
        0.797475,
        0.367757,
        0.768627,
        0.404001,
        0.800275,
        0.362552,
        0.772549,
        0.412913,
        0.803041,
        0.357269,
        0.776471,
        0.421908,
        0.805774,
        0.35191,
        0.780392,
        0.430983,
        0.808473,
        0.346476,
        0.784314,
        0.440137,
        0.811138,
        0.340967,
        0.788235,
        0.449368,
        0.813768,
        0.335384,
        0.792157,
        0.458674,
        0.816363,
        0.329727,
        0.796078,
        0.468053,
        0.818921,
        0.323998,
        0.8,
        0.477504,
        0.821444,
        0.318195,
        0.803922,
        0.487026,
        0.823929,
        0.312321,
        0.807843,
        0.496615,
        0.826376,
        0.306377,
        0.811765,
        0.506271,
        0.828786,
        0.300362,
        0.815686,
        0.515992,
        0.831158,
        0.294279,
        0.819608,
        0.525776,
        0.833491,
        0.288127,
        0.823529,
        0.535621,
        0.835785,
        0.281908,
        0.827451,
        0.545524,
        0.838039,
        0.275626,
        0.831373,
        0.555484,
        0.840254,
        0.269281,
        0.835294,
        0.565498,
        0.84243,
        0.262877,
        0.839216,
        0.575563,
        0.844566,
        0.256415,
        0.843137,
        0.585678,
        0.846661,
        0.249897,
        0.847059,
        0.595839,
        0.848717,
        0.243329,
        0.85098,
        0.606045,
        0.850733,
        0.236712,
        0.854902,
        0.616293,
        0.852709,
        0.230052,
        0.858824,
        0.626579,
        0.854645,
        0.223353,
        0.862745,
        0.636902,
        0.856542,
        0.21662,
        0.866667,
        0.647257,
        0.8584,
        0.209861,
        0.870588,
        0.657642,
        0.860219,
        0.203082,
        0.87451,
        0.668054,
        0.861999,
        0.196293,
        0.878431,
        0.678489,
        0.863742,
        0.189503,
        0.882353,
        0.688944,
        0.865448,
        0.182725,
        0.886275,
        0.699415,
        0.867117,
        0.175971,
        0.890196,
        0.709898,
        0.868751,
        0.169257,
        0.894118,
        0.720391,
        0.87035,
        0.162603,
        0.898039,
        0.730889,
        0.871916,
        0.156029,
        0.901961,
        0.741388,
        0.873449,
        0.149561,
        0.905882,
        0.751884,
        0.874951,
        0.143228,
        0.909804,
        0.762373,
        0.876424,
        0.137064,
        0.913725,
        0.772852,
        0.877868,
        0.131109,
        0.917647,
        0.783315,
        0.879285,
        0.125405,
        0.921569,
        0.79376,
        0.880678,
        0.120005,
        0.92549,
        0.804182,
        0.882046,
        0.114965,
        0.929412,
        0.814576,
        0.883393,
        0.110347,
        0.933333,
        0.82494,
        0.88472,
        0.106217,
        0.937255,
        0.83527,
        0.886029,
        0.102646,
        0.941176,
        0.845561,
        0.887322,
        0.099702,
        0.945098,
        0.85581,
        0.888601,
        0.097452,
        0.94902,
        0.866013,
        0.889868,
        0.095953,
        0.952941,
        0.876168,
        0.891125,
        0.09525,
        0.956863,
        0.886271,
        0.892374,
        0.095374,
        0.960784,
        0.89632,
        0.893616,
        0.096335,
        0.964706,
        0.906311,
        0.894855,
        0.098125,
        0.968627,
        0.916242,
        0.896091,
        0.100717,
        0.972549,
        0.926106,
        0.89733,
        0.104071,
        0.976471,
        0.935904,
        0.89857,
        0.108131,
        0.980392,
        0.945636,
        0.899815,
        0.112838,
        0.984314,
        0.9553,
        0.901065,
        0.118128,
        0.988235,
        0.964894,
        0.902323,
        0.123941,
        0.992157,
        0.974417,
        0.90359,
        0.130215,
        0.996078,
        0.983868,
        0.904867,
        0.136897,
        1,
        0.993248,
        0.906157,
        0.143936
      ]
    },
    {
      ShowIndexedColorActiveValues: 1,
      IndexedColors: [
        0.07,
        0.5,
        0.7,
        1,
        1,
        1,
        0.85,
        1,
        1,
        0.8,
        0.5,
        1,
        0.76,
        1,
        0,
        1,
        0.71,
        0.71,
        0.5,
        0.5,
        0.5,
        0.05,
        0.05,
        1,
        1,
        0.05,
        0.05,
        0.7,
        1,
        1,
        0.7,
        0.89,
        0.96,
        0.67,
        0.36,
        0.95,
        0.54,
        1,
        0,
        0.75,
        0.65,
        0.65,
        0.5,
        0.6,
        0.6,
        1,
        0.5,
        0,
        1,
        1,
        0.19,
        0.12,
        0.94,
        0.12,
        0.5,
        0.82,
        0.89,
        0.56,
        0.25,
        0.83,
        0.24,
        1,
        0,
        0.9,
        0.9,
        0.9,
        0.75,
        0.76,
        0.78,
        0.65,
        0.65,
        0.67,
        0.54,
        0.6,
        0.78,
        0.61,
        0.48,
        0.78,
        0.5,
        0.48,
        0.78,
        0.44,
        0.48,
        0.78,
        0.36,
        0.48,
        0.76,
        1,
        0.48,
        0.38,
        0.49,
        0.5,
        0.69,
        0.76,
        0.56,
        0.56,
        0.4,
        0.56,
        0.56,
        0.74,
        0.5,
        0.89,
        1,
        0.63,
        0,
        0.65,
        0.16,
        0.16,
        0.36,
        0.72,
        0.82,
        0.44,
        0.18,
        0.69,
        0,
        1,
        0,
        0.58,
        1,
        1,
        0.58,
        0.88,
        0.88,
        0.45,
        0.76,
        0.79,
        0.33,
        0.71,
        0.71,
        0.23,
        0.62,
        0.62,
        0.14,
        0.56,
        0.56,
        0.04,
        0.49,
        0.55,
        0,
        0.41,
        0.52,
        0.88,
        0.88,
        1,
        1,
        0.85,
        0.56,
        0.65,
        0.46,
        0.45,
        0.4,
        0.5,
        0.5,
        0.62,
        0.39,
        0.71,
        0.83,
        0.48,
        0,
        0.58,
        0,
        0.58,
        0.26,
        0.62,
        0.69,
        0.34,
        0.09,
        0.56,
        0,
        0.79,
        0,
        0.44,
        0.83,
        1,
        1,
        1,
        0.78,
        0.85,
        1,
        0.78,
        0.78,
        1,
        0.78,
        0.64,
        1,
        0.78,
        0.56,
        1,
        0.78,
        0.38,
        1,
        0.78,
        0.27,
        1,
        0.78,
        0.19,
        1,
        0.78,
        0.12,
        1,
        0.78,
        0,
        1,
        0.61,
        0,
        0.9,
        0.46,
        0,
        0.83,
        0.32,
        0,
        0.75,
        0.22,
        0,
        0.67,
        0.14,
        0.3,
        0.76,
        1,
        0.3,
        0.65,
        1,
        0.13,
        0.58,
        0.84,
        0.15,
        0.49,
        0.67,
        0.15,
        0.4,
        0.59,
        0.09,
        0.33,
        0.53,
        0.96,
        0.93,
        0.82,
        0.8,
        0.82,
        0.12,
        0.71,
        0.71,
        0.76,
        0.65,
        0.33,
        0.3,
        0.34,
        0.35,
        0.38,
        0.62,
        0.31,
        0.71,
        0.67,
        0.36,
        0,
        0.46,
        0.31,
        0.27,
        0.26,
        0.51,
        0.59,
        0.26,
        0,
        0.4,
        0,
        0.49,
        0,
        0.44,
        0.67,
        0.98,
        0,
        0.73,
        1,
        0,
        0.63,
        1,
        0,
        0.56,
        1,
        0,
        0.5,
        1,
        0,
        0.42,
        1,
        0.33,
        0.36,
        0.95,
        0.47,
        0.36,
        0.89,
        0.54,
        0.31,
        0.89,
        0.63,
        0.21,
        0.83,
        0.7,
        0.12,
        0.83,
        0.7,
        0.12,
        0.73,
        0.7,
        0.05,
        0.65,
        0.74,
        0.05,
        0.53,
        0.78,
        0,
        0.4,
        0.8,
        0,
        0.35,
        0.82,
        0,
        0.31,
        0.85,
        0,
        0.27,
        0.88,
        0,
        0.22,
        0.9,
        0,
        0.18,
        0.91,
        0,
        0.15,
        0.92,
        0,
        0.14,
        0.93,
        0,
        0.13,
        0.94,
        0,
        0.12,
        0.95,
        0,
        0.11,
        0.96,
        0,
        0.1,
        0.97,
        0,
        0.09,
        0.98,
        0,
        0.08,
        0.99,
        0,
        0.07,
        1,
        0,
        0.06
      ],
      Annotations: [
        0,
        "Xx",
        1,
        "H",
        2,
        "He",
        3,
        "Li",
        4,
        "Be",
        5,
        "B",
        6,
        "C",
        7,
        "N",
        8,
        "O",
        9,
        "F",
        10,
        "Ne",
        11,
        "Na",
        12,
        "Mg",
        13,
        "Al",
        14,
        "Si",
        15,
        "P",
        16,
        "S",
        17,
        "Cl",
        18,
        "Ar",
        19,
        "K",
        20,
        "Ca",
        21,
        "Sc",
        22,
        "Ti",
        23,
        "V",
        24,
        "Cr",
        25,
        "Mn",
        26,
        "Fe",
        27,
        "Co",
        28,
        "Ni",
        29,
        "Cu",
        30,
        "Zn",
        31,
        "Ga",
        32,
        "Ge",
        33,
        "As",
        34,
        "Se",
        35,
        "Br",
        36,
        "Kr",
        37,
        "Rb",
        38,
        "Sr",
        39,
        "Y",
        40,
        "Zr",
        41,
        "Nb",
        42,
        "Mo",
        43,
        "Tc",
        44,
        "Ru",
        45,
        "Rh",
        46,
        "Pd",
        47,
        "Ag",
        48,
        "Cd",
        49,
        "In",
        50,
        "Sn",
        51,
        "Sb",
        52,
        "Te",
        53,
        "I",
        54,
        "Xe",
        55,
        "Cs",
        56,
        "Ba",
        57,
        "La",
        58,
        "Ce",
        59,
        "Pr",
        60,
        "Nd",
        61,
        "Pm",
        62,
        "Sm",
        63,
        "Eu",
        64,
        "Gd",
        65,
        "Tb",
        66,
        "Dy",
        67,
        "Ho",
        68,
        "Er",
        69,
        "Tm",
        70,
        "Yb",
        71,
        "Lu",
        72,
        "Hf",
        73,
        "Ta",
        74,
        "W",
        75,
        "Re",
        76,
        "Os",
        77,
        "Ir",
        78,
        "Pt",
        79,
        "Au",
        80,
        "Hg",
        81,
        "Tl",
        82,
        "Pb",
        83,
        "Bi",
        84,
        "Po",
        85,
        "At",
        86,
        "Rn",
        87,
        "Fr",
        88,
        "Ra",
        89,
        "Ac",
        90,
        "Th",
        91,
        "Pa",
        92,
        "U",
        93,
        "Np",
        94,
        "Pu",
        95,
        "Am",
        96,
        "Cm",
        97,
        "Bk",
        98,
        "Cf",
        99,
        "Es",
        100,
        "Fm",
        101,
        "Md",
        102,
        "No",
        103,
        "Lr",
        104,
        "Rf",
        105,
        "Db",
        106,
        "Sg",
        107,
        "Bh",
        108,
        "Hs",
        109,
        "Mt",
        110,
        "Ds",
        111,
        "Rg",
        112,
        "Cn",
        113,
        "Uut",
        114,
        "Uuq",
        115,
        "Uup",
        116,
        "Uuh",
        117,
        "Uus",
        118,
        "Uuo"
      ],
      Name: "BlueObeliskElements"
    }
  ];
  const Lu = /* @__PURE__ */ Object.create(null);
  mae.filter((t) => t.RGBPoints).filter((t) => t.ColorSpace !== "CIELAB").forEach((t) => {
    Lu[t.Name] = t;
  });
  const Uu = Object.keys(Lu);
  Uu.sort();
  function vae(t) {
    return Lu[t];
  }
  function yae(t) {
    !t.RGBPoints || t.ColorSpace === "CIELAB" || (Lu[t.Name] || (Uu.push(t.Name), Uu.sort()), Lu[t.Name] = t);
  }
  function xae(t) {
    const e = Uu.indexOf(t);
    e > -1 && Uu.splice(e, 1), delete Lu[t];
  }
  var Np = {
    addPreset: yae,
    removePresetByName: xae,
    getPresetByName: vae,
    rgbPresetNames: Uu
  };
  const fu = {};
  function wae(t) {
    fu[t] !== void 0 && delete fu[t];
  }
  function Cae(t) {
    const { renderingEngineId: e, viewportId: n } = t.detail, i = _a(e).getViewport(n);
    if (!(i instanceof Ga)) throw new Error("volumeNewImageEventDispatcher: viewport is not a BaseVolumeViewport");
    fu[i.id] === void 0 && (fu[i.id] = 0);
    const a = Rp(i);
    if (!a) {
      console.warn(`volumeNewImageEventDispatcher: sliceData is undefined for viewport ${i.id}`);
      return;
    }
    const { numberOfSlices: s, imageIndex: o } = a;
    if (fu[i.id] === o) return;
    fu[i.id] = o;
    const l = {
      imageIndex: o,
      viewportId: n,
      renderingEngineId: e,
      numberOfSlices: s
    };
    qe(i.element, ze.VOLUME_NEW_IMAGE, l);
  }
  const _af = class _af {
    constructor(e) {
      this.insetImageMultiplier = 1.1, this.flipHorizontal = false, this.flipVertical = false, this.viewportStatus = Bi.NO_DATA, this._suppressCameraModifiedEvents = false, this.hasPixelSpacing = true, this.getProperties = () => ({}), this.setRotation = (n) => {
      }, this.viewportWidgets = /* @__PURE__ */ new Map(), this.addWidget = (n, r) => {
        this.viewportWidgets.set(n, r);
      }, this.getWidget = (n) => this.viewportWidgets.get(n), this.getWidgets = () => Array.from(this.viewportWidgets.values()), this.removeWidgets = () => {
        this.getWidgets().forEach((r) => {
          if (r.getEnabled() && r.setEnabled(false), r.getActor && r.getRenderer) {
            const i = r.getActor(), a = r.getRenderer();
            a && i && a.removeActor(i);
          }
        });
      }, this.id = e.id, this.renderingEngineId = e.renderingEngineId, this.type = e.type, this.element = e.element, this.canvas = e.canvas, this.sx = e.sx, this.sy = e.sy, this.sWidth = e.sWidth, this.sHeight = e.sHeight, this._actors = /* @__PURE__ */ new Map(), this.element.setAttribute("data-viewport-uid", this.id), this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId), this.defaultOptions = Ar(e.defaultOptions), this.suppressEvents = e.defaultOptions.suppressEvents ? e.defaultOptions.suppressEvents : false, this.options = Ar(e.defaultOptions), this.isDisabled = false;
    }
    static get useCustomRenderingPipeline() {
      return false;
    }
    setRendered() {
      this.viewportStatus === Bi.NO_DATA || this.viewportStatus === Bi.LOADING || (this.viewportStatus = Bi.RENDERED);
    }
    getRenderingEngine() {
      return Ch.get(this.renderingEngineId);
    }
    getRenderer() {
      const e = this.getRenderingEngine();
      if (!e || e.hasBeenDestroyed) throw new Error("Rendering engine has been destroyed");
      return e.offscreenMultiRenderWindow.getRenderer(this.id);
    }
    render() {
      this.getRenderingEngine().renderViewport(this.id);
    }
    setOptions(e, n = false) {
      var _a3, _b3;
      this.options = Ar(e), ((_a3 = this.options) == null ? void 0 : _a3.displayArea) && this.setDisplayArea((_b3 = this.options) == null ? void 0 : _b3.displayArea), n && this.render();
    }
    reset(e = false) {
      this.options = Ar(this.defaultOptions), e && this.render();
    }
    flip({ flipHorizontal: e, flipVertical: n }) {
      const r = this.getDefaultImageData();
      if (!r) return;
      const i = this.getCamera(), { viewPlaneNormal: a, viewUp: s, focalPoint: o, position: l } = i, c = Vr(He(), a, s);
      let f = Du(He(), s);
      const u = Rl(He(), a), h = Mu(l, o), v = r.getDimensions().map((E) => Math.floor(E / 2)), m = [
        v[0],
        v[1],
        v[2]
      ], y = r.indexToWorld(m, He()), w = this._getFocalPointForResetCamera(y, i, {
        resetPan: true,
        resetToCenter: false
      }), C = Ft(He(), o, w), T = Ms(C), S = (E) => {
        const b = a5(He(), E, 2 * Bt(C, E));
        return Ft(b, b, C), Pr(b, b), b;
      };
      if (e) {
        const E = S(f), b = Xr(He(), w, E, T), D = Xr(He(), b, u, h);
        this.setCamera({
          viewPlaneNormal: u,
          position: D,
          focalPoint: b
        }), this.flipHorizontal = !this.flipHorizontal;
      }
      if (n) {
        f = Rl(f, s);
        const E = S(c), b = Xr(He(), w, E, T), D = Xr(He(), b, u, h);
        this.setCamera({
          focalPoint: b,
          viewPlaneNormal: u,
          viewUp: f,
          position: D
        }), this.flipVertical = !this.flipVertical;
      }
      this.render();
    }
    getDefaultImageData() {
      const e = this.getDefaultActor();
      if (e && fo(e)) return e.actor.getMapper().getInputData();
    }
    getDefaultActor() {
      return this.getActors()[0];
    }
    getActors() {
      return Array.from(this._actors.values());
    }
    getActorUIDs() {
      return Array.from(this._actors.keys());
    }
    getActor(e) {
      return this._actors.get(e);
    }
    getActorUIDByIndex(e) {
      const n = this.getActors()[e];
      if (n) return n.uid;
    }
    getActorByIndex(e) {
      return this.getActors()[e];
    }
    setActors(e) {
      this.removeAllActors(), this.addActors(e, true);
    }
    _removeActor(e) {
      const n = this.getActor(e);
      if (!n) {
        console.warn(`Actor ${e} does not exist for this viewport`);
        return;
      }
      this.getRenderer().removeViewProp(n.actor), this._actors.delete(e);
    }
    removeActors(e) {
      e.forEach((n) => {
        this._removeActor(n);
      });
    }
    addActors(e, n = false) {
      const r = this.getRenderingEngine();
      if (!r || r.hasBeenDestroyed) {
        console.warn("Viewport::addActors::Rendering engine has not been initialized or has been destroyed");
        return;
      }
      e.forEach((i) => this.addActor(i)), this.resetCamera(n, n);
    }
    addActor(e) {
      var _a3;
      const { uid: n, actor: r } = e, i = this.getRenderingEngine();
      if (!i || i.hasBeenDestroyed) {
        console.warn(`Cannot add actor UID of ${n} Rendering Engine has been destroyed`);
        return;
      }
      if (!n || !r) throw new Error("Actors should have uid and vtk Actor properties");
      if (this.getActor(n)) {
        console.warn(`Actor ${n} already exists for this viewport`);
        return;
      }
      (_a3 = this.getRenderer()) == null ? void 0 : _a3.addActor(r), this._actors.set(n, Object.assign({}, e)), this.updateCameraClippingPlanesAndRange();
    }
    removeAllActors() {
      var _a3;
      (_a3 = this.getRenderer()) == null ? void 0 : _a3.removeAllViewProps(), this._actors = /* @__PURE__ */ new Map();
    }
    resetCameraNoEvent() {
      this._suppressCameraModifiedEvents = true, this.resetCamera(), this._suppressCameraModifiedEvents = false;
    }
    setCameraNoEvent(e) {
      this._suppressCameraModifiedEvents = true, this.setCamera(e), this._suppressCameraModifiedEvents = false;
    }
    _getViewImageDataIntersections(e, n, r) {
      const i = r[0], a = r[1], s = r[2], o = i * n[0] + a * n[1] + s * n[2], l = e.getBounds(), c = this._getEdges(l), f = [];
      for (const u of c) {
        const [[h, g, v], [m, y, w]] = u;
        if (i * (m - h) + a * (y - g) + s * (w - v) === 0) continue;
        const C = MI([
          h,
          g,
          v
        ], [
          m,
          y,
          w
        ], [
          i,
          a,
          s,
          o
        ]);
        this._isInBounds(C, l) && f.push(C);
      }
      return f;
    }
    setInterpolationType(e, n) {
    }
    setDisplayArea(e, n = false) {
      var _a3;
      if (!e) return;
      const { storeAsInitialCamera: r, type: i } = e;
      r && (this.options.displayArea = e);
      const { _suppressCameraModifiedEvents: a } = this;
      if (this._suppressCameraModifiedEvents = true, this.setCamera(this.fitToCanvasCamera), i === "SCALE" ? this.setDisplayAreaScale(e) : (this.setInterpolationType(((_a3 = this.getProperties()) == null ? void 0 : _a3.interpolationType) || ho.LINEAR), this.setDisplayAreaFit(e)), r && (this.initialCamera = this.getCamera()), this._suppressCameraModifiedEvents = a, !n && !a) {
        const s = {
          viewportId: this.id,
          displayArea: e,
          storeAsInitialCamera: r
        };
        qe(this.element, ze.DISPLAY_AREA_MODIFIED, s), this.setCamera(this.getCamera());
      }
    }
    setDisplayAreaScale(e) {
      const { scale: n = 1 } = e, r = this.canvas, i = r.height, a = r.width;
      if (i < 8 || a < 8) return;
      const l = this.getDefaultImageData().getSpacing()[1];
      this.setInterpolationType(ho.NEAREST), this.setCamera({
        parallelScale: i * l / (2 * n)
      }), delete e.imageArea, this.setDisplayAreaFit(e);
      const { focalPoint: c, position: f, viewUp: u, viewPlaneNormal: h } = this.getCamera(), g = He();
      if (r.height % 2 && Xr(g, g, u, n * 0.5 * l), r.width % 2) {
        const v = Vr(He(), u, h);
        Xr(g, g, v, n * 0.5 * l);
      }
      !g[0] && !g[1] && !g[2] || this.setCamera({
        focalPoint: Ai(He(), c, g),
        position: Ai(He(), f, g)
      });
    }
    setDisplayAreaFit(e) {
      const { imageArea: n, imageCanvasPoint: r } = e, i = (window == null ? void 0 : window.devicePixelRatio) || 1, a = this.getDefaultImageData();
      if (!a) return;
      const s = this.sWidth / i, o = this.sHeight / i, l = a.getDimensions(), c = this.worldToCanvas(a.indexToWorld([
        0,
        0,
        0
      ])), f = this.worldToCanvas(a.indexToWorld([
        l[0] - 1,
        l[1] - 1,
        l[2]
      ])), u = [
        Math.abs(f[0] - c[0]),
        Math.abs(f[1] - c[1])
      ], [h, g] = u;
      if (n) {
        const [v, m] = n, y = Math.abs(v * h / s), w = Math.abs(m * g / o), C = this.getZoom(), T = this.getZoom(this.fitToCanvasCamera), E = Math.min(1 / y, 1 / w) * C / T;
        this.setZoom(E, false);
      }
      if (r) {
        const { imagePoint: v, canvasPoint: m = v || [
          0.5,
          0.5
        ] } = r, [y, w] = m, C = s * (y - 0.5), T = o * (w - 0.5), [S, E] = v || m, b = 1, D = b * h * (0.5 - S), R = b * g * (0.5 - E), I = D + C, O = R + T, L = [
          I,
          O
        ];
        H6(L, L, this.getPan()), this.setPan(L, false);
      }
    }
    getDisplayArea() {
      var _a3;
      return (_a3 = this.options) == null ? void 0 : _a3.displayArea;
    }
    resetCamera(e = true, n = true, r = true, i = true) {
      var _a3, _b3;
      const a = this.getRenderer();
      this.setCameraNoEvent({
        flipHorizontal: false,
        flipVertical: false
      });
      const s = Ar(this.getCamera()), o = a.computeVisiblePropBounds(), l = [
        0,
        0,
        0
      ], c = this.getDefaultImageData();
      if (c) {
        const N = c.getSpacing();
        o[0] = o[0] + N[0] / 2, o[1] = o[1] - N[0] / 2, o[2] = o[2] + N[1] / 2, o[3] = o[3] - N[1] / 2, o[4] = o[4] + N[2] / 2, o[5] = o[5] - N[2] / 2;
      }
      const f = this.getVtkActiveCamera(), u = f.getViewPlaneNormal(), h = f.getViewUp();
      if (l[0] = (o[0] + o[1]) / 2, l[1] = (o[2] + o[3]) / 2, l[2] = (o[4] + o[5]) / 2, c) {
        const F = c.getDimensions().map((k) => Math.floor(k / 2)), V = [
          F[0],
          F[1],
          F[2]
        ];
        c.indexToWorld(V, l);
      }
      const { widthWorld: g, heightWorld: v } = this._getWorldDistanceViewUpAndViewRight(o, h, u), m = [
        this.sWidth,
        this.sHeight
      ], y = g / v, w = m[0] / m[1], C = y / w, T = C < 1 ? this.insetImageMultiplier * v / 2 : this.insetImageMultiplier * v * C / 2, S = _af.boundsRadius(o) * (this.type === Hn.VOLUME_3D ? 10 : 1), E = this.insetImageMultiplier * S, b = Math.abs(La.dot(h, u)) > 0.999 ? [
        -h[2],
        h[0],
        h[1]
      ] : h, D = this._getFocalPointForResetCamera(l, s, {
        resetPan: e,
        resetToCenter: r
      }), R = [
        D[0] + E * u[0],
        D[1] + E * u[1],
        D[2] + E * u[2]
      ];
      a.resetCameraClippingRange(o);
      const I = [
        -Gi.MAXIMUM_RAY_DISTANCE,
        Gi.MAXIMUM_RAY_DISTANCE
      ];
      f.setPhysicalScale(S), f.setPhysicalTranslation(-D[0], -D[1], -D[2]), this.setCamera({
        parallelScale: n ? T : s.parallelScale,
        focalPoint: D,
        position: R,
        viewAngle: 90,
        viewUp: b,
        clippingRange: I
      });
      const O = Ar(this.getCamera());
      this.setFitToCanvasCamera(Ar(this.getCamera())), i && this.setInitialCamera(O), n && this.setZoom(1, i);
      const L = {
        type: "ResetCameraEvent",
        renderer: a
      };
      return a.invokeEvent(L), this.triggerCameraModifiedEventIfNecessary(s, O), c && ((_a3 = this.options) == null ? void 0 : _a3.displayArea) && n && e && r && this.setDisplayArea((_b3 = this.options) == null ? void 0 : _b3.displayArea), true;
    }
    setInitialCamera(e) {
      this.initialCamera = e;
    }
    setFitToCanvasCamera(e) {
      this.fitToCanvasCamera = e;
    }
    getPan(e = this.initialCamera) {
      const r = this.getVtkActiveCamera().getFocalPoint(), i = this.canvasToWorld([
        0,
        0
      ]), a = this.worldToCanvas(Ft([
        0,
        0,
        0
      ], e.focalPoint, i)), s = this.worldToCanvas(Ft([
        0,
        0,
        0
      ], r, i));
      return Ru([
        0,
        0
      ], a, s);
    }
    getCurrentImageIdIndex() {
      throw new Error("Not implemented");
    }
    getSliceIndex() {
      throw new Error("Not implemented");
    }
    getReferenceId(e) {
      return null;
    }
    setPan(e, n = false) {
      const r = this.getCamera(), { focalPoint: i, position: a } = r, s = this.canvasToWorld([
        0,
        0
      ]), o = Ru([
        0,
        0
      ], e, this.getPan());
      if (Math.abs(o[0]) < 1 && Math.abs(o[1]) < 1 && !n) return;
      const l = Ft(He(), this.canvasToWorld(o), s), c = Ft(He(), i, l), f = Ft(He(), a, l);
      this.setCamera({
        ...r,
        focalPoint: c,
        position: f
      }, n);
    }
    getZoom(e = this.initialCamera) {
      if (!e) return 1;
      const n = this.getVtkActiveCamera(), { parallelScale: r } = e;
      return r / n.getParallelScale();
    }
    setZoom(e, n = false) {
      const r = this.getCamera(), { parallelScale: i } = this.initialCamera, a = i / e;
      r.parallelScale === a && !n || this.setCamera({
        ...r,
        parallelScale: a
      }, n);
    }
    _getFocalPointForViewPlaneReset(e) {
      const { focalPoint: n, viewPlaneNormal: r } = this.getCamera(), i = this._getViewImageDataIntersections(e, n, r);
      let a = 0, s = 0, o = 0;
      return i.forEach(([c, f, u]) => {
        a += c, s += f, o += u;
      }), [
        a / i.length,
        s / i.length,
        o / i.length
      ];
    }
    getCanvas() {
      return this.canvas;
    }
    getVtkActiveCamera() {
      return this.getRenderer().getActiveCamera();
    }
    getCamera() {
      const e = this.getVtkActiveCamera();
      return {
        viewUp: e.getViewUp(),
        viewPlaneNormal: e.getViewPlaneNormal(),
        position: e.getPosition(),
        focalPoint: e.getFocalPoint(),
        parallelProjection: e.getParallelProjection(),
        parallelScale: e.getParallelScale(),
        viewAngle: e.getViewAngle(),
        flipHorizontal: this.flipHorizontal,
        flipVertical: this.flipVertical
      };
    }
    setCamera(e, n = false) {
      const r = this.getVtkActiveCamera(), i = Ar(this.getCamera()), a = Object.assign({}, i, e), { viewUp: s, viewPlaneNormal: o, position: l, focalPoint: c, parallelScale: f, viewAngle: u, flipHorizontal: h, flipVertical: g, clippingRange: v } = e;
      if (h !== void 0) {
        const w = h && !this.flipHorizontal || !h && this.flipHorizontal;
        w && this.flip({
          flipHorizontal: w
        });
      }
      if (g !== void 0) {
        const w = g && !this.flipVertical || !g && this.flipVertical;
        w && this.flip({
          flipVertical: w
        });
      }
      s !== void 0 && r.setViewUp(s), o !== void 0 && r.setDirectionOfProjection(-o[0], -o[1], -o[2]), l !== void 0 && r.setPosition(...l), c !== void 0 && r.setFocalPoint(...c), f !== void 0 && r.setParallelScale(f), u !== void 0 && r.setViewAngle(u), v !== void 0 && r.setClippingRange(v);
      const m = i.focalPoint, y = i.viewUp;
      if (m && c || y && s) {
        const w = r.getViewPlaneNormal(), C = r.getViewUp();
        let T = false, S = false;
        if (c) {
          const E = [
            c[0] - m[0],
            c[1] - m[1],
            c[2] - m[2]
          ];
          T = Math.abs(La.dot(E, w)) > 0;
        }
        if (s && (S = !zr(C, y)), T || S) {
          const E = this.getDefaultActor();
          if (!(E == null ? void 0 : E.actor)) return;
          ea(E, "vtkActor") || this.updateClippingPlanesForActors(a), (ea(E, "vtkImageSlice") || this.type === Hn.VOLUME_3D) && this.getRenderer().resetCameraClippingRange();
        }
      }
      n && this.setInitialCamera(a), this.triggerCameraModifiedEventIfNecessary(i, this.getCamera());
    }
    triggerCameraModifiedEventIfNecessary(e, n) {
      if (!this._suppressCameraModifiedEvents && !this.suppressEvents) {
        const r = {
          previousCamera: e,
          camera: n,
          element: this.element,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId,
          rotation: this.getRotation()
        };
        qe(this.element, ze.CAMERA_MODIFIED, r);
      }
    }
    updateCameraClippingPlanesAndRange() {
      const e = this.getCamera();
      this.updateClippingPlanesForActors(e), this.getRenderer().resetCameraClippingRange();
    }
    async updateClippingPlanesForActors(e) {
      this.getActors().map((r) => {
        if (!r.actor) return;
        const i = r.actor.getMapper();
        let a = (r == null ? void 0 : r.clippingFilter) ? r.clippingFilter.getClippingPlanes() : i.getClippingPlanes();
        a.length === 0 && (r == null ? void 0 : r.clippingFilter) && (a = [
          Si.newInstance(),
          Si.newInstance()
        ]);
        let s = Gi.MINIMUM_SLAB_THICKNESS;
        r.slabThickness && (s = r.slabThickness);
        const { viewPlaneNormal: o, focalPoint: l } = e;
        this.setOrientationOfClippingPlanes(a, s, o, l), qe(this.element, ze.CLIPPING_PLANES_UPDATED, {
          actorEntry: r,
          focalPoint: l,
          vtkPlanes: a,
          viewport: this
        });
      });
    }
    setOrientationOfClippingPlanes(e, n, r, i) {
      if (e.length < 2) return;
      const a = [
        r[0],
        r[1],
        r[2]
      ];
      La.multiplyScalar(a, n), e[0].setNormal(r);
      const s = [
        0,
        0,
        0
      ];
      La.subtract(i, a, s), e[0].setOrigin(s), e[1].setNormal(-r[0], -r[1], -r[2]);
      const o = [
        0,
        0,
        0
      ];
      La.add(i, a, o), e[1].setOrigin(o);
    }
    getClippingPlanesForActor(e) {
      if (e || (e = this.getDefaultActor()), !e.actor) throw new Error("Invalid actor entry: Actor is undefined");
      const n = e.actor.getMapper();
      let r = (e == null ? void 0 : e.clippingFilter) ? e.clippingFilter.getClippingPlanes() : n.getClippingPlanes();
      return r.length === 0 && (e == null ? void 0 : e.clippingFilter) && (r = [
        Si.newInstance(),
        Si.newInstance()
      ]), r;
    }
    _getWorldDistanceViewUpAndViewRight(e, n, r) {
      const i = this._getCorners(e), a = this._getCorners(e), s = Vr(He(), n, r);
      let o = Lc.buildFromDegree().identity().rotateFromDirections(n, [
        1,
        0,
        0
      ]);
      i.forEach((h) => o.apply(h));
      let l = 1 / 0, c = -1 / 0;
      for (let h = 0; h < 8; h++) {
        const g = i[h][0];
        g > c && (c = g), g < l && (l = g);
      }
      o = Lc.buildFromDegree().identity().rotateFromDirections([
        s[0],
        s[1],
        s[2]
      ], [
        1,
        0,
        0
      ]), a.forEach((h) => o.apply(h));
      let f = 1 / 0, u = -1 / 0;
      for (let h = 0; h < 8; h++) {
        const g = a[h][0];
        g > u && (u = g), g < f && (f = g);
      }
      return {
        widthWorld: u - f,
        heightWorld: c - l
      };
    }
    getViewReference(e = {}) {
      const { focalPoint: n, viewPlaneNormal: r, viewUp: i } = this.getCamera();
      return {
        FrameOfReferenceUID: this.getFrameOfReferenceUID(),
        cameraFocalPoint: n,
        viewPlaneNormal: r,
        viewUp: i,
        sliceIndex: e.sliceIndex ?? this.getSliceIndex()
      };
    }
    isReferenceViewable(e, n) {
      if (e.FrameOfReferenceUID && e.FrameOfReferenceUID !== this.getFrameOfReferenceUID()) return false;
      const { viewPlaneNormal: r } = e, i = this.getCamera();
      return r && !zr(r, i.viewPlaneNormal) && !zr(Rl(i.viewPlaneNormal, i.viewPlaneNormal), r) ? (n == null ? void 0 : n.withOrientation) === true : true;
    }
    getViewPresentation(e = {
      rotation: true,
      displayArea: true,
      zoom: true,
      pan: true
    }) {
      const n = {}, { rotation: r, displayArea: i, zoom: a, pan: s } = e;
      r && (n.rotation = this.getRotation()), i && (n.displayArea = this.getDisplayArea());
      const o = this.getZoom();
      return a && (n.zoom = o), s && (n.pan = this.getPan(), Nv(n.pan, n.pan, 1 / o)), n;
    }
    setViewReference(e) {
    }
    setViewPresentation(e) {
      if (!e) return;
      const { displayArea: n, zoom: r = this.getZoom(), pan: i, rotation: a } = e;
      n !== this.getDisplayArea() && this.setDisplayArea(n), this.setZoom(r), i && this.setPan(Nv([
        0,
        0
      ], i, r)), a >= 0 && this.setRotation(a);
    }
    _shouldUseNativeDataType() {
      const { useNorm16Texture: e, preferSizeOverAccuracy: n } = Do().rendering;
      return e || n;
    }
    _getCorners(e) {
      return [
        [
          e[0],
          e[2],
          e[4]
        ],
        [
          e[0],
          e[2],
          e[5]
        ],
        [
          e[0],
          e[3],
          e[4]
        ],
        [
          e[0],
          e[3],
          e[5]
        ],
        [
          e[1],
          e[2],
          e[4]
        ],
        [
          e[1],
          e[2],
          e[5]
        ],
        [
          e[1],
          e[3],
          e[4]
        ],
        [
          e[1],
          e[3],
          e[5]
        ]
      ];
    }
    _getFocalPointForResetCamera(e, n, { resetPan: r = true, resetToCenter: i = true }) {
      if (i && r) return e;
      if (i && !r) return w6(n.focalPoint) ? e : n.focalPoint;
      if (!i && r) {
        const a = n, s = a.focalPoint, o = a.viewPlaneNormal, l = Ft(He(), e, s), c = Bt(l, o), f = Xr(He(), e, o, -1 * c);
        return [
          f[0],
          f[1],
          f[2]
        ];
      }
      if (!r && !i) return w6(n.focalPoint) ? e : n.focalPoint;
    }
    _isInBounds(e, n) {
      const [r, i, a, s, o, l] = n, [c, f, u] = e;
      return !(c < r || c > i || f < a || f > s || u < o || u > l);
    }
    _getEdges(e) {
      const [n, r, i, a, s, o, l, c] = this._getCorners(e);
      return [
        [
          n,
          r
        ],
        [
          n,
          s
        ],
        [
          n,
          i
        ],
        [
          r,
          a
        ],
        [
          r,
          o
        ],
        [
          i,
          a
        ],
        [
          i,
          l
        ],
        [
          a,
          c
        ],
        [
          s,
          l
        ],
        [
          s,
          o
        ],
        [
          o,
          c
        ],
        [
          l,
          c
        ]
      ];
    }
    static boundsRadius(e) {
      const n = (e[1] - e[0]) ** 2, r = (e[3] - e[2]) ** 2, i = (e[5] - e[4]) ** 2;
      return Math.sqrt(n + r + i || 1) * 0.5;
    }
    setDataIds(e, n) {
      throw new Error("Unsupported operatoin setDataIds");
    }
  };
  _af.CameraViewPresentation = {
    rotation: true,
    pan: true,
    zoom: true,
    displayArea: true
  };
  _af.TransferViewPresentation = {
    windowLevel: true,
    paletteLut: true
  };
  let af = _af;
  const yy = /* @__PURE__ */ new Map();
  function Tae(t) {
    yy.set(t.Name, t);
  }
  function I5(t) {
    return yy.get(t);
  }
  function SI() {
    return Array.from(yy.keys());
  }
  function xy(t, e) {
    const n = Np.rgbPresetNames.map((o) => Np.getPresetByName(o)), r = SI().map((o) => I5(o)), a = n.concat(r).find((o) => {
      const { RGBPoints: l } = o;
      if (l.length !== t.length) return false;
      for (let c = 0; c < l.length; c += 4) if (!zr(l.slice(c + 1, c + 4), t.slice(c + 1, c + 4))) return false;
      return true;
    });
    if (!a) return null;
    const s = [];
    if (ea(e, "vtkVolume")) {
      const o = e.getProperty().getScalarOpacity(0).getDataPointer();
      if (!o) return {
        name: a.Name
      };
      for (let l = 0; l < o.length; l += 2) s.push({
        value: o[l],
        opacity: o[l + 1]
      });
    }
    return {
      name: a.Name,
      opacity: s
    };
  }
  const Sae = Object.freeze(Object.defineProperty({
    __proto__: null,
    findMatchingColormap: xy,
    getColormap: I5,
    getColormapNames: SI,
    registerColormap: Tae
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function Lp(t) {
    const e = t.getSize(), n = [];
    for (let r = 0; r < e; r++) {
      const i = [];
      t.getNodeValue(r, i), n.push(i);
    }
    return n;
  }
  function V5(t, e) {
    (e == null ? void 0 : e.length) && (t.removeAllPoints(), e.forEach((n) => {
      t.addRGBPoint(...n);
    }));
  }
  const Aae = Object.freeze(Object.defineProperty({
    __proto__: null,
    getTransferFunctionNodes: Lp,
    setTransferFunctionNodes: V5
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Ga extends af {
    constructor(e) {
      if (super(e), this.useCPURendering = false, this.useNativeDataType = false, this.perVolumeIdDefaultProperties = /* @__PURE__ */ new Map(), this.viewportProperties = {}, this.setRotation = (i) => {
        const a = this.getPan(this.fitToCanvasCamera), s = this.getPan(), o = this.getCamera(), l = ep([
          0,
          0
        ], a, s);
        this.setPan(l, false);
        const { flipVertical: c } = this.getCamera(), f = c ? Rl([
          0,
          0,
          0
        ], this.initialViewUp) : this.initialViewUp;
        this.setCameraNoEvent({
          viewUp: f
        }), this.rotateCamera(i);
        const u = this.getPan(), h = this.getPan(this.fitToCanvasCamera), g = ep([
          0,
          0
        ], u, h), v = H6([
          0,
          0
        ], a, g);
        if (this.setPan(v, false), this._suppressCameraModifiedEvents) return;
        const m = this.getCamera(), y = {
          previousCamera: o,
          camera: m,
          element: this.element,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId,
          rotation: i
        };
        qe(this.element, ze.CAMERA_MODIFIED, y), this.viewportProperties.rotation = i;
      }, this.getDefaultProperties = (i) => {
        let a;
        return i !== void 0 && (a = this.perVolumeIdDefaultProperties.get(i)), a !== void 0 ? a : {
          ...this.globalDefaultProperties
        };
      }, this.getProperties = (i) => {
        var _a3, _b3;
        if (!this._getApplicableVolumeActor(i)) return;
        const { colormap: s, VOILUTFunction: o, interpolationType: l, invert: c, slabThickness: f, rotation: u, preset: h } = this.viewportProperties, g = this.getActors().map((w) => {
          var _a4;
          const C = w.actor, T = w.uid;
          if (!Ke.getVolume(T)) return null;
          const E = C.getProperty().getRGBTransferFunction(0), [b, D] = ((_a4 = this.viewportProperties) == null ? void 0 : _a4.VOILUTFunction) === "SIGMOID" ? TD(E) : E.getRange();
          return {
            volumeId: T,
            voiRange: {
              lower: b,
              upper: D
            }
          };
        }).filter(Boolean), v = i ? (_a3 = g.find((w) => w.volumeId === i)) == null ? void 0 : _a3.voiRange : (_b3 = g[0]) == null ? void 0 : _b3.voiRange, m = this.getColormap(i);
        return {
          colormap: i && m ? m : s,
          voiRange: v,
          VOILUTFunction: o,
          interpolationType: l,
          invert: c,
          slabThickness: f,
          rotation: u,
          preset: h
        };
      }, this.getColormap = (i) => {
        const a = this._getApplicableVolumeActor(i);
        if (!a) return;
        const { volumeActor: s } = a, o = s.getProperty().getRGBTransferFunction(0), { nodes: l } = o.getState(), c = l.reduce((u, h) => (u.push(h.x, h.r, h.g, h.b), u), []);
        return xy(c, s);
      }, this.getRotation = () => {
        const { viewUp: i, viewPlaneNormal: a, flipVertical: s } = this.getCamera(), o = s ? Rl([
          0,
          0,
          0
        ], this.initialViewUp) : this.initialViewUp;
        if (!o) return 0;
        const l = th(o, i) * 180 / Math.PI, c = Vr([
          0,
          0,
          0
        ], o, i);
        return Bt(c, a) >= 0 ? l : (360 - l) % 360;
      }, this.getFrameOfReferenceUID = () => this._FrameOfReferenceUID, this.canvasToWorld = (i) => {
        var _a3, _b3;
        const a = this.getVtkActiveCamera();
        (_a3 = a.setIsPerformingCoordinateTransformation) == null ? void 0 : _a3.call(a, true);
        const s = this.getRenderer(), l = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), c = l.getSize(), f = window.devicePixelRatio || 1, u = [
          i[0] * f,
          i[1] * f
        ], h = [
          u[0] + this.sx,
          u[1] + this.sy
        ];
        h[1] = c[1] - h[1];
        const g = l.displayToWorld(h[0], h[1], 0, s);
        return (_b3 = a.setIsPerformingCoordinateTransformation) == null ? void 0 : _b3.call(a, false), [
          g[0],
          g[1],
          g[2]
        ];
      }, this.worldToCanvas = (i) => {
        var _a3, _b3;
        const a = this.getVtkActiveCamera();
        (_a3 = a.setIsPerformingCoordinateTransformation) == null ? void 0 : _a3.call(a, true);
        const s = this.getRenderer(), l = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), c = l.getSize(), f = l.worldToDisplay(...i, s);
        f[1] = c[1] - f[1];
        const u = [
          f[0] - this.sx,
          f[1] - this.sy
        ], h = window.devicePixelRatio || 1, g = [
          u[0] / h,
          u[1] / h
        ];
        return (_b3 = a.setIsPerformingCoordinateTransformation) == null ? void 0 : _b3.call(a, false), g;
      }, this.hasImageURI = (i) => this.getActors().filter((s) => ea(s, "vtkVolume")).some(({ uid: s }) => {
        const o = Ke.getVolume(s);
        return !o || !o.imageIds ? false : o.imageIds.map(va).includes(i);
      }), this.getImageIds = (i) => {
        const a = this._getApplicableVolumeActor(i);
        if (!a) throw new Error(`No actor found for the given volumeId: ${i}`);
        const s = a.volumeId, o = Ke.getVolume(s);
        if (!o) throw new Error(`imageVolume with id: ${s} does not exist in cache`);
        return o.imageIds;
      }, this.useCPURendering = uh(), this.useNativeDataType = this._shouldUseNativeDataType(), this.useCPURendering) throw new Error("VolumeViewports cannot be used whilst CPU Fallback Rendering is enabled.");
      const n = this.getRenderer(), r = Lee.newInstance();
      switch (n.setActiveCamera(r), this.type) {
        case Hn.ORTHOGRAPHIC:
          r.setParallelProjection(true);
          break;
        case Hn.VOLUME_3D:
          r.setParallelProjection(true);
          break;
        case Hn.PERSPECTIVE:
          r.setParallelProjection(false);
          break;
        default:
          throw new Error(`Unrecognized viewport type: ${this.type}`);
      }
      this.initializeVolumeNewImageEventDispatcher();
    }
    static get useCustomRenderingPipeline() {
      return false;
    }
    resetCamera(e = true, n = true, r = true, i = false, a = false, s = true) {
      return super.resetCamera();
    }
    applyViewOrientation(e, n = true) {
      const { viewPlaneNormal: r, viewUp: i } = this._getOrientationVectors(e), a = this.getVtkActiveCamera();
      a.setDirectionOfProjection(-r[0], -r[1], -r[2]), a.setViewUpFrom(i), this.initialViewUp = i, n && this.resetCamera(true, true, true, false, true, false);
    }
    initializeVolumeNewImageEventDispatcher() {
      const e = r.bind(this), n = i.bind(this);
      function r(a) {
        const { viewportId: s } = a.detail;
        s !== this.id || this.isDisabled || !this.getImageData() || Cae(a);
      }
      function i(a) {
        const { viewportId: s } = a.detail;
        s === this.id && (this.element.removeEventListener(ze.CAMERA_MODIFIED, e), je.removeEventListener(ze.ELEMENT_DISABLED, n), wae(s));
      }
      this.element.removeEventListener(ze.CAMERA_MODIFIED, e), this.element.addEventListener(ze.CAMERA_MODIFIED, e), je.addEventListener(ze.ELEMENT_DISABLED, n);
    }
    resetVolumeViewportClippingRange() {
      const e = this.getVtkActiveCamera();
      e.getParallelProjection() ? e.setClippingRange(-Gi.MAXIMUM_RAY_DISTANCE, Gi.MAXIMUM_RAY_DISTANCE) : e.setClippingRange(Gi.MINIMUM_SLAB_THICKNESS, Gi.MAXIMUM_RAY_DISTANCE);
    }
    setVOILUTFunction(e, n, r) {
      Object.values(yo).indexOf(e) === -1 && (e = yo.LINEAR);
      const { voiRange: i } = this.getProperties();
      this.setVOI(i, n, r), this.viewportProperties.VOILUTFunction = e;
    }
    setColormap(e, n, r) {
      const i = this._getApplicableVolumeActor(n);
      if (!i) return;
      const { volumeActor: a } = i, s = Ul.newInstance();
      let o = I5(e.name);
      const { name: l } = e;
      if (o || (o = Np.getPresetByName(l)), !o) throw new Error(`Colormap ${e} not found`);
      const c = a.getProperty().getRGBTransferFunction(0).getRange();
      if (s.applyColorMap(o), s.setMappingRange(c[0], c[1]), a.getProperty().setRGBTransferFunction(0, s), this.viewportProperties.colormap = e, !r) {
        const f = {
          viewportId: this.id,
          colormap: e,
          volumeId: n
        };
        qe(this.element, ze.COLORMAP_MODIFIED, f);
      }
    }
    setOpacity(e, n) {
      const r = this._getApplicableVolumeActor(n);
      if (!r) return;
      const { volumeActor: i } = r, a = Iu.newInstance();
      if (typeof e.opacity == "number") {
        const s = i.getProperty().getRGBTransferFunction(0).getRange();
        a.addPoint(s[0], e.opacity), a.addPoint(s[1], e.opacity);
      } else e.opacity.forEach(({ opacity: s, value: o }) => {
        a.addPoint(o, s);
      });
      i.getProperty().setScalarOpacity(0, a), this.viewportProperties.colormap || (this.viewportProperties.colormap = {}), this.viewportProperties.colormap.opacity = e.opacity;
    }
    setInvert(e, n, r) {
      const i = this._getApplicableVolumeActor(n);
      if (!i) return;
      const a = i.volumeId, s = this._getOrCreateColorTransferFunction(a);
      if (sh(s), this.viewportProperties.invert = e, !r) {
        const o = {
          ...this.getVOIModifiedEventDetail(a),
          invertStateChanged: true
        };
        qe(this.element, ze.VOI_MODIFIED, o);
      }
    }
    getVOIModifiedEventDetail(e) {
      const n = this._getApplicableVolumeActor(e);
      if (!n) throw new Error(`No actor found for the given volumeId: ${e}`);
      const a = n.volumeActor.getProperty().getRGBTransferFunction(0).getMappingRange(), s = this.getColormap(e), { VOILUTFunction: o, invert: l } = this.getProperties(e);
      return {
        viewportId: this.id,
        range: {
          lower: a[0],
          upper: a[1]
        },
        volumeId: n.volumeId,
        VOILUTFunction: o,
        colormap: s,
        invert: l
      };
    }
    _getOrCreateColorTransferFunction(e) {
      const n = this._getApplicableVolumeActor(e);
      if (!n) return null;
      const { volumeActor: r } = n, i = r.getProperty().getRGBTransferFunction(0);
      if (i) return i;
      const a = Ul.newInstance();
      return r.getProperty().setRGBTransferFunction(0, a), a;
    }
    setInterpolationType(e, n) {
      const r = this._getApplicableVolumeActor(n);
      if (!r) return;
      const { volumeActor: i } = r;
      i.getProperty().setInterpolationType(e), this.viewportProperties.interpolationType = e;
    }
    setVOI(e, n, r = false) {
      const i = this._getApplicableVolumeActor(n);
      if (!i) return;
      const { volumeActor: a } = i, s = i.volumeId;
      let o = e;
      if (typeof o > "u") {
        const f = a.getMapper().getInputData().getPointData().getScalars().getRange();
        o = {
          lower: f[0],
          upper: f[1]
        };
      }
      const { VOILUTFunction: l } = this.getProperties(s);
      if (l === yo.SAMPLED_SIGMOID) {
        const c = I8(o);
        a.getProperty().setRGBTransferFunction(0, c);
      } else {
        const { lower: c, upper: f } = o;
        a.getProperty().getRGBTransferFunction(0).setRange(c, f);
      }
      if (!r) {
        const c = {
          ...this.getVOIModifiedEventDetail(s)
        };
        qe(this.element, ze.VOI_MODIFIED, c);
      }
      this.viewportProperties.voiRange = o;
    }
    rotateCamera(e) {
      const n = e - this.getRotation();
      this.getVtkActiveCamera().roll(-n);
    }
    setDefaultProperties(e, n) {
      n == null ? this.globalDefaultProperties = e : this.perVolumeIdDefaultProperties.set(n, e);
    }
    clearDefaultProperties(e) {
      e == null ? (this.globalDefaultProperties = {}, this.resetProperties()) : (this.perVolumeIdDefaultProperties.delete(e), this.resetToDefaultProperties(e));
    }
    getViewReference(e = {}) {
      const n = super.getViewReference(e), r = this.getVolumeId(e);
      if ((e == null ? void 0 : e.forFrameOfReference) !== false && (n.volumeId = r), typeof (e == null ? void 0 : e.sliceIndex) != "number") return n;
      const { viewPlaneNormal: i } = n, a = e.sliceIndex - this.getSliceIndex(), { sliceRangeInfo: s } = mh(this, r, true), { sliceRange: o, spacingInNormalDirection: l, camera: c } = s, { focalPoint: f, position: u } = c, { newFocalPoint: h } = Cu(f, u, o, i, l, a);
      return n.cameraFocalPoint = h, n;
    }
    isReferenceViewable(e, n) {
      if (!e.FrameOfReferenceUID || !super.isReferenceViewable(e, n)) return false;
      if (n == null ? void 0 : n.withNavigation) return true;
      const r = this.getSliceIndex(), { sliceIndex: i } = e;
      return Array.isArray(i) ? i[0] <= r && r <= i[1] : i === void 0 || i === r;
    }
    scroll(e = 1) {
      const n = this.getVolumeId(), { sliceRangeInfo: r } = mh(this, n, true);
      if (!r) return;
      const { sliceRange: i, spacingInNormalDirection: a, camera: s } = r, { focalPoint: o, viewPlaneNormal: l, position: c } = s, { newFocalPoint: f, newPosition: u } = Cu(o, c, i, l, a, e);
      this.setCamera({
        focalPoint: f,
        position: u
      });
    }
    setViewReference(e) {
      if (!e) return;
      const n = this.getVolumeId(), { viewPlaneNormal: r, FrameOfReferenceUID: i, cameraFocalPoint: a, viewUp: s } = e;
      let { sliceIndex: o } = e;
      const { focalPoint: l, viewPlaneNormal: c, position: f } = this.getCamera(), u = DD(c, r), h = zr(c, r);
      if (typeof o == "number" && e.volumeId === n && (u || h)) {
        const { currentStepIndex: g, sliceRangeInfo: v, numScrollSteps: m } = mh(this, n, true), { sliceRange: y, spacingInNormalDirection: w } = v;
        u && (o = m - o - 1);
        const C = o - g, { newFocalPoint: T, newPosition: S } = Cu(l, f, y, c, w, C);
        this.setCamera({
          focalPoint: T,
          position: S
        });
      } else if (i === this.getFrameOfReferenceUID()) {
        if (r && !u && !h) return this.setOrientation({
          viewPlaneNormal: r,
          viewUp: s
        }), this.setViewReference(e);
        if (a) {
          const g = Ft([
            0,
            0,
            0
          ], a, l), v = r ?? c, m = Bt(g, v);
          zr(m, 0) || a5(g, v, m);
          const y = Ai([
            0,
            0,
            0
          ], l, g), w = Ai([
            0,
            0,
            0
          ], f, g);
          this.setCamera({
            focalPoint: y,
            position: w
          });
        }
      } else throw new Error(`Incompatible view refs: ${i}!==${this.getFrameOfReferenceUID()}`);
    }
    setProperties({ voiRange: e, VOILUTFunction: n, invert: r, colormap: i, preset: a, interpolationType: s, slabThickness: o, rotation: l } = {}, c, f = false) {
      this.globalDefaultProperties == null && this.setDefaultProperties({
        voiRange: e,
        VOILUTFunction: n,
        invert: r,
        colormap: i,
        preset: a,
        slabThickness: o,
        rotation: l
      }), (i == null ? void 0 : i.name) && this.setColormap(i, c, f), (i == null ? void 0 : i.opacity) != null && this.setOpacity(i, c), e !== void 0 && this.setVOI(e, c, f), typeof s < "u" && this.setInterpolationType(s), n !== void 0 && this.setVOILUTFunction(n, c, f), r !== void 0 && this.viewportProperties.invert !== r && this.setInvert(r, c, f), a !== void 0 && this.setPreset(a, c, f), o !== void 0 && (this.setSlabThickness(o), this.viewportProperties.slabThickness = o), l !== void 0 && this.setRotation(l);
    }
    resetToDefaultProperties(e) {
      var _a3, _b3;
      const n = this.globalDefaultProperties;
      ((_a3 = n.colormap) == null ? void 0 : _a3.name) && this.setColormap(n.colormap, e), ((_b3 = n.colormap) == null ? void 0 : _b3.opacity) != null && this.setOpacity(n.colormap, e), n.voiRange !== void 0 && this.setVOI(n.voiRange, e), n.VOILUTFunction !== void 0 && this.setVOILUTFunction(n.VOILUTFunction, e), n.invert !== void 0 && this.setInvert(n.invert, e), n.slabThickness !== void 0 && (this.setSlabThickness(n.slabThickness), this.viewportProperties.slabThickness = n.slabThickness), n.rotation !== void 0 && this.setRotation(n.rotation), n.preset !== void 0 && this.setPreset(n.preset, e, false), this.render();
    }
    setPreset(e, n, r) {
      const i = this._getApplicableVolumeActor(n);
      if (!i) return;
      const { volumeActor: a } = i;
      let s = e;
      typeof s == "string" && (s = yb.find((o) => o.name === e)), s && (mI(a, s), this.viewportProperties.preset = s, this.render(), r || qe(this.element, ze.PRESET_MODIFIED, {
        viewportId: this.id,
        volumeId: i.volumeId,
        actor: a,
        presetName: s.name
      }));
    }
    async setVolumes(e, n = false, r = false) {
      const i = Ke.getVolume(e[0].volumeId);
      if (!i) throw new Error(`imageVolume with id: ${i.volumeId} does not exist`);
      const a = i.metadata.FrameOfReferenceUID;
      await this._isValidVolumeInputArray(e, a), this._FrameOfReferenceUID = a;
      const s = [];
      for (let o = 0; o < e.length; o++) {
        const { volumeId: l, actorUID: c, slabThickness: f } = e[o], u = await uS(e[o], this.element, this.id, r, this.useNativeDataType), h = c || l;
        s.push({
          uid: h,
          actor: u,
          slabThickness: f,
          referenceId: l
        });
      }
      this._setVolumeActors(s), this.viewportStatus = Bi.PRE_RENDER, this.initializeColorTransferFunction(e), qe(this.element, ze.VOLUME_VIEWPORT_NEW_VOLUME, {
        viewportId: this.id,
        volumeActors: s
      }), n && this.render();
    }
    async addVolumes(e, n = false, r = false) {
      const i = Ke.getVolume(e[0].volumeId);
      if (!i) throw new Error(`imageVolume with id: ${i.volumeId} does not exist`);
      const a = [];
      await this._isValidVolumeInputArray(e, this._FrameOfReferenceUID);
      for (let s = 0; s < e.length; s++) {
        const { volumeId: o, visibility: l, actorUID: c, slabThickness: f } = e[s], u = await uS(e[s], this.element, this.id, r, this.useNativeDataType);
        l === false && u.setVisibility(false);
        const h = c || o;
        a.push({
          uid: h,
          actor: u,
          slabThickness: f,
          referenceId: o
        });
      }
      this.addActors(a), this.initializeColorTransferFunction(e), n && this.render();
    }
    removeVolumeActors(e, n = false) {
      this.removeActors(e), n && this.render();
    }
    setOrientation(e, n = true) {
      console.warn('Method "setOrientation" needs implementation');
    }
    initializeColorTransferFunction(e) {
      const n = e[0].volumeId, r = this._getOrCreateColorTransferFunction(n);
      this.initialTransferFunctionNodes || (this.initialTransferFunctionNodes = Lp(r));
    }
    _getApplicableVolumeActor(e) {
      var _a3;
      if (e !== void 0 && !this.getActor(e)) return;
      const n = this.getActors();
      if (!n.length) return;
      let r;
      return e && (r = (_a3 = this.getActor(e)) == null ? void 0 : _a3.actor), r || (r = n[0].actor, e = n[0].uid), {
        volumeActor: r,
        volumeId: e
      };
    }
    async _isValidVolumeInputArray(e, n) {
      const r = e.length;
      for (let i = 1; i < r; i++) {
        const a = e[i], s = await JO(a.volumeId);
        if (!s) throw new Error(`imageVolume with id: ${s.volumeId} does not exist`);
        if (n !== s.metadata.FrameOfReferenceUID) throw new Error(`Volumes being added to viewport ${this.id} do not share the same FrameOfReferenceUID. This is not yet supported`);
      }
      return true;
    }
    getBounds() {
      return this.getRenderer().computeVisiblePropBounds();
    }
    flip(e) {
      super.flip(e);
    }
    hasVolumeId(e) {
      return this.getActors().some((r) => r.uid === e);
    }
    getImageData(e) {
      var _a3;
      const n = this.getDefaultActor();
      if (!n) return;
      const { uid: r } = n;
      e = e ?? r;
      const i = this.getActor(e);
      if (!ea(i, "vtkVolume")) return;
      const a = i.actor, s = Ke.getVolume(e), o = a.getMapper().getInputData();
      return {
        dimensions: o.getDimensions(),
        spacing: o.getSpacing(),
        origin: o.getOrigin(),
        direction: o.getDirection(),
        scalarData: o.getPointData().getScalars().isDeleted() ? null : o.getPointData().getScalars().getData(),
        imageData: a.getMapper().getInputData(),
        metadata: {
          Modality: (_a3 = s == null ? void 0 : s.metadata) == null ? void 0 : _a3.Modality
        },
        scaling: s == null ? void 0 : s.scaling,
        hasPixelSpacing: true
      };
    }
    _setVolumeActors(e) {
      for (let n = 0; n < e.length; n++) this.viewportProperties.invert = false;
      this.setActors(e);
    }
    _getOrientationVectors(e) {
      if (typeof e == "object") {
        if (e.viewPlaneNormal && e.viewUp) return e;
        throw new Error("Invalid orientation object. It must contain viewPlaneNormal and viewUp");
      } else {
        if (typeof e == "string" && Al[e]) return this.viewportProperties.orientation = e, Al[e];
        throw new Error(`Invalid orientation: ${e}. Valid orientations are: ${Object.keys(Al).join(", ")}`);
      }
    }
    getSlabThickness() {
      const e = this.getActors();
      let n = Gi.MINIMUM_SLAB_THICKNESS;
      return e.forEach((r) => {
        r.slabThickness > n && (n = r.slabThickness);
      }), n;
    }
    getIntensityFromWorld(e) {
      const n = this.getDefaultActor();
      if (!ea(n, "vtkVolume")) return;
      const { actor: r, uid: i } = n, a = r.getMapper().getInputData(), s = Ke.getVolume(i), { dimensions: o } = s, l = wl(a, e), c = l[2] * o[0] * o[1] + l[1] * o[0] + l[0];
      return s.getScalarData()[c];
    }
    getVolumeId(e) {
      var _a3, _b3;
      const n = this.getActors();
      if (n) return (e == null ? void 0 : e.volumeId) ? (_a3 = n.find((r) => r.actor.getClassName() === "vtkVolume" && r.uid === e.volumeId)) == null ? void 0 : _a3.uid : (_b3 = n.find((r) => r.actor.getClassName() === "vtkVolume")) == null ? void 0 : _b3.uid;
    }
    getReferenceId(e = {}) {
      var _a3;
      let { volumeId: n, sliceIndex: r } = e;
      if (!n) {
        const l = this.getActors();
        if (!l) return;
        n = (_a3 = l.find((c) => c.actor.getClassName() === "vtkVolume")) == null ? void 0 : _a3.uid;
      }
      const i = this.getSliceIndex();
      r ?? (r = i);
      const { viewPlaneNormal: a, focalPoint: s } = this.getCamera(), o = n.indexOf("?") > -1 ? "&" : "?";
      return `volumeId:${n}${o}sliceIndex=${r}&viewPlaneNormal=${a.join(",")}&focalPoint=${s.join(",")}`;
    }
  }
  async function AI(t, e, n, r = false, i = false) {
    n.forEach((s) => {
      const o = t.getViewport(s);
      if (!o) throw new Error(`Viewport with Id ${s} does not exist`);
      if (!(o instanceof Ga)) throw new Error("setVolumesForViewports only supports VolumeViewport and VolumeViewport3D");
    });
    const a = n.map(async (s) => {
      await t.getViewport(s).setVolumes(e, r, i);
    });
    await Promise.all(a);
  }
  async function Eae(t, e, n, r = false, i = false) {
    for (const s of n) {
      const o = t.getViewport(s);
      if (!o) throw new Error(`Viewport with Id ${s} does not exist`);
      if (!(o instanceof Ga)) {
        console.warn(`Viewport with Id ${s} is not a BaseVolumeViewport. Cannot add volume to this viewport.`);
        return;
      }
    }
    const a = n.map(async (s) => {
      await t.getViewport(s).addVolumes(e, r, i);
    });
    await Promise.all(a);
  }
  async function bae(t, e, n) {
    for (const i of n) {
      const a = t.getViewport(i);
      if (!a) throw new Error(`Viewport with Id ${i} does not exist`);
      if (!a.addImages) {
        console.warn(`Viewport with Id ${i} does not have addImages. Cannot add image segmentation to this viewport.`);
        return;
      }
    }
    const r = n.map(async (i) => t.getViewport(i).addImages(e));
    await Promise.all(r);
  }
  async function Dae({ viewport: t, options: e }) {
    const n = t.getRenderingEngine();
    let { volumeId: r } = e;
    r.split(":").length === 1 && (r = `${Ore()}:${r}`);
    const { id: i, element: a } = t, s = e.viewportId || i, o = t.getImageIds(), l = t.getCamera();
    n.enableElement({
      viewportId: s,
      type: Hn.ORTHOGRAPHIC,
      element: a,
      defaultOptions: {
        background: e.background,
        orientation: e.orientation
      }
    }), (await m6(r, {
      imageIds: o
    })).load();
    const f = n.getViewport(s);
    AI(n, [
      {
        volumeId: r
      }
    ], [
      s
    ]);
    const u = () => {
      e.orientation || f.setCamera({
        ...l
      }), f.render(), a.removeEventListener(ze.VOLUME_VIEWPORT_NEW_VOLUME, u);
    };
    return (() => {
      a.addEventListener(ze.VOLUME_VIEWPORT_NEW_VOLUME, u);
    })(), f.render(), f;
  }
  async function Mae({ viewport: t, options: e }) {
    const n = t, { id: r, element: i } = n, a = t.getRenderingEngine(), s = t.getCurrentImageIdIndex(), { background: o } = e, l = e.viewportId || r, c = n.getDefaultActor(), { uid: f } = c, u = Ke.getVolume(f);
    if (!(u instanceof Gl)) throw new Error("Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.");
    const h = {
      viewportId: l,
      type: Hn.STACK,
      element: i,
      defaultOptions: {
        background: o
      }
    };
    a.enableElement(h);
    const g = a.getViewport(l), v = u.imageCacheOffsetMap.size > 0;
    let m = false;
    v && (m = u.imageIds.every((S) => Ke.getImage(S)));
    const y = a.getVolumeViewports().find((S) => S.hasVolumeId(f));
    u.decache(!y && m);
    const w = [
      ...u.imageIds
    ].reverse();
    let C = Math.max(u.imageIds.length - s - 1, 0);
    if (!Ke.getImage(w[C])) {
      let S = 1 / 0, E = null;
      w.forEach((b, D) => {
        if (Ke.getImage(b)) {
          const I = Math.abs(C - D);
          I < S && (S = I, E = D);
        }
      }), C = E;
    }
    return await g.setStack(w, C ?? 0), g.render(), g;
  }
  class EI {
    constructor(e, n, r = 1) {
      this.rows = /* @__PURE__ */ new Map(), this.height = 1, this.width = 1, this.depth = 1, this.jMultiple = 1, this.kMultiple = 1, this.numComps = 1, this.defaultValue = 0, this.pixelDataConstructor = Uint8Array, this.get = (i) => {
        var _a3;
        const a = i % this.jMultiple, s = (i - a) / this.jMultiple;
        return ((_a3 = this.getRLE(a, s)) == null ? void 0 : _a3.value) || this.defaultValue;
      }, this.getRun = (i, a) => {
        const s = i + a * this.height;
        return this.rows.get(s);
      }, this.set = (i, a) => {
        if (a === void 0) throw new Error(`Can't set undefined at ${i % this.width}`);
        const s = i % this.width, o = (i - s) / this.width, l = this.rows.get(o);
        if (!l) {
          this.rows.set(o, [
            {
              start: s,
              end: s + 1,
              value: a
            }
          ]);
          return;
        }
        const c = this.findIndex(l, s), f = l[c], u = l[c - 1];
        if (!f) {
          if (!u || u.value !== a || u.end !== s) {
            l[c] = {
              start: s,
              end: s + 1,
              value: a
            };
            return;
          }
          u.end++;
          return;
        }
        const { start: h, end: g, value: v } = f;
        if (a === v && s >= h) return;
        const m = {
          start: s,
          end: s + 1,
          value: a
        }, y = s > h, w = y ? c + 1 : c, C = y ? f : u;
        let T = y ? l[c + 1] : f;
        if ((C == null ? void 0 : C.value) === a && (C == null ? void 0 : C.end) === s) {
          C.end++, (T == null ? void 0 : T.value) === a && T.start === s + 1 ? (C.end = T.end, l.splice(c, 1)) : (T == null ? void 0 : T.start) === s && (T.start++, T.start === T.end && (l.splice(c, 1), T = l[c], (T == null ? void 0 : T.start) === s + 1 && T.value === a && (C.end = T.end, l.splice(c, 1))));
          return;
        }
        if ((T == null ? void 0 : T.value) === a && T.start === s + 1) {
          T.start--, (C == null ? void 0 : C.end) > s && (C.end = s, C.end === C.start && l.splice(c, 1));
          return;
        }
        if ((T == null ? void 0 : T.start) === s && T.end === s + 1) {
          T.value = a;
          const S = l[c + 1];
          (S == null ? void 0 : S.start) == s + 1 && S.value === a && (l.splice(c + 1, 1), T.end = S.end);
          return;
        }
        s === (T == null ? void 0 : T.start) && T.start++, y && g > s + 1 ? l.splice(w, 0, m, {
          start: s + 1,
          end: C.end,
          value: C.value
        }) : l.splice(w, 0, m), (C == null ? void 0 : C.end) > s && (C.end = s);
      }, this.width = e, this.height = n, this.depth = r, this.jMultiple = e, this.kMultiple = this.jMultiple * n;
    }
    getRLE(e, n, r = 0) {
      const i = this.rows.get(n + r * this.height);
      if (!i) return;
      const a = this.findIndex(i, e), s = i[a];
      return e >= (s == null ? void 0 : s.start) ? s : void 0;
    }
    findIndex(e, n) {
      for (let r = 0; r < e.length; r++) {
        const { end: i } = e[r];
        if (n < i) return r;
      }
      return e.length;
    }
    clear() {
      this.rows.clear();
    }
    keys() {
      return [
        ...this.rows.keys()
      ];
    }
    getPixelData(e = 0, n) {
      n ? n.fill(0) : n = new this.pixelDataConstructor(this.width * this.height * this.numComps);
      const { width: r, height: i, numComps: a } = this;
      for (let s = 0; s < i; s++) {
        const o = this.getRun(s, e);
        if (o) if (a === 1) for (const l of o) {
          const c = s * r, { start: f, end: u, value: h } = l;
          for (let g = f; g < u; g++) n[c + g] = h;
        }
        else for (const l of o) {
          const c = s * r * a, { start: f, end: u, value: h } = l;
          for (let g = f; g < u; g += a) for (let v = 0; v < a; v++) n[c + g + v] = h[v];
        }
      }
      return n;
    }
  }
  const Rae = 5 * 1024;
  class Zi {
    constructor(e, n, r) {
      this.modifiedSlices = /* @__PURE__ */ new Set(), this.boundsIJK = [
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ]
      ], this.numComps = 1, this.getAtIJK = (i, a, s) => {
        const o = i + a * this.width + s * this.frameSize;
        return this._get(o);
      }, this.setAtIJK = (i, a, s, o) => {
        const l = i + a * this.width + s * this.frameSize;
        this._set(l, o) !== false && (this.modifiedSlices.add(s), Zi.addBounds(this.boundsIJK, [
          i,
          a,
          s
        ]));
      }, this.getAtIJKPoint = ([i, a, s]) => this.getAtIJK(i, a, s), this.setAtIJKPoint = ([i, a, s], o) => this.setAtIJK(i, a, s, o), this.getAtIndex = (i) => this._get(i), this.setAtIndex = (i, a) => {
        if (this._set(i, a) !== false) {
          const s = this.toIJK(i);
          this.modifiedSlices.add(s[2]), Zi.addBounds(this.boundsIJK, s);
        }
      }, this.forEach = (i, a) => {
        const s = (a == null ? void 0 : a.boundsIJK) || this.getBoundsIJK(), { isWithinObject: o } = a || {};
        if (this.map) for (const l of this.map.keys()) {
          const c = this.toIJK(l), u = {
            value: this._get(l),
            index: l,
            pointIJK: c
          };
          (o == null ? void 0 : o(u)) !== false && i(u);
        }
        else for (let l = s[2][0]; l <= s[2][1]; l++) {
          const c = l * this.frameSize;
          for (let f = s[1][0]; f <= s[1][1]; f++) {
            const u = c + f * this.width;
            for (let h = s[0][0], g = u + h; h <= s[0][1]; h++, g++) {
              const m = {
                value: this.getAtIndex(g),
                index: g,
                pointIJK: [
                  h,
                  f,
                  l
                ]
              };
              (o == null ? void 0 : o(m)) !== false && i(m);
            }
          }
        }
      }, this.dimensions = e, this.width = e[0], this.frameSize = this.width * e[1], this._get = n, this._set = r;
    }
    addPoint(e) {
      const n = Array.isArray(e) ? e[0] + this.width * e[1] + this.frameSize * e[2] : e;
      this.points || (this.points = /* @__PURE__ */ new Set()), this.points.add(n);
    }
    getPoints() {
      return this.points ? [
        ...this.points
      ].map((e) => this.toIJK(e)) : [];
    }
    getPointIndices() {
      return this.points ? [
        ...this.points
      ] : [];
    }
    toIJK(e) {
      return [
        e % this.width,
        Math.floor(e % this.frameSize / this.width),
        Math.floor(e / this.frameSize)
      ];
    }
    toIndex(e) {
      return e[0] + e[1] * this.width + e[2] * this.frameSize;
    }
    getBoundsIJK() {
      return this.boundsIJK[0][0] < this.dimensions[0] ? this.boundsIJK : this.dimensions.map((e) => [
        0,
        e - 1
      ]);
    }
    clear() {
      var _a3;
      this.map && this.map.clear(), this.boundsIJK.map((e) => {
        e[0] = 1 / 0, e[1] = -1 / 0;
      }), this.modifiedSlices.clear(), (_a3 = this.points) == null ? void 0 : _a3.clear();
    }
    getArrayOfSlices() {
      return Array.from(this.modifiedSlices);
    }
    static addBounds(e, n) {
      e || (e = [
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ]
      ]), e[0][0] = Math.min(n[0], e[0][0]), e[0][1] = Math.max(n[0], e[0][1]), e[1][0] = Math.min(n[1], e[1][0]), e[1][1] = Math.max(n[1], e[1][1]), e[2][0] = Math.min(n[2], e[2][0]), e[2][1] = Math.max(n[2], e[2][1]);
    }
    static createRGBVolumeVoxelManager(e, n, r) {
      const i = new Zi(e, (a) => (a *= r, [
        n[a++],
        n[a++],
        n[a++]
      ]), (a, s) => {
        a *= 3;
        const o = !zr(n[a], s);
        return n[a++] = s[0], n[a++] = s[1], n[a++] = s[2], o;
      });
      return i.numComps = r, i.scalarData = n, i;
    }
    static createVolumeVoxelManager(e, n, r = 0) {
      if (e.length !== 3) throw new Error("Dimensions must be provided as [number, number, number] for [width, height, depth]");
      if (!r && (r = n.length / e[0] / e[1] / e[2], r > 4 || r < 1 || r === 2)) throw new Error(`Number of components ${r} must be 1, 3 or 4`);
      return r > 1 ? Zi.createRGBVolumeVoxelManager(e, n, r) : Zi.createNumberVolumeVoxelManager(e, n);
    }
    static createNumberVolumeVoxelManager(e, n) {
      const r = new Zi(e, (i) => n[i], (i, a) => {
        const s = n[i] !== a;
        return n[i] = a, s;
      });
      return r.scalarData = n, r;
    }
    static createMapVoxelManager(e) {
      const n = /* @__PURE__ */ new Map(), r = new Zi(e, n.get.bind(n), (i, a) => n.set(i, a) && true);
      return r.map = n, r;
    }
    static createHistoryVoxelManager(e) {
      const n = /* @__PURE__ */ new Map(), { dimensions: r } = e, i = new Zi(r, (a) => n.get(a), function(a, s) {
        if (n.has(a)) s === n.get(a) && n.delete(a);
        else {
          const o = this.sourceVoxelManager.getAtIndex(a);
          if (o === s) return false;
          n.set(a, o);
        }
        this.sourceVoxelManager.setAtIndex(a, s);
      });
      return i.map = n, i.scalarData = e.scalarData, i.sourceVoxelManager = e, i;
    }
    static createLazyVoxelManager(e, n) {
      const r = /* @__PURE__ */ new Map(), [i, a, s] = e, o = i * a, l = new Zi(e, (c) => {
        var _a3;
        return (_a3 = r.get(Math.floor(c / o))) == null ? void 0 : _a3[c % o];
      }, (c, f) => {
        const u = Math.floor(c / o);
        let h = r.get(u);
        h || (h = n(i, a), r.set(u, h)), h[c % o] = f;
      });
      return l.map = r, l;
    }
    static createRLEVoxelManager(e) {
      const [n, r, i] = e, a = new EI(n, r, i), s = new Zi(e, (o) => a.get(o), (o, l) => a.set(o, l));
      return s.map = a, s.getPixelData = a.getPixelData.bind(a), s;
    }
    static addInstanceToImage(e) {
      const { width: n, height: r } = e, i = e.getPixelData();
      if ((i == null ? void 0 : i.length) >= n * r) {
        e.voxelManager = Zi.createVolumeVoxelManager([
          n,
          r,
          1
        ], i);
        return;
      }
      e.voxelManager = Zi.createRLEVoxelManager([
        n,
        r,
        1
      ]), e.getPixelData = e.voxelManager.getPixelData, e.sizeInBytes = Rae;
    }
  }
  function wy(t, e = 2) {
    if (Array.isArray(t)) return t.map((i) => wy(i, e)).join(", ");
    if (t == null || t === "") return "NaN";
    t = Number(t);
    const n = Math.abs(t);
    if (n < 1e-4) return `${t}`;
    const r = n >= 100 ? e - 2 : n >= 10 ? e - 1 : n >= 1 ? e : n >= 0.1 ? e + 1 : n >= 0.01 ? e + 2 : n >= 1e-3 ? e + 3 : e + 4;
    return t.toFixed(r);
  }
  function Oae(t) {
    return Math.round(t / Vl) * Vl;
  }
  function Iae(t, e, n) {
    const r = t.length === e * n * 4, i = t.length === e * n * 3;
    if (r || i) {
      const a = new Float32Array(e * n);
      let s = 0, o = 0;
      const l = r ? 4 : 3;
      for (let c = 0; c < e; c++) for (let f = 0; f < n; f++) {
        const u = t[s], h = t[s + 1], g = t[s + 2];
        a[o] = (u + h + g) / 3, s += l, o++;
      }
      return a;
    } else return t;
  }
  function bI(t) {
    if (t instanceof Ba) {
      const n = t.getDefaultActor().uid;
      return Ke.getVolume(n).imageIds;
    } else if (t.getImageIds) return t.getImageIds();
  }
  function DI(t, e) {
    const n = [
      ...t
    ];
    return e >= n.length ? (fS(n), n) : (fS(n), n.slice(0, e));
  }
  function fS(t) {
    for (let e = t.length - 1; e > 0; e--) {
      const n = Math.floor(Math.random() * (e + 1));
      [t[e], t[n]] = [
        t[n],
        t[e]
      ];
    }
  }
  function MI(t, e, n) {
    const [r, i, a] = t, [s, o, l] = e, [c, f, u, h] = n, g = s - r, v = o - i, m = l - a, y = -1 * (c * r + f * i + u * a - h) / (c * g + f * v + u * m), w = g * y + r, C = v * y + i, T = m * y + a;
    return [
      w,
      C,
      T
    ];
  }
  function RI(t, e, n = false) {
    const [r, i, a] = t, s = r * e[0] + i * e[1] + a * e[2];
    if (n) {
      const o = Math.sqrt(r * r + i * i + a * a);
      return [
        r / o,
        i / o,
        a / o,
        s / o
      ];
    }
    return [
      r,
      i,
      a,
      s
    ];
  }
  function Vae(t, e, n) {
    const [r, i, a, s] = t, [o, l, c, f] = e, [u, h, g, v] = n, m = as(r, o, u, i, l, h, a, c, g), y = as(s, f, v, i, l, h, a, c, g), w = as(r, o, u, s, f, v, a, c, g), C = as(r, o, u, i, l, h, s, f, v), T = H0(y) / H0(m), S = H0(w) / H0(m), E = H0(C) / H0(m);
    return [
      T,
      S,
      E
    ];
  }
  function OI(t, e, n = false) {
    const [r, i, a, s] = t, [o, l, c] = e, f = r * o + i * l + a * c - s, u = Math.abs(f) / Math.sqrt(r * r + i * i + a * a);
    return (n ? Math.sign(f) : 1) * u;
  }
  const Nae = Object.freeze(Object.defineProperty({
    __proto__: null,
    linePlaneIntersection: MI,
    planeDistanceToPoint: OI,
    planeEquation: RI,
    threePlaneIntersection: Vae
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function Q4(t) {
    const e = t.toString(16);
    return e.length == 1 ? "0" + e : e;
  }
  function Lae(t, e, n) {
    return "#" + Q4(t) + Q4(e) + Q4(n);
  }
  function Uae(t) {
    const e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    return e ? {
      r: parseInt(e[1], 16),
      g: parseInt(e[2], 16),
      b: parseInt(e[3], 16)
    } : null;
  }
  const Fae = Object.freeze(Object.defineProperty({
    __proto__: null,
    hexToRgb: Uae,
    rgbToHex: Lae
  }, Symbol.toStringTag, {
    value: "Module"
  })), a0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    PointsManager: Gie,
    ProgressiveIterator: Mh,
    RLEVoxelMap: EI,
    VoxelManager: Zi,
    actorIsA: ea,
    applyPreset: mI,
    cacheUtils: Cre,
    calculateViewportsSpatialRegistration: Uie,
    calibratedPixelSpacingMetadataProvider: iK,
    clamp: t6,
    color: Fae,
    colormap: Sae,
    convertStackToVolumeViewport: Dae,
    convertToGrayscale: Iae,
    convertVolumeToStackViewport: Mae,
    createFloat32SharedArray: fh,
    createInt16SharedArray: WD,
    createLinearRGBTransferFunction: SD,
    createSigmoidRGBTransferFunction: I8,
    createUint16SharedArray: pp,
    createUint8SharedArray: gp,
    decimate: wI,
    deepMerge: zi,
    eventListener: UW,
    generateVolumePropsFromImageIds: O5,
    genericMetadataProvider: Nu,
    getBufferConfiguration: R5,
    getClosestImageId: bp,
    getClosestStackImageIndexForPoint: Rie,
    getCurrentVolumeViewportSlice: Nie,
    getImageLegacy: Kie,
    getImageSliceDataForVolumeViewport: Rp,
    getMinMax: V8,
    getRandomSampleFromArray: DI,
    getRuntimeId: AD,
    getScalarDataType: Hie,
    getScalingParameters: vI,
    getSliceRange: D5,
    getSpacingInNormalDirection: Vu,
    getTargetVolumeAndSpacingInNormalDir: ad,
    getViewportImageCornersInWorld: Fie,
    getViewportImageIds: bI,
    getViewportModality: Bee,
    getViewportsWithImageURI: x6,
    getViewportsWithVolumeId: nI,
    getVoiFromSigmoidRGBTransferFunction: TD,
    getVolumeActorCorners: tI,
    getVolumeId: nf,
    getVolumeSliceRangeInfo: pI,
    getVolumeViewportScrollInfo: mh,
    getVolumeViewportsContainingSameVolumes: Ure,
    hasFloatScalingParameters: CI,
    hasNaNValues: w6,
    imageIdToURI: va,
    imageRetrieveMetadataProvider: Vp,
    imageToWorldCoords: bie,
    indexWithinDimensions: Lre,
    invertRgbTransferFunction: sh,
    isEqual: zr,
    isEqualAbs: sK,
    isEqualNegative: DD,
    isImageActor: fo,
    isOpposite: oK,
    isPTPrescaledWithSUV: sI,
    isValidVolume: Yie,
    isVideoTransferSyntax: Xie,
    loadImageToCanvas: Aie,
    makeVolumeMetadata: xI,
    planar: Nae,
    renderToCanvasCPU: gI,
    renderToCanvasGPU: oI,
    roundNumber: wy,
    roundToPrecision: Oae,
    scaleRgbTransferFunction: Jj,
    snapFocalPointToSlice: Cu,
    sortImageIdsAndGetSpacing: yI,
    spatialRegistrationMetadataProvider: Op,
    transferFunctionUtils: Aae,
    transformIndexToWorld: rI,
    transformWorldToIndex: wl,
    triggerEvent: qe,
    updateVTKImageDataWithCornerstoneImage: M5,
    uuidv4: gi,
    windowLevel: Qj,
    worldToImageCoords: Eie
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class Ba extends Ga {
    constructor(e) {
      super(e), this._useAcquisitionPlaneForViewPlane = false, this.getNumberOfSlices = () => {
        const { numberOfSlices: r } = Rp(this) || {};
        return r;
      }, this.getCurrentImageIdIndex = (r) => {
        const { viewPlaneNormal: i, focalPoint: a } = this.getCamera(), s = this.getImageData(r);
        if (!s) return;
        const { origin: o, direction: l, spacing: c } = s, f = Vu({
          direction: l,
          spacing: c
        }, i), u = He();
        hi(u, a, o);
        const h = Bt(u, i);
        return Math.round(Math.abs(h) / f);
      }, this.getSliceIndex = () => {
        const { imageIndex: r } = Rp(this) || {};
        return r;
      }, this.getCurrentImageId = () => {
        const r = this.getDefaultActor();
        if (!r || !ea(r, "vtkVolume")) return;
        const { uid: i } = r, a = Ke.getVolume(i);
        if (!a) return;
        const { viewPlaneNormal: s, focalPoint: o } = this.getCamera();
        return bp(a, o, s);
      }, this.getSlicePlaneCoordinates = () => {
        const r = this.getDefaultActor();
        if (!(r == null ? void 0 : r.actor)) return console.warn("No image data found for calculating vtkPlanes."), [];
        const i = r.uid, a = Ke.getVolume(i), s = this.getCamera(), { focalPoint: o, position: l, viewPlaneNormal: c } = s, f = Vu(a, c), u = D5(r.actor, c, o), h = Math.round((u.current - u.min) / f), g = Math.round((u.max - u.current) / f), v = this.getSliceIndex(), m = [];
        for (let y = -h; y <= g; y++) {
          const { newFocalPoint: w } = Cu(o, l, u, c, f, y);
          m.push({
            sliceIndex: v + y,
            point: w
          });
        }
        return m;
      };
      const { orientation: n } = this.options;
      if (n && n !== vo.ACQUISITION) {
        this.applyViewOrientation(n);
        return;
      }
      this._useAcquisitionPlaneForViewPlane = true;
    }
    async setVolumes(e, n = false, r = false) {
      const i = Ke.getVolume(e[0].volumeId);
      if (!i) throw new Error(`imageVolume with id: ${i.volumeId} does not exist`);
      return this._useAcquisitionPlaneForViewPlane && (this._setViewPlaneToAcquisitionPlane(i), this._useAcquisitionPlaneForViewPlane = false), super.setVolumes(e, n, r);
    }
    async addVolumes(e, n = false, r = false) {
      const i = Ke.getVolume(e[0].volumeId);
      if (!i) throw new Error(`imageVolume with id: ${i.volumeId} does not exist`);
      return this._useAcquisitionPlaneForViewPlane && (this._setViewPlaneToAcquisitionPlane(i), this._useAcquisitionPlaneForViewPlane = false), super.addVolumes(e, n, r);
    }
    setOrientation(e, n = true) {
      let r, i;
      if (typeof e == "string") {
        if (Al[e]) ({ viewPlaneNormal: r, viewUp: i } = Al[e]);
        else if (e === "acquisition") ({ viewPlaneNormal: r, viewUp: i } = this._getAcquisitionPlaneOrientation());
        else throw new Error(`Invalid orientation: ${e}. Use Enums.OrientationAxis instead.`);
        this.setCamera({
          viewPlaneNormal: r,
          viewUp: i
        }), this.viewportProperties.orientation = e, this.resetCamera();
      } else ({ viewPlaneNormal: r, viewUp: i } = e), this.applyViewOrientation(e);
      n && this.render();
    }
    _getAcquisitionPlaneOrientation() {
      const e = this.getDefaultActor();
      if (!e) return;
      const n = e.uid, r = Ke.getVolume(n);
      if (!r) throw new Error(`imageVolume with id: ${n} does not exist in cache`);
      const { direction: i } = r, a = i.slice(6, 9).map((o) => -o), s = i.slice(3, 6).map((o) => -o);
      return {
        viewPlaneNormal: a,
        viewUp: s
      };
    }
    _setViewPlaneToAcquisitionPlane(e) {
      let n, r;
      if (e) {
        const { direction: i } = e;
        n = i.slice(6, 9).map((a) => -a), r = i.slice(3, 6).map((a) => -a);
      } else ({ viewPlaneNormal: n, viewUp: r } = this._getAcquisitionPlaneOrientation());
      this.setCamera({
        viewPlaneNormal: n,
        viewUp: r
      }), this.initialViewUp = r, this.resetCamera();
    }
    setBlendMode(e, n = [], r = false) {
      let i = this.getActors();
      n && n.length > 0 && (i = i.filter((a) => n.includes(a.uid))), i.forEach((a) => {
        var _a3, _b3;
        const { actor: s } = a;
        (_b3 = (_a3 = s.getMapper()).setBlendMode) == null ? void 0 : _b3.call(_a3, e);
      }), r && this.render();
    }
    resetCamera(e = true, n = true, r = true, i = false, a = false, s = true) {
      const { orientation: o } = this.viewportProperties;
      o && s && this.applyViewOrientation(o, false), super.resetCamera(e, n, r), this.resetVolumeViewportClippingRange();
      const l = this.getVtkActiveCamera(), c = l.getViewPlaneNormal(), f = l.getFocalPoint();
      if (this.getActors().forEach((h) => {
        if (!h.actor) return;
        const g = h.actor.getMapper();
        if (g.getClippingPlanes().length === 0 && !(h == null ? void 0 : h.clippingFilter)) {
          const m = Si.newInstance(), y = Si.newInstance(), w = [
            m,
            y
          ];
          let C = Gi.MINIMUM_SLAB_THICKNESS;
          h.slabThickness && (C = h.slabThickness), this.setOrientationOfClippingPlanes(w, C, c, f), g.addClippingPlane(m), g.addClippingPlane(y);
        }
      }), i && Al[this.viewportProperties.orientation] !== void 0) {
        const h = Al[this.viewportProperties.orientation];
        this.setCameraNoEvent({
          viewUp: h.viewUp,
          viewPlaneNormal: h.viewPlaneNormal
        });
      }
      if (!a) {
        const h = {
          viewportId: this.id,
          camera: this.getCamera(),
          renderingEngineId: this.renderingEngineId,
          element: this.element
        };
        qe(this.element, ze.CAMERA_RESET, h);
      }
      return true;
    }
    setSlabThickness(e, n = []) {
      e < 0.1 && (e = 0.1);
      let r = this.getActors();
      n && n.length > 0 && (r = r.filter((a) => n.includes(a.uid))), r.forEach((a) => {
        ea(a, "vtkVolume") && (a.slabThickness = e);
      });
      const i = this.getCamera();
      this.updateClippingPlanesForActors(i), this.triggerCameraModifiedEventIfNecessary(i, i), this.viewportProperties.slabThickness = e;
    }
    resetSlabThickness() {
      this.getActors().forEach((r) => {
        ea(r, "vtkVolume") && (r.slabThickness = Gi.MINIMUM_SLAB_THICKNESS);
      });
      const n = this.getCamera();
      this.updateClippingPlanesForActors(n), this.triggerCameraModifiedEventIfNecessary(n, n), this.viewportProperties.slabThickness = void 0;
    }
    getViewReference(e = {}) {
      const n = super.getViewReference(e);
      if (!(n == null ? void 0 : n.volumeId)) return;
      const r = Ke.getVolume(n.volumeId);
      return n.referencedImageId = bp(r, n.cameraFocalPoint, n.viewPlaneNormal), n;
    }
    resetProperties(e) {
      this._resetProperties(e);
    }
    _resetProperties(e) {
      const n = e ? this.getActor(e) : this.getDefaultActor();
      if (!n) throw new Error(`No actor found for the given volumeId: ${e}`);
      n.slabThickness && (n.slabThickness = Gi.MINIMUM_SLAB_THICKNESS, this.viewportProperties.slabThickness = void 0, this.updateClippingPlanesForActors(this.getCamera()));
      const r = Ke.getVolume(n.uid);
      if (!r) throw new Error(`imageVolume with id: ${n.uid} does not exist in cache`);
      if (vy(n.actor, r, false), fo(n)) {
        const c = n.actor.getProperty().getRGBTransferFunction(0);
        V5(c, this.initialTransferFunctionNodes);
      }
      const i = {
        ...super.getVOIModifiedEventDetail(e)
      };
      this.resetCamera(true, true, true, true), qe(this.element, ze.VOI_MODIFIED, i);
    }
    getSlicesClippingPlanes() {
      const e = this.getSlicePlaneCoordinates(), { viewPlaneNormal: n } = this.getCamera(), r = Gi.MINIMUM_SLAB_THICKNESS;
      return e.map(({ point: i, sliceIndex: a }) => {
        const s = [
          Si.newInstance(),
          Si.newInstance()
        ];
        return this.setOrientationOfClippingPlanes(s, r, n, i), {
          sliceIndex: a,
          planes: s.map((o) => ({
            normal: o.getNormal(),
            origin: o.getOrigin()
          }))
        };
      });
    }
  }
  function Bae(t, e) {
    e.classHierarchy.push("vtkAbstractImageMapper"), t.getIsOpaque = () => true, t.getCurrentImage = () => null, t.getBoundsForSlice = () => (H.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"), Ll());
  }
  const _ae = {
    slice: 0,
    customDisplayExtent: [
      0,
      0,
      0,
      0,
      0,
      0
    ],
    useCustomExtents: false,
    backgroundColor: [
      0,
      0,
      0,
      1
    ]
  };
  function kae(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, _ae, n), ey.extend(t, e, n), H.setGet(t, e, [
      "slice",
      "useCustomExtents"
    ]), H.setGetArray(t, e, [
      "customDisplayExtent"
    ], 6), H.setGetArray(t, e, [
      "backgroundColor"
    ], 4), Bae(t, e);
  }
  var Pae = {
    extend: kae
  };
  function II(t, e, n) {
    const r = n.getCurrentImage(), i = r.getExtent(), a = [
      i[0],
      i[2],
      i[4]
    ], { ijkMode: s } = n.getClosestIJKAxis();
    let o = n.isA("vtkImageArrayMapper") ? n.getSubSlice() : n.getSlice();
    s !== n.getSlicingMode() && (o = n.getSliceAtPosition(o)), a[s] += o;
    const l = [
      0,
      0,
      0
    ];
    r.indexToWorld(a, l), a[s] += 1;
    const c = [
      0,
      0,
      0
    ];
    r.indexToWorld(a, c), c[0] -= l[0], c[1] -= l[1], c[2] -= l[2], cs(c, c);
    const f = Si.intersectWithLine(t, e, l, c);
    if (f.intersection) {
      const u = f.x, h = [
        0,
        0,
        0
      ];
      return r.worldToIndex(u, h), {
        t: f.t,
        absoluteIJK: h
      };
    }
    return null;
  }
  function Gae(t, e, n) {
    const r = II(t, e, n);
    if (r) {
      const a = n.getCurrentImage().getExtent(), s = [
        Math.round(r.absoluteIJK[0]),
        Math.round(r.absoluteIJK[1]),
        Math.round(r.absoluteIJK[2])
      ];
      return s[0] < a[0] || s[0] > a[1] || s[1] < a[2] || s[1] > a[3] || s[2] < a[4] || s[2] > a[5] ? null : {
        t: r.t,
        ijk: s
      };
    }
    return null;
  }
  function zae(t, e, n) {
    const r = II(t, e, n);
    if (r) {
      const a = n.getCurrentImage().getExtent(), s = r.absoluteIJK, o = [
        Math.floor(s[0]),
        Math.floor(s[1]),
        Math.floor(s[2])
      ];
      if (o[0] < a[0] || o[0] > a[1] - 1 || o[1] < a[2] || o[1] > a[3] - 1 || o[2] < a[4] || o[2] > (a[5] ? a[5] - 1 : a[5])) return null;
      const l = [
        s[0] - o[0],
        s[1] - o[1],
        s[2] - o[2]
      ];
      return {
        t: r.t,
        ijk: o,
        pCoords: l
      };
    }
    return null;
  }
  const { staticOffsetAPI: Wae, otherStaticMethods: Hae } = A5, { SlicingMode: gn } = b5;
  function jae(t, e) {
    e.classHierarchy.push("vtkImageMapper"), t.getSliceAtPosition = (r) => {
      const i = t.getCurrentImage();
      let a;
      if (r.length === 3) a = r;
      else if (Number.isFinite(r)) {
        const f = i.getBounds();
        switch (e.slicingMode) {
          case gn.X:
            a = [
              r,
              (f[3] + f[2]) / 2,
              (f[5] + f[4]) / 2
            ];
            break;
          case gn.Y:
            a = [
              (f[1] + f[0]) / 2,
              r,
              (f[5] + f[4]) / 2
            ];
            break;
          case gn.Z:
            a = [
              (f[1] + f[0]) / 2,
              (f[3] + f[2]) / 2,
              r
            ];
            break;
        }
      }
      const s = [
        0,
        0,
        0
      ];
      i.worldToIndex(a, s);
      const o = i.getExtent(), { ijkMode: l } = t.getClosestIJKAxis();
      let c = 0;
      switch (l) {
        case gn.I:
          c = os(s[0], o[0], o[1]);
          break;
        case gn.J:
          c = os(s[1], o[2], o[3]);
          break;
        case gn.K:
          c = os(s[2], o[4], o[5]);
          break;
        default:
          return 0;
      }
      return c;
    }, t.setSliceFromCamera = (r) => {
      const i = r.getFocalPoint();
      switch (e.slicingMode) {
        case gn.I:
        case gn.J:
        case gn.K:
          {
            const a = t.getSliceAtPosition(i);
            t.setSlice(a);
          }
          break;
        case gn.X:
          t.setSlice(i[0]);
          break;
        case gn.Y:
          t.setSlice(i[1]);
          break;
        case gn.Z:
          t.setSlice(i[2]);
          break;
      }
    }, t.setXSlice = (r) => {
      t.setSlicingMode(gn.X), t.setSlice(r);
    }, t.setYSlice = (r) => {
      t.setSlicingMode(gn.Y), t.setSlice(r);
    }, t.setZSlice = (r) => {
      t.setSlicingMode(gn.Z), t.setSlice(r);
    }, t.setISlice = (r) => {
      t.setSlicingMode(gn.I), t.setSlice(r);
    }, t.setJSlice = (r) => {
      t.setSlicingMode(gn.J), t.setSlice(r);
    }, t.setKSlice = (r) => {
      t.setSlicingMode(gn.K), t.setSlice(r);
    }, t.getSlicingModeNormal = () => {
      const r = [
        0,
        0,
        0
      ], i = t.getCurrentImage().getDirection();
      switch (e.slicingMode) {
        case gn.X:
          r[0] = 1;
          break;
        case gn.Y:
          r[1] = 1;
          break;
        case gn.Z:
          r[2] = 1;
          break;
        case gn.I:
          Og(i, [
            1,
            0,
            0
          ], r);
          break;
        case gn.J:
          Og(i, [
            0,
            1,
            0
          ], r);
          break;
        case gn.K:
          Og(i, [
            0,
            0,
            1
          ], r);
          break;
      }
      return r;
    };
    function n() {
      let r;
      switch (e.slicingMode) {
        case gn.X:
          r = 0;
          break;
        case gn.Y:
          r = 1;
          break;
        case gn.Z:
          r = 2;
          break;
        default:
          e.closestIJKAxis = {
            ijkMode: e.slicingMode,
            flip: false
          };
          return;
      }
      const i = t.getCurrentImage().getDirection(), a = hD(i);
      let s = 0;
      for (; s < 3 && a[r + 3 * s] === 0; ++s) ;
      const o = a[r + 3 * s] < 0;
      e.closestIJKAxis = {
        ijkMode: s,
        flip: o
      };
    }
    t.setSlicingMode = (r) => {
      e.slicingMode !== r && (e.slicingMode = r, t.getCurrentImage() && n(), t.modified());
    }, t.getClosestIJKAxis = () => ((e.closestIJKAxis === void 0 || e.closestIJKAxis.ijkMode === gn.NONE) && t.getCurrentImage() && n(), e.closestIJKAxis), t.getBounds = () => {
      const r = t.getCurrentImage();
      if (!r) return Ll();
      if (!e.useCustomExtents) return r.getBounds();
      const i = e.customDisplayExtent.slice(), { ijkMode: a } = t.getClosestIJKAxis();
      let s = e.slice;
      switch (a !== e.slicingMode && (s = t.getSliceAtPosition(e.slice)), a) {
        case gn.I:
          i[0] = s, i[1] = s;
          break;
        case gn.J:
          i[2] = s, i[3] = s;
          break;
        case gn.K:
          i[4] = s, i[5] = s;
          break;
      }
      return r.extentToBounds(i);
    }, t.getBoundsForSlice = function() {
      let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.slice, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      const a = t.getCurrentImage();
      if (!a) return Ll();
      const s = a.getSpatialExtent(), { ijkMode: o } = t.getClosestIJKAxis();
      let l = r;
      switch (o !== e.slicingMode && (l = t.getSliceAtPosition(r)), o) {
        case gn.I:
          s[0] = l - i, s[1] = l + i;
          break;
        case gn.J:
          s[2] = l - i, s[3] = l + i;
          break;
        case gn.K:
          s[4] = l - i, s[5] = l + i;
          break;
      }
      return a.extentToBounds(s);
    }, t.intersectWithLineForPointPicking = (r, i) => Gae(r, i, t), t.intersectWithLineForCellPicking = (r, i) => zae(r, i, t), t.getCurrentImage = () => t.getInputData();
  }
  const Kae = {
    slicingMode: gn.NONE,
    closestIJKAxis: {
      ijkMode: gn.NONE,
      flip: false
    },
    renderToRectangle: false,
    sliceAtFocalPoint: false,
    preferSizeOverAccuracy: false
  };
  function VI(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Kae, n), Pae.extend(t, e, n), H.get(t, e, [
      "slicingMode"
    ]), H.setGet(t, e, [
      "closestIJKAxis",
      "renderToRectangle",
      "sliceAtFocalPoint",
      "preferSizeOverAccuracy"
    ]), A5.implementCoincidentTopologyMethods(t, e), jae(t, e);
  }
  const Yae = H.newInstance(VI, "vtkImageMapper");
  var qae = {
    newInstance: Yae,
    extend: VI,
    ...Wae,
    ...Hae,
    ...b5
  };
  const { InterpolationType: zg } = FQ, { vtkErrorMacro: hS } = H, Wg = 4;
  function Xae(t, e) {
    e.classHierarchy.push("vtkImageProperty"), t.getMTime = () => {
      let n = e.mtime, r;
      for (let i = 0; i < Wg; i++) e.componentData[i].rGBTransferFunction && (r = e.componentData[i].rGBTransferFunction.getMTime(), n = n > r ? n : r), e.componentData[i].piecewiseFunction && (r = e.componentData[i].piecewiseFunction.getMTime(), n = n > r ? n : r);
      return n;
    }, t.setRGBTransferFunction = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = n, a = r;
      return Number.isInteger(n) || (a = n, i = 0), e.componentData[i].rGBTransferFunction !== a ? (e.componentData[i].rGBTransferFunction = a, t.modified(), true) : false;
    }, t.getRGBTransferFunction = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.componentData[n].rGBTransferFunction;
    }, t.setPiecewiseFunction = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = n, a = r;
      return Number.isInteger(n) || (a = n, i = 0), e.componentData[i].piecewiseFunction !== a ? (e.componentData[i].piecewiseFunction = a, t.modified(), true) : false;
    }, t.getPiecewiseFunction = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return e.componentData[n].piecewiseFunction;
    }, t.setScalarOpacity = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = n, a = r;
      return Number.isInteger(n) || (a = n, i = 0), t.setPiecewiseFunction(i, a);
    }, t.getScalarOpacity = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return t.getPiecewiseFunction(n);
    }, t.setComponentWeight = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      if (n < 0 || n >= Wg) return hS("Invalid index"), false;
      const i = Math.min(1, Math.max(0, r));
      return e.componentData[n].componentWeight !== i ? (e.componentData[n].componentWeight = i, t.modified(), true) : false;
    }, t.getComponentWeight = function() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return n < 0 || n >= Wg ? (hS("Invalid index"), 0) : e.componentData[n].componentWeight;
    }, t.setInterpolationTypeToNearest = () => t.setInterpolationType(zg.NEAREST), t.setInterpolationTypeToLinear = () => t.setInterpolationType(zg.LINEAR), t.getInterpolationTypeAsString = () => H.enumToString(zg, e.interpolationType);
  }
  const Zae = {
    independentComponents: false,
    interpolationType: zg.LINEAR,
    colorWindow: 255,
    colorLevel: 127.5,
    ambient: 1,
    diffuse: 0,
    opacity: 1,
    useLookupTableScalarRange: false,
    useLabelOutline: false,
    labelOutlineThickness: [
      1
    ],
    labelOutlineOpacity: 1
  };
  function Qae(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (Object.assign(e, Zae, n), H.obj(t, e), !e.componentData) {
      e.componentData = [];
      for (let r = 0; r < Wg; r++) e.componentData.push({
        rGBTransferFunction: null,
        piecewiseFunction: null,
        componentWeight: 1
      });
    }
    H.setGet(t, e, [
      "independentComponents",
      "interpolationType",
      "colorWindow",
      "colorLevel",
      "ambient",
      "diffuse",
      "opacity",
      "useLookupTableScalarRange",
      "useLabelOutline",
      "labelOutlineOpacity"
    ]), H.setGetArray(t, e, [
      "labelOutlineThickness"
    ]), Xae(t, e);
  }
  const Jae = H.newInstance(Qae, "vtkImageProperty");
  var $ae = {
    newInstance: Jae
  };
  const { vtkDebugMacro: ese } = H;
  function tse(t, e) {
    e.classHierarchy.push("vtkImageSlice"), t.getActors = () => t, t.getImages = () => t, t.getIsOpaque = () => {
      if (e.forceOpaque) return true;
      if (e.forceTranslucent) return false;
      e.property || t.getProperty();
      let n = e.property.getOpacity() >= 1;
      return n = n && (!e.mapper || e.mapper.getIsOpaque()), n;
    }, t.hasTranslucentPolygonalGeometry = () => false, t.makeProperty = $ae.newInstance, t.getProperty = () => (e.property === null && (e.property = t.makeProperty()), e.property), t.getBounds = () => {
      if (e.mapper === null) return e.bounds;
      const n = e.mapper.getBounds();
      if (!n || n.length !== 6) return n;
      if (n[0] > n[1]) return e.mapperBounds = n.concat(), e.bounds = [
        1,
        -1,
        1,
        -1,
        1,
        -1
      ], e.boundsMTime.modified(), n;
      const r = (i) => i[0].map((a, s) => i.map((o) => o[s]));
      if (!e.mapperBounds || !r([
        n,
        e.mapperBounds
      ]).reduce((i, a) => i && a[0] === a[1], true) || t.getMTime() > e.boundsMTime.getMTime()) {
        ese("Recomputing bounds..."), e.mapperBounds = n.map((a) => a), t.computeMatrix();
        const i = new Float64Array(16);
        en(i, e.matrix), En.transformBounds(n, i, e.bounds), e.boundsMTime.modified();
      }
      return e.bounds;
    }, t.getBoundsForSlice = (n, r) => {
      const i = e.mapper.getBoundsForSlice(n, r);
      if (!En.isValid(i)) return i;
      t.computeMatrix();
      const a = new Float64Array(16);
      return en(a, e.matrix), En.transformBounds(i, a);
    }, t.getMinXBound = () => t.getBounds()[0], t.getMaxXBound = () => t.getBounds()[1], t.getMinYBound = () => t.getBounds()[2], t.getMaxYBound = () => t.getBounds()[3], t.getMinZBound = () => t.getBounds()[4], t.getMaxZBound = () => t.getBounds()[5], t.getMTime = () => {
      let n = e.mtime;
      if (e.property !== null) {
        const r = e.property.getMTime();
        n = r > n ? r : n;
      }
      return n;
    }, t.getRedrawMTime = () => {
      let n = e.mtime;
      if (e.mapper !== null) {
        let r = e.mapper.getMTime();
        n = r > n ? r : n, e.mapper.getInput() !== null && (e.mapper.getInputAlgorithm().update(), r = e.mapper.getInput().getMTime(), n = r > n ? r : n);
      }
      if (e.property !== null) {
        let r = e.property.getMTime();
        n = r > n ? r : n, e.property.getRGBTransferFunction() !== null && (r = e.property.getRGBTransferFunction().getMTime(), n = r > n ? r : n);
      }
      return n;
    }, t.getSupportsSelection = () => e.mapper ? e.mapper.getSupportsSelection() : false;
  }
  const nse = {
    mapper: null,
    property: null,
    bounds: [
      ...En.INIT_BOUNDS
    ]
  };
  function NI(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, nse, n), oy.extend(t, e, n), e.boundsMTime = {}, H.obj(e.boundsMTime), H.set(t, e, [
      "property"
    ]), H.setGet(t, e, [
      "mapper"
    ]), H.getArray(t, e, [
      "bounds"
    ], 6), tse(t, e);
  }
  const rse = H.newInstance(NI, "vtkImageSlice");
  var ise = {
    newInstance: rse,
    extend: NI
  };
  function LI(t) {
    return bh(t);
  }
  function Y2(t, e) {
    const n = LI(t);
    return n.invert(), n.transformPoint(e);
  }
  function dS(t, e) {
    return LI(t).transformPoint(e);
  }
  function ase(t) {
    const { image: e } = t;
    t.viewport.scale = hy(t.canvas, e, t.viewport.rotation).scaleFactor, t.viewport.translation.x = 0, t.viewport.translation.y = 0;
  }
  function sse(t) {
    const { canvas: e } = t, { clientWidth: n, clientHeight: r } = e;
    (e.width !== n || e.height !== r) && (e.width = n, e.height = r);
  }
  function ose(t, e, n) {
    const r = t.viewport.scale, i = lI(t.image, t.viewport.rotation), a = Math.round(i.width * r), s = Math.round(i.height * r), o = t.viewport.translation.x, l = t.viewport.translation.y;
    return a === e && s <= n || a <= e && s === n && o === 0 && l === 0;
  }
  function lse(t, e, n) {
    const r = t.viewport.scale, i = t.canvas.width, a = t.canvas.height, s = i / e, o = a / n, l = Math.sqrt(s * o);
    t.viewport.scale = l * r;
  }
  function cse(t, e = false) {
    const n = t.canvas.width, r = t.canvas.height;
    sse(t), t.image !== void 0 && (e || ose(t, n, r) ? ase(t) : lse(t, n, r));
  }
  const gS = [
    {
      id: "initialImages",
      retrieveType: "single"
    },
    {
      id: "errorRetrieve"
    }
  ], use = [
    {
      id: "lossySequential",
      retrieveType: "singleFast"
    },
    {
      id: "finalSequential",
      retrieveType: "singleFinal"
    }
  ], J4 = [
    {
      offset: -1,
      imageQualityStatus: Fc.ADJACENT_REPLICATE
    },
    {
      offset: 1,
      imageQualityStatus: Fc.ADJACENT_REPLICATE
    },
    {
      offset: 2,
      imageQualityStatus: Fc.FAR_REPLICATE
    }
  ], fse = [
    {
      id: "initialImages",
      positions: [
        0.5,
        0,
        -1
      ],
      retrieveType: "default",
      requestType: ar.Thumbnail,
      priority: 5,
      nearbyFrames: J4
    },
    {
      id: "quarterThumb",
      decimate: 4,
      offset: 3,
      requestType: ar.Thumbnail,
      retrieveType: "multipleFast",
      priority: 6,
      nearbyFrames: J4
    },
    {
      id: "halfThumb",
      decimate: 4,
      offset: 1,
      priority: 7,
      requestType: ar.Thumbnail,
      retrieveType: "multipleFast",
      nearbyFrames: J4
    },
    {
      id: "quarterFull",
      decimate: 4,
      offset: 2,
      priority: 8,
      requestType: ar.Thumbnail,
      retrieveType: "multipleFinal"
    },
    {
      id: "halfFull",
      decimate: 4,
      offset: 0,
      priority: 9,
      requestType: ar.Thumbnail,
      retrieveType: "multipleFinal"
    },
    {
      id: "threeQuarterFull",
      decimate: 4,
      offset: 1,
      priority: 10,
      requestType: ar.Thumbnail,
      retrieveType: "multipleFinal"
    },
    {
      id: "finalFull",
      decimate: 4,
      offset: 3,
      priority: 11,
      requestType: ar.Thumbnail,
      retrieveType: "multipleFinal"
    },
    {
      id: "errorRetrieve"
    }
  ];
  function hse(t, e, n, r, i) {
    var _a3;
    if (!((_a3 = n == null ? void 0 : n.nearbyRequests) == null ? void 0 : _a3.length)) return;
    const { arrayBuffer: a, offset: s, type: o, length: l } = i.targetBuffer;
    if (!a || s === void 0 || !o) return;
    const c = new Float32Array(a), f = c.byteLength / c.length, u = i.targetBuffer.offset / f, h = c.slice(u, u + l);
    for (const g of n.nearbyRequests) try {
      const { itemId: v, imageQualityStatus: m } = g, y = e.get(v);
      if (y !== void 0 && y >= m) continue;
      const w = t.getLoaderImageOptions(v), { offset: C } = w.targetBuffer;
      c.set(h, C / f);
      const T = {
        ...r,
        imageQualityStatus: m
      };
      t.successCallback(v, T), e.set(v, m);
    } catch (v) {
      console.log("Couldn't fill nearby item ", g.itemId, v);
    }
  }
  const _dse = class _dse {
    constructor(e) {
      this.stages = e.stages || gS, this.retrieveOptions = e.retrieveOptions || {};
    }
    loadImages(e, n) {
      return new gse(this, e, n).loadImages();
    }
  };
  _dse.createProgressive = UI;
  _dse.interleavedRetrieveStages = {
    stages: fse
  };
  _dse.singleRetrieveStages = {
    stages: gS
  };
  _dse.sequentialRetrieveStages = {
    stages: use
  };
  let dse = _dse;
  class gse {
    constructor(e, n, r) {
      this.outstandingRequests = 0, this.stageStatusMap = /* @__PURE__ */ new Map(), this.imageQualityStatusMap = /* @__PURE__ */ new Map(), this.displayedIterator = new Mh("displayed"), this.stages = e.stages, this.retrieveOptions = e.retrieveOptions, this.imageIds = n, this.listener = r;
    }
    async loadImages() {
      const e = this.createStageRequests();
      this.outstandingRequests = e.length;
      for (const n of e) this.addRequest(n);
      return this.outstandingRequests === 0 ? Promise.resolve(null) : this.displayedIterator.getDonePromise();
    }
    sendRequest(e, n) {
      const { imageId: r, next: i } = e, a = (f, u) => {
        this.listener.errorCallback(r, l || !i, f), u && this.updateStageStatus(e.stage, f);
      }, s = (n.loader || Eh)(r, n), o = Mh.as(s);
      let l = false;
      return o.forEach(async (f, u) => {
        const h = this.imageQualityStatusMap.get(r);
        if (!f) {
          console.warn("No image retrieved", r);
          return;
        }
        const { imageQualityStatus: g } = f;
        if (l || (l = g === Fc.FULL_RESOLUTION), h !== void 0 && h > g) {
          this.updateStageStatus(e.stage, null, true);
          return;
        }
        this.listener.successCallback(r, f), this.imageQualityStatusMap.set(r, g), this.displayedIterator.add(f), u && this.updateStageStatus(e.stage), hse(this.listener, this.imageQualityStatusMap, e, f, n);
      }, a).finally(() => {
        if (!l && i) Ke.getImageLoadObject(r) && Ke.removeImageLoadObject(r), this.addRequest(i, n.streamingData);
        else {
          l || this.listener.errorCallback(r, true, "Couldn't decode"), this.outstandingRequests--;
          for (let f = i; f; f = f.next) this.updateStageStatus(f.stage, null, true);
        }
        this.outstandingRequests <= 0 && this.displayedIterator.resolve();
      }), o.getDonePromise().catch((f) => null);
    }
    addRequest(e, n = {}) {
      const { imageId: r, stage: i } = e, a = this.listener.getLoaderImageOptions(r);
      if (!a) return;
      const { retrieveType: s = "default" } = i, { retrieveOptions: o } = this, l = o[s] || o.default, c = {
        ...a,
        retrieveType: s,
        retrieveOptions: l,
        streamingData: n
      }, f = i.priority ?? -5, u = i.requestType || ar.Interaction, h = {
        imageId: r
      };
      i0.addRequest(this.sendRequest.bind(this, e, c), u, h, f);
    }
    updateStageStatus(e, n, r = false) {
      const { id: i } = e, a = this.stageStatusMap.get(i);
      if (a && (a.imageLoadPendingCount--, n ? a.imageLoadFailedCount++ : r || a.totalImageCount++, !r && !a.stageStartTime && (a.stageStartTime = Date.now()), !a.imageLoadPendingCount)) {
        const { imageLoadFailedCount: s, totalImageCount: o, stageStartTime: l = Date.now(), startTime: c } = a, f = {
          stageId: i,
          numberOfFailures: s,
          numberOfImages: o,
          stageDurationInMS: l ? Date.now() - l : null,
          startDurationInMS: Date.now() - c
        };
        qe(je, ze.IMAGE_RETRIEVAL_STAGE, f), this.stageStatusMap.delete(i);
      }
    }
    createStageRequests() {
      const e = new Array(), n = /* @__PURE__ */ new Map(), r = (i, a) => {
        const s = a < 0 ? this.imageIds.length + a : a < 1 ? Math.floor((this.imageIds.length - 1) * a) : a, o = this.imageIds[s];
        if (!o) throw new Error(`No value found to add to requests at ${a}`);
        const l = {
          imageId: o,
          stage: i,
          nearbyRequests: this.findNearbyRequests(s, i)
        };
        this.addStageStatus(i);
        const c = n.get(o);
        c ? c.next = l : e.push(l), n.set(o, l);
      };
      for (const i of this.stages) (i.positions || wI(this.imageIds, i.decimate || 1, i.offset ?? 0)).forEach((s) => r(i, s));
      return e;
    }
    findNearbyRequests(e, n) {
      const r = new Array();
      if (!n.nearbyFrames) return r;
      for (const i of n.nearbyFrames) {
        const a = e + i.offset;
        a < 0 || a >= this.imageIds.length || r.push({
          itemId: this.imageIds[a],
          imageQualityStatus: i.imageQualityStatus
        });
      }
      return r;
    }
    addStageStatus(e) {
      const { id: n } = e, r = this.stageStatusMap.get(n) || {
        stageId: n,
        startTime: Date.now(),
        stageStartTime: null,
        totalImageCount: 0,
        imageLoadFailedCount: 0,
        imageLoadPendingCount: 0
      };
      return r.imageLoadPendingCount++, this.stageStatusMap.set(n, r), r;
    }
  }
  function UI(t) {
    return new dse(t);
  }
  function pse(t, e) {
    const { hflip: n, vflip: r, rotation: i } = e;
    if (t.x *= n ? -1 : 1, t.y *= r ? -1 : 1, i !== 0) {
      const a = i * Math.PI / 180, s = Math.cos(a), o = Math.sin(a), l = t.x * s - t.y * o, c = t.x * o + t.y * s;
      t.x = l, t.y = c;
    }
    return t;
  }
  function mse(t, e = true, n = true) {
    const { canvas: r, image: i, viewport: a } = t, s = hy(r, i, 0).scaleFactor;
    a.vflip = false, a.hflip = false, e && (a.translation.x = 0, a.translation.y = 0), n && (a.displayedArea.tlhc.x = 1, a.displayedArea.tlhc.y = 1, a.displayedArea.brhc.x = i.columns, a.displayedArea.brhc.y = i.rows, a.scale = s);
  }
  const vse = 1;
  class bo extends af {
    constructor(e) {
      super(e), this.imagesLoader = this, this.perImageIdDefaultProperties = /* @__PURE__ */ new Map(), this.voiUpdatedWithSetProperties = false, this.invert = false, this.initialInvert = false, this.initialTransferFunctionNodes = null, this.stackInvalidated = false, this._publishCalibratedEvent = false, this.useNativeDataType = false, this.updateRenderingPipeline = () => {
        this._configureRenderingPipeline();
      }, this.resize = () => {
        this.useCPURendering && this._resizeCPU();
      }, this._resizeCPU = () => {
        this._cpuFallbackEnabledElement.viewport && cse(this._cpuFallbackEnabledElement);
      }, this.getFrameOfReferenceUID = (n) => {
        var _a3;
        return (_a3 = this.getImagePlaneReferenceData(n)) == null ? void 0 : _a3.FrameOfReferenceUID;
      }, this.getCornerstoneImage = () => this.csImage, this.createActorMapper = (n) => {
        const r = qae.newInstance();
        r.setInputData(n);
        const i = ise.newInstance();
        i.setMapper(r);
        const { preferSizeOverAccuracy: a } = Do().rendering;
        return a && r.setPreferSizeOverAccuracy(true), n.getPointData().getNumberOfComponents() > 1 && i.getProperty().setIndependentComponents(false), i;
      }, this.getNumberOfSlices = () => this.imageIds.length, this.getDefaultProperties = (n) => {
        let r;
        return n !== void 0 && (r = this.perImageIdDefaultProperties.get(n)), r !== void 0 ? r : {
          ...this.globalDefaultProperties,
          rotation: this.getRotation()
        };
      }, this.getProperties = () => {
        const { colormap: n, voiRange: r, VOILUTFunction: i, interpolationType: a, invert: s, voiUpdatedWithSetProperties: o } = this, l = this.getRotation();
        return {
          colormap: n,
          voiRange: r,
          VOILUTFunction: i,
          interpolationType: a,
          invert: s,
          rotation: l,
          isComputedVOI: !o
        };
      }, this.getRotationCPU = () => {
        const { viewport: n } = this._cpuFallbackEnabledElement;
        return n.rotation;
      }, this.getRotationGPU = () => {
        const { viewUp: n, viewPlaneNormal: r, flipVertical: i } = this.getCamera(), a = i ? Rl(He(), this.initialViewUp) : this.initialViewUp, s = th(a, n) * 180 / Math.PI, o = Vr(He(), a, n);
        return Bt(o, r) >= 0 ? s : (360 - s) % 360;
      }, this.setRotation = (n) => {
        const r = this.getCamera();
        if (this.useCPURendering ? this.setRotationCPU(n) : this.setRotationGPU(n), this._suppressCameraModifiedEvents) return;
        const i = this.getCamera(), a = {
          previousCamera: r,
          camera: i,
          element: this.element,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId,
          rotation: n
        };
        qe(this.element, ze.CAMERA_MODIFIED, a);
      }, this.renderImageObject = (n) => {
        this._setCSImage(n), (this.useCPURendering ? this._updateToDisplayImageCPU : this._updateActorToDisplayImageId).call(this, n);
      }, this._setCSImage = (n) => {
        var _a3;
        n.isPreScaled = (_a3 = n.preScale) == null ? void 0 : _a3.scaled, this.csImage = n;
      }, this.canvasToWorldCPU = (n, r = [
        0,
        0,
        0
      ]) => {
        if (!this._cpuFallbackEnabledElement.image) return;
        const [i, a] = Y2(this._cpuFallbackEnabledElement, n), { origin: s, spacing: o, direction: l } = this.getImageData(), c = l.slice(0, 3), f = l.slice(3, 6);
        return Xr(r, s, c, i * o[0]), Xr(r, r, f, a * o[1]), r;
      }, this.worldToCanvasCPU = (n) => {
        const { spacing: r, direction: i, origin: a } = this.getImageData(), s = i.slice(0, 3), o = i.slice(3, 6), l = Ft(He(), n, a), c = [
          Bt(l, s) / r[0],
          Bt(l, o) / r[1]
        ];
        return dS(this._cpuFallbackEnabledElement, c);
      }, this.canvasToWorldGPU = (n) => {
        const r = this.getRenderer(), i = this.getVtkActiveCamera(), a = i.getClippingRange(), s = i.getDistance();
        i.setClippingRange(s, s + 0.1);
        const l = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), c = l.getSize(), f = window.devicePixelRatio || 1, u = [
          n[0] * f,
          n[1] * f
        ], h = [
          u[0] + this.sx,
          u[1] + this.sy
        ];
        h[1] = c[1] - h[1];
        const g = l.displayToWorld(h[0], h[1], 0, r);
        return i.setClippingRange(a[0], a[1]), [
          g[0],
          g[1],
          g[2]
        ];
      }, this.worldToCanvasGPU = (n) => {
        const r = this.getRenderer(), i = this.getVtkActiveCamera(), a = i.getClippingRange(), s = i.getDistance();
        i.setClippingRange(s, s + 0.1);
        const l = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), c = l.getSize(), f = l.worldToDisplay(...n, r);
        f[1] = c[1] - f[1];
        const u = [
          f[0] - this.sx,
          f[1] - this.sy
        ];
        i.setClippingRange(a[0], a[1]);
        const h = window.devicePixelRatio || 1;
        return [
          u[0] / h,
          u[1] / h
        ];
      }, this.getCurrentImageIdIndex = () => this.currentImageIdIndex, this.getSliceIndex = () => this.currentImageIdIndex, this.getTargetImageIdIndex = () => this.targetImageIdIndex, this.getImageIds = () => this.imageIds, this.getCurrentImageId = () => this.imageIds[this.currentImageIdIndex], this.hasImageId = (n) => this.imageIds.includes(n), this.hasImageURI = (n) => {
        const r = this.imageIds;
        for (let i = 0; i < r.length; i++) if (va(r[i]) === n) return true;
        return false;
      }, this.customRenderViewportToCanvas = () => {
        if (!this.useCPURendering) throw new Error("Custom cpu rendering pipeline should only be hit in CPU rendering mode");
        return this._cpuFallbackEnabledElement.image ? (dI(this._cpuFallbackEnabledElement, this.cpuRenderingInvalidated), this.cpuRenderingInvalidated = false) : this.fillWithBackgroundColor(), {
          canvas: this.canvas,
          element: this.element,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId,
          viewportStatus: this.viewportStatus
        };
      }, this.renderingPipelineFunctions = {
        getImageData: {
          cpu: this.getImageDataCPU,
          gpu: this.getImageDataGPU
        },
        setColormap: {
          cpu: this.setColormapCPU,
          gpu: this.setColormapGPU
        },
        getCamera: {
          cpu: this.getCameraCPU,
          gpu: super.getCamera
        },
        setCamera: {
          cpu: this.setCameraCPU,
          gpu: super.setCamera
        },
        getPan: {
          cpu: this.getPanCPU,
          gpu: super.getPan
        },
        setPan: {
          cpu: this.setPanCPU,
          gpu: super.setPan
        },
        getZoom: {
          cpu: this.getZoomCPU,
          gpu: super.getZoom
        },
        setZoom: {
          cpu: this.setZoomCPU,
          gpu: super.setZoom
        },
        setVOI: {
          cpu: this.setVOICPU,
          gpu: this.setVOIGPU
        },
        getRotation: {
          cpu: this.getRotationCPU,
          gpu: this.getRotationGPU
        },
        setInterpolationType: {
          cpu: this.setInterpolationTypeCPU,
          gpu: this.setInterpolationTypeGPU
        },
        setInvertColor: {
          cpu: this.setInvertColorCPU,
          gpu: this.setInvertColorGPU
        },
        resetCamera: {
          cpu: (n = true, r = true) => (this.resetCameraCPU(n, r), true),
          gpu: (n = true, r = true) => (this.resetCameraGPU(n, r), true)
        },
        canvasToWorld: {
          cpu: this.canvasToWorldCPU,
          gpu: this.canvasToWorldGPU
        },
        worldToCanvas: {
          cpu: this.worldToCanvasCPU,
          gpu: this.worldToCanvasGPU
        },
        getRenderer: {
          cpu: () => this.getCPUFallbackError("getRenderer"),
          gpu: super.getRenderer
        },
        getDefaultActor: {
          cpu: () => this.getCPUFallbackError("getDefaultActor"),
          gpu: super.getDefaultActor
        },
        getActors: {
          cpu: () => this.getCPUFallbackError("getActors"),
          gpu: super.getActors
        },
        getActor: {
          cpu: () => this.getCPUFallbackError("getActor"),
          gpu: super.getActor
        },
        setActors: {
          cpu: () => this.getCPUFallbackError("setActors"),
          gpu: super.setActors
        },
        addActors: {
          cpu: () => this.getCPUFallbackError("addActors"),
          gpu: super.addActors
        },
        addActor: {
          cpu: () => this.getCPUFallbackError("addActor"),
          gpu: super.addActor
        },
        removeAllActors: {
          cpu: () => this.getCPUFallbackError("removeAllActors"),
          gpu: super.removeAllActors
        },
        unsetColormap: {
          cpu: this.unsetColormapCPU,
          gpu: this.unsetColormapGPU
        }
      }, this.scaling = {}, this.modality = null, this.useCPURendering = uh(), this.useNativeDataType = this._shouldUseNativeDataType(), this._configureRenderingPipeline(), this.useCPURendering ? this._resetCPUFallbackElement() : this._resetGPUViewport(), this.imageIds = [], this.currentImageIdIndex = 0, this.targetImageIdIndex = 0, this.cameraFocalPointOnRender = [
        0,
        0,
        0
      ], this.resetCamera(), this.initializeElementDisabledHandler();
    }
    setUseCPURendering(e) {
      this.useCPURendering = e, this._configureRenderingPipeline(e);
    }
    static get useCustomRenderingPipeline() {
      return uh();
    }
    _configureRenderingPipeline(e) {
      this.useNativeDataType = this._shouldUseNativeDataType(), this.useCPURendering = e ?? uh();
      for (const [n, r] of Object.entries(this.renderingPipelineFunctions)) this[n] = this.useCPURendering ? r.cpu : r.gpu;
      this.useCPURendering ? this._resetCPUFallbackElement() : this._resetGPUViewport();
    }
    _resetCPUFallbackElement() {
      this._cpuFallbackEnabledElement = {
        canvas: this.canvas,
        renderingTools: {},
        transform: new rf(),
        viewport: {
          rotation: 0
        }
      };
    }
    _resetGPUViewport() {
      const e = this.getRenderer(), n = iy.newInstance();
      e.setActiveCamera(n), this.initialViewUp = [
        0,
        -1,
        0
      ], n.setDirectionOfProjection(-0, -0, 1), n.setViewUp(...this.initialViewUp), n.setParallelProjection(true), n.setThicknessFromFocalPoint(0.1), n.setFreezeFocalPoint(true);
    }
    initializeElementDisabledHandler() {
      je.addEventListener(ze.ELEMENT_DISABLED, function e() {
        clearTimeout(this.debouncedTimeout), je.removeEventListener(ze.ELEMENT_DISABLED, e);
      });
    }
    getImageDataGPU() {
      const e = this.getDefaultActor();
      if (!e || !fo(e)) return;
      const { actor: n } = e, r = n.getMapper().getInputData();
      return {
        dimensions: r.getDimensions(),
        spacing: r.getSpacing(),
        origin: r.getOrigin(),
        direction: r.getDirection(),
        scalarData: r.getPointData().getScalars().getData(),
        imageData: n.getMapper().getInputData(),
        metadata: {
          Modality: this.modality
        },
        scaling: this.scaling,
        hasPixelSpacing: this.hasPixelSpacing,
        calibration: {
          ...this.csImage.calibration,
          ...this.calibration
        },
        preScale: {
          ...this.csImage.preScale
        }
      };
    }
    getImageDataCPU() {
      const { metadata: e } = this._cpuFallbackEnabledElement, n = e.spacing;
      return {
        dimensions: e.dimensions,
        spacing: n,
        origin: e.origin,
        direction: e.direction,
        metadata: {
          Modality: this.modality
        },
        scaling: this.scaling,
        imageData: {
          getDirection: () => e.direction,
          getDimensions: () => e.dimensions,
          getScalarData: () => this.cpuImagePixelData,
          getSpacing: () => n,
          worldToIndex: (r) => {
            const i = this.worldToCanvasCPU(r), a = Y2(this._cpuFallbackEnabledElement, i);
            return [
              a[0],
              a[1],
              0
            ];
          },
          indexToWorld: (r, i) => {
            const a = dS(this._cpuFallbackEnabledElement, [
              r[0],
              r[1]
            ]);
            return this.canvasToWorldCPU(a, i);
          }
        },
        scalarData: this.cpuImagePixelData,
        hasPixelSpacing: this.hasPixelSpacing,
        calibration: {
          ...this.csImage.calibration,
          ...this.calibration
        },
        preScale: {
          ...this.csImage.preScale
        }
      };
    }
    buildMetadata(e) {
      const n = e.imageId, { pixelRepresentation: r, bitsAllocated: i, bitsStored: a, highBit: s, photometricInterpretation: o, samplesPerPixel: l } = Ct("imagePixelModule", n), { windowWidth: c, windowCenter: f, voiLUTFunction: u } = e, { modality: h } = Ct("generalSeriesModule", n), g = Ct("scalingModule", n), v = Ct(ma.CALIBRATION, n);
      h === "PT" && g && this._addScalingToViewport(g), this.modality = h;
      const m = this._getValidVOILUTFunction(u);
      this.VOILUTFunction = m, this.calibration = v;
      let y = this._getImagePlaneModule(n);
      return this.useCPURendering || (y = this.calibrateIfNecessary(n, y)), {
        imagePlaneModule: y,
        imagePixelModule: {
          bitsAllocated: i,
          bitsStored: a,
          samplesPerPixel: l,
          highBit: s,
          photometricInterpretation: o,
          pixelRepresentation: r,
          windowWidth: c,
          windowCenter: f,
          modality: h,
          voiLUTFunction: m
        }
      };
    }
    calibrateIfNecessary(e, n) {
      const r = Ct("calibratedPixelSpacing", e), i = this.calibration !== r, { scale: a } = r || {};
      return this.hasPixelSpacing = a > 0 || n.rowPixelSpacing > 0, n.calibration = r, i && (this.calibration = r, this._publishCalibratedEvent = true, this._calibrationEvent = {
        scale: a,
        calibration: r
      }), n;
    }
    setDefaultProperties(e, n) {
      n == null ? this.globalDefaultProperties = e : (this.perImageIdDefaultProperties.set(n, e), this.getCurrentImageId() === n && this.setProperties(e));
    }
    clearDefaultProperties(e) {
      e == null ? (this.globalDefaultProperties = {}, this.resetProperties()) : (this.perImageIdDefaultProperties.delete(e), this.resetToDefaultProperties());
    }
    setProperties({ colormap: e, voiRange: n, VOILUTFunction: r, invert: i, interpolationType: a, rotation: s } = {}, o = false) {
      this.viewportStatus = this.csImage ? Bi.PRE_RENDER : Bi.LOADING, this.globalDefaultProperties == null && this.setDefaultProperties({
        colormap: e,
        voiRange: n,
        VOILUTFunction: r,
        invert: i,
        interpolationType: a,
        rotation: s
      }), typeof e < "u" && this.setColormap(e), typeof n < "u" && this.setVOI(n, {
        suppressEvents: o,
        voiUpdatedWithSetProperties: true
      }), typeof r < "u" && this.setVOILUTFunction(r, o), typeof i < "u" && this.setInvertColor(i), typeof a < "u" && this.setInterpolationType(a), typeof s < "u" && this.getRotation() !== s && this.setRotation(s);
    }
    resetProperties() {
      this.cpuRenderingInvalidated = true, this.voiUpdatedWithSetProperties = false, this.viewportStatus = Bi.PRE_RENDER, this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {}), this._resetProperties(), this.render();
    }
    _resetProperties() {
      let e;
      this._isCurrentImagePTPrescaled() ? e = this._getDefaultPTPrescaledVOIRange() : e = this._getVOIRangeForCurrentImage(), this.setVOI(e), this.setInvertColor(this.initialInvert), this.setInterpolationType(ho.LINEAR), this.getRotation() !== 0 && this.setRotation(0);
      const n = this.getTransferFunction();
      V5(n, this.initialTransferFunctionNodes);
      const i = Lp(n).reduce((o, l) => (o.push(l[0], l[1], l[2], l[3]), o), []), a = this.getDefaultActor(), s = xy(i, a.actor);
      this.setColormap(s);
    }
    resetToDefaultProperties() {
      var _a3;
      this.cpuRenderingInvalidated = true, this.viewportStatus = Bi.PRE_RENDER, this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {});
      const e = this.getCurrentImageId(), n = this.perImageIdDefaultProperties.get(e) || this.globalDefaultProperties;
      ((_a3 = n.colormap) == null ? void 0 : _a3.name) && this.setColormap(n.colormap);
      let r;
      n.voiRange == null ? r = this._getVOIRangeForCurrentImage() : r = n.voiRange, this.setVOI(r), this.getRotation() !== 0 && this.setRotation(0), this.setInterpolationType(ho.LINEAR), this.setInvertColor(false), this.render();
    }
    _setPropertiesFromCache() {
      const { interpolationType: e, invert: n } = this;
      let r;
      this.voiUpdatedWithSetProperties ? r = this.voiRange : this._isCurrentImagePTPrescaled() ? r = this._getDefaultPTPrescaledVOIRange() : r = this._getVOIRangeForCurrentImage() ?? this.voiRange, this.setVOI(r), this.setInterpolationType(e), this.setInvertColor(n);
    }
    getCameraCPU() {
      const { metadata: e, viewport: n } = this._cpuFallbackEnabledElement, { direction: r } = e, i = r.slice(6, 9).map((u) => -u);
      let a = r.slice(3, 6).map((u) => -u);
      if (n.rotation) {
        const u = DE(Yt(), n.rotation * Math.PI / 180, i);
        a = M_(He(), a, u);
      }
      const s = [
        this.element.clientWidth / 2,
        this.element.clientHeight / 2
      ], o = this.canvasToWorld(s), l = this.canvasToWorld([
        0,
        0
      ]), c = this.canvasToWorld([
        0,
        this.element.clientHeight
      ]), f = Mu(l, c) / 2;
      return {
        parallelProjection: true,
        focalPoint: o,
        position: [
          0,
          0,
          0
        ],
        parallelScale: f,
        scale: n.scale,
        viewPlaneNormal: [
          i[0],
          i[1],
          i[2]
        ],
        viewUp: [
          a[0],
          a[1],
          a[2]
        ],
        flipHorizontal: this.flipHorizontal,
        flipVertical: this.flipVertical
      };
    }
    setCameraCPU(e) {
      const { viewport: n, image: r } = this._cpuFallbackEnabledElement, i = this.getCameraCPU(), { focalPoint: a, parallelScale: s, scale: o, flipHorizontal: l, flipVertical: c } = e, { clientHeight: f } = this.element;
      if (a) {
        const h = this.worldToCanvasCPU(a), g = Y2(this._cpuFallbackEnabledElement, h), v = this.worldToCanvasCPU(i.focalPoint), m = Y2(this._cpuFallbackEnabledElement, v), y = mo();
        Ru(y, $g(g[0], g[1]), $g(m[0], m[1]));
        const w = pse({
          x: y[0],
          y: y[1]
        }, n);
        n.translation.x -= w.x, n.translation.y -= w.y;
      }
      if (s) {
        const { rowPixelSpacing: h } = r, g = f * h * 0.5 / s;
        n.scale = g, n.parallelScale = s;
      }
      if (o) {
        const { rowPixelSpacing: h } = r;
        n.scale = o, n.parallelScale = f * h * 0.5 / o;
      }
      (l !== void 0 || c !== void 0) && this.setFlipCPU({
        flipHorizontal: l,
        flipVertical: c
      }), this._cpuFallbackEnabledElement.transform = bh(this._cpuFallbackEnabledElement);
      const u = {
        previousCamera: i,
        camera: this.getCamera(),
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId,
        rotation: this.getRotation()
      };
      qe(this.element, ze.CAMERA_MODIFIED, u);
    }
    getPanCPU() {
      const { viewport: e } = this._cpuFallbackEnabledElement;
      return [
        e.translation.x,
        e.translation.y
      ];
    }
    setPanCPU(e) {
      const n = this.getCameraCPU();
      this.setCameraCPU({
        ...n,
        focalPoint: [
          ...e.map((r) => -r),
          0
        ]
      });
    }
    getZoomCPU() {
      const { viewport: e } = this._cpuFallbackEnabledElement;
      return e.scale;
    }
    setZoomCPU(e) {
      const n = this.getCameraCPU();
      this.setCameraCPU({
        ...n,
        scale: e
      });
    }
    setFlipCPU({ flipHorizontal: e, flipVertical: n }) {
      const { viewport: r } = this._cpuFallbackEnabledElement;
      e !== void 0 && (r.hflip = e, this.flipHorizontal = r.hflip), n !== void 0 && (r.vflip = n, this.flipVertical = r.vflip);
    }
    setVOILUTFunction(e, n) {
      if (this.useCPURendering) throw new Error("VOI LUT function is not supported in CPU rendering");
      const r = this._getValidVOILUTFunction(e);
      let i = false;
      this.VOILUTFunction !== r && (i = true), this.VOILUTFunction = r;
      const { voiRange: a } = this.getProperties();
      this.setVOI(a, {
        suppressEvents: n,
        forceRecreateLUTFunction: i
      });
    }
    setRotationCPU(e) {
      const { viewport: n } = this._cpuFallbackEnabledElement;
      n.rotation = e;
    }
    setRotationGPU(e) {
      const n = this.getPan(this.fitToCanvasCamera), r = this.getPan(), i = ep([
        0,
        0
      ], n, r);
      this.setPan(i, false);
      const { flipVertical: a } = this.getCamera(), s = a ? Rl(He(), this.initialViewUp) : this.initialViewUp;
      this.setCameraNoEvent({
        viewUp: s
      }), this.getVtkActiveCamera().roll(-e);
      const o = this.getPan(), l = this.getPan(this.fitToCanvasCamera), c = ep([
        0,
        0
      ], o, l), f = H6([
        0,
        0
      ], n, c);
      this.setPan(f, false);
    }
    setInterpolationTypeGPU(e) {
      const n = this.getDefaultActor();
      if (!n || !fo(n)) return;
      const { actor: r } = n;
      r.getProperty().setInterpolationType(e), this.interpolationType = e;
    }
    setInterpolationTypeCPU(e) {
      const { viewport: n } = this._cpuFallbackEnabledElement;
      n.pixelReplication = e !== ho.LINEAR, this.interpolationType = e;
    }
    setInvertColorCPU(e) {
      const { viewport: n } = this._cpuFallbackEnabledElement;
      n && (n.invert = e, this.invert = e);
    }
    setInvertColorGPU(e) {
      const n = this.getDefaultActor();
      if (n && fo(n)) {
        if (ea(n, "vtkVolume")) {
          const i = n.actor.getProperty().getRGBTransferFunction(0);
          (!this.invert && e || this.invert && !e) && sh(i), this.invert = e;
        } else if (ea(n, "vtkImageSlice")) {
          const i = n.actor.getProperty().getRGBTransferFunction(0);
          (!this.invert && e || this.invert && !e) && sh(i), this.invert = e;
        }
      }
    }
    setVOICPU(e, n = {}) {
      const { suppressEvents: r = false } = n, { viewport: i, image: a } = this._cpuFallbackEnabledElement;
      if (!i || !a) return;
      if (typeof e > "u") {
        const { windowWidth: o, windowCenter: l } = a, c = Array.isArray(o) ? o[0] : o, f = Array.isArray(l) ? l[0] : l;
        i.voi = {
          windowWidth: c,
          windowCenter: f
        };
        const { lower: u, upper: h } = lh(c, f);
        e = {
          lower: u,
          upper: h
        };
      } else {
        const { lower: o, upper: l } = e, { windowCenter: c, windowWidth: f } = O8(o, l);
        i.voi || (i.voi = {
          windowWidth: 0,
          windowCenter: 0
        }), i.voi.windowWidth = f, i.voi.windowCenter = c;
      }
      this.voiRange = e;
      const s = {
        viewportId: this.id,
        range: e
      };
      r || qe(this.element, ze.VOI_MODIFIED, s);
    }
    getTransferFunction() {
      const e = this.getDefaultActor();
      return !e || !fo(e) ? void 0 : e.actor.getProperty().getRGBTransferFunction(0);
    }
    setVOIGPU(e, n = {}) {
      const { suppressEvents: r = false, forceRecreateLUTFunction: i = false, voiUpdatedWithSetProperties: a = false } = n;
      if (e && this.voiRange && this.voiRange.lower === e.lower && this.voiRange.upper === e.upper && !i && !this.stackInvalidated) return;
      const s = this.getDefaultActor();
      if (!s || !fo(s)) return;
      const o = s.actor;
      let l = e;
      if (typeof l > "u") {
        const g = o.getMapper().getInputData().getPointData().getScalars().getRange();
        l = {
          lower: g[0],
          upper: g[1]
        };
      }
      o.getProperty().setUseLookupTableScalarRange(true);
      let c = o.getProperty().getRGBTransferFunction(0);
      const f = this.VOILUTFunction === yo.SAMPLED_SIGMOID;
      if ((f || !c || i) && (c = (f ? I8 : SD)(l), this.invert && sh(c), o.getProperty().setRGBTransferFunction(0, c), this.initialTransferFunctionNodes = Lp(c)), f || c.setRange(l.lower, l.upper), this.voiRange = l, this.voiUpdatedWithSetProperties || (this.voiUpdatedWithSetProperties = a), r) return;
      const u = {
        viewportId: this.id,
        range: l,
        VOILUTFunction: this.VOILUTFunction
      };
      qe(this.element, ze.VOI_MODIFIED, u);
    }
    _addScalingToViewport(e) {
      if (this.scaling.PT) return;
      const { suvbw: n, suvlbm: r, suvbsa: i } = e, a = {};
      r && (a.suvbwToSuvlbm = r / n), i && (a.suvbwToSuvbsa = i / n), this.scaling.PT = a;
    }
    _getNumCompsFromPhotometricInterpretation(e) {
      let n = 1;
      return (e === "RGB" || e.indexOf("YBR") !== -1 || e === "PALETTE COLOR") && (n = 3), n;
    }
    getImageDataMetadata(e) {
      const { imagePlaneModule: n, imagePixelModule: r } = this.buildMetadata(e);
      let i, a;
      i = n.rowCosines, a = n.columnCosines, (i == null || a == null) && (i = [
        1,
        0,
        0
      ], a = [
        0,
        1,
        0
      ]);
      const s = Ue(i[0], i[1], i[2]), o = Ue(a[0], a[1], a[2]), l = He();
      Vr(l, s, o);
      let c = n.imagePositionPatient;
      c == null && (c = [
        0,
        0,
        0
      ]);
      const f = n.columnPixelSpacing || e.columnPixelSpacing, u = n.rowPixelSpacing || e.rowPixelSpacing, h = e.columns, g = e.rows, v = vse, m = 1, y = e.numComps || this._getNumCompsFromPhotometricInterpretation(r.photometricInterpretation);
      return {
        bitsAllocated: r.bitsAllocated,
        numComps: y,
        origin: c,
        direction: [
          ...s,
          ...o,
          ...l
        ],
        dimensions: [
          h,
          g,
          m
        ],
        spacing: [
          f,
          u,
          v
        ],
        numVoxels: h * g * m,
        imagePlaneModule: n,
        imagePixelModule: r
      };
    }
    getImagePlaneReferenceData(e = this.getCurrentImageIdIndex()) {
      const n = this.imageIds[e];
      if (!n) return;
      const r = Ct(ma.IMAGE_PLANE, n);
      if (!r) return;
      const { imagePositionPatient: i, frameOfReferenceUID: a } = r;
      let { rowCosines: s, columnCosines: o } = r;
      s || (s = [
        1,
        0,
        0
      ]), o || (o = [
        0,
        1,
        0
      ]);
      const l = Vr([
        0,
        0,
        0
      ], o, s);
      return {
        FrameOfReferenceUID: a,
        viewPlaneNormal: l,
        cameraFocalPoint: i,
        referencedImageId: n,
        sliceIndex: e
      };
    }
    _getCameraOrientation(e) {
      const n = e.slice(6, 9).map((i) => -i), r = e.slice(3, 6).map((i) => -i);
      return {
        viewPlaneNormal: [
          n[0],
          n[1],
          n[2]
        ],
        viewUp: [
          r[0],
          r[1],
          r[2]
        ]
      };
    }
    createVTKImageData({ origin: e, direction: n, dimensions: r, spacing: i, numComps: a, pixelArray: s }) {
      const o = new s.constructor(s.length), l = Tt.newInstance({
        name: "Pixels",
        numberOfComponents: a,
        values: o
      }), c = Bl.newInstance();
      return c.setDimensions(r), c.setSpacing(i), c.setDirection(n), c.setOrigin(e), c.getPointData().setScalars(l), c;
    }
    _createVTKImageData({ origin: e, direction: n, dimensions: r, spacing: i, numComps: a, pixelArray: s }) {
      this._imageData = this.createVTKImageData({
        origin: e,
        direction: n,
        dimensions: r,
        spacing: i,
        numComps: a,
        pixelArray: s
      });
    }
    async setStack(e, n = 0) {
      this._throwIfDestroyed(), this.imageIds = e, this.currentImageIdIndex = n, this.targetImageIdIndex = n;
      const r = Ct(Vp.IMAGE_RETRIEVE_CONFIGURATION, e[n], "stack");
      this.imagesLoader = r ? (r.create || UI)(r) : this, this.stackInvalidated = true, this.flipVertical = false, this.flipHorizontal = false, this.voiRange = null, this.interpolationType = ho.LINEAR, this.invert = false, this.viewportStatus = Bi.LOADING, this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {}, delete this._cpuFallbackEnabledElement.viewport.colormap);
      const i = await this._setImageIdIndex(n), a = {
        imageIds: e,
        viewportId: this.id,
        element: this.element,
        currentImageIdIndex: n
      };
      return qe(je, ze.STACK_VIEWPORT_NEW_STACK, a), i;
    }
    _throwIfDestroyed() {
      if (this.isDisabled) throw new Error("The stack viewport has been destroyed and is no longer usable. Renderings will not be performed. If you are using the same viewportId and have re-enabled the viewport, you need to grab the new viewport instance using renderingEngine.getViewport(viewportId), instead of using your lexical scoped reference to the viewport instance.");
    }
    _checkVTKImageDataMatchesCornerstoneImage(e, n) {
      if (!n) return false;
      const [r, i] = n.getSpacing(), [a, s] = n.getDimensions(), o = this._getImagePlaneModule(e.imageId), l = n.getDirection(), c = l.slice(0, 3), f = l.slice(3, 6), u = n.getPointData().getScalars().getDataType(), h = zr(r, e.columnPixelSpacing), g = zr(i, e.rowPixelSpacing);
      return (h || e.columnPixelSpacing === null && r === 1) && (g || e.rowPixelSpacing === null && i === 1) && a === e.columns && s === e.rows && zr(o.rowCosines, c) && zr(o.columnCosines, f) && (!this.useNativeDataType || u === e.getPixelData().constructor.name);
    }
    _updateVTKImageDataFromCornerstoneImage(e) {
      let r = this._getImagePlaneModule(e.imageId).imagePositionPatient;
      r == null && (r = [
        0,
        0,
        0
      ]), this._imageData.setOrigin(r), M5(this._imageData, e);
    }
    _loadAndDisplayImage(e, n) {
      return this.useCPURendering ? this._loadAndDisplayImageCPU(e, n) : this._loadAndDisplayImageGPU(e, n);
    }
    _loadAndDisplayImageCPU(e, n) {
      return new Promise((r, i) => {
        function a(g, v, m) {
          if (this.currentImageIdIndex !== v) return;
          const y = g.getPixelData(), w = g.preScale, C = w == null ? void 0 : w.scalingParameters, T = (w == null ? void 0 : w.scaled) && (C == null ? void 0 : C.rescaleIntercept) % 1 !== 0 || (C == null ? void 0 : C.rescaleSlope) % 1 !== 0;
          if (y instanceof Float32Array && T) {
            const E = {
              min: g.maxPixelValue,
              max: g.minPixelValue
            }, R = Math.abs(E.max - E.min) / 65535, I = E.min, O = y.length, L = new Uint16Array(O);
            let N = 65535, F = 0;
            for (let V = 0; V < O; V++) {
              const k = Math.floor((y[V] - I) / R);
              L[V] = k, N = Math.min(N, k), F = Math.max(F, k);
            }
            g.minPixelValue = N, g.maxPixelValue = F, g.slope = R, g.intercept = I, g.getPixelData = () => L, g.preScale = {
              ...g.preScale,
              scaled: false
            };
          }
          this._setCSImage(g), this.viewportStatus = Bi.PRE_RENDER;
          const S = {
            image: g,
            imageId: m,
            imageIdIndex: v,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId
          };
          qe(this.element, ze.STACK_NEW_IMAGE, S), this._updateToDisplayImageCPU(g), this.render(), this.currentImageIdIndex = v, r(m);
        }
        function s(g, v, m) {
          const y = {
            error: g,
            imageIdIndex: v,
            imageId: m
          };
          this.suppressEvents || qe(je, ze.IMAGE_LOAD_ERROR, y), i(g);
        }
        function o(g, v, m) {
          return Eh(g, m).then((y) => {
            a.call(this, y, v, g);
          }, (y) => {
            s.call(this, y, v, g);
          });
        }
        const l = -5, c = ar.Interaction, f = {
          imageId: e,
          imageIdIndex: n
        }, u = {
          preScale: {
            enabled: true
          },
          useRGBA: true,
          requestType: c
        }, h = {
          imageId: e,
          imageIdIndex: n,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId
        };
        qe(this.element, ze.PRE_STACK_NEW_IMAGE, h), i0.addRequest(o.bind(this, e, n, u), c, f, l);
      });
    }
    successCallback(e, n) {
      var _a3, _b3;
      const r = this.imageIds.indexOf(e);
      if (this.currentImageIdIndex !== r) return;
      const i = (_a3 = this.csImage) == null ? void 0 : _a3.imageFrame, a = n == null ? void 0 : n.imageFrame, s = (i == null ? void 0 : i.photometricInterpretation) || ((_b3 = this.csImage) == null ? void 0 : _b3.photometricInterpretation), o = (a == null ? void 0 : a.photometricInterpretation) || (n == null ? void 0 : n.photometricInterpretation);
      s !== o && (this.stackInvalidated = true), this._setCSImage(n);
      const l = {
        image: n,
        imageId: e,
        imageIdIndex: r,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      this._updateActorToDisplayImageId(n), qe(this.element, ze.STACK_NEW_IMAGE, l), this.render(), this.currentImageIdIndex = r;
    }
    errorCallback(e, n, r) {
      if (!n) return;
      const i = this.imageIds.indexOf(e), a = {
        error: r,
        imageIdIndex: i,
        imageId: e
      };
      qe(je, ze.IMAGE_LOAD_ERROR, a);
    }
    getLoaderImageOptions(e) {
      const n = this.imageIds.indexOf(e), { transferSyntaxUID: r } = Ct("transferSyntax", e) || {}, i = {
        imageId: e,
        imageIdIndex: n
      };
      return {
        targetBuffer: {
          type: this.useNativeDataType ? void 0 : "Float32Array"
        },
        preScale: {
          enabled: true
        },
        useRGBA: false,
        transferSyntaxUID: r,
        useNativeDataType: this.useNativeDataType,
        priority: 5,
        requestType: ar.Interaction,
        additionalDetails: i
      };
    }
    async loadImages(e, n) {
      const r = await Promise.allSettled(e.map((a) => {
        const s = this.getLoaderImageOptions(a);
        return Eh(a, s).then((o) => (n.successCallback(a, o), a), (o) => (n.errorCallback(a, true, o), a));
      })), i = r.filter((a) => a.status === "rejected");
      if (i && i.length) {
        const a = new CustomEvent(ze.IMAGE_LOAD_ERROR, {
          detail: i,
          cancelable: true
        });
        je.dispatchEvent(a);
      }
      return r;
    }
    _loadAndDisplayImageGPU(e, n) {
      const r = {
        imageId: e,
        imageIdIndex: n,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      return qe(this.element, ze.PRE_STACK_NEW_IMAGE, r), this.imagesLoader.loadImages([
        e
      ], this).then((i) => e);
    }
    _updateToDisplayImageCPU(e) {
      const n = this.getImageDataMetadata(e), r = cI(this.canvas, e, this.modality, this._cpuFallbackEnabledElement.viewport.colormap), { windowCenter: i, windowWidth: a } = r.voi;
      this.voiRange = lh(a, i), this._cpuFallbackEnabledElement.image = e, this._cpuFallbackEnabledElement.metadata = {
        ...n
      }, this.cpuImagePixelData = e.getPixelData();
      const s = Object.assign({}, r, this._cpuFallbackEnabledElement.viewport);
      this._cpuFallbackEnabledElement.viewport = this.stackInvalidated ? r : s, this.stackInvalidated = false, this.cpuRenderingInvalidated = true, this._cpuFallbackEnabledElement.transform = bh(this._cpuFallbackEnabledElement);
    }
    addImages(e) {
      const n = this.getActors();
      e.forEach((r) => {
        const i = Ke.getImage(r.imageId), { origin: a, dimensions: s, direction: o, spacing: l, numComps: c } = this.getImageDataMetadata(i), f = this.createVTKImageData({
          origin: a,
          dimensions: s,
          direction: o,
          spacing: l,
          numComps: c,
          pixelArray: i.getPixelData()
        }), u = this.createActorMapper(f);
        u && (n.push({
          uid: r.actorUID,
          actor: u
        }), r.callback && r.callback({
          imageActor: u,
          imageId: r.imageId
        }));
      }), this.setActors(n);
    }
    _updateActorToDisplayImageId(e) {
      const n = this._checkVTKImageDataMatchesCornerstoneImage(e, this._imageData), r = this.getRenderer().getActiveCamera(), i = Ar(this.getCamera());
      if (n && !this.stackInvalidated) {
        this._updateVTKImageDataFromCornerstoneImage(e);
        const w = this.getCamera(), C = Ft(He(), this.cameraFocalPointOnRender, w.focalPoint);
        this.resetCameraNoEvent(), this.setCameraNoEvent({
          flipHorizontal: i.flipHorizontal,
          flipVertical: i.flipVertical,
          viewUp: i.viewUp
        });
        const { focalPoint: T } = this.getCamera();
        this.cameraFocalPointOnRender = T, r.setFreezeFocalPoint(true), this._restoreCameraProps(w, i, C), this._setPropertiesFromCache(), this.stackActorReInitialized = false;
        return;
      }
      const { origin: a, direction: s, dimensions: o, spacing: l, numComps: c, imagePixelModule: f } = this.getImageDataMetadata(e), u = e.getPixelData();
      this._createVTKImageData({
        origin: a,
        direction: s,
        dimensions: o,
        spacing: l,
        numComps: c,
        pixelArray: u
      }), this._updateVTKImageDataFromCornerstoneImage(e);
      const h = this.createActorMapper(this._imageData), g = this.getActors();
      g.length && g[0].uid === this.id ? g[0].actor = h : g.unshift({
        uid: this.id,
        actor: h
      }), this.setActors(g);
      const { viewPlaneNormal: v, viewUp: m } = this._getCameraOrientation(s);
      this.setCameraNoEvent({
        viewUp: m,
        viewPlaneNormal: v
      }), this.initialViewUp = m, this.resetCameraNoEvent(), this.triggerCameraEvent(this.getCamera(), i), r.setFreezeFocalPoint(true);
      const y = f.photometricInterpretation === "MONOCHROME1";
      this.stackInvalidated = true, this.setVOI(this._getInitialVOIRange(e), {
        forceRecreateLUTFunction: !!y
      }), this.initialInvert = !!y, this.setInvertColor(this.invert || this.initialInvert), this.cameraFocalPointOnRender = this.getCamera().focalPoint, this.stackInvalidated = false, this.stackActorReInitialized = true, this._publishCalibratedEvent && this.triggerCalibrationEvent();
    }
    _getInitialVOIRange(e) {
      if (this.voiRange && this.voiUpdatedWithSetProperties) return this.globalDefaultProperties.voiRange;
      const { windowCenter: n, windowWidth: r } = e;
      let i = this._getVOIRangeFromWindowLevel(r, n);
      return i = this._getPTPreScaledRange() || i, i;
    }
    _getPTPreScaledRange() {
      if (this._isCurrentImagePTPrescaled()) return this._getDefaultPTPrescaledVOIRange();
    }
    _isCurrentImagePTPrescaled() {
      var _a3, _b3;
      return !(this.modality !== "PT" || !this.csImage.isPreScaled || !((_b3 = (_a3 = this.csImage.preScale) == null ? void 0 : _a3.scalingParameters) == null ? void 0 : _b3.suvbw));
    }
    _getDefaultPTPrescaledVOIRange() {
      return {
        lower: 0,
        upper: 5
      };
    }
    _getVOIRangeFromWindowLevel(e, n) {
      let r, i;
      if (typeof n == "number" && typeof e == "number" ? (r = n, i = e) : Array.isArray(n) && Array.isArray(e) && (r = n[0], i = e[0]), r !== void 0 && i !== void 0) return lh(i, r);
    }
    async _setImageIdIndex(e) {
      if (e >= this.imageIds.length) throw new Error(`ImageIdIndex provided ${e} is invalid, the stack only has ${this.imageIds.length} elements`);
      this.currentImageIdIndex = e, this.hasPixelSpacing = true, this.viewportStatus = Bi.PRE_RENDER;
      const n = await this._loadAndDisplayImage(this.imageIds[e], e);
      if (this.perImageIdDefaultProperties.size >= 1) {
        const r = this.perImageIdDefaultProperties.get(n);
        r !== void 0 ? this.setProperties(r) : this.globalDefaultProperties !== void 0 && this.setProperties(this.globalDefaultProperties);
      }
      return n;
    }
    resetCameraCPU(e, n) {
      const { image: r } = this._cpuFallbackEnabledElement;
      if (!r) return;
      mse(this._cpuFallbackEnabledElement, e, n);
      const { scale: i } = this._cpuFallbackEnabledElement.viewport, { clientWidth: a, clientHeight: s } = this.element, o = [
        a / 2,
        s / 2
      ], l = this.canvasToWorldCPU(o);
      this.setCameraCPU({
        focalPoint: l,
        scale: i
      });
    }
    resetCameraGPU(e, n) {
      return this.setCamera({
        flipHorizontal: false,
        flipVertical: false,
        viewUp: this.initialViewUp
      }), super.resetCamera(e, n, true);
    }
    scroll(e, n = true, r = false) {
      const i = this.imageIds, a = this.targetImageIdIndex, s = i.length;
      let o = a + e;
      o = Math.max(0, o), r ? o = o % s : o = Math.min(s - 1, o), this.targetImageIdIndex = o;
      const l = i[o];
      Ke.isLoaded(l) || !n ? this.setImageIdIndex(o) : (clearTimeout(this.debouncedTimeout), this.debouncedTimeout = window.setTimeout(() => {
        this.setImageIdIndex(o);
      }, 40));
      const f = {
        newImageIdIndex: o,
        imageId: l,
        direction: e
      };
      o !== a && qe(this.element, ze.STACK_VIEWPORT_SCROLL, f);
    }
    setImageIdIndex(e) {
      return this._throwIfDestroyed(), this.currentImageIdIndex === e ? Promise.resolve(this.getCurrentImageId()) : this._setImageIdIndex(e);
    }
    calibrateSpacing(e) {
      const n = this.getImageIds().indexOf(e);
      this.stackInvalidated = true, this._loadAndDisplayImage(e, n);
    }
    _restoreCameraProps({ parallelScale: e }, n, r) {
      const i = this.getRenderer(), { position: a, focalPoint: s } = this.getCamera(), o = Ft(He(), a, r), l = Ft(He(), s, r);
      this.setCameraNoEvent({
        parallelScale: e,
        position: o,
        focalPoint: l
      });
      const c = this.getCamera();
      this.triggerCameraEvent(c, n);
      const f = {
        type: "ResetCameraEvent",
        renderer: i
      };
      i.invokeEvent(f);
    }
    triggerCameraEvent(e, n) {
      const r = {
        previousCamera: n,
        camera: e,
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      this.suppressEvents || qe(this.element, ze.CAMERA_MODIFIED, r);
    }
    triggerCalibrationEvent() {
      const { imageData: e } = this.getImageData(), n = {
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId,
        imageId: this.getCurrentImageId(),
        imageData: e,
        worldToIndex: e.getWorldToIndex(),
        ...this._calibrationEvent
      };
      this.suppressEvents || qe(this.element, ze.IMAGE_SPACING_CALIBRATED, n), this._publishCalibratedEvent = false;
    }
    _getVOIRangeForCurrentImage() {
      const { windowCenter: e, windowWidth: n } = this.csImage;
      return this._getVOIRangeFromWindowLevel(n, e);
    }
    _getValidVOILUTFunction(e) {
      return Object.values(yo).indexOf(e) === -1 && (e = yo.LINEAR), e;
    }
    isReferenceViewable(e, n = {}) {
      if (!super.isReferenceViewable(e, n)) return false;
      let { imageURI: r } = n;
      const { referencedImageId: i, sliceIndex: a } = e;
      if (e.volumeId && !i) return n.asVolume === true;
      let s = this.getCurrentImageIdIndex();
      n.withNavigation && typeof a == "number" && (s = a);
      const o = this.imageIds[s];
      if (!o) return false;
      if (!r) {
        const f = o.indexOf(":");
        r = o.substring(f + 1);
      }
      const l = i == null ? void 0 : i.endsWith(r);
      if (l) return l;
      const { cameraFocalPoint: c } = e;
      if (n.asNearbyProjection && c) {
        const { spacing: f, direction: u, origin: h } = this.getImageData(), g = u.slice(6, 9), v = Vu({
          direction: u,
          spacing: f
        }, g), m = Ft(He(), c, h), y = Bt(m, g), w = v / 2;
        if (Math.abs(y) <= w) return true;
      }
      return false;
    }
    getViewReference(e = {}) {
      const { sliceIndex: n = this.getCurrentImageIdIndex() } = e, r = super.getViewReference(e), i = this.imageIds[n];
      if (i) {
        if (r.referencedImageId = i, this.getCurrentImageIdIndex() !== n) {
          const a = this.getImagePlaneReferenceData(n);
          if (!a) return;
          Object.assign(r, a);
        }
        return r;
      }
    }
    setViewReference(e) {
      if (!e) return;
      const { referencedImageId: n, sliceIndex: r } = e;
      if (typeof r == "number" && n && n === this.imageIds[r]) this.scroll(r - this.targetImageIdIndex);
      else {
        const i = this.imageIds.indexOf(n);
        if (i !== -1) this.scroll(i - this.targetImageIdIndex);
        else throw new Error("Unsupported - referenced image id not found");
      }
    }
    getReferenceId(e = {}) {
      const { sliceIndex: n = this.currentImageIdIndex } = e;
      if (Array.isArray(n)) throw new Error("Use of slice ranges for stacks not supported");
      return `imageId:${this.imageIds[n]}`;
    }
    getCPUFallbackError(e) {
      return new Error(`method ${e} cannot be used during CPU Fallback mode`);
    }
    fillWithBackgroundColor() {
      const e = this.getRenderingEngine();
      e && e.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
    }
    unsetColormapCPU() {
      delete this._cpuFallbackEnabledElement.viewport.colormap, this._cpuFallbackEnabledElement.renderingTools = {}, this.cpuRenderingInvalidated = true, this.fillWithBackgroundColor(), this.render();
    }
    setColormapCPU(e) {
      this.colormap = e;
      const n = hI(e.name, e);
      this._cpuFallbackEnabledElement.viewport.colormap = n, this._cpuFallbackEnabledElement.renderingTools = {}, this.fillWithBackgroundColor(), this.cpuRenderingInvalidated = true, this.render();
      const r = {
        viewportId: this.id,
        colormap: e
      };
      qe(this.element, ze.COLORMAP_MODIFIED, r);
    }
    setColormapGPU(e) {
      const i = this.getDefaultActor().actor.getProperty(), a = i.getRGBTransferFunction(), s = I5(e.name) || Np.getPresetByName(e.name);
      if (a) a.applyColorMap(s), a.setMappingRange(this.voiRange.lower, this.voiRange.upper), i.setRGBTransferFunction(0, a);
      else {
        const l = Ul.newInstance();
        l.applyColorMap(s), l.setMappingRange(this.voiRange.lower, this.voiRange.upper), i.setRGBTransferFunction(0, l);
      }
      this.colormap = e, this.render();
      const o = {
        viewportId: this.id,
        colormap: e
      };
      qe(this.element, ze.COLORMAP_MODIFIED, o);
    }
    unsetColormapGPU() {
      throw new Error("unsetColormapGPU not implemented.");
    }
    _getImagePlaneModule(e) {
      var _a3, _b3;
      const n = Ct(ma.IMAGE_PLANE, e);
      this.calibration || (this.calibration = n.calibration);
      const r = {
        ...n
      };
      return r.columnPixelSpacing || (r.columnPixelSpacing = 1, this.hasPixelSpacing = ((_a3 = this.calibration) == null ? void 0 : _a3.scale) > 0), r.rowPixelSpacing || (r.rowPixelSpacing = 1, this.hasPixelSpacing = ((_b3 = this.calibration) == null ? void 0 : _b3.scale) > 0), r.columnCosines || (r.columnCosines = [
        0,
        1,
        0
      ]), r.rowCosines || (r.rowCosines = [
        1,
        0,
        0
      ]), r.imagePositionPatient || (r.imagePositionPatient = [
        0,
        0,
        0
      ]), r.imageOrientationPatient || (r.imageOrientationPatient = new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0
      ])), r;
    }
  }
  class Cy extends Ga {
    constructor(e) {
      super(e), this.getRotation = () => 0, this.getCurrentImageIdIndex = () => {
      }, this.getCurrentImageId = () => null;
      const { parallelProjection: n, orientation: r } = this.options, i = this.getVtkActiveCamera();
      n != null && i.setParallelProjection(n), r && r !== vo.ACQUISITION && this.applyViewOrientation(r);
    }
    resetCamera(e = true, n = true, r = true) {
      super.resetCamera(e, n, r), this.resetVolumeViewportClippingRange();
    }
    setSlabThickness(e, n) {
      return null;
    }
    setBlendMode(e, n, r) {
      return null;
    }
    resetProperties(e) {
      const n = e ? this.getActor(e) : this.getDefaultActor();
      if (!n) throw new Error(`No actor found for the given volumeId: ${e}`);
      n.slabThickness && (n.slabThickness = Gi.MINIMUM_SLAB_THICKNESS, this.viewportProperties.slabThickness = void 0, this.updateClippingPlanesForActors(this.getCamera()));
      const r = Ke.getVolume(n.uid);
      if (!r) throw new Error(`imageVolume with id: ${n.uid} does not exist in cache`);
      if (vy(n.actor, r, false), fo(n)) {
        const i = n.actor.getProperty().getRGBTransferFunction(0);
        V5(i, this.initialTransferFunctionNodes);
      }
      this.setCamera(this.initialCamera), qe(this.element, ze.VOI_MODIFIED, super.getVOIModifiedEventDetail(e));
    }
    resetSlabThickness() {
      return null;
    }
  }
  class yse {
    constructor(e) {
      this.opacity = 0.4, this.outlineOpacity = 0.4, this.transferFunction = [], this.actor = e;
    }
    setRGBTransferFunction(e, n) {
      this.transferFunction[e] = n;
    }
    setScalarOpacity(e) {
    }
    setInterpolationTypeToNearest() {
    }
    setUseLabelOutline() {
    }
    setLabelOutlineOpacity(e) {
      this.outlineOpacity = e;
    }
    setLabelOutlineThickness() {
    }
    getColor(e) {
      const n = this.transferFunction[0], r = n.getRedValue(e), i = n.getGreenValue(e), a = n.getBlueValue(e);
      return [
        r,
        i,
        a,
        this.opacity
      ];
    }
  }
  class xse {
    constructor(e) {
      this.actor = e;
    }
    getInputData() {
      return this.actor.getImage();
    }
  }
  class wse {
    constructor(e, n) {
      this.canvasProperties = new yse(this), this.visibility = false, this.mapper = new xse(this), this.className = "CanvasActor", this.derivedImage = n, this.viewport = e;
    }
    renderRLE(e, n, r) {
      const { width: i, height: a } = this.image;
      let { canvas: s } = this;
      (!s || s.width !== i || s.height !== a) && (this.canvas = s = new window.OffscreenCanvas(i, a));
      const o = s.getContext("2d"), l = o.createImageData(i, a), { data: c } = l;
      c.fill(0);
      const { map: f } = r;
      let u = 1 / 0, h = 1 / 0, g = -1 / 0, v = -1 / 0;
      for (let w = 0; w < a; w++) {
        const C = f.getRun(w, 0);
        if (!C) continue;
        h = Math.min(h, w), v = Math.max(v, w);
        const T = w * i << 2;
        let S;
        for (const E of C) {
          const { start: b, end: D, value: R } = E;
          if (R === 0) {
            S || (S = []), S.push(C.indexOf(E));
            continue;
          }
          u = Math.min(u, b), g = Math.max(g, D);
          const I = this.canvasProperties.getColor(R).map((L) => L * 255);
          let O = T + (b << 2);
          for (let L = b; L < D; L++) c[O++] = I[0], c[O++] = I[1], c[O++] = I[2], c[O++] = I[3];
        }
      }
      if (u > i) return;
      const m = g - u, y = v - h;
      o.putImageData(l, 0, 0, u - 1, h - 1, m + 2, y + 2), n.drawImage(s, u, h, m, y, u, h, m, y);
    }
    render(e, n) {
      if (!this.visibility) return;
      const r = this.image || this.getImage(), { width: i, height: a } = r, s = r.getScalarData();
      if (!s) return;
      const { voxelManager: o } = r;
      if (o && o.map.getRun) return this.renderRLE(e, n, o);
      let { canvas: l } = this;
      (!l || l.width !== i || l.height !== a) && (this.canvas = l = new window.OffscreenCanvas(i, a));
      const c = l.getContext("2d"), f = c.createImageData(i, a), { data: u } = f;
      let h = 0, g = 0, v = 1 / 0, m = 1 / 0, y = -1 / 0, w = -1 / 0;
      for (let S = 0; S < a; S++) for (let E = 0; E < i; E++) {
        const b = s[h++];
        if (b) {
          v = Math.min(E, v), m = Math.min(S, m), y = Math.max(E, y), w = Math.max(S, w);
          const D = this.canvasProperties.getColor(b);
          u[g] = D[0] * 255, u[g + 1] = D[1] * 255, u[g + 2] = D[2] * 255, u[g + 3] = 127;
        }
        g += 4;
      }
      if (v > i) return;
      const C = y - v + 1, T = w - m + 1;
      c.putImageData(f, 0, 0, v, m, C, T), n.drawImage(l, v, m, C, T, v, m, C, T);
    }
    getClassName() {
      return this.className;
    }
    getProperty() {
      return this.canvasProperties;
    }
    setVisibility(e) {
      this.visibility = e;
    }
    getMapper() {
      return this.mapper;
    }
    isA(e) {
      return e === this.className;
    }
    getImage() {
      if (this.image) return this.image;
      this.image = {
        ...this.derivedImage
      };
      const e = this.viewport.getImageData();
      return Object.assign(this.image, {
        worldToIndex: (n) => e.imageData.worldToIndex(n),
        indexToWorld: (n, r) => e.imageData.indexToWorld(n, r),
        getDimensions: () => e.dimensions,
        getScalarData: () => {
          var _a3;
          return (_a3 = this.derivedImage) == null ? void 0 : _a3.getPixelData();
        },
        getDirection: () => e.direction,
        getSpacing: () => e.spacing,
        setOrigin: () => null,
        setDerivedImage: (n) => {
          this.derivedImage = n, this.image = null;
        },
        modified: () => null
      }), this.image;
    }
  }
  const _Up = class _Up extends af {
    constructor(e) {
      super({
        ...e,
        canvas: e.canvas || co(e.element)
      }), this.videoWidth = 0, this.videoHeight = 0, this.loop = true, this.mute = true, this.isPlaying = false, this.scrollSpeed = 1, this.playbackRate = 1, this.frameRange = [
        0,
        0
      ], this.fps = 30, this.videoCamera = {
        panWorld: [
          0,
          0
        ],
        parallelScale: 1
      }, this.voiRange = {
        lower: 0,
        upper: 255
      }, this.getProperties = () => ({
        loop: this.videoElement.loop,
        muted: this.videoElement.muted,
        playbackRate: this.playbackRate,
        scrollSpeed: this.scrollSpeed,
        voiRange: {
          ...this.voiRange
        }
      }), this.resetCamera = () => (this.refreshRenderValues(), this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height), this.isPlaying === false && this.renderFrame(), true), this.getNumberOfSlices = () => {
        const n = Math.round(this.videoElement.duration * this.fps / this.scrollSpeed);
        return isNaN(n) ? this.numberOfFrames : n;
      }, this.getFrameOfReferenceUID = () => this.videoElement.src, this.resize = () => {
        const n = this.canvas, { clientWidth: r, clientHeight: i } = n;
        (n.width !== r || n.height !== i) && (n.width = r, n.height = i), this.refreshRenderValues(), this.isPlaying === false && this.renderFrame();
      }, this.canvasToWorld = (n, r = [
        0,
        0,
        0
      ]) => {
        const i = this.videoCamera.panWorld, a = this.getWorldToCanvasRatio(), s = [
          i[0] * a,
          i[1] * a
        ], o = [
          n[0] - s[0],
          n[1] - s[1]
        ];
        return r.splice(0, 2, o[0] / a, o[1] / a), r;
      }, this.worldToCanvas = (n) => {
        const r = this.videoCamera.panWorld, i = this.getWorldToCanvasRatio();
        return [
          (n[0] + r[0]) * i,
          (n[1] + r[1]) * i
        ];
      }, this.getRotation = () => 0, this.canvasToIndex = (n) => {
        const r = this.getTransform();
        return r.invert(), r.transformPoint(n.map((i) => i * devicePixelRatio));
      }, this.indexToCanvas = (n) => this.getTransform().transformPoint(n).map((i) => i / devicePixelRatio), this.customRenderViewportToCanvas = () => {
        this.renderFrame();
      }, this.renderFrame = () => {
        var _a3;
        const r = this.getTransform().getMatrix(), i = this.canvasContext;
        i.resetTransform(), i.transform(r[0], r[1], r[2], r[3], r[4], r[5]), i.drawImage(this.videoElement, 0, 0, this.videoWidth || 1024, this.videoHeight || 1024);
        for (const s of this.getActors()) s.actor.render(this, this.canvasContext);
        this.canvasContext.resetTransform(), qe(this.element, ze.STACK_NEW_IMAGE, {
          element: this.element,
          viewportId: this.id,
          viewport: this,
          renderingEngineId: this.renderingEngineId,
          time: this.videoElement.currentTime,
          duration: this.videoElement.duration
        }), qe(this.element, ze.IMAGE_RENDERED, {
          element: this.element,
          viewportId: this.id,
          viewport: this,
          imageIndex: this.getCurrentImageIdIndex(),
          numberOfSlices: this.numberOfFrames,
          renderingEngineId: this.renderingEngineId,
          time: this.videoElement.currentTime,
          duration: this.videoElement.duration
        }), (_a3 = this.initialRender) == null ? void 0 : _a3.call(this);
        const a = this.getFrameNumber();
        this.isPlaying && (a < this.frameRange[0] ? this.setFrameNumber(this.frameRange[0]) : a > this.frameRange[1] && (this.loop ? this.setFrameNumber(this.frameRange[0]) : this.pause()));
      }, this.renderWhilstPlaying = () => {
        this.renderFrame(), this.isPlaying && requestAnimationFrame(this.renderWhilstPlaying);
      }, this.canvasContext = this.canvas.getContext("2d"), this.renderingEngineId = e.renderingEngineId, this.element.setAttribute("data-viewport-uid", this.id), this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId), this.videoElement = document.createElement("video"), this.videoElement.muted = this.mute, this.videoElement.loop = this.loop, this.videoElement.autoplay = true, this.videoElement.crossOrigin = "anonymous", this.addEventListeners(), this.resize();
    }
    static get useCustomRenderingPipeline() {
      return true;
    }
    addEventListeners() {
      this.canvas.addEventListener(ze.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    removeEventListeners() {
      this.canvas.removeEventListener(ze.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    elementDisabledHandler() {
      this.removeEventListeners(), this.videoElement.remove();
    }
    getImageDataMetadata(e) {
      const n = typeof e == "string" ? e : e.imageId, r = Ct(ma.IMAGE_PLANE, n);
      let i = r.rowCosines, a = r.columnCosines;
      (i == null || a == null) && (i = [
        1,
        0,
        0
      ], a = [
        0,
        1,
        0
      ]);
      const s = Ue(i[0], i[1], i[2]), o = Ue(a[0], a[1], a[2]), { rows: l, columns: c } = r, f = He();
      Vr(f, s, o);
      let u = r.imagePositionPatient;
      u == null && (u = [
        0,
        0,
        0
      ]);
      const h = r.columnPixelSpacing || 1, g = r.rowPixelSpacing || 1, v = r.columns, m = r.rows, y = 1, w = 1;
      return this.hasPixelSpacing = !!r.columnPixelSpacing, {
        bitsAllocated: 8,
        numComps: 3,
        origin: u,
        rows: l,
        columns: c,
        direction: [
          ...s,
          ...o,
          ...f
        ],
        dimensions: [
          v,
          m,
          w
        ],
        spacing: [
          h,
          g,
          y
        ],
        hasPixelSpacing: this.hasPixelSpacing,
        numVoxels: v * m * w,
        imagePlaneModule: r
      };
    }
    setDataIds(e, n) {
      var _a3;
      this.setVideo(e[0], (((_a3 = n == null ? void 0 : n.viewReference) == null ? void 0 : _a3.sliceIndex) || 0) + 1);
    }
    setVideo(e, n) {
      this.imageId = Array.isArray(e) ? e[0] : e;
      const r = Ct(ma.IMAGE_URL, e);
      if (!(r == null ? void 0 : r.rendered)) throw new Error(`Video Image ID ${e} does not have a rendered video view`);
      const { rendered: i } = r, a = Ct(ma.GENERAL_SERIES, e);
      this.modality = a == null ? void 0 : a.Modality, this.metadata = this.getImageDataMetadata(e);
      let { cineRate: s, numberOfFrames: o } = Ct(ma.CINE, e);
      return this.numberOfFrames = o, this.setVideoURL(i).then(() => ((!o || o === 1) && (o = Math.round(this.videoElement.duration * (s || 30))), s || (s = Math.round(o / this.videoElement.duration)), this.fps = s, this.numberOfFrames = o, this.setFrameRange([
        1,
        o
      ]), this.initialRender = () => {
        this.initialRender = null, this.pause(), this.setFrameNumber(n || 1);
      }, new Promise((l) => {
        window.setTimeout(() => {
          this.setFrameNumber(n || 1), l(this);
        }, 25);
      })));
    }
    async setVideoURL(e) {
      return new Promise((n) => {
        this.videoElement.src = e, this.videoElement.preload = "auto";
        const r = () => {
          this.videoWidth = this.videoElement.videoWidth, this.videoHeight = this.videoElement.videoHeight, this.videoElement.removeEventListener("loadedmetadata", r), this.refreshRenderValues(), n(true);
        };
        this.videoElement.addEventListener("loadedmetadata", r);
      });
    }
    getImageIds() {
      const e = new Array(this.numberOfFrames), n = this.imageId.replace(/[0-9]+$/, "");
      for (let r = 0; r < this.numberOfFrames; r++) e[r] = `${n}${r + 1}`;
      return e;
    }
    togglePlayPause() {
      return this.isPlaying ? (this.pause(), false) : (this.play(), true);
    }
    async play() {
      try {
        this.isPlaying || (this.isPlaying = true, await this.videoElement.play(), this.renderWhilstPlaying());
      } catch {
      }
    }
    pause() {
      try {
        this.isPlaying = false, this.videoElement.pause();
      } catch {
      }
    }
    async scroll(e = 1) {
      await this.pause();
      const n = this.videoElement, r = this.renderFrame, a = n.currentTime + e * this.scrollSpeed / this.fps;
      n.currentTime = a;
      const s = (o) => {
        r(), n.removeEventListener("seeked", s);
      };
      n.addEventListener("seeked", s);
    }
    async start() {
      const e = this.videoElement, n = this.renderFrame;
      if (e.currentTime = 0, e.paused) {
        const r = (i) => {
          n(), e.removeEventListener("seeked", r);
        };
        e.addEventListener("seeked", r);
      }
    }
    async end() {
      const e = this.videoElement, n = this.renderFrame;
      if (e.currentTime = e.duration, e.paused) {
        const r = (i) => {
          n(), e.removeEventListener("seeked", r);
        };
        e.addEventListener("seeked", r);
      }
    }
    async setTime(e) {
      const n = this.videoElement, r = this.renderFrame;
      if (n.currentTime = e, n.paused) {
        const i = (a) => {
          r(), n.removeEventListener("seeked", i);
        };
        n.addEventListener("seeked", i);
      }
    }
    async setFrameNumber(e) {
      this.setTime((e - 1) / this.fps);
    }
    setFrameRange(e) {
      if (!e) {
        this.frameRange = [
          1,
          this.numberOfFrames
        ];
        return;
      }
      e.length !== 2 || e[0] === e[1] || (this.frameRange = [
        e[0],
        e[1]
      ]);
    }
    getFrameRange() {
      return this.frameRange;
    }
    setProperties(e) {
      e.loop !== void 0 && (this.videoElement.loop = e.loop), e.muted !== void 0 && (this.videoElement.muted = e.muted), e.playbackRate !== void 0 && this.setPlaybackRate(e.playbackRate), e.scrollSpeed !== void 0 && this.setScrollSpeed(e.scrollSpeed), e.voiRange && this.setVOI(e.voiRange);
    }
    setPlaybackRate(e = 1) {
      if (this.playbackRate = e, e < 0.0625) {
        this.pause();
        return;
      }
      this.videoElement && (this.videoElement.playbackRate = e, this.play());
    }
    setScrollSpeed(e = 1, n = wh.FRAME) {
      this.scrollSpeed = n === wh.SECOND ? e * this.fps : e;
    }
    resetProperties() {
      this.setProperties({
        loop: false,
        muted: true
      });
    }
    getScalarData() {
      var _a3;
      if (((_a3 = this.scalarData) == null ? void 0 : _a3.frameNumber) === this.getFrameNumber()) return this.scalarData;
      const e = document.createElement("canvas");
      e.width = this.videoWidth, e.height = this.videoHeight;
      const n = e.getContext("2d");
      n.drawImage(this.videoElement, 0, 0);
      const i = n.getImageData(0, 0, this.videoWidth, this.videoHeight).data;
      return i.getRange = () => [
        0,
        255
      ], i.frameNumber = this.getFrameNumber(), this.scalarData = i, i;
    }
    getImageData() {
      const { metadata: e } = this, n = e.spacing, r = {
        dimensions: e.dimensions,
        spacing: n,
        origin: e.origin,
        direction: e.direction,
        metadata: {
          Modality: this.modality
        },
        getScalarData: () => this.getScalarData(),
        imageData: {
          getDirection: () => e.direction,
          getDimensions: () => e.dimensions,
          getRange: () => [
            0,
            255
          ],
          getScalarData: () => this.getScalarData(),
          getSpacing: () => e.spacing,
          worldToIndex: (i) => {
            const a = this.worldToCanvas(i), s = this.canvasToIndex(a);
            return [
              s[0],
              s[1],
              0
            ];
          },
          indexToWorld: (i, a) => {
            const s = this.indexToCanvas([
              i[0],
              i[1]
            ]);
            return this.canvasToWorld(s, a);
          }
        },
        hasPixelSpacing: this.hasPixelSpacing,
        calibration: this.calibration,
        preScale: {
          scaled: false
        }
      };
      return Object.defineProperty(r, "scalarData", {
        get: () => this.getScalarData(),
        enumerable: true
      }), r;
    }
    hasImageURI(e) {
      const n = e.match(_Up.frameRangeExtractor), r = n ? e.substring(0, n.index) : e;
      return this.imageId.indexOf(r) !== -1;
    }
    setVOI(e) {
      this.voiRange = e, this.setColorTransform();
    }
    setWindowLevel(e = 256, n = 128) {
      const r = n - e / 2, i = n + e / 2 - 1;
      this.setVOI({
        lower: r,
        upper: i
      }), this.setColorTransform();
    }
    setAverageWhite(e) {
      this.averageWhite = e, this.setColorTransform();
    }
    setColorTransform() {
      if (!this.voiRange && !this.averageWhite) {
        this.feFilter = null;
        return;
      }
      const e = this.averageWhite || [
        255,
        255,
        255
      ], n = Math.max(...e), r = e.map((l) => n / l), { lower: i = 0, upper: a = 255 } = this.voiRange || {}, s = (a - i + 1) / 255, o = i / 255;
      this.feFilter = `url('data:image/svg+xml,      <svg xmlns="http://www.w3.org/2000/svg">        <filter id="colour" color-interpolation-filters="linearRGB">        <feColorMatrix type="matrix"         values="          ${r[0] * s} 0 0 0 ${o}           0 ${r[1] * s} 0 0 ${o}           0 0 ${r[2] * s} 0 ${o}           0 0 0 1 0" />        </filter>      </svg>#colour')`, this.canvas.style.filter = this.feFilter;
    }
    setCamera(e) {
      const { parallelScale: n, focalPoint: r } = e;
      if (n && (this.videoCamera.parallelScale = this.element.clientHeight / 2 / n), r !== void 0) {
        const i = this.worldToCanvas(r), a = [
          this.element.clientWidth / 2,
          this.element.clientHeight / 2
        ], s = [
          (i[0] - a[0]) / this.videoCamera.parallelScale,
          (i[1] - a[1]) / this.videoCamera.parallelScale
        ];
        this.videoCamera.panWorld = [
          this.videoCamera.panWorld[0] - s[0],
          this.videoCamera.panWorld[1] - s[1]
        ];
      }
      this.canvasContext.fillStyle = "rgba(0,0,0,1)", this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height), this.isPlaying === false && this.renderFrame();
    }
    getCurrentImageId() {
      return this.imageId.replace("/frames/1", this.isPlaying ? `/frames/${this.frameRange[0]}-${this.frameRange[1]}` : `/frames/${this.getFrameNumber()}`);
    }
    getReferenceId(e = {}) {
      const { sliceIndex: n } = e;
      return n === void 0 ? `videoId:${this.getCurrentImageId()}` : Array.isArray(n) ? `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${n[0] + 1}-${n[1] + 1}` : `videoId:${this.imageId.replace("/frames/1", `/frames/${1 + n}`)}`;
    }
    isReferenceViewable(e, n = {}) {
      let { imageURI: r } = n;
      const { referencedImageId: i, sliceIndex: a } = e;
      if (!super.isReferenceViewable(e)) return false;
      const s = this.getCurrentImageId();
      if (!r) {
        const u = s.indexOf(":");
        r = s.substring(u + 1, s.length - 1);
      }
      if (n.withNavigation) return true;
      const o = this.getSliceIndex();
      if (Array.isArray(a)) return o >= a[0] && o <= a[1];
      if (a !== void 0) return o === a;
      if (!i) return false;
      const l = i.match(_Up.frameRangeExtractor);
      if (!l || !l[2]) return true;
      const c = l[2].split("-").map((u) => Number(u)), f = o + 1;
      return c[0] <= f && f <= (c[1] ?? c[0]);
    }
    setViewReference(e) {
      typeof e.sliceIndex == "number" ? this.setFrameNumber(e.sliceIndex + 1) : Array.isArray(e.sliceIndex) && this.setFrameRange(e.sliceIndex);
    }
    getViewReference(e) {
      let n = e == null ? void 0 : e.sliceIndex;
      return n || (n = this.isPlaying ? [
        this.frameRange[0] - 1,
        this.frameRange[1] - 1
      ] : this.getCurrentImageIdIndex()), {
        ...super.getViewReference(e),
        referencedImageId: this.getReferenceId(e),
        sliceIndex: n
      };
    }
    getFrameNumber() {
      return 1 + this.getCurrentImageIdIndex();
    }
    getCurrentImageIdIndex() {
      return Math.round(this.videoElement.currentTime * this.fps);
    }
    getSliceIndex() {
      return this.getCurrentImageIdIndex() / this.scrollSpeed;
    }
    getCamera() {
      const { parallelScale: e } = this.videoCamera, n = [
        this.element.clientWidth / 2,
        this.element.clientHeight / 2
      ];
      return {
        parallelProjection: true,
        focalPoint: this.canvasToWorld(n),
        position: [
          0,
          0,
          0
        ],
        viewUp: [
          0,
          -1,
          0
        ],
        parallelScale: this.element.clientHeight / 2 / e,
        viewPlaneNormal: [
          0,
          0,
          1
        ]
      };
    }
    getFrameRate() {
      return this.fps;
    }
    getPan() {
      const e = this.videoCamera.panWorld;
      return [
        e[0],
        e[1]
      ];
    }
    refreshRenderValues() {
      let e = this.canvas.offsetWidth / this.videoWidth;
      this.videoHeight * e > this.canvas.height && (e = this.canvas.offsetHeight / this.videoHeight);
      const n = Math.floor(this.videoWidth * e), r = Math.floor(this.videoHeight * e), i = (this.canvas.offsetWidth - n) / 2, a = (this.canvas.offsetHeight - r) / 2, s = i / e, o = a / e;
      this.videoCamera.panWorld = [
        s,
        o
      ], this.videoCamera.parallelScale = e;
    }
    getWorldToCanvasRatio() {
      return this.videoCamera.parallelScale;
    }
    getCanvasToWorldRatio() {
      return 1 / this.videoCamera.parallelScale;
    }
    getTransform() {
      const e = this.videoCamera.panWorld, n = window.devicePixelRatio || 1, r = this.getWorldToCanvasRatio(), i = this.getCanvasToWorldRatio(), a = [
        this.canvas.offsetWidth / 2,
        this.canvas.offsetHeight / 2
      ], s = [
        a[0] * i,
        a[1] * i
      ], o = new rf();
      return o.scale(n, n), o.translate(a[0], a[1]), o.scale(r, r), o.translate(e[0], e[1]), o.translate(-s[0], -s[1]), o;
    }
    updateCameraClippingPlanesAndRange() {
    }
    addImages(e) {
      const n = this.getActors();
      e.forEach((r) => {
        const i = Ke.getImage(r.imageId), a = this.createActorMapper(i);
        a && (n.push({
          uid: r.actorUID,
          actor: a
        }), r.callback && r.callback({
          imageActor: a,
          imageId: r.imageId
        }));
      }), this.setActors(n);
    }
    createActorMapper(e) {
      return new wse(this, e);
    }
  };
  _Up.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i;
  let Up = _Up;
  const pS = Symbol.for("map"), Cse = "postrender";
  const _Ty = class _Ty extends af {
    constructor(e) {
      super({
        ...e,
        canvas: e.canvas || co(e.element)
      }), this.internalCamera = {
        rotation: 0,
        centerIndex: [
          0,
          0
        ],
        extent: [
          0,
          -2,
          1,
          -1
        ],
        xSpacing: 1,
        ySpacing: 1,
        resolution: 1,
        zoom: 1
      }, this.voiRange = {
        lower: 0,
        upper: 255
      }, this.getProperties = () => ({}), this.resetCamera = () => true, this.getNumberOfSlices = () => 1, this.getFrameOfReferenceUID = () => this.frameOfReferenceUID, this.resize = () => {
        const r = this.canvas, { clientWidth: i, clientHeight: a } = r;
        (r.width !== i || r.height !== a) && (r.width = i, r.height = a), this.refreshRenderValues();
      }, this.canvasToWorld = (r) => {
        if (!this.metadata) return;
        const [i, a] = this.canvasToIndex(r), { origin: s, spacing: o, direction: l } = this.getImageData(), c = Ue(0, 0, 0), f = l.slice(0, 3), u = l.slice(3, 6);
        return Xr(c, s, f, i * o[0]), Xr(c, c, u, a * o[1]), [
          c[0],
          c[1],
          c[2]
        ];
      }, this.worldToCanvas = (r) => {
        if (!this.metadata) return;
        const { spacing: i, direction: a, origin: s } = this.metadata, o = a.slice(0, 3), l = a.slice(3, 6), c = Ft([
          0,
          0,
          0
        ], r, s), f = [
          Bt(c, o) / i[0],
          Bt(c, l) / i[1]
        ];
        return this.indexToCanvas(f);
      }, this.postrender = () => {
        this.refreshRenderValues(), qe(this.element, ze.IMAGE_RENDERED, {
          element: this.element,
          viewportId: this.id,
          viewport: this,
          renderingEngineId: this.renderingEngineId
        });
      }, this.getRotation = () => 0, this.canvasToIndex = (r) => {
        const i = this.getTransform();
        return i.invert(), i.transformPoint(r);
      }, this.indexToCanvas = (r) => this.getTransform().transformPoint(r), this.customRenderViewportToCanvas = () => {
      }, this.renderingEngineId = e.renderingEngineId, this.element.setAttribute("data-viewport-uid", this.id), this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId), this.element.style.position = "relative", this.microscopyElement = document.createElement("div"), this.microscopyElement.id = gi(), this.microscopyElement.innerText = "Initial", this.microscopyElement.style.background = "grey", this.microscopyElement.style.width = "100%", this.microscopyElement.style.height = "100%", this.microscopyElement.style.position = "absolute", this.microscopyElement.style.left = "0", this.microscopyElement.style.top = "0";
      const n = this.element.firstElementChild;
      n.insertBefore(this.microscopyElement, n.childNodes[1]), this.addEventListeners(), this.resize();
    }
    static get useCustomRenderingPipeline() {
      return true;
    }
    addEventListeners() {
      this.canvas.addEventListener(ze.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    removeEventListeners() {
      this.canvas.removeEventListener(ze.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    elementDisabledHandler() {
      this.removeEventListeners();
    }
    getImageDataMetadata(e = 0) {
      var _a3;
      const n = this.metadataDicomweb.reduce((I, O) => (I == null ? void 0 : I.NumberOfFrames) < O.NumberOfFrames ? O : I), { TotalPixelMatrixColumns: r, TotalPixelMatrixRows: i, ImageOrientationSlide: a, ImagedVolumeWidth: s, ImagedVolumeHeight: o, ImagedVolumeDepth: l } = n, c = Ct(ma.IMAGE_PLANE, this.imageIds[e]);
      let f = a.slice(0, 3), u = a.slice(3, 6);
      (f == null || u == null) && (f = [
        1,
        0,
        0
      ], u = [
        0,
        1,
        0
      ]);
      const h = Ue(f[0], f[1], f[2]), g = Ue(u[0], u[1], u[2]), v = He();
      Vr(v, h, g);
      const { XOffsetInSlideCoordinateSystem: m = 0, YOffsetInSlideCoordinateSystem: y = 0, ZOffsetInSlideCoordinateSystem: w = 0 } = ((_a3 = n.TotalPixelMatrixOriginSequence) == null ? void 0 : _a3[0]) || {}, C = [
        m,
        y,
        w
      ], T = s / r, S = o / i, E = r, b = i, D = l, R = 1;
      return this.hasPixelSpacing = !!(s && o), {
        bitsAllocated: 8,
        numComps: 3,
        origin: C,
        direction: [
          ...h,
          ...g,
          ...v
        ],
        dimensions: [
          E,
          b,
          R
        ],
        spacing: [
          T,
          S,
          D
        ],
        hasPixelSpacing: this.hasPixelSpacing,
        numVoxels: E * b * R,
        imagePlaneModule: c
      };
    }
    async setFrameNumber(e) {
    }
    setProperties(e) {
    }
    resetProperties() {
      this.setProperties({});
    }
    getScalarData() {
      return null;
    }
    getImageData() {
      const { metadata: e } = this;
      if (!e) return;
      const { spacing: n } = e;
      return {
        dimensions: e.dimensions,
        spacing: n,
        numComps: 3,
        origin: e.origin,
        direction: e.direction,
        metadata: {
          Modality: this.modality
        },
        getScalarData: () => this.getScalarData(),
        imageData: {
          getDirection: () => e.direction,
          getDimensions: () => e.dimensions,
          getRange: () => [
            0,
            255
          ],
          getScalarData: () => this.getScalarData(),
          getSpacing: () => e.spacing,
          worldToIndex: (r) => {
            const i = this.worldToCanvas(r), a = this.canvasToIndex(i);
            return [
              a[0],
              a[1],
              0
            ];
          },
          indexToWorld: (r) => {
            const i = this.indexToCanvas([
              r[0],
              r[1]
            ]);
            return this.canvasToWorld(i);
          }
        },
        hasPixelSpacing: this.hasPixelSpacing,
        calibration: this.calibration,
        preScale: {
          scaled: false
        }
      };
    }
    hasImageURI(e) {
      return true;
    }
    setCamera(e) {
      const n = this.getCamera(), { parallelScale: r, focalPoint: i } = e, a = this.getView(), { xSpacing: s } = this.internalCamera;
      if (r) {
        const l = this.element.clientHeight / r, c = 1 / s / l;
        a.setResolution(c);
      }
      if (i) {
        const l = this.worldToCanvas(i), c = this.canvasToIndex(l);
        a.setCenter(c);
      }
      const o = this.getCamera();
      this.triggerCameraModifiedEventIfNecessary(n, o);
    }
    getCurrentImageId() {
      return this.imageIds[0];
    }
    getFrameNumber() {
      return 1;
    }
    getCamera() {
      this.refreshRenderValues();
      const { resolution: e, xSpacing: n } = this.internalCamera, r = e * n, i = [
        this.element.clientWidth / 2,
        this.element.clientHeight / 2
      ], a = this.canvasToWorld(i);
      return {
        parallelProjection: true,
        focalPoint: a,
        position: a,
        viewUp: [
          0,
          -1,
          0
        ],
        parallelScale: this.element.clientHeight * r,
        viewPlaneNormal: [
          0,
          0,
          1
        ]
      };
    }
    setDataIds(e) {
      const n = Ct(ma.WADO_WEB_CLIENT, e[0]);
      if (!n) throw new Error(`To use setDataIds on WSI data, you must provide metaData.webClient for ${e[0]}`);
      return this.setWSI(e, n);
    }
    async setWSI(e, n) {
      this.microscopyElement.style.background = "black", this.microscopyElement.innerText = "Loading", this.imageIds = e;
      const r = await _Ty.getDicomMicroscopyViewer();
      this.frameOfReferenceUID = null;
      const i = this.imageIds.map((o) => {
        var _a3, _b3, _c3;
        const l = n.getDICOMwebMetadata(o);
        Object.defineProperty(l, "isMultiframe", {
          value: l.isMultiframe,
          enumerable: false
        }), Object.defineProperty(l, "frameNumber", {
          value: void 0,
          enumerable: false
        });
        const c = (_a3 = l["00080008"]) == null ? void 0 : _a3.Value;
        (c == null ? void 0 : c.length) === 1 && (l["00080008"].Value = c[0].split("\\"));
        const f = (_c3 = (_b3 = l["00200052"]) == null ? void 0 : _b3.Value) == null ? void 0 : _c3[0];
        return this.frameOfReferenceUID ? f !== this.frameOfReferenceUID && (l["00200052"].Value = [
          this.frameOfReferenceUID
        ]) : this.frameOfReferenceUID = f, l;
      }), a = [];
      i.forEach((o) => {
        const l = new r.metadata.VLWholeSlideMicroscopyImage({
          metadata: o
        }), c = l.ImageType[2];
        c === "VOLUME" || c === "THUMBNAIL" ? a.push(l) : console.log("Unknown image type", l.ImageType);
      }), this.metadataDicomweb = a;
      const s = new r.viewer.VolumeImageViewer({
        client: n,
        metadata: a,
        controls: [],
        bindings: {}
      });
      s.render({
        container: this.microscopyElement
      }), this.metadata = this.getImageDataMetadata(), s.deactivateDragPanInteraction(), this.viewer = s, this.map = s[pS], this.map.on(Cse, this.postrender), this.resize(), this.microscopyElement.innerText = "", Object.assign(this.microscopyElement.style, {
        "--ol-partial-background-color": "rgba(127, 127, 127, 0.7)",
        "--ol-foreground-color": "#000000",
        "--ol-subtle-foreground-color": "#000",
        "--ol-subtle-background-color": "rgba(78, 78, 78, 0.5)",
        background: "none"
      });
    }
    scroll(e) {
      const n = this.getCamera();
      this.setCamera({
        parallelScale: n.parallelScale * (1 + 0.1 * e)
      });
    }
    getSliceIndex() {
      return 0;
    }
    getView() {
      if (!this.viewer) return;
      const e = this.viewer[pS], n = window;
      return n.map = e, n.viewer = this.viewer, n.view = e == null ? void 0 : e.getView(), n.wsi = this, e == null ? void 0 : e.getView();
    }
    refreshRenderValues() {
      const e = this.getView();
      if (!e) return;
      const n = e.getResolution();
      if (!n || n < Vl) return;
      const r = e.getCenter(), i = e.getProjection().getExtent(), a = e.getRotation(), s = e.getZoom(), { metadata: { spacing: [o, l] } } = this, c = 1 / n / o;
      Object.assign(this.internalCamera, {
        extent: i,
        centerIndex: r,
        worldToCanvasRatio: c,
        xSpacing: o,
        ySpacing: l,
        resolution: n,
        rotation: a,
        zoom: s
      });
    }
    getZoom() {
      var _a3;
      return (_a3 = this.getView()) == null ? void 0 : _a3.getZoom();
    }
    setZoom(e) {
      var _a3;
      (_a3 = this.getView()) == null ? void 0 : _a3.setZoom(e);
    }
    getTransform() {
      this.refreshRenderValues();
      const { centerIndex: e, resolution: n, rotation: r } = this.internalCamera, i = [
        this.canvas.width / 2,
        this.canvas.height / 2
      ], a = new rf();
      return a.translate(i[0], i[1]), a.rotate(r), a.scale(1 / n, -1 / n), a.translate(-e[0], -e[1]), a;
    }
    getReferenceId() {
      return `imageId:${this.getCurrentImageId()}`;
    }
    getCurrentImageIdIndex() {
      return 0;
    }
  };
  _Ty.getDicomMicroscopyViewer = async () => OK("dicom-microscopy-viewer");
  let Ty = _Ty;
  const FI = {
    [Hn.ORTHOGRAPHIC]: Ba,
    [Hn.PERSPECTIVE]: Ba,
    [Hn.STACK]: bo,
    [Hn.VOLUME_3D]: Cy,
    [Hn.VIDEO]: Up,
    [Hn.WholeSlide]: Ty
  };
  function $0(t) {
    return FI[t].useCustomRenderingPipeline;
  }
  const mS = 2;
  class BI {
    constructor(e) {
      if (this._needsRender = /* @__PURE__ */ new Set(), this._animationFrameSet = false, this._animationFrameHandle = null, this.renderFrameOfReference = (n) => {
        const i = this._getViewportsAsArray().map((a) => {
          if (a.getFrameOfReferenceUID() === n) return a.id;
        });
        return this.renderViewports(i);
      }, this._renderFlaggedViewports = () => {
        this._throwIfDestroyed(), this.useCPURendering || this.performVtkDrawCall();
        const n = this._getViewportsAsArray(), r = [];
        for (let i = 0; i < n.length; i++) {
          const a = n[i];
          if (this._needsRender.has(a.id)) {
            const s = this.renderViewportUsingCustomOrVtkPipeline(a);
            if (r.push(s), a.setRendered(), this._needsRender.delete(a.id), this._needsRender.size === 0) break;
          }
        }
        this._animationFrameSet = false, this._animationFrameHandle = null, r.forEach((i) => {
          (i == null ? void 0 : i.element) && qe(i.element, ze.IMAGE_RENDERED, i);
        });
      }, this.id = e || gi(), this.useCPURendering = uh(), Ch.set(this), !RK()) throw new Error("@cornerstonejs/core is not initialized, run init() first");
      this.useCPURendering || (this.offscreenMultiRenderWindow = dee.newInstance(), this.offScreenCanvasContainer = document.createElement("div"), this.offscreenMultiRenderWindow.setContainer(this.offScreenCanvasContainer)), this._viewports = /* @__PURE__ */ new Map(), this.hasBeenDestroyed = false;
    }
    enableElement(e) {
      const n = this._normalizeViewportInputEntry(e);
      this._throwIfDestroyed();
      const { element: r, viewportId: i } = n;
      if (!r) throw new Error("No element provided");
      this.getViewport(i) && this.disableElement(i);
      const { type: s } = n, o = $0(s);
      !this.useCPURendering && !o ? this.enableVTKjsDrivenViewport(n) : this.addCustomViewport(n);
      const l = co(r), { background: c } = n.defaultOptions;
      this.fillCanvasWithBackgroundColor(l, c);
    }
    disableElement(e) {
      this._throwIfDestroyed();
      const n = this.getViewport(e);
      if (!n) {
        console.warn(`viewport ${e} does not exist`);
        return;
      }
      this._resetViewport(n), !$0(n.type) && !this.useCPURendering && this.offscreenMultiRenderWindow.removeRenderer(e), this._removeViewport(e), n.isDisabled = true, this._needsRender.delete(e), this.getViewports().length || this._clearAnimationFrame();
    }
    setViewports(e) {
      const n = this._normalizeViewportInputEntries(e);
      this._throwIfDestroyed(), this._reset();
      const r = [], i = [];
      n.forEach((a) => {
        !this.useCPURendering && !$0(a.type) ? r.push(a) : i.push(a);
      }), this.setVtkjsDrivenViewports(r), this.setCustomViewports(i), n.forEach((a) => {
        const s = co(a.element), { background: o } = a.defaultOptions;
        this.fillCanvasWithBackgroundColor(s, o);
      });
    }
    resize(e = true, n = true) {
      this._throwIfDestroyed();
      const r = this._getViewportsAsArray(), i = [], a = [];
      r.forEach((s) => {
        $0(s.type) ? a.push(s) : i.push(s);
      }), i.length && this._resizeVTKViewports(i, n, e), a.length && this._resizeUsingCustomResizeHandler(a, n, e);
    }
    getViewport(e) {
      return this._viewports.get(e);
    }
    getViewports() {
      return this._throwIfDestroyed(), this._getViewportsAsArray();
    }
    getStackViewports() {
      this._throwIfDestroyed();
      const e = this.getViewports(), n = (r) => r instanceof bo;
      return e.filter(n);
    }
    getVolumeViewports() {
      this._throwIfDestroyed();
      const e = this.getViewports(), n = (r) => r instanceof Ga;
      return e.filter(n);
    }
    render() {
      const n = this.getViewports().map((r) => r.id);
      this._setViewportsToBeRenderedNextFrame(n);
    }
    renderViewports(e) {
      this._setViewportsToBeRenderedNextFrame(e);
    }
    renderViewport(e) {
      this._setViewportsToBeRenderedNextFrame([
        e
      ]);
    }
    destroy() {
      this.hasBeenDestroyed || (this.useCPURendering || (this._getViewportsAsArray().forEach((n) => {
        this.offscreenMultiRenderWindow.removeRenderer(n.id);
      }), this.offscreenMultiRenderWindow.delete(), delete this.offscreenMultiRenderWindow), this._reset(), Ch.delete(this.id), this.hasBeenDestroyed = true);
    }
    fillCanvasWithBackgroundColor(e, n) {
      const r = e.getContext("2d");
      let i;
      if (n) {
        const a = n.map((s) => Math.floor(255 * s));
        i = `rgb(${a[0]}, ${a[1]}, ${a[2]})`;
      } else i = "black";
      r.fillStyle = i, r.fillRect(0, 0, e.width, e.height);
    }
    _normalizeViewportInputEntry(e) {
      const { type: n, defaultOptions: r } = e;
      let i = r;
      return (!i || Object.keys(i).length === 0) && (i = {
        background: [
          0,
          0,
          0
        ],
        orientation: null,
        displayArea: null
      }, n === Hn.ORTHOGRAPHIC && (i = {
        ...i,
        orientation: vo.AXIAL
      })), {
        ...e,
        defaultOptions: i
      };
    }
    _normalizeViewportInputEntries(e) {
      const n = [];
      return e.forEach((r) => {
        n.push(this._normalizeViewportInputEntry(r));
      }), n;
    }
    _resizeUsingCustomResizeHandler(e, n = true, r = true) {
      e.forEach((i) => {
        typeof i.resize == "function" && i.resize();
      }), e.forEach((i) => {
        const a = i.getCamera();
        i.resetCamera(), n && i.setCamera(a);
      }), r === true && this.render();
    }
    _resizeVTKViewports(e, n = true, r = true) {
      e.forEach((a) => {
        co(a.element);
      });
      const i = e.map((a) => a.canvas);
      if (i.length) {
        const { offScreenCanvasWidth: a, offScreenCanvasHeight: s } = this._resizeOffScreenCanvas(i);
        this._resize(e, a, s);
      }
      e.forEach((a) => {
        const s = a.getCamera(), o = a.getRotation(), { flipHorizontal: l } = s;
        a.resetCamera(true, true, true, false, true);
        const v = a.getDisplayArea();
        n && (v ? (l && a.setCamera({
          flipHorizontal: l
        }), o && a.setProperties({
          rotation: o
        })) : a.setCamera(s));
      }), r === true && this.render();
    }
    enableVTKjsDrivenViewport(e) {
      const r = this._getViewportsAsArray().filter((f) => $0(f.type) === false), i = r.map((f) => f.canvas), a = co(e.element);
      i.push(a);
      const { offScreenCanvasWidth: s, offScreenCanvasHeight: o } = this._resizeOffScreenCanvas(i), l = this._resize(r, s, o), c = {
        ...e,
        canvas: a
      };
      this.addVtkjsDrivenViewport(c, {
        offScreenCanvasWidth: s,
        offScreenCanvasHeight: o,
        xOffset: l
      });
    }
    _removeViewport(e) {
      if (!this.getViewport(e)) {
        console.warn(`viewport ${e} does not exist`);
        return;
      }
      this._viewports.delete(e);
    }
    addVtkjsDrivenViewport(e, n) {
      const { element: r, canvas: i, viewportId: a, type: s, defaultOptions: o } = e;
      r.tabIndex = -1;
      const { offScreenCanvasWidth: l, offScreenCanvasHeight: c, xOffset: f } = n, { sxStartDisplayCoords: u, syStartDisplayCoords: h, sxEndDisplayCoords: g, syEndDisplayCoords: v, sx: m, sy: y, sWidth: w, sHeight: C } = this._getViewportCoordsOnOffScreenCanvas(e, l, c, f);
      this.offscreenMultiRenderWindow.addRenderer({
        viewport: [
          u,
          h,
          g,
          v
        ],
        id: a,
        background: o.background ? o.background : [
          0,
          0,
          0
        ]
      });
      const T = {
        id: a,
        element: r,
        renderingEngineId: this.id,
        type: s,
        canvas: i,
        sx: m,
        sy: y,
        sWidth: w,
        sHeight: C,
        defaultOptions: o || {}
      };
      let S;
      if (s === Hn.STACK) S = new bo(T);
      else if (s === Hn.ORTHOGRAPHIC || s === Hn.PERSPECTIVE) S = new Ba(T);
      else if (s === Hn.VOLUME_3D) S = new Cy(T);
      else throw new Error(`Viewport Type ${s} is not supported`);
      this._viewports.set(a, S);
      const E = {
        element: r,
        viewportId: a,
        renderingEngineId: this.id
      };
      S.suppressEvents || qe(je, ze.ELEMENT_ENABLED, E);
    }
    addCustomViewport(e) {
      const { element: n, viewportId: r, type: i, defaultOptions: a } = e;
      n.tabIndex = -1;
      const s = co(n), { clientWidth: o, clientHeight: l } = s;
      (s.width !== o || s.height !== l) && (s.width = o, s.height = l);
      const c = {
        id: r,
        renderingEngineId: this.id,
        element: n,
        type: i,
        canvas: s,
        sx: 0,
        sy: 0,
        sWidth: o,
        sHeight: l,
        defaultOptions: a || {}
      }, f = FI[i], u = new f(c);
      this._viewports.set(r, u);
      const h = {
        element: n,
        viewportId: r,
        renderingEngineId: this.id
      };
      qe(je, ze.ELEMENT_ENABLED, h);
    }
    setCustomViewports(e) {
      e.forEach((n) => this.addCustomViewport(n));
    }
    setVtkjsDrivenViewports(e) {
      if (e.length) {
        const n = e.map((s) => co(s.element));
        n.forEach((s) => {
          const o = window.devicePixelRatio || 1, l = s.getBoundingClientRect();
          s.width = l.width * o, s.height = l.height * o;
        });
        const { offScreenCanvasWidth: r, offScreenCanvasHeight: i } = this._resizeOffScreenCanvas(n);
        let a = 0;
        for (let s = 0; s < e.length; s++) {
          const o = e[s], l = n[s], c = {
            ...o,
            canvas: l
          };
          this.addVtkjsDrivenViewport(c, {
            offScreenCanvasWidth: r,
            offScreenCanvasHeight: i,
            xOffset: a
          }), a += l.width;
        }
      }
    }
    _resizeOffScreenCanvas(e) {
      const { offScreenCanvasContainer: n, offscreenMultiRenderWindow: r } = this, i = Math.max(...e.map((s) => s.height));
      let a = 0;
      return e.forEach((s) => {
        a += s.width;
      }), n.width = a, n.height = i, r.resize(), {
        offScreenCanvasWidth: a,
        offScreenCanvasHeight: i
      };
    }
    _resize(e, n, r) {
      let i = 0;
      for (let a = 0; a < e.length; a++) {
        const s = e[a], { sxStartDisplayCoords: o, syStartDisplayCoords: l, sxEndDisplayCoords: c, syEndDisplayCoords: f, sx: u, sy: h, sWidth: g, sHeight: v } = this._getViewportCoordsOnOffScreenCanvas(s, n, r, i);
        i += s.canvas.width, s.sx = u, s.sy = h, s.sWidth = g, s.sHeight = v, this.offscreenMultiRenderWindow.getRenderer(s.id).setViewport([
          o,
          l,
          c,
          f
        ]);
      }
      return i;
    }
    _getViewportCoordsOnOffScreenCanvas(e, n, r, i) {
      const { canvas: a } = e, { width: s, height: o } = a, l = i, c = 0, f = l / n, u = c + (r - o) / r, h = s / n, g = o / r;
      return {
        sxStartDisplayCoords: f,
        syStartDisplayCoords: u,
        sxEndDisplayCoords: f + h,
        syEndDisplayCoords: u + g,
        sx: l,
        sy: c,
        sWidth: s,
        sHeight: o
      };
    }
    _getViewportsAsArray() {
      return Array.from(this._viewports.values());
    }
    _setViewportsToBeRenderedNextFrame(e) {
      e.forEach((n) => {
        this._needsRender.add(n);
      }), this._render();
    }
    _render() {
      this._needsRender.size > 0 && this._animationFrameSet === false && (this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports), this._animationFrameSet = true);
    }
    performVtkDrawCall() {
      const { offscreenMultiRenderWindow: e } = this, n = e.getRenderWindow(), r = e.getRenderers();
      if (r.length) {
        for (let i = 0; i < r.length; i++) {
          const { renderer: a, id: s } = r[i];
          this._needsRender.has(s) ? a.setDraw(true) : a.setDraw(false);
        }
        n.render();
        for (let i = 0; i < r.length; i++) r[i].renderer.setDraw(false);
      }
    }
    renderViewportUsingCustomOrVtkPipeline(e) {
      let n;
      if (e.sWidth < mS || e.sHeight < mS) {
        console.warn("Viewport is too small", e.sWidth, e.sHeight);
        return;
      }
      if ($0(e.type) === true) n = e.customRenderViewportToCanvas();
      else {
        if (this.useCPURendering) throw new Error("GPU not available, and using a viewport with no custom render pipeline.");
        const { offscreenMultiRenderWindow: r } = this, s = r.getOpenGLRenderWindow().get3DContext().canvas;
        n = this._renderViewportFromVtkCanvasToOnscreenCanvas(e, s);
      }
      return n;
    }
    _renderViewportFromVtkCanvasToOnscreenCanvas(e, n) {
      const { element: r, canvas: i, sx: a, sy: s, sWidth: o, sHeight: l, id: c, renderingEngineId: f, suppressEvents: u } = e, { width: h, height: g } = i;
      return i.getContext("2d").drawImage(n, a, s, o, l, 0, 0, h, g), {
        element: r,
        suppressEvents: u,
        viewportId: c,
        renderingEngineId: f,
        viewportStatus: e.viewportStatus
      };
    }
    _resetViewport(e) {
      const n = this.id, { element: r, canvas: i, id: a } = e, s = {
        element: r,
        viewportId: a,
        renderingEngineId: n
      };
      e.removeWidgets(), qe(je, ze.ELEMENT_DISABLED, s), r.removeAttribute("data-viewport-uid"), r.removeAttribute("data-rendering-engine-uid"), i.getContext("2d").clearRect(0, 0, i.width, i.height);
    }
    _clearAnimationFrame() {
      window.cancelAnimationFrame(this._animationFrameHandle), this._needsRender.clear(), this._animationFrameSet = false, this._animationFrameHandle = null;
    }
    _reset() {
      this._getViewportsAsArray().forEach((n) => {
        this._resetViewport(n);
      }), this._clearAnimationFrame(), this._viewports = /* @__PURE__ */ new Map();
    }
    _throwIfDestroyed() {
      if (this.hasBeenDestroyed) throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
    }
    _downloadOffScreenCanvas() {
      const e = this._debugRender();
      Tse(e);
    }
    _debugRender() {
      const { offscreenMultiRenderWindow: e } = this, n = e.getRenderWindow(), r = e.getRenderers();
      for (let l = 0; l < r.length; l++) r[l].renderer.setDraw(true);
      n.render();
      const s = e.getOpenGLRenderWindow().get3DContext().canvas, o = s.toDataURL();
      return this._getViewportsAsArray().forEach((l) => {
        const { sx: c, sy: f, sWidth: u, sHeight: h } = l, g = l.canvas, { width: v, height: m } = g;
        g.getContext("2d").drawImage(s, c, f, u, h, 0, 0, v, m);
      }), o;
    }
  }
  function Tse(t) {
    const e = document.createElement("a");
    e.download = "viewport.png", e.href = t, document.body.appendChild(e), e.click(), document.body.removeChild(e);
  }
  const vS = Symbol("DefaultSettings"), yS = Symbol("RuntimeSettings"), xS = Symbol("ObjectSettingsMap"), io = Symbol("Dictionary");
  class Pn {
    constructor(e) {
      const n = Object.create(e instanceof Pn && io in e ? e[io] : null);
      Object.seal(Object.defineProperty(this, io, {
        value: n
      }));
    }
    set(e, n) {
      return Fp(this[io], e, n, null);
    }
    get(e) {
      return Ese(this[io], e);
    }
    unset(e) {
      return Sse(this[io], e + "");
    }
    forEach(e) {
      wS(this[io], e);
    }
    extend() {
      return new Pn(this);
    }
    import(e) {
      _I(e) && Object.keys(e).forEach((n) => {
        Fp(this[io], n, e[n], null);
      });
    }
    dump() {
      const e = {};
      return wS(this[io], (n, r) => {
        typeof r < "u" && kI(e, n, r);
      }), e;
    }
    static assert(e) {
      return e instanceof Pn ? e : Pn.getRuntimeSettings();
    }
    static getDefaultSettings(e = null) {
      let n = Pn[vS];
      if (n instanceof Pn || (n = new Pn(), Pn[vS] = n), e) {
        const r = {};
        return n.forEach((i) => {
          if (i.startsWith(e)) {
            const a = i.split(`${e}.`)[1];
            r[a] = n.get(i);
          }
        }), r;
      }
      return n;
    }
    static getRuntimeSettings() {
      let e = Pn[yS];
      return e instanceof Pn || (e = new Pn(Pn.getDefaultSettings()), Pn[yS] = e), e;
    }
    static getObjectSettings(e, n) {
      let r = null;
      if (e instanceof Pn) r = e;
      else if (typeof e == "object" && e !== null) {
        let i = Pn[xS];
        i instanceof WeakMap || (i = /* @__PURE__ */ new WeakMap(), Pn[xS] = i), r = i.get(e), r instanceof Pn || (r = new Pn(Pn.assert(Pn.getObjectSettings(n))), i.set(e, r));
      }
      return r;
    }
    static extendRuntimeSettings() {
      return Pn.getRuntimeSettings().extend();
    }
  }
  function Sse(t, e) {
    if (e.endsWith(".")) {
      let n = 0;
      const r = e, i = r.slice(0, -1), a = i.length === 0;
      for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (a || s.startsWith(r) || s === i) && (delete t[s], ++n);
      return n > 0;
    }
    return delete t[e];
  }
  function wS(t, e) {
    for (const n in t) e(n, t[n]);
  }
  function Ase(t, e, n, r) {
    let i;
    if (r.has(n)) return Fp(t, e, null, r);
    r.add(n), i = 0;
    for (const a in n) if (Object.prototype.hasOwnProperty.call(n, a)) {
      const s = a.length === 0 ? e : `${e}.${a}`;
      Fp(t, s, n[a], r) || ++i;
    }
    return r.delete(n), i === 0;
  }
  function Fp(t, e, n, r) {
    return bse(e) ? _I(n) ? Ase(t, e, n, r instanceof WeakSet ? r : /* @__PURE__ */ new WeakSet()) : (t[e] = n, true) : false;
  }
  function Ese(t, e) {
    return t[e];
  }
  function bse(t) {
    let e, n, r;
    if (typeof t != "string" || (e = t.length - 1) < 0) return false;
    for (r = -1; (n = t.indexOf(".", r + 1)) >= 0; ) {
      if (n - r < 2 || n === e) return false;
      r = n;
    }
    return true;
  }
  function _I(t) {
    if (typeof t == "object" && t !== null) {
      const e = Object.getPrototypeOf(t);
      if (e === Object.prototype || e === null) return true;
    }
    return false;
  }
  function kI(t, e, n) {
    const r = e.indexOf(".");
    if (r >= 0) {
      const i = e.slice(0, r);
      let a = t[i];
      if (typeof a != "object" || a === null) {
        const s = a;
        a = {}, typeof s < "u" && (a[""] = s), t[i] = a;
      }
      kI(a, e.slice(r + 1, e.length), n);
    } else t[e] = n;
  }
  Pn.getDefaultSettings().set("useCursors", true);
  function Hg(t, e) {
    return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function Dse(t, e) {
    return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
  }
  function PI(t) {
    let e, n, r;
    t.length !== 2 ? (e = Hg, n = (o, l) => Hg(t(o), l), r = (o, l) => t(o) - l) : (e = t === Hg || t === Dse ? t : Mse, n = t, r = t);
    function i(o, l, c = 0, f = o.length) {
      if (c < f) {
        if (e(l, l) !== 0) return f;
        do {
          const u = c + f >>> 1;
          n(o[u], l) < 0 ? c = u + 1 : f = u;
        } while (c < f);
      }
      return c;
    }
    function a(o, l, c = 0, f = o.length) {
      if (c < f) {
        if (e(l, l) !== 0) return f;
        do {
          const u = c + f >>> 1;
          n(o[u], l) <= 0 ? c = u + 1 : f = u;
        } while (c < f);
      }
      return c;
    }
    function s(o, l, c = 0, f = o.length) {
      const u = i(o, l, c, f - 1);
      return u > c && r(o[u - 1], l) > -r(o[u], l) ? u - 1 : u;
    }
    return {
      left: i,
      center: s,
      right: a
    };
  }
  function Mse() {
    return 0;
  }
  function Rse(t) {
    return t === null ? NaN : +t;
  }
  const Ose = PI(Hg), Ise = Ose.right;
  PI(Rse).center;
  const Vse = Math.sqrt(50), Nse = Math.sqrt(10), Lse = Math.sqrt(2);
  function Bp(t, e, n) {
    const r = (e - t) / Math.max(0, n), i = Math.floor(Math.log10(r)), a = r / Math.pow(10, i), s = a >= Vse ? 10 : a >= Nse ? 5 : a >= Lse ? 2 : 1;
    let o, l, c;
    return i < 0 ? (c = Math.pow(10, -i) / s, o = Math.round(t * c), l = Math.round(e * c), o / c < t && ++o, l / c > e && --l, c = -c) : (c = Math.pow(10, i) * s, o = Math.round(t / c), l = Math.round(e / c), o * c < t && ++o, l * c > e && --l), l < o && 0.5 <= n && n < 2 ? Bp(t, e, n * 2) : [
      o,
      l,
      c
    ];
  }
  function Use(t, e, n) {
    if (e = +e, t = +t, n = +n, !(n > 0)) return [];
    if (t === e) return [
      t
    ];
    const r = e < t, [i, a, s] = r ? Bp(e, t, n) : Bp(t, e, n);
    if (!(a >= i)) return [];
    const o = a - i + 1, l = new Array(o);
    if (r) if (s < 0) for (let c = 0; c < o; ++c) l[c] = (a - c) / -s;
    else for (let c = 0; c < o; ++c) l[c] = (a - c) * s;
    else if (s < 0) for (let c = 0; c < o; ++c) l[c] = (i + c) / -s;
    else for (let c = 0; c < o; ++c) l[c] = (i + c) * s;
    return l;
  }
  function C6(t, e, n) {
    return e = +e, t = +t, n = +n, Bp(t, e, n)[2];
  }
  function Fse(t, e, n) {
    e = +e, t = +t, n = +n;
    const r = e < t, i = r ? C6(e, t, n) : C6(t, e, n);
    return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
  }
  function Bse(t, e) {
    let n;
    if (e === void 0) for (const r of t) r != null && (n > r || n === void 0 && r >= r) && (n = r);
    else {
      let r = -1;
      for (let i of t) (i = e(i, ++r, t)) != null && (n > i || n === void 0 && i >= i) && (n = i);
    }
    return n;
  }
  function _se(t) {
    if (!(a = t.length)) return [];
    for (var e = -1, n = Bse(t, kse), r = new Array(n); ++e < n; ) for (var i = -1, a, s = r[e] = new Array(a); ++i < a; ) s[i] = t[i][e];
    return r;
  }
  function kse(t) {
    return t.length;
  }
  function CS() {
    return _se(arguments);
  }
  function Pse(t, e) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(t);
        break;
      default:
        this.range(e).domain(t);
        break;
    }
    return this;
  }
  function Sy(t, e, n) {
    t.prototype = e.prototype = n, n.constructor = t;
  }
  function GI(t, e) {
    var n = Object.create(t.prototype);
    for (var r in e) n[r] = e[r];
    return n;
  }
  function sd() {
  }
  var Rh = 0.7, _p = 1 / Rh, Tu = "\\s*([+-]?\\d+)\\s*", Oh = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Os = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Gse = /^#([0-9a-f]{3,8})$/, zse = new RegExp(`^rgb\\(${Tu},${Tu},${Tu}\\)$`), Wse = new RegExp(`^rgb\\(${Os},${Os},${Os}\\)$`), Hse = new RegExp(`^rgba\\(${Tu},${Tu},${Tu},${Oh}\\)$`), jse = new RegExp(`^rgba\\(${Os},${Os},${Os},${Oh}\\)$`), Kse = new RegExp(`^hsl\\(${Oh},${Os},${Os}\\)$`), Yse = new RegExp(`^hsla\\(${Oh},${Os},${Os},${Oh}\\)$`), TS = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  Sy(sd, Ih, {
    copy(t) {
      return Object.assign(new this.constructor(), this, t);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: SS,
    formatHex: SS,
    formatHex8: qse,
    formatHsl: Xse,
    formatRgb: AS,
    toString: AS
  });
  function SS() {
    return this.rgb().formatHex();
  }
  function qse() {
    return this.rgb().formatHex8();
  }
  function Xse() {
    return zI(this).formatHsl();
  }
  function AS() {
    return this.rgb().formatRgb();
  }
  function Ih(t) {
    var e, n;
    return t = (t + "").trim().toLowerCase(), (e = Gse.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? ES(e) : n === 3 ? new Ji(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? q2(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? q2(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = zse.exec(t)) ? new Ji(e[1], e[2], e[3], 1) : (e = Wse.exec(t)) ? new Ji(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Hse.exec(t)) ? q2(e[1], e[2], e[3], e[4]) : (e = jse.exec(t)) ? q2(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = Kse.exec(t)) ? MS(e[1], e[2] / 100, e[3] / 100, 1) : (e = Yse.exec(t)) ? MS(e[1], e[2] / 100, e[3] / 100, e[4]) : TS.hasOwnProperty(t) ? ES(TS[t]) : t === "transparent" ? new Ji(NaN, NaN, NaN, 0) : null;
  }
  function ES(t) {
    return new Ji(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
  }
  function q2(t, e, n, r) {
    return r <= 0 && (t = e = n = NaN), new Ji(t, e, n, r);
  }
  function Zse(t) {
    return t instanceof sd || (t = Ih(t)), t ? (t = t.rgb(), new Ji(t.r, t.g, t.b, t.opacity)) : new Ji();
  }
  function T6(t, e, n, r) {
    return arguments.length === 1 ? Zse(t) : new Ji(t, e, n, r ?? 1);
  }
  function Ji(t, e, n, r) {
    this.r = +t, this.g = +e, this.b = +n, this.opacity = +r;
  }
  Sy(Ji, T6, GI(sd, {
    brighter(t) {
      return t = t == null ? _p : Math.pow(_p, t), new Ji(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    darker(t) {
      return t = t == null ? Rh : Math.pow(Rh, t), new Ji(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Ji(_c(this.r), _c(this.g), _c(this.b), kp(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: bS,
    formatHex: bS,
    formatHex8: Qse,
    formatRgb: DS,
    toString: DS
  }));
  function bS() {
    return `#${Uc(this.r)}${Uc(this.g)}${Uc(this.b)}`;
  }
  function Qse() {
    return `#${Uc(this.r)}${Uc(this.g)}${Uc(this.b)}${Uc((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function DS() {
    const t = kp(this.opacity);
    return `${t === 1 ? "rgb(" : "rgba("}${_c(this.r)}, ${_c(this.g)}, ${_c(this.b)}${t === 1 ? ")" : `, ${t})`}`;
  }
  function kp(t) {
    return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
  }
  function _c(t) {
    return Math.max(0, Math.min(255, Math.round(t) || 0));
  }
  function Uc(t) {
    return t = _c(t), (t < 16 ? "0" : "") + t.toString(16);
  }
  function MS(t, e, n, r) {
    return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new is(t, e, n, r);
  }
  function zI(t) {
    if (t instanceof is) return new is(t.h, t.s, t.l, t.opacity);
    if (t instanceof sd || (t = Ih(t)), !t) return new is();
    if (t instanceof is) return t;
    t = t.rgb();
    var e = t.r / 255, n = t.g / 255, r = t.b / 255, i = Math.min(e, n, r), a = Math.max(e, n, r), s = NaN, o = a - i, l = (a + i) / 2;
    return o ? (e === a ? s = (n - r) / o + (n < r) * 6 : n === a ? s = (r - e) / o + 2 : s = (e - n) / o + 4, o /= l < 0.5 ? a + i : 2 - a - i, s *= 60) : o = l > 0 && l < 1 ? 0 : s, new is(s, o, l, t.opacity);
  }
  function Jse(t, e, n, r) {
    return arguments.length === 1 ? zI(t) : new is(t, e, n, r ?? 1);
  }
  function is(t, e, n, r) {
    this.h = +t, this.s = +e, this.l = +n, this.opacity = +r;
  }
  Sy(is, Jse, GI(sd, {
    brighter(t) {
      return t = t == null ? _p : Math.pow(_p, t), new is(this.h, this.s, this.l * t, this.opacity);
    },
    darker(t) {
      return t = t == null ? Rh : Math.pow(Rh, t), new is(this.h, this.s, this.l * t, this.opacity);
    },
    rgb() {
      var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * e, i = 2 * n - r;
      return new Ji($4(t >= 240 ? t - 240 : t + 120, i, r), $4(t, i, r), $4(t < 120 ? t + 240 : t - 120, i, r), this.opacity);
    },
    clamp() {
      return new is(RS(this.h), X2(this.s), X2(this.l), kp(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const t = kp(this.opacity);
      return `${t === 1 ? "hsl(" : "hsla("}${RS(this.h)}, ${X2(this.s) * 100}%, ${X2(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
    }
  }));
  function RS(t) {
    return t = (t || 0) % 360, t < 0 ? t + 360 : t;
  }
  function X2(t) {
    return Math.max(0, Math.min(1, t || 0));
  }
  function $4(t, e, n) {
    return (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) * 255;
  }
  function $se(t, e, n, r, i) {
    var a = t * t, s = a * t;
    return ((1 - 3 * t + 3 * a - s) * e + (4 - 6 * a + 3 * s) * n + (1 + 3 * t + 3 * a - 3 * s) * r + s * i) / 6;
  }
  function ev(t) {
    var e = t.length - 1;
    return function(n) {
      var r = n <= 0 ? n = 0 : n >= 1 ? (n = 1, e - 1) : Math.floor(n * e), i = t[r], a = t[r + 1], s = r > 0 ? t[r - 1] : 2 * i - a, o = r < e - 1 ? t[r + 2] : 2 * a - i;
      return $se((n - r / e) * e, s, i, a, o);
    };
  }
  const Ay = (t) => () => t;
  function eoe(t, e) {
    return function(n) {
      return t + n * e;
    };
  }
  function toe(t, e, n) {
    return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function(r) {
      return Math.pow(t + r * e, n);
    };
  }
  function noe(t) {
    return (t = +t) == 1 ? WI : function(e, n) {
      return n - e ? toe(e, n, t) : Ay(isNaN(e) ? n : e);
    };
  }
  function WI(t, e) {
    var n = e - t;
    return n ? eoe(t, n) : Ay(isNaN(t) ? e : t);
  }
  const OS = (function t(e) {
    var n = noe(e);
    function r(i, a) {
      var s = n((i = T6(i)).r, (a = T6(a)).r), o = n(i.g, a.g), l = n(i.b, a.b), c = WI(i.opacity, a.opacity);
      return function(f) {
        return i.r = s(f), i.g = o(f), i.b = l(f), i.opacity = c(f), i + "";
      };
    }
    return r.gamma = t, r;
  })(1);
  function roe(t, e) {
    e || (e = []);
    var n = t ? Math.min(e.length, t.length) : 0, r = e.slice(), i;
    return function(a) {
      for (i = 0; i < n; ++i) r[i] = t[i] * (1 - a) + e[i] * a;
      return r;
    };
  }
  function ioe(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  }
  function aoe(t, e) {
    var n = e ? e.length : 0, r = t ? Math.min(n, t.length) : 0, i = new Array(r), a = new Array(n), s;
    for (s = 0; s < r; ++s) i[s] = Ey(t[s], e[s]);
    for (; s < n; ++s) a[s] = e[s];
    return function(o) {
      for (s = 0; s < r; ++s) a[s] = i[s](o);
      return a;
    };
  }
  function soe(t, e) {
    var n = /* @__PURE__ */ new Date();
    return t = +t, e = +e, function(r) {
      return n.setTime(t * (1 - r) + e * r), n;
    };
  }
  function Pp(t, e) {
    return t = +t, e = +e, function(n) {
      return t * (1 - n) + e * n;
    };
  }
  function ooe(t, e) {
    var n = {}, r = {}, i;
    (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
    for (i in e) i in t ? n[i] = Ey(t[i], e[i]) : r[i] = e[i];
    return function(a) {
      for (i in n) r[i] = n[i](a);
      return r;
    };
  }
  var S6 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, tv = new RegExp(S6.source, "g");
  function loe(t) {
    return function() {
      return t;
    };
  }
  function coe(t) {
    return function(e) {
      return t(e) + "";
    };
  }
  function uoe(t, e) {
    var n = S6.lastIndex = tv.lastIndex = 0, r, i, a, s = -1, o = [], l = [];
    for (t = t + "", e = e + ""; (r = S6.exec(t)) && (i = tv.exec(e)); ) (a = i.index) > n && (a = e.slice(n, a), o[s] ? o[s] += a : o[++s] = a), (r = r[0]) === (i = i[0]) ? o[s] ? o[s] += i : o[++s] = i : (o[++s] = null, l.push({
      i: s,
      x: Pp(r, i)
    })), n = tv.lastIndex;
    return n < e.length && (a = e.slice(n), o[s] ? o[s] += a : o[++s] = a), o.length < 2 ? l[0] ? coe(l[0].x) : loe(e) : (e = l.length, function(c) {
      for (var f = 0, u; f < e; ++f) o[(u = l[f]).i] = u.x(c);
      return o.join("");
    });
  }
  function Ey(t, e) {
    var n = typeof e, r;
    return e == null || n === "boolean" ? Ay(e) : (n === "number" ? Pp : n === "string" ? (r = Ih(e)) ? (e = r, OS) : uoe : e instanceof Ih ? OS : e instanceof Date ? soe : ioe(e) ? roe : Array.isArray(e) ? aoe : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? ooe : Pp)(t, e);
  }
  function foe(t, e) {
    return t = +t, e = +e, function(n) {
      return Math.round(t * (1 - n) + e * n);
    };
  }
  function S1(t, e) {
    for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t(r / (e - 1));
    return n;
  }
  function hoe(t) {
    return function() {
      return t;
    };
  }
  function doe(t) {
    return +t;
  }
  var IS = [
    0,
    1
  ];
  function hu(t) {
    return t;
  }
  function A6(t, e) {
    return (e -= t = +t) ? function(n) {
      return (n - t) / e;
    } : hoe(isNaN(e) ? NaN : 0.5);
  }
  function goe(t, e) {
    var n;
    return t > e && (n = t, t = e, e = n), function(r) {
      return Math.max(t, Math.min(e, r));
    };
  }
  function poe(t, e, n) {
    var r = t[0], i = t[1], a = e[0], s = e[1];
    return i < r ? (r = A6(i, r), a = n(s, a)) : (r = A6(r, i), a = n(a, s)), function(o) {
      return a(r(o));
    };
  }
  function moe(t, e, n) {
    var r = Math.min(t.length, e.length) - 1, i = new Array(r), a = new Array(r), s = -1;
    for (t[r] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < r; ) i[s] = A6(t[s], t[s + 1]), a[s] = n(e[s], e[s + 1]);
    return function(o) {
      var l = Ise(t, o, 1, r) - 1;
      return a[l](i[l](o));
    };
  }
  function voe(t, e) {
    return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
  }
  function yoe() {
    var t = IS, e = IS, n = Ey, r, i, a, s = hu, o, l, c;
    function f() {
      var h = Math.min(t.length, e.length);
      return s !== hu && (s = goe(t[0], t[h - 1])), o = h > 2 ? moe : poe, l = c = null, u;
    }
    function u(h) {
      return h == null || isNaN(h = +h) ? a : (l || (l = o(t.map(r), e, n)))(r(s(h)));
    }
    return u.invert = function(h) {
      return s(i((c || (c = o(e, t.map(r), Pp)))(h)));
    }, u.domain = function(h) {
      return arguments.length ? (t = Array.from(h, doe), f()) : t.slice();
    }, u.range = function(h) {
      return arguments.length ? (e = Array.from(h), f()) : e.slice();
    }, u.rangeRound = function(h) {
      return e = Array.from(h), n = foe, f();
    }, u.clamp = function(h) {
      return arguments.length ? (s = h ? true : hu, f()) : s !== hu;
    }, u.interpolate = function(h) {
      return arguments.length ? (n = h, f()) : n;
    }, u.unknown = function(h) {
      return arguments.length ? (a = h, u) : a;
    }, function(h, g) {
      return r = h, i = g, f();
    };
  }
  function xoe() {
    return yoe()(hu, hu);
  }
  function woe(t) {
    return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
  }
  function Gp(t, e) {
    if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
    var n, r = t.slice(0, n);
    return [
      r.length > 1 ? r[0] + r.slice(2) : r,
      +t.slice(n + 1)
    ];
  }
  function Fu(t) {
    return t = Gp(Math.abs(t)), t ? t[1] : NaN;
  }
  function Coe(t, e) {
    return function(n, r) {
      for (var i = n.length, a = [], s = 0, o = t[0], l = 0; i > 0 && o > 0 && (l + o + 1 > r && (o = Math.max(1, r - l)), a.push(n.substring(i -= o, i + o)), !((l += o + 1) > r)); ) o = t[s = (s + 1) % t.length];
      return a.reverse().join(e);
    };
  }
  function Toe(t) {
    return function(e) {
      return e.replace(/[0-9]/g, function(n) {
        return t[+n];
      });
    };
  }
  var Soe = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function zp(t) {
    if (!(e = Soe.exec(t))) throw new Error("invalid format: " + t);
    var e;
    return new by({
      fill: e[1],
      align: e[2],
      sign: e[3],
      symbol: e[4],
      zero: e[5],
      width: e[6],
      comma: e[7],
      precision: e[8] && e[8].slice(1),
      trim: e[9],
      type: e[10]
    });
  }
  zp.prototype = by.prototype;
  function by(t) {
    this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
  }
  by.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };
  function Aoe(t) {
    e: for (var e = t.length, n = 1, r = -1, i; n < e; ++n) switch (t[n]) {
      case ".":
        r = i = n;
        break;
      case "0":
        r === 0 && (r = n), i = n;
        break;
      default:
        if (!+t[n]) break e;
        r > 0 && (r = 0);
        break;
    }
    return r > 0 ? t.slice(0, r) + t.slice(i + 1) : t;
  }
  var HI;
  function Eoe(t, e) {
    var n = Gp(t, e);
    if (!n) return t + "";
    var r = n[0], i = n[1], a = i - (HI = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, s = r.length;
    return a === s ? r : a > s ? r + new Array(a - s + 1).join("0") : a > 0 ? r.slice(0, a) + "." + r.slice(a) : "0." + new Array(1 - a).join("0") + Gp(t, Math.max(0, e + a - 1))[0];
  }
  function VS(t, e) {
    var n = Gp(t, e);
    if (!n) return t + "";
    var r = n[0], i = n[1];
    return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
  }
  const NS = {
    "%": (t, e) => (t * 100).toFixed(e),
    b: (t) => Math.round(t).toString(2),
    c: (t) => t + "",
    d: woe,
    e: (t, e) => t.toExponential(e),
    f: (t, e) => t.toFixed(e),
    g: (t, e) => t.toPrecision(e),
    o: (t) => Math.round(t).toString(8),
    p: (t, e) => VS(t * 100, e),
    r: VS,
    s: Eoe,
    X: (t) => Math.round(t).toString(16).toUpperCase(),
    x: (t) => Math.round(t).toString(16)
  };
  function LS(t) {
    return t;
  }
  var US = Array.prototype.map, FS = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "\xB5",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
  ];
  function boe(t) {
    var e = t.grouping === void 0 || t.thousands === void 0 ? LS : Coe(US.call(t.grouping, Number), t.thousands + ""), n = t.currency === void 0 ? "" : t.currency[0] + "", r = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", a = t.numerals === void 0 ? LS : Toe(US.call(t.numerals, String)), s = t.percent === void 0 ? "%" : t.percent + "", o = t.minus === void 0 ? "\u2212" : t.minus + "", l = t.nan === void 0 ? "NaN" : t.nan + "";
    function c(u) {
      u = zp(u);
      var h = u.fill, g = u.align, v = u.sign, m = u.symbol, y = u.zero, w = u.width, C = u.comma, T = u.precision, S = u.trim, E = u.type;
      E === "n" ? (C = true, E = "g") : NS[E] || (T === void 0 && (T = 12), S = true, E = "g"), (y || h === "0" && g === "=") && (y = true, h = "0", g = "=");
      var b = m === "$" ? n : m === "#" && /[boxX]/.test(E) ? "0" + E.toLowerCase() : "", D = m === "$" ? r : /[%p]/.test(E) ? s : "", R = NS[E], I = /[defgprs%]/.test(E);
      T = T === void 0 ? 6 : /[gprs]/.test(E) ? Math.max(1, Math.min(21, T)) : Math.max(0, Math.min(20, T));
      function O(L) {
        var N = b, F = D, V, k, _;
        if (E === "c") F = R(L) + F, L = "";
        else {
          L = +L;
          var K = L < 0 || 1 / L < 0;
          if (L = isNaN(L) ? l : R(Math.abs(L), T), S && (L = Aoe(L)), K && +L == 0 && v !== "+" && (K = false), N = (K ? v === "(" ? v : o : v === "-" || v === "(" ? "" : v) + N, F = (E === "s" ? FS[8 + HI / 3] : "") + F + (K && v === "(" ? ")" : ""), I) {
            for (V = -1, k = L.length; ++V < k; ) if (_ = L.charCodeAt(V), 48 > _ || _ > 57) {
              F = (_ === 46 ? i + L.slice(V + 1) : L.slice(V)) + F, L = L.slice(0, V);
              break;
            }
          }
        }
        C && !y && (L = e(L, 1 / 0));
        var Z = N.length + L.length + F.length, j = Z < w ? new Array(w - Z + 1).join(h) : "";
        switch (C && y && (L = e(j + L, j.length ? w - F.length : 1 / 0), j = ""), g) {
          case "<":
            L = N + L + F + j;
            break;
          case "=":
            L = N + j + L + F;
            break;
          case "^":
            L = j.slice(0, Z = j.length >> 1) + N + L + F + j.slice(Z);
            break;
          default:
            L = j + N + L + F;
            break;
        }
        return a(L);
      }
      return O.toString = function() {
        return u + "";
      }, O;
    }
    function f(u, h) {
      var g = c((u = zp(u), u.type = "f", u)), v = Math.max(-8, Math.min(8, Math.floor(Fu(h) / 3))) * 3, m = Math.pow(10, -v), y = FS[8 + v / 3];
      return function(w) {
        return g(m * w) + y;
      };
    }
    return {
      format: c,
      formatPrefix: f
    };
  }
  var Z2, jI, KI;
  Doe({
    thousands: ",",
    grouping: [
      3
    ],
    currency: [
      "$",
      ""
    ]
  });
  function Doe(t) {
    return Z2 = boe(t), jI = Z2.format, KI = Z2.formatPrefix, Z2;
  }
  function Moe(t) {
    return Math.max(0, -Fu(Math.abs(t)));
  }
  function Roe(t, e) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Fu(e) / 3))) * 3 - Fu(Math.abs(t)));
  }
  function Ooe(t, e) {
    return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, Fu(e) - Fu(t)) + 1;
  }
  function Ioe(t, e, n, r) {
    var i = Fse(t, e, n), a;
    switch (r = zp(r ?? ",f"), r.type) {
      case "s": {
        var s = Math.max(Math.abs(t), Math.abs(e));
        return r.precision == null && !isNaN(a = Roe(i, s)) && (r.precision = a), KI(r, s);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        r.precision == null && !isNaN(a = Ooe(i, Math.max(Math.abs(t), Math.abs(e)))) && (r.precision = a - (r.type === "e"));
        break;
      }
      case "f":
      case "%": {
        r.precision == null && !isNaN(a = Moe(i)) && (r.precision = a - (r.type === "%") * 2);
        break;
      }
    }
    return jI(r);
  }
  function Voe(t) {
    var e = t.domain;
    return t.ticks = function(n) {
      var r = e();
      return Use(r[0], r[r.length - 1], n ?? 10);
    }, t.tickFormat = function(n, r) {
      var i = e();
      return Ioe(i[0], i[i.length - 1], n ?? 10, r);
    }, t.nice = function(n) {
      n == null && (n = 10);
      var r = e(), i = 0, a = r.length - 1, s = r[i], o = r[a], l, c, f = 10;
      for (o < s && (c = s, s = o, o = c, c = i, i = a, a = c); f-- > 0; ) {
        if (c = C6(s, o, n), c === l) return r[i] = s, r[a] = o, e(r);
        if (c > 0) s = Math.floor(s / c) * c, o = Math.ceil(o / c) * c;
        else if (c < 0) s = Math.ceil(s * c) / c, o = Math.floor(o * c) / c;
        else break;
        l = c;
      }
      return t;
    }, t;
  }
  function Dy() {
    var t = xoe();
    return t.copy = function() {
      return voe(t, Dy());
    }, Pse.apply(t, arguments), Voe(t);
  }
  function Noe(t, e) {
    e.classHierarchy.push("vtkTexture"), t.imageLoaded = () => {
      e.image.removeEventListener("load", t.imageLoaded), e.imageLoaded = true, t.modified();
    }, t.setJsImageData = (n) => {
      e.jsImageData !== n && (n !== null && (t.setInputData(null), t.setInputConnection(null), e.image = null, e.canvas = null), e.jsImageData = n, e.imageLoaded = true, t.modified());
    }, t.setCanvas = (n) => {
      e.canvas !== n && (n !== null && (t.setInputData(null), t.setInputConnection(null), e.image = null, e.jsImageData = null), e.canvas = n, t.modified());
    }, t.setImage = (n) => {
      e.image !== n && (n !== null && (t.setInputData(null), t.setInputConnection(null), e.canvas = null, e.jsImageData = null), e.image = n, e.imageLoaded = false, n.complete ? t.imageLoaded() : n.addEventListener("load", t.imageLoaded), t.modified());
    }, t.getDimensionality = () => {
      let n = 0, r = 0, i = 1;
      if (t.getInputData()) {
        const s = t.getInputData();
        n = s.getDimensions()[0], r = s.getDimensions()[1], i = s.getDimensions()[2];
      }
      return e.jsImageData && (n = e.jsImageData.width, r = e.jsImageData.height), e.canvas && (n = e.canvas.width, r = e.canvas.height), e.image && (n = e.image.width, r = e.image.height), (n > 1) + (r > 1) + (i > 1);
    }, t.getInputAsJsImageData = () => {
      if (!e.imageLoaded || t.getInputData()) return null;
      if (e.jsImageData) return e.jsImageData();
      if (e.canvas) return e.canvas.getContext("2d").getImageData(0, 0, e.canvas.width, e.canvas.height);
      if (e.image) {
        const n = document.createElement("canvas");
        n.width = e.image.width, n.height = e.image.height;
        const r = n.getContext("2d");
        return r.translate(0, n.height), r.scale(1, -1), r.drawImage(e.image, 0, 0, e.image.width, e.image.height), r.getImageData(0, 0, n.width, n.height);
      }
      return null;
    };
  }
  const Loe = (t, e, n, r) => {
    const i = [
      1,
      2,
      1
    ], a = 4, s = i, o = a, l = t.length / (e * n);
    let c = e, f = n, u = t;
    const h = [
      u
    ];
    for (let g = 0; g < r; g++) {
      const v = [
        ...u
      ];
      c /= 2, f /= 2, u = new Uint8ClampedArray(c * f * l);
      const m = l * c;
      let y = 0;
      for (let C = 0; C < u.length; C += l) {
        C % m === 0 && (y += 2 * l * c);
        for (let T = 0; T < l; T++) {
          let S = v[y + T];
          S += v[y + l + T], S += v[y - 2 * m + T], S += v[y - 2 * m + l + T], S /= 4, u[C + T] = S;
        }
        y += 2 * l;
      }
      let w = [
        ...u
      ];
      for (let C = 0; C < u.length; C += l) for (let T = 0; T < l; T++) {
        let S = -(s.length - 1) / 2, E = o, b = 0;
        for (let D = 0; D < s.length; D++) {
          let R = C + T + S * l;
          const I = R % m - (C + T) % m;
          I > l && (R += m), I < -l && (R -= m), w[R] ? b += w[R] * s[D] : E -= s[D], S += 1;
        }
        u[C + T] = b / E;
      }
      w = [
        ...u
      ];
      for (let C = 0; C < u.length; C += l) for (let T = 0; T < l; T++) {
        let S = -(s.length - 1) / 2, E = o, b = 0;
        for (let D = 0; D < s.length; D++) {
          const R = C + T + S * m;
          w[R] ? b += w[R] * s[D] : E -= s[D], S += 1;
        }
        u[C + T] = b / E;
      }
      h.push(u);
    }
    return h;
  }, Uoe = {
    image: null,
    canvas: null,
    jsImageData: null,
    imageLoaded: false,
    repeat: false,
    interpolate: false,
    edgeClamp: false,
    mipLevel: 0,
    resizable: false
  };
  function YI(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Uoe, n), H.obj(t, e), H.algo(t, e, 6, 0), H.get(t, e, [
      "canvas",
      "image",
      "jsImageData",
      "imageLoaded",
      "resizable"
    ]), H.setGet(t, e, [
      "repeat",
      "edgeClamp",
      "interpolate",
      "mipLevel"
    ]), Noe(t, e);
  }
  const Foe = H.newInstance(YI, "vtkTexture"), Boe = {
    generateMipmaps: Loe
  };
  var N5 = {
    newInstance: Foe,
    extend: YI,
    ...Boe
  };
  const _oe = [
    [
      -1,
      0,
      0
    ],
    [
      1,
      0,
      0
    ],
    [
      0,
      -1,
      0
    ],
    [
      0,
      1,
      0
    ],
    [
      0,
      0,
      -1
    ],
    [
      0,
      0,
      1
    ]
  ], BS = [
    [
      8,
      7,
      11,
      3
    ],
    [
      9,
      1,
      10,
      5
    ],
    [
      4,
      9,
      0,
      8
    ],
    [
      2,
      11,
      6,
      10
    ],
    [
      0,
      3,
      2,
      1
    ],
    [
      4,
      5,
      6,
      7
    ]
  ], Q2 = [
    [
      0,
      1
    ],
    [
      1,
      3
    ],
    [
      2,
      3
    ],
    [
      0,
      2
    ],
    [
      4,
      5
    ],
    [
      5,
      7
    ],
    [
      6,
      7
    ],
    [
      4,
      6
    ],
    [
      0,
      4
    ],
    [
      1,
      5
    ],
    [
      3,
      7
    ],
    [
      2,
      6
    ]
  ], _S = [
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    2,
    2,
    2,
    2
  ], Jn = [
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      0,
      2
    ],
    [
      0,
      2
    ],
    [
      0,
      1
    ],
    [
      0,
      1
    ]
  ], kt = new Float64Array(3), J2 = new Float64Array(3), bn = new Float64Array(3), Oc = new Float64Array(3), Cc = new Float64Array(3), $2 = new Float64Array(3), nv = new Float64Array(16);
  function rv(t, e) {
    t.strokeStyle = e.strokeColor, t.lineWidth = e.strokeSize, t.fillStyle = e.fontColor, t.font = `${e.fontStyle} ${e.fontSize}px ${e.fontFamily}`;
  }
  function qI(t) {
    const e = [], n = [];
    for (let r = 0; r < 3; r++) {
      const i = Dy().domain([
        t[r * 2],
        t[r * 2 + 1]
      ]);
      e[r] = i.ticks(5);
      const a = i.tickFormat(5);
      n[r] = e[r].map(a);
    }
    return {
      ticks: e,
      tickStrings: n
    };
  }
  function koe(t, e) {
    e.classHierarchy.push("vtkCubeAxesActorHelper"), t.setRenderable = (n) => {
      e.renderable !== n && (e.renderable = n, e.tmActor.addTexture(e.renderable.getTmTexture()), e.tmActor.setProperty(n.getProperty()), e.tmActor.setParentProp(n), t.modified());
    }, t.createPolyDataForOneLabel = (n, r, i, a, s, o, l) => {
      const c = e.renderable.get_tmAtlas().get(n);
      if (!c) return;
      const f = e.renderable.getTextPolyData().getPoints().getData(), u = e.lastSize;
      kt[0] = f[r * 3], kt[1] = f[r * 3 + 1], kt[2] = f[r * 3 + 2], $t(bn, kt, i), bn[0] += 0.1, $t(J2, bn, a), bl(Cc, J2, kt), bn[0] -= 0.1, bn[1] += 0.1, $t(J2, bn, a), bl($2, J2, kt);
      for (let v = 0; v < 3; v++) Cc[v] /= 0.5 * 0.1 * u[0], $2[v] /= 0.5 * 0.1 * u[1];
      let h = l.ptIdx, g = l.cellIdx;
      kt[0] = f[r * 3], kt[1] = f[r * 3 + 1], kt[2] = f[r * 3 + 2], s[0] < -0.5 ? so(bn, Cc, s[0] * o - c.width) : s[0] > 0.5 ? so(bn, Cc, s[0] * o) : so(bn, Cc, s[0] * o - c.width / 2), K1(kt, kt, bn), so(bn, $2, s[1] * o - c.height / 2), K1(kt, kt, bn), l.points[h * 3] = kt[0], l.points[h * 3 + 1] = kt[1], l.points[h * 3 + 2] = kt[2], l.tcoords[h * 2] = c.tcoords[0], l.tcoords[h * 2 + 1] = c.tcoords[1], h++, so(bn, Cc, c.width), K1(kt, kt, bn), l.points[h * 3] = kt[0], l.points[h * 3 + 1] = kt[1], l.points[h * 3 + 2] = kt[2], l.tcoords[h * 2] = c.tcoords[2], l.tcoords[h * 2 + 1] = c.tcoords[3], h++, so(bn, $2, c.height), K1(kt, kt, bn), l.points[h * 3] = kt[0], l.points[h * 3 + 1] = kt[1], l.points[h * 3 + 2] = kt[2], l.tcoords[h * 2] = c.tcoords[4], l.tcoords[h * 2 + 1] = c.tcoords[5], h++, so(bn, Cc, c.width), bl(kt, kt, bn), l.points[h * 3] = kt[0], l.points[h * 3 + 1] = kt[1], l.points[h * 3 + 2] = kt[2], l.tcoords[h * 2] = c.tcoords[6], l.tcoords[h * 2 + 1] = c.tcoords[7], h++, l.polys[g * 4] = 3, l.polys[g * 4 + 1] = h - 4, l.polys[g * 4 + 2] = h - 3, l.polys[g * 4 + 3] = h - 2, g++, l.polys[g * 4] = 3, l.polys[g * 4 + 1] = h - 4, l.polys[g * 4 + 2] = h - 2, l.polys[g * 4 + 3] = h - 1, l.ptIdx += 4, l.cellIdx += 2;
    }, t.updateTexturePolyData = () => {
      const n = e.camera.getCompositeProjectionMatrix(e.lastAspectRatio, -1, 1);
      en(n, n);
      const r = e.renderable.getTextValues().length, i = r * 4, a = r * 2, s = new Float64Array(i * 3), o = new Uint16Array(a * 4), l = new Float32Array(i * 2);
      Nr(nv, n);
      const c = {
        ptIdx: 0,
        cellIdx: 0,
        polys: o,
        points: s,
        tcoords: l
      };
      let f = 0, u = 0, h = 0;
      const g = e.renderable.getTextPolyData().getPoints().getData(), v = e.renderable.getTextValues();
      for (; f < g.length / 3; ) {
        kt[0] = g[f * 3], kt[1] = g[f * 3 + 1], kt[2] = g[f * 3 + 2], $t(bn, kt, n), kt[0] = g[f * 3 + 3], kt[1] = g[f * 3 + 4], kt[2] = g[f * 3 + 5], $t(Oc, kt, n), bl(bn, bn, Oc);
        const y = [
          bn[0],
          bn[1]
        ];
        Qb(y), t.createPolyDataForOneLabel(v[u], f, n, nv, y, e.renderable.getAxisTitlePixelOffset(), c), f += 2, u++;
        for (let w = 0; w < e.renderable.getTickCounts()[h]; w++) t.createPolyDataForOneLabel(v[u], f, n, nv, y, e.renderable.getTickLabelPixelOffset(), c), f++, u++;
        h++;
      }
      const m = Tt.newInstance({
        numberOfComponents: 2,
        values: l,
        name: "TextureCoordinates"
      });
      e.tmPolyData.getPointData().setTCoords(m), e.tmPolyData.getPoints().setData(s, 3), e.tmPolyData.getPoints().modified(), e.tmPolyData.getPolys().setData(o, 1), e.tmPolyData.getPolys().modified(), e.tmPolyData.modified();
    }, t.updateAPISpecificData = (n, r, i) => {
      (e.lastSize[0] !== n[0] || e.lastSize[1] !== n[1]) && (e.lastSize[0] = n[0], e.lastSize[1] = n[1], e.lastAspectRatio = n[0] / n[1], e.forceUpdate = true), e.camera = r, t.updateTexturePolyData();
    };
  }
  const Poe = H.newInstance(function(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      renderable: null
    };
    Object.assign(e, {}, n), H.obj(t, e), e.tmPolyData = $i.newInstance(), e.tmMapper = Kc.newInstance(), e.tmMapper.setInputData(e.tmPolyData), e.tmActor = qc.newInstance({
      parentProp: t
    }), e.tmActor.setMapper(e.tmMapper), H.setGet(t, e, [
      "renderable"
    ]), H.get(t, e, [
      "lastSize",
      "lastAspectRatio",
      "axisTextStyle",
      "tickTextStyle",
      "tmActor",
      "ticks"
    ]), e.forceUpdate = false, e.lastRedrawTime = {}, H.obj(e.lastRedrawTime, {
      mtime: 0
    }), e.lastRebuildTime = {}, H.obj(e.lastRebuildTime, {
      mtime: 0
    }), e.lastSize = [
      -1,
      -1
    ], e.lastTickBounds = [], koe(t, e);
  }, "vtkCubeAxesActorHelper");
  function Goe(t, e) {
    e.classHierarchy.push("vtkCubeAxesActor"), t.setCamera = (r) => {
      e.camera !== r && (e.cameraModifiedSub && (e.cameraModifiedSub.unsubscribe(), e.cameraModifiedSub = null), e.camera = r, r && (e.cameraModifiedSub = r.onModified(t.update)), t.update(), t.modified());
    }, t.computeFacesToDraw = () => {
      const r = e.camera.getViewMatrix();
      en(r, r);
      let i = false;
      const a = En.getDiagonalLength(e.dataBounds), s = Math.sin(e.faceVisibilityAngle * Math.PI / 180);
      for (let o = 0; o < 6; o++) {
        let l = false;
        const c = Math.floor(o / 2), f = (c + 1) % 3, u = (c + 2) % 3;
        e.dataBounds[f * 2] !== e.dataBounds[f * 2 + 1] && e.dataBounds[u * 2] !== e.dataBounds[u * 2 + 1] && (kt[c] = e.dataBounds[o] - 0.1 * a * _oe[o][c], kt[f] = 0.5 * (e.dataBounds[f * 2] + e.dataBounds[f * 2 + 1]), kt[u] = 0.5 * (e.dataBounds[u * 2] + e.dataBounds[u * 2 + 1]), $t(bn, kt, r), kt[c] = e.dataBounds[o], $t(Oc, kt, r), bl(bn, Oc, bn), cs(bn, bn), l = bn[2] > s, e.camera.getParallelProjection() || (cs(Oc, Oc), l = Sh(Oc, bn) > s)), l !== e.lastFacesToDraw[o] && (e.lastFacesToDraw[o] = l, i = true);
      }
      return i;
    }, t.updatePolyData = (r, i, a) => {
      let s = 0, o = 0;
      s += 8;
      let l = 0;
      for (let g = 0; g < 12; g++) i[g] > 0 && l++;
      if (o += l, e.gridLines) for (let g = 0; g < 6; g++) r[g] && (s += a[Jn[g][0]].length * 2 + a[Jn[g][1]].length * 2, o += a[Jn[g][0]].length + a[Jn[g][1]].length);
      const c = new Float64Array(s * 3), f = new Uint32Array(o * 3);
      let u = 0, h = 0;
      for (let g = 0; g < 2; g++) for (let v = 0; v < 2; v++) for (let m = 0; m < 2; m++) c[u * 3] = e.dataBounds[m], c[u * 3 + 1] = e.dataBounds[2 + v], c[u * 3 + 2] = e.dataBounds[4 + g], u++;
      for (let g = 0; g < 12; g++) i[g] > 0 && (f[h * 3] = 2, f[h * 3 + 1] = Q2[g][0], f[h * 3 + 2] = Q2[g][1], h++);
      if (e.gridLines) {
        for (let g = 0; g < 6; g++) if (r[g]) {
          const v = Math.floor(g / 2);
          let m = a[Jn[g][0]];
          for (let y = 0; y < m.length; y++) c[u * 3 + v] = e.dataBounds[g], c[u * 3 + Jn[g][0]] = m[y], c[u * 3 + Jn[g][1]] = e.dataBounds[Jn[g][1] * 2], u++, c[u * 3 + v] = e.dataBounds[g], c[u * 3 + Jn[g][0]] = m[y], c[u * 3 + Jn[g][1]] = e.dataBounds[Jn[g][1] * 2 + 1], u++, f[h * 3] = 2, f[h * 3 + 1] = u - 2, f[h * 3 + 2] = u - 1, h++;
          m = a[Jn[g][1]];
          for (let y = 0; y < m.length; y++) c[u * 3 + v] = e.dataBounds[g], c[u * 3 + Jn[g][1]] = m[y], c[u * 3 + Jn[g][0]] = e.dataBounds[Jn[g][0] * 2], u++, c[u * 3 + v] = e.dataBounds[g], c[u * 3 + Jn[g][1]] = m[y], c[u * 3 + Jn[g][0]] = e.dataBounds[Jn[g][0] * 2 + 1], u++, f[h * 3] = 2, f[h * 3 + 1] = u - 2, f[h * 3 + 2] = u - 1, h++;
        }
      }
      e.polyData.getPoints().setData(c, 3), e.polyData.getPoints().modified(), e.polyData.getLines().setData(f, 1), e.polyData.getLines().modified(), e.polyData.modified();
    }, t.updateTextData = (r, i, a, s) => {
      let o = 0;
      for (let g = 0; g < 12; g++) i[g] === 1 && (o += 2, o += a[_S[g]].length);
      const l = e.polyData.getPoints().getData(), c = new Float64Array(o * 3);
      let f = 0, u = 0, h = 0;
      for (let g = 0; g < 6; g++) if (r[g]) for (let v = 0; v < 4; v++) {
        const m = BS[g][v];
        if (i[m] === 1) {
          const y = _S[m], w = Q2[m][0] * 3, C = Q2[m][1] * 3;
          c[f * 3] = 0.5 * (l[w] + l[C]), c[f * 3 + 1] = 0.5 * (l[w + 1] + l[C + 1]), c[f * 3 + 2] = 0.5 * (l[w + 2] + l[C + 2]), f++;
          const T = Math.floor(g / 2);
          c[f * 3 + T] = e.dataBounds[g], c[f * 3 + Jn[g][0]] = 0.5 * (e.dataBounds[Jn[g][0] * 2] + e.dataBounds[Jn[g][0] * 2 + 1]), c[f * 3 + Jn[g][1]] = 0.5 * (e.dataBounds[Jn[g][1] * 2] + e.dataBounds[Jn[g][1] * 2 + 1]), f++, e.textValues[u] = e.axisLabels[y], u++;
          const S = (y + 1) % 3, E = (y + 2) % 3, b = a[y], D = s[y];
          e.tickCounts[h] = b.length;
          for (let R = 0; R < b.length; R++) c[f * 3 + y] = b[R], c[f * 3 + S] = l[w + S], c[f * 3 + E] = l[w + E], f++, e.textValues[u] = D[R], u++;
          h++;
        }
      }
      e.textPolyData.getPoints().setData(c, 3), e.textPolyData.modified();
    }, t.update = () => {
      if (!e.camera) return;
      const r = t.computeFacesToDraw(), i = e.lastFacesToDraw;
      let a = false;
      for (let s = 0; s < 6; s++) e.dataBounds[s] !== e.lastTickBounds[s] && (a = true, e.lastTickBounds[s] = e.dataBounds[s]);
      if (r || a || e.forceUpdate) {
        const s = new Array(12).fill(0);
        for (let l = 0; l < 6; l++) if (i[l]) for (let c = 0; c < 4; c++) s[BS[l][c]]++;
        const o = e.generateTicks(e.dataBounds);
        t.updatePolyData(i, s, o.ticks), t.updateTextData(i, s, o.ticks, o.tickStrings), (a || e.forceUpdate) && t.updateTextureAtlas(o.tickStrings);
      }
      e.forceUpdate = false;
    }, t.updateTextureAtlas = (r) => {
      e.tmContext.textBaseline = "bottom", e.tmContext.textAlign = "left", e._tmAtlas.clear();
      let i = 0, a = 1;
      for (let s = 0; s < 3; s++) {
        if (!e._tmAtlas.has(e.axisLabels[s])) {
          rv(e.tmContext, e.axisTextStyle);
          const o = e.tmContext.measureText(e.axisLabels[s]), l = {
            height: o.actualBoundingBoxAscent + 2,
            startingHeight: a,
            width: o.width + 2,
            textStyle: e.axisTextStyle
          };
          e._tmAtlas.set(e.axisLabels[s], l), a += l.height, i < l.width && (i = l.width);
        }
        rv(e.tmContext, e.tickTextStyle);
        for (let o = 0; o < r[s].length; o++) if (!e._tmAtlas.has(r[s][o])) {
          const l = e.tmContext.measureText(r[s][o]), c = {
            height: l.actualBoundingBoxAscent + 2,
            startingHeight: a,
            width: l.width + 2,
            textStyle: e.tickTextStyle
          };
          e._tmAtlas.set(r[s][o], c), a += c.height, i < c.width && (i = c.width);
        }
      }
      i = Na(i), a = Na(a), e._tmAtlas.forEach((s) => {
        s.tcoords = [
          0,
          (a - s.startingHeight - s.height) / a,
          s.width / i,
          (a - s.startingHeight - s.height) / a,
          s.width / i,
          (a - s.startingHeight) / a,
          0,
          (a - s.startingHeight) / a
        ];
      }), e.tmCanvas.width = i, e.tmCanvas.height = a, e.tmContext.textBaseline = "bottom", e.tmContext.textAlign = "left", e.tmContext.clearRect(0, 0, i, a), e._tmAtlas.forEach((s, o) => {
        rv(e.tmContext, s.textStyle), e.tmContext.fillText(o, 1, s.startingHeight + s.height - 1);
      }), e.tmTexture.setCanvas(e.tmCanvas), e.tmTexture.modified();
    }, t.onModified(() => {
      e.forceUpdate = true, t.update();
    }), t.setTickTextStyle = (r) => {
      e.tickTextStyle = {
        ...e.tickTextStyle,
        ...r
      }, t.modified();
    }, t.setAxisTextStyle = (r) => {
      e.axisTextStyle = {
        ...e.axisTextStyle,
        ...r
      }, t.modified();
    }, t.get_tmAtlas = () => e._tmAtlas, t.getBounds = () => (t.update(), En.setBounds(e.bounds, e.gridActor.getBounds()), En.scaleAboutCenter(e.bounds, e.boundsScaleFactor, e.boundsScaleFactor, e.boundsScaleFactor), e.bounds);
    const n = H.chain(t.setProperty, e.gridActor.setProperty);
    t.setProperty = (r) => n(r)[0];
  }
  function zoe(t, e, n) {
    return {
      boundsScaleFactor: 1.3,
      camera: null,
      dataBounds: [
        ...En.INIT_BOUNDS
      ],
      faceVisibilityAngle: 8,
      gridLines: true,
      axisLabels: null,
      axisTitlePixelOffset: 35,
      tickLabelPixelOffset: 12,
      generateTicks: qI,
      ...n,
      axisTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 18,
        fontFamily: "serif",
        ...n == null ? void 0 : n.axisTextStyle
      },
      tickTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 14,
        fontFamily: "serif",
        ...n == null ? void 0 : n.tickTextStyle
      }
    };
  }
  function XI(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    qc.extend(t, e, zoe(t, e, n)), e.lastFacesToDraw = [
      false,
      false,
      false,
      false,
      false,
      false
    ], e.axisLabels = [
      "X-Axis",
      "Y-Axis",
      "Z-Axis"
    ], e.tickCounts = [], e.textValues = [], e.lastTickBounds = [], e.tmCanvas = document.createElement("canvas"), e.tmContext = e.tmCanvas.getContext("2d"), e._tmAtlas = /* @__PURE__ */ new Map(), e.tmTexture = N5.newInstance({
      resizable: true
    }), e.tmTexture.setInterpolate(false), t.getProperty().setDiffuse(0), t.getProperty().setAmbient(1), e.gridMapper = Kc.newInstance(), e.polyData = $i.newInstance(), e.gridMapper.setInputData(e.polyData), e.gridActor = qc.newInstance(), e.gridActor.setMapper(e.gridMapper), e.gridActor.setProperty(t.getProperty()), e.gridActor.setParentProp(t), e.textPolyData = $i.newInstance(), H.setGet(t, e, [
      "axisTitlePixelOffset",
      "boundsScaleFactor",
      "faceVisibilityAngle",
      "gridLines",
      "tickLabelPixelOffset",
      "generateTicks"
    ]), H.setGetArray(t, e, [
      "dataBounds"
    ], 6), H.setGetArray(t, e, [
      "axisLabels"
    ], 3), H.get(t, e, [
      "axisTextStyle",
      "tickTextStyle",
      "camera",
      "tmTexture",
      "textValues",
      "textPolyData",
      "tickCounts",
      "gridActor"
    ]), Goe(t, e);
  }
  const Woe = H.newInstance(XI, "vtkCubeAxesActor");
  var ZI = {
    newInstance: Woe,
    extend: XI,
    newCubeAxesActorHelper: Poe,
    defaultGenerateTicks: qI
  };
  function Hoe(t, e) {
    e.classHierarchy.push("vtkOpenGLCubeAxesActor"), t.buildPass = (n) => {
      n && (e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.CubeAxesActorHelper.getRenderable() || e.CubeAxesActorHelper.setRenderable(e.renderable), t.prepareNodes(), t.addMissingNode(e.CubeAxesActorHelper.getTmActor()), t.addMissingNode(e.renderable.getGridActor()), t.removeUnusedNodes());
    }, t.opaquePass = (n, r) => {
      if (n) {
        const i = e._openGLRenderer ? e._openGLRenderer.getRenderable().getActiveCamera() : null, a = e._openGLRenderer.getTiledSizeAndOrigin();
        e.CubeAxesActorHelper.updateAPISpecificData([
          a.usize,
          a.vsize
        ], i, e._openGLRenderWindow.getRenderable());
      }
    };
  }
  const joe = {};
  function Koe(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, joe, n), Rn.extend(t, e, n), e.CubeAxesActorHelper = ZI.newCubeAxesActorHelper(), Hoe(t, e);
  }
  const Yoe = pn(Koe, "vtkOpenGLCubeAxesActor");
  Er("vtkCubeAxesActor", Yoe);
  const { ColorMode: qoe, ScalarMode: Tc, GetArray: iv } = m5;
  function Xoe(t, e) {
    e.classHierarchy.push("vtkMapper2D"), t.createDefaultLookupTable = () => {
      e.lookupTable = X1.newInstance();
    }, t.getColorModeAsString = () => H.enumToString(qoe, e.colorMode), t.setColorModeToDefault = () => t.setColorMode(0), t.setColorModeToMapScalars = () => t.setColorMode(1), t.setColorModeToDirectScalars = () => t.setColorMode(2), t.getScalarModeAsString = () => H.enumToString(Tc, e.scalarMode), t.setScalarModeToDefault = () => t.setScalarMode(0), t.setScalarModeToUsePointData = () => t.setScalarMode(1), t.setScalarModeToUseCellData = () => t.setScalarMode(2), t.setScalarModeToUsePointFieldData = () => t.setScalarMode(3), t.setScalarModeToUseCellFieldData = () => t.setScalarMode(4), t.setScalarModeToUseFieldData = () => t.setScalarMode(5), t.getAbstractScalars = (n, r, i, a, s) => {
      if (!n || !e.scalarVisibility) return {
        scalars: null,
        cellFLag: false
      };
      let o = null, l = false;
      if (r === Tc.DEFAULT) o = n.getPointData().getScalars(), o || (o = n.getCellData().getScalars(), l = true);
      else if (r === Tc.USE_POINT_DATA) o = n.getPointData().getScalars();
      else if (r === Tc.USE_CELL_DATA) o = n.getCellData().getScalars(), l = true;
      else if (r === Tc.USE_POINT_FIELD_DATA) {
        const c = n.getPointData();
        i === iv.BY_ID ? o = c.getArrayByIndex(a) : o = c.getArrayByName(s);
      } else if (r === Tc.USE_CELL_FIELD_DATA) {
        const c = n.getCellData();
        l = true, i === iv.BY_ID ? o = c.getArrayByIndex(a) : o = c.getArrayByName(s);
      } else if (r === Tc.USE_FIELD_DATA) {
        const c = n.getFieldData();
        i === iv.BY_ID ? o = c.getArrayByIndex(a) : o = c.getArrayByName(s);
      }
      return {
        scalars: o,
        cellFlag: l
      };
    }, t.getLookupTable = () => (e.lookupTable || t.createDefaultLookupTable(), e.lookupTable), t.getMTime = () => {
      let n = e.mtime;
      if (e.lookupTable !== null) {
        const r = e.lookupTable.getMTime();
        n = r > n ? r : n;
      }
      return n;
    }, t.mapScalars = (n, r) => {
      const i = t.getAbstractScalars(n, e.scalarMode, e.arrayAccessMode, e.arrayId, e.colorByArrayName).scalars;
      if (!i) {
        e.colorMapColors = null;
        return;
      }
      const a = `${t.getMTime()}${i.getMTime()}${r}`;
      if (e.colorBuildString === a) return;
      e.useLookupTableScalarRange || t.getLookupTable().setRange(e.scalarRange[0], e.scalarRange[1]);
      const s = t.getLookupTable();
      s && (s.build(), e.colorMapColors = s.mapScalars(i, e.colorMode, e.fieldDataTupleId)), e.colorBuildString = `${t.getMTime()}${i.getMTime()}${r}`;
    }, t.getPrimitiveCount = () => {
      const n = t.getInputData();
      return {
        points: n.getPoints().getNumberOfValues() / 3,
        verts: n.getVerts().getNumberOfValues() - n.getVerts().getNumberOfCells(),
        lines: n.getLines().getNumberOfValues() - 2 * n.getLines().getNumberOfCells(),
        triangles: n.getPolys().getNumberOfValues() - 3 * n.getPolys().getNumberOfCells()
      };
    };
  }
  const Zoe = {
    static: false,
    lookupTable: null,
    scalarVisibility: false,
    scalarRange: [
      0,
      1
    ],
    useLookupTableScalarRange: false,
    colorMode: 0,
    scalarMode: 0,
    arrayAccessMode: 1,
    renderTime: 0,
    colorByArrayName: null,
    transformCoordinate: null,
    viewSpecificProperties: null,
    customShaderAttributes: []
  };
  function Qoe(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Zoe, n), bR.extend(t, e, n), H.get(t, e, [
      "colorMapColors"
    ]), H.setGet(t, e, [
      "arrayAccessMode",
      "colorByArrayName",
      "colorMode",
      "lookupTable",
      "renderTime",
      "scalarMode",
      "scalarVisibility",
      "static",
      "transformCoordinate",
      "useLookupTableScalarRange",
      "viewSpecificProperties",
      "customShaderAttributes"
    ]), H.setGetArray(t, e, [
      "scalarRange"
    ], 2), e.viewSpecificProperties || (e.viewSpecificProperties = {}), Xoe(t, e);
  }
  H.newInstance(Qoe, "vtkMapper2D");
  var Joe = {}, $oe = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyData2DFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

uniform int PrimitiveIDOffset;

// Texture coordinates
//VTK::TCoord::Dec

// Scalar coloring
//VTK::Color::Dec

// Depth Peeling
//VTK::DepthPeeling::Dec

// picking support
//VTK::Picking::Dec

// the output of this shader
//VTK::Output::Dec

// Apple Bug
//VTK::PrimID::Dec

void main()
{
  // Apple Bug
  //VTK::PrimID::Impl

  //VTK::Color::Impl
  //VTK::TCoord::Impl

  //VTK::DepthPeeling::Impl
  //VTK::Picking::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }
}
`, ele = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyData2DVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

// all variables that represent positions or directions have a suffix
// indicating the coordinate system they are in. The possible values are
// MC - Model Coordinates
// WC - WC world coordinates
// VC - View Coordinates
// DC - Display Coordinates

in vec4 vertexWC;

// frag position in VC
//VTK::PositionVC::Dec

// material property values
//VTK::Color::Dec

// Texture coordinates
//VTK::TCoord::Dec

// Apple Bug
//VTK::PrimID::Dec

uniform mat4 WCVCMatrix;  // World to view matrix

void main()
{
  // Apple Bug
  //VTK::PrimID::Impl

  gl_Position = WCVCMatrix*vertexWC;

  //VTK::TCoord::Impl

  //VTK::Color::Impl

  //VTK::PositionVC::Impl
}
`;
  const QI = {
    BACKGROUND: 0,
    FOREGROUND: 1
  };
  var JI = {
    DisplayLocation: QI
  };
  const { primTypes: ts } = Bs, { ScalarMode: eg } = Joe, { vtkErrorMacro: tg } = di, tle = {
    type: "StartEvent"
  }, nle = {
    type: "EndEvent"
  };
  function rle(t, e) {
    e.classHierarchy.push("vtkOpenGLPolyDataMapper2D"), t.buildPass = (r) => {
      r && (e.openGLActor2D = t.getFirstAncestorOfType("vtkOpenGLActor2D"), e._openGLRenderer = e.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.openGLCamera = e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()));
    }, t.overlayPass = (r) => {
      r && t.render();
    }, t.getShaderTemplate = (r, i, a) => {
      r.Vertex = ele, r.Fragment = $oe, r.Geometry = "";
    }, t.render = () => {
      const r = e._openGLRenderWindow.getContext();
      if (e.context !== r) {
        e.context = r;
        for (let s = ts.Start; s < ts.End; s++) e.primitives[s].setOpenGLRenderWindow(e._openGLRenderWindow);
      }
      const i = e.openGLActor2D.getRenderable(), a = e._openGLRenderer.getRenderable();
      t.renderPiece(a, i);
    }, t.renderPiece = (r, i) => {
      if (t.invokeEvent(tle), e.renderable.getStatic() || e.renderable.update(), e.currentInput = e.renderable.getInputData(), t.invokeEvent(nle), !e.currentInput) {
        tg("No input!");
        return;
      }
      !e.currentInput.getPoints || !e.currentInput.getPoints().getNumberOfValues() || (t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i));
    }, t.renderPieceStart = (r, i) => {
      if (e.primitiveIDOffset = 0, e._openGLRenderer.getSelector()) switch (e._openGLRenderer.getSelector().getCurrentPass()) {
        default:
          e._openGLRenderer.getSelector().renderProp(i);
      }
      t.updateBufferObjects(r, i), e.lastBoundBO = null;
    }, t.getNeedToRebuildShaders = (r, i, a) => r.getShaderSourceTime().getMTime() < e.renderable.getMTime() || r.getShaderSourceTime().getMTime() < e.currentInput.getMTime(), t.updateBufferObjects = (r, i) => {
      t.getNeedToRebuildBufferObjects(r, i) && t.buildBufferObjects(r, i);
    }, t.getNeedToRebuildBufferObjects = (r, i) => {
      const a = e.VBOBuildTime.getMTime();
      return !!(a < t.getMTime() || a < e._openGLRenderWindow.getMTime() || a < e.renderable.getMTime() || a < i.getMTime() || a < e.currentInput.getMTime() || e.renderable.getTransformCoordinate() && a < r.getMTime());
    }, t.buildBufferObjects = (r, i) => {
      const a = e.currentInput;
      if (a === null) return;
      e.renderable.mapScalars(a, i.getProperty().getOpacity());
      const s = e.renderable.getColorMapColors();
      e.haveCellScalars = false;
      const o = e.renderable.getScalarMode();
      e.renderable.getScalarVisibility() && (o === eg.USE_CELL_DATA || o === eg.USE_CELL_FIELD_DATA || o === eg.USE_FIELD_DATA || !a.getPointData().getScalars()) && o !== eg.USE_POINT_FIELD_DATA && s && (e.haveCellScalars = true);
      const l = i.getProperty().getRepresentation();
      let c = a.getPointData().getTCoords();
      e.openGLActor2D.getActiveTextures() || (c = null);
      const f = e.renderable.getTransformCoordinate(), h = r.getRenderWindow().getViews()[0].getViewportSize(r), g = `${a.getMTime()}A${l}B${a.getMTime()}C${s ? s.getMTime() : 1}D${c ? c.getMTime() : 1}E${f ? r.getMTime() : 1}F${h}`;
      if (e.VBOBuildString !== g) {
        let v = a.getPoints();
        if (f) {
          const y = Sp.newInstance(), w = v.getNumberOfPoints();
          y.setNumberOfPoints(w);
          const C = [];
          for (let T = 0; T < w; ++T) {
            v.getPoint(T, C), f.setValue(C);
            const S = f.getComputedDoubleViewportValue(r);
            y.setPoint(T, S[0], S[1], 0);
          }
          v = y;
        }
        const m = {
          points: v,
          tcoords: c,
          colors: s,
          cellOffset: 0,
          haveCellScalars: e.haveCellSCalars,
          customAttributes: e.renderable.getCustomShaderAttributes().map((y) => a.getPointData().getArrayByName(y))
        };
        m.cellOffset += e.primitives[ts.Points].getCABO().createVBO(a.getVerts(), "verts", l, m), m.cellOffset += e.primitives[ts.Lines].getCABO().createVBO(a.getLines(), "lines", l, m), m.cellOffset += e.primitives[ts.Tris].getCABO().createVBO(a.getPolys(), "polys", l, m), m.cellOffset += e.primitives[ts.TriStrips].getCABO().createVBO(a.getStrips(), "strips", l, m), e.VBOBuildTime.modified(), e.VBOBuildString = g;
      }
    }, t.renderPieceDraw = (r, i) => {
      const a = i.getProperty().getRepresentation();
      e.context.depthMask(true);
      for (let o = ts.Start; o < ts.End; o++) e.primitives[o].getCABO().getElementCount() && (e.lastBoundBO = e.primitives[o], e.primitiveIDOffset += e.primitives[o].drawArrays(r, i, a, t));
    }, t.renderPieceFinish = (r, i) => {
      e.lastBoundBO && e.lastBoundBO.getVAO().release();
    }, t.replaceShaderValues = (r, i, a) => {
      t.replaceShaderColor(r, i, a), t.replaceShaderTCoord(r, i, a), t.replaceShaderPicking(r, i, a), t.replaceShaderPositionVC(r, i, a);
    }, t.replaceShaderColor = (r, i, a) => {
      let s = r.Vertex, o = r.Geometry, l = r.Fragment;
      e.haveCellScalars && (l = se.substitute(l, "//VTK::Color::Dec", [
        "uniform samplerBuffer texture1;"
      ]).result, l = se.substitute(l, "//VTK::Color::Impl", [
        "gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"
      ]).result), e.lastBoundBO.getCABO().getColorComponents() !== 0 ? (s = se.substitute(s, "//VTK::Color::Dec", [
        "in vec4 diffuseColor;",
        "out vec4 fcolorVSOutput;"
      ]).result, s = se.substitute(s, "//VTK::Color::Impl", [
        "fcolorVSOutput = diffuseColor;"
      ]).result, o = se.substitute(o, "//VTK::Color::Dec", [
        `in vec4 fcolorVSOutput[];
`,
        "out vec4 fcolorGSOutput;"
      ]).result, o = se.substitute(o, "//VTK::Color::Impl", [
        "fcolorGSOutput = fcolorVSOutput[i];"
      ]).result, l = se.substitute(l, "//VTK::Color::Dec", [
        "in vec4 fcolorVSOutput;"
      ]).result, l = se.substitute(l, "//VTK::Color::Impl", [
        "gl_FragData[0] = fcolorVSOutput;"
      ]).result) : (l = se.substitute(l, "//VTK::Color::Dec", [
        "uniform vec4 diffuseColor;"
      ]).result, l = se.substitute(l, "//VTK::Color::Impl", [
        "gl_FragData[0] = diffuseColor;"
      ]).result), r.Vertex = s, r.Geometry = o, r.Fragment = l;
    }, t.replaceShaderTCoord = (r, i, a) => {
      if (e.lastBoundBO.getCABO().getTCoordOffset()) {
        let s = r.Vertex, o = r.Geometry, l = r.Fragment;
        const c = e.lastBoundBO.getCABO().getTCoordComponents();
        c === 1 ? (s = se.substitute(s, "//VTK::TCoord::Dec", [
          "in float tcoordMC;",
          "out float tcoordVCVSOutput;"
        ]).result, s = se.substitute(s, "//VTK::TCoord::Impl", [
          "tcoordVCVSOutput = tcoordMC;"
        ]).result, o = se.substitute(o, "//VTK::TCoord::Dec", [
          `in float tcoordVCVSOutput[];
`,
          "out float tcoordVCGSOutput;"
        ]).result, o = se.substitute(o, [
          "//VTK::TCoord::Impl",
          "tcoordVCGSOutput = tcoordVCVSOutput[i];"
        ]).result, l = se.substitute(l, "//VTK::TCoord::Dec", [
          "in float tcoordVCVSOutput;",
          "uniform sampler2D texture1;"
        ]).result, l = se.substitute(l, "//VTK::TCoord::Impl", [
          "gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"
        ]).result) : c === 2 && (s = se.substitute(s, "//VTK::TCoord::Dec", [
          "in vec2 tcoordMC;",
          "out vec2 tcoordVCVSOutput;"
        ]).result, s = se.substitute(s, "//VTK::TCoord::Impl", [
          "tcoordVCVSOutput = tcoordMC;"
        ]).result, o = se.substitute(o, "//VTK::TCoord::Dec", [
          `in vec2 tcoordVCVSOutput[];
`,
          "out vec2 tcoordVCGSOutput;"
        ]).result, o = se.substitute(o, "//VTK::TCoord::Impl", [
          "tcoordVCGSOutput = tcoordVCVSOutput[i];"
        ]).result, l = se.substitute(l, "//VTK::TCoord::Dec", [
          "in vec2 tcoordVCVSOutput;",
          "uniform sampler2D texture1;"
        ]).result, l = se.substitute(l, "//VTK::TCoord::Impl", [
          "gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"
        ]).result), e.haveCellScalars && (o = se.substitute(o, "//VTK::PrimID::Impl", [
          "gl_PrimitiveID = gl_PrimitiveIDIn;"
        ]).result), r.Vertex = s, r.Geometry = o, r.Fragment = l;
      }
    }, t.replaceShaderPicking = (r, i, a) => {
      let s = r.Fragment;
      s = se.substitute(s, "//VTK::Picking::Dec", [
        "uniform vec3 mapperIndex;",
        "uniform int picking;"
      ]).result, s = se.substitute(s, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result, r.Fragment = s;
    }, t.replaceShaderPositionVC = (r, i, a) => {
      e.lastBoundBO.replaceShaderPositionVC(r, i, a);
    }, t.invokeShaderCallbacks = (r, i, a) => {
      const s = e.renderable.getViewSpecificProperties().ShadersCallbacks;
      s && s.forEach((o) => {
        o.callback(o.userData, r, i, a);
      });
    }, t.setMapperShaderParameters = (r, i, a) => {
      if (r.getProgram().isUniformUsed("PrimitiveIDOffset") && r.getProgram().setUniformi("PrimitiveIDOffset", e.primitiveIDOffset), r.getProgram().isAttributeUsed("vertexWC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "vertexWC", r.getCABO().getVertexOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, false) || tg("Error setting vertexWC in shader VAO.")), r.getCABO().getElementCount() && (e.VBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime())) {
        e.renderable.getCustomShaderAttributes().forEach((l, c) => {
          r.getProgram().isAttributeUsed(`${l}MC`) && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), `${l}MC`, r.getCABO().getCustomData()[c].offset, r.getCABO().getStride(), e.context.FLOAT, r.getCABO().getCustomData()[c].components, false) || tg(`Error setting ${l}MC in shader VAO.`));
        }), r.getProgram().isAttributeUsed("tcoordMC") && r.getCABO().getTCoordOffset() ? r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "tcoordMC", r.getCABO().getTCoordOffset(), r.getCABO().getStride(), e.context.FLOAT, r.getCABO().getTCoordComponents(), false) || tg("Error setting tcoordMC in shader VAO.") : r.getVAO().removeAttributeArray("tcoordMC"), e.internalColorTexture && r.getProgram().isUniformUsed("texture1") && r.getProgram().setUniformi("texture1", e.internalColorTexture.getTextureUnit());
        const s = e.openGLActor2D.getActiveTextures();
        if (s) for (let l = 0; l < s.length; ++l) {
          const f = s[l].getTextureUnit(), u = `texture${f + 1}`;
          r.getProgram().isUniformUsed(u) && r.getProgram().setUniformi(u, f);
        }
        r.setMapperShaderParameters(i, a, e._openGLRenderer.getTiledSizeAndOrigin());
        const o = e._openGLRenderer.getSelector();
        r.getProgram().setUniform3fArray("mapperIndex", o ? o.getPropColorValue() : [
          0,
          0,
          0
        ]), r.getProgram().setUniformi("picking", o ? o.getCurrentPass() + 1 : 0);
      }
    }, t.setPropertyShaderParameters = (r, i, a) => {
      const s = e.renderable.getColorMapColors();
      if (!s || s.getNumberOfComponents() === 0) {
        const o = r.getProgram(), l = a.getProperty(), c = l.getOpacity(), f = l.getColor(), u = [
          f[0],
          f[1],
          f[2],
          c
        ];
        o.setUniform4f("diffuseColor", u);
      }
    }, t.setLightingShaderParameters = (r, i, a) => {
    };
    function n(r, i, a) {
      return i.identity(a), r.reduce((s, o, l) => l === 0 ? o ? i.copy(s, o) : i.identity(s) : o ? i.multiply(s, s, o) : s, a);
    }
    t.setCameraShaderParameters = (r, i, a) => {
      const s = r.getProgram(), l = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null, f = i.getRenderWindow().getViews()[0].getViewportSize(i), u = i.getViewport(), h = a.getActualPositionCoordinate().getComputedDoubleViewportValue(i), g = [
        0,
        0,
        1,
        1
      ], v = [
        0,
        0,
        1,
        1
      ];
      if (v[0] = u[0] >= g[0] ? u[0] : g[0], v[1] = u[1] >= g[1] ? u[1] : g[1], v[2] = u[2] <= g[2] ? u[2] : g[2], v[3] = u[3] <= g[3] ? u[3] : g[3], v[0] >= v[2] || v[1] >= v[3]) return;
      f[0] = G1(f[0] * (v[2] - v[0]) / (u[2] - u[0])), f[1] = G1(f[1] * (v[3] - v[1]) / (u[3] - u[1]));
      const m = e._openGLRenderer.getParent().getSize(), y = G1(h[0] - (v[0] - u[0]) * m[0]), w = G1(h[1] - (v[1] - u[1]) * m[1]), C = -y;
      let T = -y + f[0];
      const S = -w;
      let E = -w + f[1];
      C === T && (T = C + 1), S === E && (E = S + 1);
      const b = gt(new Float64Array(16));
      b[0] = 2 / (T - C), b[5] = 2 / (E - S), b[3] = -1 * (T + C) / (T - C), b[7] = -1 * (E + S) / (E - S), b[10] = 0, b[11] = a.getProperty().getDisplayLocation() === QI.FOREGROUND ? -1 : 1, b[15] = 1, en(b, b), s.setUniformMatrix("WCVCMatrix", n([
        b,
        l
      ], Th, e.tmpMat4));
    }, t.getAllocatedGPUMemoryInBytes = () => {
      let r = 0;
      return e.primitives.forEach((i) => {
        r += i.getAllocatedGPUMemoryInBytes();
      }), r;
    };
  }
  const ile = {
    context: null,
    VBOBuildTime: 0,
    VBOBuildString: null,
    primitives: null,
    primTypes: null,
    shaderRebuildString: null
  };
  function ale(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, ile, n), Rn.extend(t, e, n), Ls.implementReplaceShaderCoincidentOffset(t, e, n), Ls.implementBuildShadersWithReplacements(t, e, n), e.primitives = [], e.primTypes = ts, e.tmpMat4 = gt(new Float64Array(16));
    for (let r = ts.Start; r < ts.End; r++) e.primitives[r] = Bs.newInstance(), e.primitives[r].setPrimitiveType(r), e.primitives[r].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
    pr(t, e, [
      "context"
    ]), e.VBOBuildTime = {}, _n(e.VBOBuildTime, {
      mtime: 0
    }), rle(t, e);
  }
  const sle = pn(ale, "vtkOpenGLPolyDataMapper2D");
  Er("vtkMapper2D", sle);
  const { VectorMode: ole } = v5;
  function av(t, e) {
    t.strokeStyle = e.strokeColor, t.lineWidth = e.strokeSize, t.fillStyle = e.fontColor, t.font = `${e.fontStyle} ${e.fontSize}px ${e.fontFamily}`;
  }
  function $I(t, e) {
    return (n) => {
      const r = n.getLastSize(), i = (r[0] / 700) ** 0.8, a = (r[1] / 700) ** 0.8, s = Math.min(i, a), o = n.getAxisTextStyle(), l = n.getTickTextStyle();
      Object.assign(o, e.axisTextStyle), Object.assign(l, e.tickTextStyle), o.fontSize = Math.max(24 * s, 12), n.getLastAspectRatio() > 1 ? l.fontSize = Math.max(20 * s, 10) : l.fontSize = Math.max(16 * s, 10);
      const c = n.updateTextureAtlas();
      n.setTopTitle(false);
      const f = n.getBoxSizeByReference();
      if (n.getLastAspectRatio() > 1) n.setTickLabelPixelOffset(0.3 * l.fontSize), c.titleWidth <= c.tickWidth + n.getTickLabelPixelOffset() + 0.8 * l.fontSize ? (n.setTopTitle(true), n.setAxisTitlePixelOffset(0.2 * l.fontSize), f[0] = 2 * (c.tickWidth + n.getTickLabelPixelOffset() + 0.8 * l.fontSize) / r[0], n.setBoxPosition([
        0.98 - f[0],
        -0.92
      ])) : (n.setAxisTitlePixelOffset(0.2 * l.fontSize), f[0] = 2 * (c.titleHeight + n.getAxisTitlePixelOffset() + c.tickWidth + n.getTickLabelPixelOffset() + 0.8 * l.fontSize) / r[0], n.setBoxPosition([
        0.99 - f[0],
        -0.92
      ])), f[1] = Math.max(1.2, Math.min(1.84 / a, 1.84));
      else {
        n.setAxisTitlePixelOffset(1.2 * l.fontSize), n.setTickLabelPixelOffset(0.1 * l.fontSize);
        const u = 2 * (0.8 * l.fontSize + c.titleHeight + n.getAxisTitlePixelOffset()) / r[1], h = 2 * c.tickWidth / r[0];
        f[0] = Math.min(1.9, Math.max(1.4, 1.4 * h * (n.getTicks().length + 3))), f[1] = u, n.setBoxPosition([
          -0.5 * f[0],
          -0.97
        ]);
      }
      n.recomputeBarSegments(c);
    };
  }
  function eV(t, e) {
    return (n) => {
      const r = n.getLastTickBounds(), i = Dy().domain([
        r[0],
        r[1]
      ]), a = i.ticks(5), s = i.tickFormat(5);
      n.setTicks(a), n.setTickStrings(a.map(s));
    };
  }
  function lle(t, e) {
    e.classHierarchy.push("vtkScalarBarActorHelper"), t.setRenderable = (i) => {
      e.renderable !== i && (e.renderable = i, e.barActor.setProperty(i.getProperty()), e.barActor.setParentProp(i), e.barActor.setCoordinateSystemToDisplay(), e.tmActor.setProperty(i.getProperty()), e.tmActor.setParentProp(i), e.tmActor.setCoordinateSystemToDisplay(), e.generateTicks = i.generateTicks, e.axisTextStyle = {
        ...i.getAxisTextStyle()
      }, e.tickTextStyle = {
        ...i.getTickTextStyle()
      }, t.modified());
    }, t.updateAPISpecificData = (i, a, s) => {
      (e.lastSize[0] !== i[0] || e.lastSize[1] !== i[1]) && (e.lastSize[0] = i[0], e.lastSize[1] = i[1], e.lastAspectRatio = i[0] / i[1], e.forceUpdate = true);
      const o = e.renderable.getScalarsToColors();
      if (!(!o || !e.renderable.getVisibility()) && (e.barMapper.setLookupTable(o), e.camera = a, e.renderWindow = s, e.forceUpdate || Math.max(o.getMTime(), t.getMTime(), e.renderable.getMTime()) > e.lastRebuildTime.getMTime())) {
        const l = o.getMappingRange();
        if (e.lastTickBounds = [
          ...l
        ], e.renderable.getGenerateTicks()(t), e.renderable.getAutomated()) e.renderable.getAutoLayout()(t);
        else {
          e.axisTextStyle = {
            ...e.renderable.getAxisTextStyle()
          }, e.tickTextStyle = {
            ...e.renderable.getTickTextStyle()
          }, e.barPosition = [
            ...e.renderable.getBarPosition()
          ], e.barSize = [
            ...e.renderable.getBarSize()
          ], e.boxPosition = [
            ...e.renderable.getBoxPosition()
          ], e.boxSize = [
            ...e.renderable.getBoxSize()
          ], e.axisTitlePixelOffset = e.renderable.getAxisTitlePixelOffset(), e.tickLabelPixelOffset = e.renderable.getTickLabelPixelOffset();
          const c = t.updateTextureAtlas();
          t.recomputeBarSegments(c);
        }
        t.updatePolyDataForLabels(), t.updatePolyDataForBarSegments(), e.lastRebuildTime.modified(), e.forceUpdate = false;
      }
    }, t.updateTextureAtlas = () => {
      e.tmContext.textBaseline = "bottom", e.tmContext.textAlign = "left";
      const i = {}, a = /* @__PURE__ */ new Map();
      let s = 0, o = 1;
      av(e.tmContext, e.axisTextStyle);
      let l = e.tmContext.measureText(e.renderable.getAxisLabel()), c = {
        height: l.actualBoundingBoxAscent + 2,
        startingHeight: o,
        width: l.width + 2,
        textStyle: e.axisTextStyle
      };
      a.set(e.renderable.getAxisLabel(), c), o += c.height, s = c.width, i.titleWidth = c.width, i.titleHeight = c.height, i.tickWidth = 0, i.tickHeight = 0, av(e.tmContext, e.tickTextStyle);
      const f = [
        ...t.getTickStrings(),
        "NaN",
        "Below",
        "Above"
      ];
      for (let u = 0; u < f.length; u++) a.has(f[u]) || (l = e.tmContext.measureText(f[u]), c = {
        height: l.actualBoundingBoxAscent + 2,
        startingHeight: o,
        width: l.width + 2,
        textStyle: e.tickTextStyle
      }, a.set(f[u], c), o += c.height, s < c.width && (s = c.width), i.tickWidth < c.width && (i.tickWidth = c.width), i.tickHeight < c.height && (i.tickHeight = c.height));
      return s = Na(s), o = Na(o), a.forEach((u) => {
        u.tcoords = [
          0,
          (o - u.startingHeight - u.height) / o,
          u.width / s,
          (o - u.startingHeight - u.height) / o,
          u.width / s,
          (o - u.startingHeight) / o,
          0,
          (o - u.startingHeight) / o
        ];
      }), e.tmCanvas.width = s, e.tmCanvas.height = o, e.tmContext.textBaseline = "bottom", e.tmContext.textAlign = "left", e.tmContext.clearRect(0, 0, s, o), a.forEach((u, h) => {
        av(e.tmContext, u.textStyle), e.tmContext.fillText(h, 1, u.startingHeight + u.height - 1);
      }), e.tmTexture.setCanvas(e.tmCanvas), e.tmTexture.modified(), e._tmAtlas = a, i;
    }, t.computeBarSize = (i) => {
      e.vertical = e.boxSize[1] > e.boxSize[0];
      const a = 2 * i.tickHeight / e.lastSize[1], s = [
        1,
        1
      ];
      if (e.vertical) {
        const o = 2 * (i.tickWidth + e.tickLabelPixelOffset) / e.lastSize[0];
        if (e.topTitle) {
          const l = 2 * (i.titleHeight + e.axisTitlePixelOffset) / e.lastSize[1];
          e.barSize[0] = e.boxSize[0] - o, e.barSize[1] = e.boxSize[1] - l;
        } else {
          const l = 2 * (i.titleHeight + e.axisTitlePixelOffset) / e.lastSize[0];
          e.barSize[0] = e.boxSize[0] - l - o, e.barSize[1] = e.boxSize[1];
        }
        e.barPosition[0] = e.boxPosition[0] + o, e.barPosition[1] = e.boxPosition[1], s[1] = a;
      } else {
        const o = (2 * i.tickWidth - 8) / e.lastSize[0], l = 2 * (i.titleHeight + e.axisTitlePixelOffset) / e.lastSize[1];
        e.barSize[0] = e.boxSize[0], e.barPosition[0] = e.boxPosition[0], e.barSize[1] = e.boxSize[1] - l, e.barPosition[1] = e.boxPosition[1], s[0] = o;
      }
      return s;
    }, t.recomputeBarSegments = (i) => {
      var _a3, _b3, _c3, _d;
      const a = t.computeBarSize(i);
      e.barSegments = [];
      const s = [
        0,
        0
      ], o = e.vertical ? 1 : 0, l = e.vertical ? 0.01 : 0.02;
      function c(h, g) {
        e.barSegments.push({
          corners: [
            [
              ...s
            ],
            [
              s[0] + a[0],
              s[1]
            ],
            [
              s[0] + a[0],
              s[1] + a[1]
            ],
            [
              s[0],
              s[1] + a[1]
            ]
          ],
          scalars: g,
          title: h
        }), s[o] += a[o] + l;
      }
      e.renderable.getDrawNanAnnotation() && e.renderable.getScalarsToColors().getNanColor() && c("NaN", [
        NaN,
        NaN,
        NaN,
        NaN
      ]), e.renderable.getDrawBelowRangeSwatch() && ((_b3 = (_a3 = e.renderable.getScalarsToColors()).getUseBelowRangeColor) == null ? void 0 : _b3.call(_a3)) && c("Below", [
        -0.1,
        -0.1,
        -0.1,
        -0.1
      ]);
      const f = (_d = (_c3 = e.renderable.getScalarsToColors()).getUseAboveRangeColor) == null ? void 0 : _d.call(_c3);
      s[o] += l;
      const u = a[o];
      a[o] = f ? 1 - 2 * l - a[o] - s[o] : 1 - l - s[o], c("ticks", e.vertical ? [
        0,
        0,
        0.995,
        0.995
      ] : [
        0,
        0.995,
        0.995,
        0
      ]), e.renderable.getDrawAboveRangeSwatch() && f && (a[o] = u, s[o] += l, c("Above", [
        1.1,
        1.1,
        1.1,
        1.1
      ]));
    };
    const n = new Float64Array(3);
    t.createPolyDataForOneLabel = (i, a, s, o, l, c) => {
      const f = e._tmAtlas.get(i);
      if (!f) return;
      let u = c.ptIdx, h = c.cellIdx;
      n[0] = (0.5 * a[0] + 0.5) * e.lastSize[0], n[1] = (0.5 * a[1] + 0.5) * e.lastSize[1], n[2] = a[2], n[0] += l[0], n[1] += l[1];
      const g = [], v = o === "vertical" ? [
        1,
        0
      ] : [
        0,
        1
      ];
      o === "vertical" ? (g[0] = f.width, g[1] = -f.height, s[0] === "middle" ? n[1] -= f.width / 2 : s[0] === "right" && (n[1] -= f.width), s[1] === "middle" ? n[0] += f.height / 2 : s[1] === "top" && (n[0] += f.height)) : (g[0] = f.width, g[1] = f.height, s[0] === "middle" ? n[0] -= f.width / 2 : s[0] === "right" && (n[0] -= f.width), s[1] === "middle" ? n[1] -= f.height / 2 : s[1] === "top" && (n[1] -= f.height)), c.points[u * 3] = n[0], c.points[u * 3 + 1] = n[1], c.points[u * 3 + 2] = n[2], c.tcoords[u * 2] = f.tcoords[0], c.tcoords[u * 2 + 1] = f.tcoords[1], u++, n[v[0]] += g[0], c.points[u * 3] = n[0], c.points[u * 3 + 1] = n[1], c.points[u * 3 + 2] = n[2], c.tcoords[u * 2] = f.tcoords[2], c.tcoords[u * 2 + 1] = f.tcoords[3], u++, n[v[1]] += g[1], c.points[u * 3] = n[0], c.points[u * 3 + 1] = n[1], c.points[u * 3 + 2] = n[2], c.tcoords[u * 2] = f.tcoords[4], c.tcoords[u * 2 + 1] = f.tcoords[5], u++, n[v[0]] -= g[0], c.points[u * 3] = n[0], c.points[u * 3 + 1] = n[1], c.points[u * 3 + 2] = n[2], c.tcoords[u * 2] = f.tcoords[6], c.tcoords[u * 2 + 1] = f.tcoords[7], u++, c.polys[h * 4] = 3, c.polys[h * 4 + 1] = u - 4, c.polys[h * 4 + 2] = u - 3, c.polys[h * 4 + 3] = u - 2, h++, c.polys[h * 4] = 3, c.polys[h * 4 + 1] = u - 4, c.polys[h * 4 + 2] = u - 2, c.polys[h * 4 + 3] = u - 1, c.ptIdx += 4, c.cellIdx += 2;
    };
    const r = new Float64Array(3);
    t.updatePolyDataForLabels = () => {
      const i = t.getTickStrings().length + e.barSegments.length, a = i * 4, s = i * 2, o = new Float64Array(a * 3), l = new Uint16Array(s * 4), c = new Float32Array(a * 2), f = {
        ptIdx: 0,
        cellIdx: 0,
        polys: l,
        points: o,
        tcoords: c
      }, u = e.vertical ? 0 : 1, h = e.vertical ? 1 : 0;
      r[2] = -0.99;
      const g = e.vertical ? [
        "right",
        "middle"
      ] : [
        "middle",
        "bottom"
      ];
      let v = [
        0,
        1
      ];
      const m = [
        0,
        0
      ];
      e.vertical ? (m[0] = -e.tickLabelPixelOffset, e.topTitle ? (r[0] = e.boxPosition[0] + 0.5 * e.boxSize[0], r[1] = e.barPosition[1] + e.barSize[1], t.createPolyDataForOneLabel(e.renderable.getAxisLabel(), r, [
        "middle",
        "bottom"
      ], "horizontal", [
        0,
        e.axisTitlePixelOffset
      ], f)) : (r[0] = e.barPosition[0] + e.barSize[0], r[1] = e.barPosition[1] + 0.5 * e.barSize[1], t.createPolyDataForOneLabel(e.renderable.getAxisLabel(), r, [
        "middle",
        "top"
      ], "vertical", [
        e.axisTitlePixelOffset,
        0
      ], f)), v = [
        -1,
        0
      ]) : (m[1] = e.tickLabelPixelOffset, r[0] = e.barPosition[0] + 0.5 * e.barSize[0], r[1] = e.barPosition[1] + e.barSize[1], t.createPolyDataForOneLabel(e.renderable.getAxisLabel(), r, [
        "middle",
        "bottom"
      ], "horizontal", [
        0,
        e.axisTitlePixelOffset
      ], f)), r[u] = e.barPosition[u] + (0.5 * v[u] + 0.5) * e.barSize[u], r[h] = e.barPosition[h] + e.barSize[h] * 0.5;
      let y = null;
      for (let b = 0; b < e.barSegments.length; b++) {
        const D = e.barSegments[b];
        D.title === "ticks" ? y = D : (r[h] = e.barPosition[h] + 0.5 * e.barSize[h] * (D.corners[2][h] + D.corners[0][h]), t.createPolyDataForOneLabel(D.title, r, g, "horizontal", m, f));
      }
      const w = e.barPosition[h] + e.barSize[h] * y.corners[0][h], C = e.barSize[h] * (y.corners[2][h] - y.corners[0][h]), T = t.getTicks(), S = t.getTickStrings();
      for (let b = 0; b < T.length; b++) {
        const D = (T[b] - e.lastTickBounds[0]) / (e.lastTickBounds[1] - e.lastTickBounds[0]);
        r[h] = w + C * D, t.createPolyDataForOneLabel(S[b], r, g, "horizontal", m, f);
      }
      const E = Tt.newInstance({
        numberOfComponents: 2,
        values: c,
        name: "TextureCoordinates"
      });
      e.tmPolyData.getPointData().setTCoords(E), e.tmPolyData.getPoints().setData(o, 3), e.tmPolyData.getPoints().modified(), e.tmPolyData.getPolys().setData(l, 1), e.tmPolyData.getPolys().modified(), e.tmPolyData.modified();
    }, t.updatePolyDataForBarSegments = () => {
      var _a3, _b3;
      const i = e.renderable.getScalarsToColors();
      let a = 0;
      e.renderable.getDrawNanAnnotation() && i.getNanColor() && (a += 1), e.renderable.getDrawBelowRangeSwatch() && ((_a3 = i.getUseBelowRangeColor) == null ? void 0 : _a3.call(i)) && (a += 1), e.renderable.getDrawAboveRangeSwatch() && ((_b3 = i.getUseAboveRangeColor) == null ? void 0 : _b3.call(i)) && (a += 1);
      const s = 4 * (1 + a), o = s;
      let l = 1;
      i.getVectorMode() === ole.COMPONENT && (l = i.getVectorComponent() + 1);
      const c = new Float64Array(s * 3), f = new Uint16Array(o * 5), u = new Float32Array(s * l);
      let h = 0, g = 0;
      for (let m = 0; m < e.barSegments.length; m++) {
        const y = e.barSegments[m];
        for (let w = 0; w < 4; w++) {
          r[0] = e.barPosition[0] + y.corners[w][0] * e.barSize[0], r[1] = e.barPosition[1] + y.corners[w][1] * e.barSize[1], c[h * 3] = (0.5 * r[0] + 0.5) * e.lastSize[0], c[h * 3 + 1] = (0.5 * r[1] + 0.5) * e.lastSize[1], c[h * 3 + 2] = r[2];
          for (let C = 0; C < l; C++) u[h * l + C] = e.lastTickBounds[0] + y.scalars[w] * (e.lastTickBounds[1] - e.lastTickBounds[0]);
          h++;
        }
        f[g * 5] = 4, f[g * 5 + 1] = h - 4, f[g * 5 + 2] = h - 3, f[g * 5 + 3] = h - 2, f[g * 5 + 4] = h - 1, g++;
      }
      const v = Tt.newInstance({
        numberOfComponents: l,
        values: u,
        name: "Scalars"
      });
      e.polyData.getPointData().setScalars(v), e.polyData.getPoints().setData(c, 3), e.polyData.getPoints().modified(), e.polyData.getPolys().setData(f, 1), e.polyData.getPolys().modified(), e.polyData.modified();
    };
  }
  const cle = H.newInstance(function(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      renderable: null
    };
    Object.assign(e, {}, n), H.obj(t, e), H.setGet(t, e, [
      "axisTitlePixelOffset",
      "tickLabelPixelOffset",
      "renderable",
      "topTitle",
      "ticks",
      "tickStrings"
    ]), H.get(t, e, [
      "lastSize",
      "lastAspectRatio",
      "lastTickBounds",
      "axisTextStyle",
      "tickTextStyle",
      "barActor",
      "tmActor"
    ]), H.getArray(t, e, [
      "boxPosition",
      "boxSize"
    ]), H.setArray(t, e, [
      "boxPosition",
      "boxSize"
    ], 2), e.forceUpdate = false, e.lastRebuildTime = {}, H.obj(e.lastRebuildTime, {
      mtime: 0
    }), e.lastSize = [
      -1,
      -1
    ], e.tmCanvas = document.createElement("canvas"), e.tmContext = e.tmCanvas.getContext("2d"), e._tmAtlas = /* @__PURE__ */ new Map(), e.barMapper = Kc.newInstance(), e.barMapper.setInterpolateScalarsBeforeMapping(true), e.barMapper.setUseLookupTableScalarRange(true), e.polyData = $i.newInstance(), e.barMapper.setInputData(e.polyData), e.barActor = qc.newInstance(), e.barActor.setMapper(e.barMapper), e.tmPolyData = $i.newInstance(), e.tmMapper = Kc.newInstance(), e.tmMapper.setInputData(e.tmPolyData), e.tmTexture = N5.newInstance({
      resizable: true
    }), e.tmTexture.setInterpolate(false), e.tmActor = qc.newInstance({
      parentProp: t
    }), e.tmActor.setMapper(e.tmMapper), e.tmActor.addTexture(e.tmTexture), e.barPosition = [
      0,
      0
    ], e.barSize = [
      0,
      0
    ], e.boxPosition = [
      0.88,
      -0.92
    ], e.boxSize = [
      0.1,
      1.1
    ], e.lastTickBounds = [], lle(t, e);
  }, "vtkScalarBarActorHelper");
  function ule(t, e) {
    e.classHierarchy.push("vtkScalarBarActor"), t.setTickTextStyle = (n) => {
      e.tickTextStyle = {
        ...e.tickTextStyle,
        ...n
      }, t.modified();
    }, t.setAxisTextStyle = (n) => {
      e.axisTextStyle = {
        ...e.axisTextStyle,
        ...n
      }, t.modified();
    }, t.resetAutoLayoutToDefault = () => {
      t.setAutoLayout($I(t, e));
    }, t.resetGenerateTicksToDefault = () => {
      t.setGenerateTicks(eV());
    };
  }
  function fle(t) {
    return {
      automated: true,
      autoLayout: null,
      axisLabel: "Scalar Value",
      barPosition: [
        0,
        0
      ],
      barSize: [
        0,
        0
      ],
      boxPosition: [
        0.88,
        -0.92
      ],
      boxSize: [
        0.1,
        1.1
      ],
      scalarToColors: null,
      axisTitlePixelOffset: 36,
      axisTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 18,
        fontFamily: "serif"
      },
      tickLabelPixelOffset: 14,
      tickTextStyle: {
        fontColor: "white",
        fontStyle: "normal",
        fontSize: 14,
        fontFamily: "serif"
      },
      generateTicks: null,
      drawNanAnnotation: true,
      drawBelowRangeSwatch: true,
      drawAboveRangeSwatch: true,
      ...t
    };
  }
  function tV(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, fle(n)), e.autoLayout || (e.autoLayout = $I(t, e)), e.generateTicks || (e.generateTicks = eV()), qc.extend(t, e, n), t.getProperty().setDiffuse(0), t.getProperty().setAmbient(1), H.setGet(t, e, [
      "automated",
      "autoLayout",
      "axisTitlePixelOffset",
      "axisLabel",
      "scalarsToColors",
      "tickLabelPixelOffset",
      "generateTicks",
      "drawNanAnnotation",
      "drawBelowRangeSwatch",
      "drawAboveRangeSwatch"
    ]), H.get(t, e, [
      "axisTextStyle",
      "tickTextStyle"
    ]), H.getArray(t, e, [
      "barPosition",
      "barSize",
      "boxPosition",
      "boxSize"
    ]), H.setArray(t, e, [
      "barPosition",
      "barSize",
      "boxPosition",
      "boxSize"
    ], 2), ule(t, e);
  }
  const hle = H.newInstance(tV, "vtkScalarBarActor");
  var nV = {
    newInstance: hle,
    extend: tV,
    newScalarBarActorHelper: cle
  };
  function dle(t, e) {
    e.classHierarchy.push("vtkOpenGLScalarBarActor"), t.buildPass = (n) => {
      n && (e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.scalarBarActorHelper.getRenderable() || e.scalarBarActorHelper.setRenderable(e.renderable), t.prepareNodes(), t.addMissingNode(e.scalarBarActorHelper.getBarActor()), t.addMissingNode(e.scalarBarActorHelper.getTmActor()), t.removeUnusedNodes());
    }, t.opaquePass = (n, r) => {
      if (n) {
        const i = e._openGLRenderer ? e._openGLRenderer.getRenderable().getActiveCamera() : null, a = e._openGLRenderer.getTiledSizeAndOrigin();
        e.scalarBarActorHelper.updateAPISpecificData([
          a.usize,
          a.vsize
        ], i, e._openGLRenderWindow.getRenderable());
      }
    };
  }
  const gle = {};
  function ple(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, gle, n), Rn.extend(t, e, n), e.scalarBarActorHelper = nV.newScalarBarActorHelper(), dle(t, e);
  }
  const mle = pn(ple, "vtkOpenGLScalarBarActor");
  Er("vtkScalarBarActor", mle);
  const { CoordinateSystem: kS } = nd;
  function vle(t, e) {
    e.classHierarchy.push("vtkWebGPUActor"), t.buildPass = (n) => {
      n && (e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow"), e.propID === void 0 && (e.propID = e.WebGPURenderWindow.getUniquePropID()), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes());
    }, t.traverseOpaquePass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children[0] && e.children[0].traverse(n), t.apply(n, false));
    }, t.traverseTranslucentPass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children[0] && e.children[0].traverse(n), t.apply(n, false));
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
      }
    }, t.getBufferShift = (n) => (t.getKeyMatrices(n), e.bufferShift), t.getKeyMatrices = (n) => {
      if (Math.max(e.renderable.getMTime(), n.getStabilizedTime()) > e.keyMatricesTime.getMTime()) {
        e.renderable.computeMatrix();
        const r = e.renderable.getMatrix();
        e.bufferShift[0] = r[3], e.bufferShift[1] = r[7], e.bufferShift[2] = r[11];
        const i = n.getStabilizedCenterByReference();
        e.renderable.getCoordinateSystem() === kS.WORLD && (e.bufferShift[0] -= i[0], e.bufferShift[1] -= i[1], e.bufferShift[2] -= i[2]), en(e.keyMatrices.bcwc, r), e.renderable.getIsIdentity() ? gt(e.keyMatrices.normalMatrix) : (sr(e.keyMatrices.normalMatrix, e.keyMatrices.bcwc), e.keyMatrices.normalMatrix[3] = 0, e.keyMatrices.normalMatrix[7] = 0, e.keyMatrices.normalMatrix[11] = 0, Nr(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), en(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix)), $n(e.keyMatrices.bcwc, e.keyMatrices.bcwc, [
          -e.bufferShift[0],
          -e.bufferShift[1],
          -e.bufferShift[2]
        ]), e.renderable.getCoordinateSystem() === kS.WORLD ? $n(e.keyMatrices.bcsc, e.keyMatrices.bcwc, [
          -i[0],
          -i[1],
          -i[2]
        ]) : sr(e.keyMatrices.bcsc, e.keyMatrices.bcwc), e.keyMatricesTime.modified();
      }
      return e.keyMatrices;
    };
  }
  const yle = {
    keyMatricesTime: null,
    keyMatrices: null,
    propID: void 0,
    bufferShift: void 0
  };
  function xle(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, yle, n), Rn.extend(t, e, n), e.keyMatricesTime = {}, H.obj(e.keyMatricesTime, {
      mtime: 0
    }), e.keyMatrices = {
      normalMatrix: new Float64Array(16),
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    }, H.get(t, e, [
      "propID",
      "keyMatricesTime"
    ]), e.bufferShift = [
      0,
      0,
      0,
      0
    ], vle(t, e);
  }
  const wle = H.newInstance(xle);
  ka("vtkActor", wle);
  const { CoordinateSystem: PS } = nd;
  function Cle(t, e) {
    e.classHierarchy.push("vtkWebGPUActor2D"), t.buildPass = (n) => {
      n && (e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow"), e.propID === void 0 && (e.propID = e.WebGPURenderWindow.getUniquePropID()), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes());
    }, t.traverseOpaquePass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children[0] && e.children[0].traverse(n), t.apply(n, false));
    }, t.traverseTranslucentPass = (n) => {
      !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, true), e.children[0] && e.children[0].traverse(n), t.apply(n, false));
    }, t.queryPass = (n, r) => {
      if (n) {
        if (!e.renderable || !e.renderable.getVisibility()) return;
        e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
      }
    }, t.getBufferShift = (n) => (t.getKeyMatrices(n), e.bufferShift), t.getKeyMatrices = (n) => {
      if (Math.max(e.renderable.getMTime(), n.getStabilizedTime()) > e.keyMatricesTime.getMTime()) {
        e.bufferShift[0] = 0, e.bufferShift[1] = 0, e.bufferShift[2] = 0;
        const r = n.getStabilizedCenterByReference();
        e.renderable.getCoordinateSystem() === PS.WORLD && (e.bufferShift[0] -= r[0], e.bufferShift[1] -= r[1], e.bufferShift[2] -= r[2]), gt(e.keyMatrices.bcwc), gt(e.keyMatrices.normalMatrix), $n(e.keyMatrices.bcwc, e.keyMatrices.bcwc, [
          -e.bufferShift[0],
          -e.bufferShift[1],
          -e.bufferShift[2]
        ]), e.renderable.getCoordinateSystem() === PS.WORLD ? $n(e.keyMatrices.bcsc, e.keyMatrices.bcwc, [
          -r[0],
          -r[1],
          -r[2]
        ]) : sr(e.keyMatrices.bcsc, e.keyMatrices.bcwc), e.keyMatricesTime.modified();
      }
      return e.keyMatrices;
    };
  }
  const Tle = {
    keyMatricesTime: null,
    keyMatrices: null,
    propID: void 0,
    bufferShift: void 0
  };
  function Sle(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Tle, n), Rn.extend(t, e, n), e.keyMatricesTime = {}, H.obj(e.keyMatricesTime, {
      mtime: 0
    }), e.keyMatrices = {
      normalMatrix: new Float64Array(16),
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    }, H.get(t, e, [
      "propID",
      "keyMatricesTime"
    ]), e.bufferShift = [
      0,
      0,
      0,
      0
    ], Cle(t, e);
  }
  const Ale = H.newInstance(Sle);
  ka("vtkActor2D", Ale);
  function Ele(t, e) {
    e.classHierarchy.push("vtkWebGPUCubeAxesActor"), t.buildPass = (n) => {
      n && (e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getParent(), e.CubeAxesActorHelper.getRenderable() || e.CubeAxesActorHelper.setRenderable(e.renderable), t.prepareNodes(), t.addMissingNode(e.CubeAxesActorHelper.getTmActor()), t.addMissingNode(e.renderable.getGridActor()), t.removeUnusedNodes());
    }, t.opaquePass = (n, r) => {
      if (n) {
        const i = e.WebGPURenderer ? e.WebGPURenderer.getRenderable().getActiveCamera() : null, a = e.WebGPURenderer.getTiledSizeAndOrigin();
        e.CubeAxesActorHelper.updateAPISpecificData([
          a.usize,
          a.vsize
        ], i, e.WebGPURenderWindow.getRenderable());
      }
    };
  }
  const ble = {};
  function Dle(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, ble, n), Rn.extend(t, e, n), e.CubeAxesActorHelper = ZI.newCubeAxesActorHelper(), Ele(t, e);
  }
  const Mle = pn(Dle, "vtkWebGPUCubeAxesActor");
  ka("vtkCubeAxesActor", Mle);
  const { DisplayLocation: E6 } = JI;
  function Rle(t, e) {
    e.classHierarchy.push("vtkProperty2D"), t.setDisplayLocationToBackground = () => t.setDisplayLocation(E6.BACKGROUND), t.setDisplayLocationToForeground = () => t.setDisplayLocation(E6.FOREGROUND), t.setRepresentationToWireframe = () => t.setRepresentation(fi.WIREFRAME), t.setRepresentationToSurface = () => t.setRepresentation(fi.SURFACE), t.setRepresentationToPoints = () => t.setRepresentation(fi.POINTS), t.getRepresentationAsString = () => H.enumToString(fi, e.representation);
  }
  const Ole = {
    color: [
      1,
      1,
      1
    ],
    opacity: 1,
    pointSize: 1,
    lineWidth: 1,
    representation: fi.SURFACE,
    displayLocation: E6.FOREGROUND
  };
  function Ile(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Ole, n), H.obj(t, e), H.setGet(t, e, [
      "opacity",
      "lineWidth",
      "pointSize",
      "displayLocation",
      "representation"
    ]), H.setGetArray(t, e, [
      "color"
    ], 3), Rle(t, e);
  }
  H.newInstance(Ile, "vtkProperty2D");
  var Vle = {
    ...JI
  };
  const { BufferUsage: Yr, PrimitiveTypes: Li } = tf, { Representation: ng } = ef, { ScalarMode: rg } = Kc, { CoordinateSystem: Nle } = nd, { DisplayLocation: Lle } = Vle, Ule = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`, Fle = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var pi: f32 = 3.14159265359; 
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var pi: f32 = 3.14159265359; 

  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;
  
  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  
  var L: vec3<f32> = normalize(direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf*incoming*angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); 
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// TODO: find some way to reduce the number of arguments going in here
fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = color * (1.0 / (dist*dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  
  // Cones.x is the inner phi and cones.y is the outer phi
  var theta: f32 = mdot(normalize(direction), L);
  var epsilon: f32 = cones.x - cones.y;
  var intensity: f32 = (theta - cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist*dist;

  var incoming: vec3<f32> = color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
  function GS(t) {
    return t.indexOf("edge") >= 0;
  }
  function Ble(t, e) {
    e.classHierarchy.push("vtkWebGPUCellArrayMapper"), t.buildPass = (n) => {
      n && (e.is2D ? (e.WebGPUActor = t.getFirstAncestorOfType("vtkWebGPUActor2D"), e.forceZValue = true) : (e.WebGPUActor = t.getFirstAncestorOfType("vtkWebGPUActor"), e.forceZValue = false), e.coordinateSystem = e.WebGPUActor.getRenderable().getCoordinateSystem(), e.useRendererMatrix = e.coordinateSystem !== Nle.DISPLAY, e.WebGPURenderer = e.WebGPUActor.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getParent(), e.device = e.WebGPURenderWindow.getDevice());
    }, t.translucentPass = (n) => {
      n && (t.prepareToDraw(e.WebGPURenderer.getRenderEncoder()), e.renderEncoder.registerDrawCallback(e.pipeline, t.draw));
    }, t.opaquePass = (n) => {
      n && (t.prepareToDraw(e.WebGPURenderer.getRenderEncoder()), e.renderEncoder.registerDrawCallback(e.pipeline, t.draw));
    }, t.updateUBO = () => {
      var _a3;
      const r = e.WebGPUActor.getRenderable().getProperty(), i = e.UBO.getSendTime();
      if (t.getMTime() > i || r.getMTime() > i || e.renderable.getMTime() > i) {
        const a = e.WebGPUActor.getKeyMatrices(e.WebGPURenderer);
        if (e.UBO.setArray("BCWCMatrix", a.bcwc), e.UBO.setArray("BCSCMatrix", a.bcsc), e.UBO.setArray("MCWCNormals", a.normalMatrix), e.is2D) {
          e.UBO.setValue("ZValue", e.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === Lle.FOREGROUND ? 1 : 0);
          const l = r.getColorByReference();
          e.UBO.setValue("AmbientIntensity", 1), e.UBO.setArray("DiffuseColor", [
            l[0],
            l[1],
            l[2],
            1
          ]), e.UBO.setValue("DiffuseIntensity", 0), e.UBO.setValue("SpecularIntensity", 0);
        } else {
          let l = r.getAmbientColorByReference();
          e.UBO.setValue("AmbientIntensity", r.getAmbient()), e.UBO.setArray("AmbientColor", [
            l[0],
            l[1],
            l[2],
            1
          ]), e.UBO.setValue("DiffuseIntensity", r.getDiffuse()), l = r.getDiffuseColorByReference(), e.UBO.setArray("DiffuseColor", [
            l[0],
            l[1],
            l[2],
            1
          ]), e.UBO.setValue("Roughness", r.getRoughness()), e.UBO.setValue("BaseIOR", r.getBaseIOR()), e.UBO.setValue("Metallic", r.getMetallic()), e.UBO.setValue("NormalStrength", r.getNormalStrength()), e.UBO.setValue("Emission", r.getEmission()), e.UBO.setValue("SpecularIntensity", r.getSpecular()), l = r.getSpecularColorByReference(), e.UBO.setArray("SpecularColor", [
            l[0],
            l[1],
            l[2],
            1
          ]);
        }
        const s = (_a3 = r.getEdgeColorByReference) == null ? void 0 : _a3.call(r);
        s && e.UBO.setArray("EdgeColor", [
          s[0],
          s[1],
          s[2],
          1
        ]), e.UBO.setValue("LineWidth", r.getLineWidth()), e.UBO.setValue("Opacity", r.getOpacity()), e.UBO.setValue("PropID", e.WebGPUActor.getPropID());
        const o = e.WebGPURenderWindow.getDevice();
        e.UBO.sendIfNeeded(o);
      }
    }, t.haveWideLines = () => {
      const n = e.WebGPUActor.getRenderable(), r = n.getProperty().getRepresentation();
      return n.getProperty().getLineWidth() <= 1 || e.primitiveType === Li.Verts ? false : e.primitiveType === Li.Triangles || e.primitiveType === Li.TriangleStrips ? r === ng.WIREFRAME : true;
    }, t.replaceShaderPosition = (n, r, i) => {
      const a = r.getShaderDescription("vertex");
      a.addBuiltinOutput("vec4<f32>", "@builtin(position) Position"), a.hasOutput("vertexVC") || a.addOutput("vec4<f32>", "vertexVC");
      let s = a.getCode();
      e.useRendererMatrix ? (s = Dn.substitute(s, "//VTK::Position::Impl", [
        "    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;",
        "    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);",
        "//VTK::Position::Impl"
      ]).result, e.forceZValue && (s = Dn.substitute(s, "//VTK::Position::Impl", [
        "pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);",
        "pCoord.z = mapperUBO.ZValue;",
        "//VTK::Position::Impl"
      ]).result)) : (s = Dn.substitute(s, "//VTK::Position::Impl", [
        "    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;",
        "    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;",
        "    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;",
        "    pCoord.z = 0.5 - 0.5 * pCoord.z;",
        "//VTK::Position::Impl"
      ]).result, e.forceZValue && (s = Dn.substitute(s, "//VTK::Position::Impl", [
        "    pCoord.z = mapperUBO.ZValue;",
        "//VTK::Position::Impl"
      ]).result)), t.haveWideLines() && (a.addBuiltinInput("u32", "@builtin(instance_index) instanceIndex"), s = Dn.substitute(s, "//VTK::Position::Impl", [
        "    var tmpPos: vec4<f32> = pCoord;",
        "    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);",
        "    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;",
        "    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;",
        "    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;",
        "    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;",
        "    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);",
        "    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);",
        "//VTK::Position::Impl"
      ]).result), s = Dn.substitute(s, "//VTK::Position::Impl", [
        "    output.Position = pCoord;"
      ]).result, a.setCode(s);
    }, e.shaderReplacements.set("replaceShaderPosition", t.replaceShaderPosition), t.replaceShaderNormal = (n, r, i) => {
      const a = i.getBuffer("normalMC"), s = e.WebGPUActor.getRenderable();
      if (a) {
        const o = r.getShaderDescription("vertex");
        o.hasOutput("normalVC") || o.addOutput("vec3<f32>", "normalVC", a.getArrayInformation()[0].interpolation), o.hasOutput("tangentVC") || o.addOutput("vec3<f32>", "tangentVC", a.getArrayInformation()[0].interpolation), o.hasOutput("bitangentVC") || o.addOutput("vec3<f32>", "bitangentVC", a.getArrayInformation()[0].interpolation);
        let l = o.getCode();
        l = Dn.substitute(l, "//VTK::Normal::Impl", [
          "  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);",
          "  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));",
          "  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));",
          "  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));",
          "  output.tangentVC = normalize(tangent);",
          "  output.bitangentVC = normalize(cross(output.normalVC, tangent));"
        ]).result, o.setCode(l);
        const c = r.getShaderDescription("fragment");
        l = c.getCode(), s.getProperty().getNormalTexture() ? l = Dn.substitute(l, "//VTK::Normal::Impl", [
          "  var normal: vec3<f32> = input.normalVC;",
          "  if (!input.frontFacing) { normal = -normal; }",
          "  var tangent: vec3<f32> = input.tangentVC;",
          "  var bitangent: vec3<f32> = input.bitangentVC;",
          "  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(",
          "    tangent.x, bitangent.x, normal.x,",
          "    tangent.y, bitangent.y, normal.y,",
          "    tangent.z, bitangent.z, normal.z,",
          "  );",
          "  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);",
          "  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);",
          "  normal = normalize(normal);"
        ]).result : l = Dn.substitute(l, "//VTK::Normal::Impl", [
          "  var normal: vec3<f32> = input.normalVC;",
          "  if (!input.frontFacing) { normal = -normal; }",
          "  normal = normalize(normal);"
        ]).result, c.setCode(l);
      }
    }, e.shaderReplacements.set("replaceShaderNormal", t.replaceShaderNormal), t.replaceShaderLight = (n, r, i) => {
      var _a3;
      if (n.includes("sel")) return;
      const a = r.getShaderDescription("vertex");
      a.hasOutput("vertexVC") || a.addOutput("vec4<f32>", "vertexVC");
      const s = e.WebGPURenderer.getRenderable(), o = r.getShaderDescription("fragment");
      let l = o.getCode();
      if (l.includes("var normal:") && e.useRendererMatrix && !GS(n) && !e.is2D && !n.includes("sel")) {
        const c = [
          "  var pi: f32 = 3.14159265359;",
          "  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);",
          "  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector",
          "  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;",
          "  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);",
          "  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;",
          "  var alpha: f32 = roughness*roughness;",
          "  var ior: f32 = mapperUBO.BaseIOR;",
          "  var k: f32 = alpha*alpha / 2;",
          "  var diffuse: vec3<f32> = vec3<f32>(0.);",
          "  var specular: vec3<f32> = vec3<f32>(0.);",
          "  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;",
          "  {",
          "    var i: i32 = 0;",
          "    loop {",
          "      if !(i < rendererUBO.LightCount) { break; }",
          "      switch (i32(rendererLightSSBO.values[i].LightData.x)) {",
          "         // Point Light",
          "         case 0 {",
          "           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
          "           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;",
          "           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);",
          "           diffuse += max(vec3<f32>(0), calculated.diffuse);",
          "           specular += max(vec3<f32>(0), calculated.specular);",
          "          }",
          "         // Directional light",
          "         case 1 {",
          "           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;",
          "           dir = normalize(dir);",
          "           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
          "           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color",
          "           diffuse += max(vec3<f32>(0), calculated.diffuse);",
          "           specular += max(vec3<f32>(0), calculated.specular);",
          "         }",
          "         // Spot Light",
          "         case 2 {",
          "           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
          "           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;",
          "           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;",
          "           dir = normalize(dir);",
          "           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);",
          "           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);",
          "           diffuse += max(vec3<f32>(0), calculated.diffuse);",
          "           specular += max(vec3<f32>(0), calculated.specular);",
          "         }",
          "         default { continue; }",
          "       }",
          "      continuing { i++; }",
          "    }",
          "  }",
          "  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel",
          "  fresnel = min(1.0, fresnel);",
          "  // This could be controlled with its own variable (that isnt base color) for better artistic control",
          "  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account",
          "  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);",
          "  kS = min(vec3<f32>(1.0), kS);",
          "  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);",
          "  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;",
          "  PBR += emission;",
          "  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);"
        ];
        ((_a3 = s.getEnvironmentTexture()) == null ? void 0 : _a3.getImageLoaded()) && c.push("  // To get diffuse IBL, the texture is sampled with normals in worldspace", "  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;", "  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);", "  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors", "  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment", "  var VreflN: vec3<f32> = normalize(reflect(-V, normal));", "  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;", "  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);", "  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);", "  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;", "  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);", "  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;", "  computedColor += vec4<f32>(specularIBLContribution*kS, 0);", "  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;", "  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;", "  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);"), l = Dn.substitute(l, "//VTK::Light::Impl", c).result, o.setCode(l);
      } else l = Dn.substitute(l, "//VTK::Light::Impl", [
        "  var diffuse: vec3<f32> = diffuseColor.rgb;",
        "  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;",
        "  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);"
      ]).result, o.setCode(l);
    }, e.shaderReplacements.set("replaceShaderLight", t.replaceShaderLight), t.replaceShaderColor = (n, r, i) => {
      if (GS(n)) {
        const c = r.getShaderDescription("fragment");
        let f = c.getCode();
        f = Dn.substitute(f, "//VTK::Color::Impl", [
          "ambientColor = mapperUBO.EdgeColor;",
          "diffuseColor = mapperUBO.EdgeColor;"
        ]).result, c.setCode(f);
        return;
      }
      const a = i.getBuffer("colorVI");
      if (!a) return;
      const s = r.getShaderDescription("vertex");
      s.addOutput("vec4<f32>", "color", a.getArrayInformation()[0].interpolation);
      let o = s.getCode();
      o = Dn.substitute(o, "//VTK::Color::Impl", [
        "  output.color = colorVI;"
      ]).result, s.setCode(o);
      const l = r.getShaderDescription("fragment");
      o = l.getCode(), o = Dn.substitute(o, "//VTK::Color::Impl", [
        "ambientColor = input.color;",
        "diffuseColor = input.color;",
        "opacity = mapperUBO.Opacity * input.color.a;"
      ]).result, l.setCode(o);
    }, e.shaderReplacements.set("replaceShaderColor", t.replaceShaderColor), t.replaceShaderTCoord = (n, r, i) => {
      var _a3, _b3, _c3, _d, _e11, _f, _g2, _h2, _i3, _j2, _k2, _l2, _m, _n3, _o, _p2, _q2, _r2, _s, _t6;
      if (!i.hasAttribute("tcoord")) return;
      const a = r.getShaderDescription("vertex"), s = i.getBuffer("tcoord"), o = ui.getNumberOfComponentsFromBufferFormat(s.getArrayInformation()[0].format);
      let l = a.getCode();
      a.addOutput(`vec${o}<f32>`, "tcoordVS"), l = Dn.substitute(l, "//VTK::TCoord::Impl", [
        "  output.tcoordVS = tcoord;"
      ]).result, a.setCode(l);
      const c = r.getShaderDescription("fragment");
      l = c.getCode();
      const f = e.WebGPUActor.getRenderable(), u = (g) => g ? g.getDimensionality() === o : false, h = [];
      (((_c3 = (_b3 = (_a3 = f.getProperty()).getDiffuseTexture) == null ? void 0 : _b3.call(_a3)) == null ? void 0 : _c3.getImageLoaded()) || f.getTextures()[0] || e.colorTexture) && (u((_e11 = (_d = f.getProperty()).getDiffuseTexture) == null ? void 0 : _e11.call(_d)) || u(f.getTextures()[0]) || u(e.colorTexture)) && h.push("_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);"), ((_h2 = (_g2 = (_f = f.getProperty()).getRoughnessTexture) == null ? void 0 : _g2.call(_f)) == null ? void 0 : _h2.getImageLoaded()) && u(f.getProperty().getRoughnessTexture()) && h.push("_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);"), ((_k2 = (_j2 = (_i3 = f.getProperty()).getMetallicTexture) == null ? void 0 : _j2.call(_i3)) == null ? void 0 : _k2.getImageLoaded()) && u(f.getProperty().getMetallicTexture()) && h.push("_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);"), ((_n3 = (_m = (_l2 = f.getProperty()).getNormalTexture) == null ? void 0 : _m.call(_l2)) == null ? void 0 : _n3.getImageLoaded()) && u(f.getProperty().getNormalTexture()) && h.push("_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);"), ((_q2 = (_p2 = (_o = f.getProperty()).getAmbientOcclusionTexture) == null ? void 0 : _p2.call(_o)) == null ? void 0 : _q2.getImageLoaded()) && u(f.getProperty().getAmbientOcclusionTexture()) && h.push("_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);"), ((_t6 = (_s = (_r2 = f.getProperty()).getEmissionTexture) == null ? void 0 : _s.call(_r2)) == null ? void 0 : _t6.getImageLoaded()) && u(f.getProperty().getEmissionTexture()) && h.push("_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);"), l = Dn.substitute(l, "//VTK::TCoord::Impl", h).result, c.setCode(l);
    }, e.shaderReplacements.set("replaceShaderTCoord", t.replaceShaderTCoord), t.replaceShaderSelect = (n, r, i) => {
      if (n.includes("sel")) {
        const a = r.getShaderDescription("fragment");
        let s = a.getCode();
        s = Dn.substitute(s, "//VTK::Select::Impl", [
          "  var compositeID: u32 = 0u;"
        ]).result, a.setCode(s);
      }
    }, e.shaderReplacements.set("replaceShaderSelect", t.replaceShaderSelect), t.getUsage = (n, r) => n === ng.POINTS || r === Li.Points ? Yr.Verts : r === Li.Lines ? Yr.Lines : n === ng.WIREFRAME ? r === Li.Triangles ? Yr.LinesFromTriangles : Yr.LinesFromStrips : r === Li.Triangles ? Yr.Triangles : r === Li.TriangleStrips ? Yr.Strips : r === Li.TriangleEdges ? Yr.LinesFromTriangles : Yr.LinesFromStrips, t.getHashFromUsage = (n) => `pt${n}`, t.getTopologyFromUsage = (n) => {
      switch (n) {
        case Yr.Triangles:
          return "triangle-list";
        case Yr.Verts:
          return "point-list";
        case Yr.Lines:
        default:
          return "line-list";
      }
    }, t.buildVertexInput = () => {
      var _a3, _b3;
      const n = e.currentInput, r = e.cellArray, i = e.primitiveType;
      let s = e.WebGPUActor.getRenderable().getProperty().getRepresentation();
      const o = e.WebGPURenderWindow.getDevice();
      let l = false;
      i === Li.TriangleEdges && (l = true, s = ng.WIREFRAME);
      const c = e.vertexInput, f = n.getPoints();
      let u;
      if (r) {
        const m = {
          hash: `R${s}P${i}${r.getMTime()}`,
          usage: Yr.Index,
          cells: r,
          numberOfPoints: f.getNumberOfPoints(),
          primitiveType: i,
          representation: s
        };
        u = o.getBufferManager().getBuffer(m), c.setIndexBuffer(u);
      } else c.setIndexBuffer(null);
      if (f) {
        const m = e.WebGPUActor.getBufferShift(e.WebGPURenderer), y = {
          hash: `${f.getMTime()}I${u.getMTime()}${m.join()}float32x4`,
          usage: Yr.PointArray,
          format: "float32x4",
          dataArray: f,
          indexBuffer: u,
          shift: m,
          packExtra: true
        }, w = o.getBufferManager().getBuffer(y);
        c.addBuffer(w, [
          "vertexBC"
        ]);
      } else c.removeBufferIfPresent("vertexBC");
      const h = t.getUsage(s, i);
      if (e._usesCellNormals = false, !e.is2D && (h === Yr.Triangles || h === Yr.Strips)) {
        const m = n.getPointData().getNormals(), y = {
          format: "snorm8x4",
          indexBuffer: u,
          packExtra: true,
          shift: 0,
          scale: 127
        };
        if (m) {
          y.hash = `${m.getMTime()}I${u.getMTime()}snorm8x4`, y.dataArray = m, y.usage = Yr.PointArray;
          const w = o.getBufferManager().getBuffer(y);
          c.addBuffer(w, [
            "normalMC"
          ]);
        } else if (i === Li.Triangles) {
          e._usesCellNormals = true, y.hash = `PFN${f.getMTime()}I${u.getMTime()}snorm8x4`, y.dataArray = f, y.cells = r, y.usage = Yr.NormalsFromPoints;
          const w = o.getBufferManager().getBuffer(y);
          c.addBuffer(w, [
            "normalMC"
          ]);
        } else c.removeBufferIfPresent("normalMC");
      } else c.removeBufferIfPresent("normalMC");
      let g = false;
      if (e.renderable.getScalarVisibility()) {
        const m = e.renderable.getColorMapColors();
        if (m && !l) {
          const y = e.renderable.getScalarMode();
          let w = false;
          (y === rg.USE_CELL_DATA || y === rg.USE_CELL_FIELD_DATA || y === rg.USE_FIELD_DATA || !n.getPointData().getScalars()) && y !== rg.USE_POINT_FIELD_DATA && m && (w = true);
          const C = {
            usage: Yr.PointArray,
            format: "unorm8x4",
            hash: `${w}${m.getMTime()}I${u.getMTime()}unorm8x4`,
            dataArray: m,
            indexBuffer: u,
            cellData: w,
            cellOffset: 0
          }, T = o.getBufferManager().getBuffer(C);
          c.addBuffer(T, [
            "colorVI"
          ]), g = true;
        }
      }
      g || c.removeBufferIfPresent("colorVI");
      let v = null;
      if (((_b3 = (_a3 = e.renderable).getInterpolateScalarsBeforeMapping) == null ? void 0 : _b3.call(_a3)) && e.renderable.getColorCoordinates() ? v = e.renderable.getColorCoordinates() : v = n.getPointData().getTCoords(), v && !l) {
        const m = o.getBufferManager().getBufferForPointArray(v, c.getIndexBuffer());
        c.addBuffer(m, [
          "tcoord"
        ]);
      } else c.removeBufferIfPresent("tcoord");
    }, t.updateTextures = () => {
      var _a3, _b3, _c3, _d, _e11, _f, _g2, _h2, _i3, _j2, _k2, _l2, _m, _n3, _o;
      const n = [], r = [], i = (_b3 = (_a3 = e.renderable).getColorTextureMap) == null ? void 0 : _b3.call(_a3);
      i && (e.colorTexture || (e.colorTexture = N5.newInstance({
        label: "polyDataColor"
      })), e.colorTexture.setInputData(i), r.push([
        "Diffuse",
        e.colorTexture
      ]));
      const a = e.WebGPUActor.getRenderable(), s = e.WebGPURenderer.getRenderable(), o = [];
      if ((_d = (_c3 = a.getProperty()).getDiffuseTexture) == null ? void 0 : _d.call(_c3)) {
        const l = [
          "Diffuse",
          a.getProperty().getDiffuseTexture()
        ];
        o.push(l);
      }
      if (a.getTextures()[0]) {
        const l = [
          "Diffuse",
          a.getTextures()[0]
        ];
        o.push(l);
      }
      if (e.colorTexture) {
        const l = [
          "Diffuse",
          e.colorTexture
        ];
        o.push(l);
      }
      if ((_f = (_e11 = a.getProperty()).getRoughnessTexture) == null ? void 0 : _f.call(_e11)) {
        const l = [
          "Roughness",
          a.getProperty().getRoughnessTexture()
        ];
        o.push(l);
      }
      if ((_h2 = (_g2 = a.getProperty()).getMetallicTexture) == null ? void 0 : _h2.call(_g2)) {
        const l = [
          "Metallic",
          a.getProperty().getMetallicTexture()
        ];
        o.push(l);
      }
      if ((_j2 = (_i3 = a.getProperty()).getNormalTexture) == null ? void 0 : _j2.call(_i3)) {
        const l = [
          "Normal",
          a.getProperty().getNormalTexture()
        ];
        o.push(l);
      }
      if ((_l2 = (_k2 = a.getProperty()).getAmbientOcclusionTexture) == null ? void 0 : _l2.call(_k2)) {
        const l = [
          "AmbientOcclusion",
          a.getProperty().getAmbientOcclusionTexture()
        ];
        o.push(l);
      }
      if ((_n3 = (_m = a.getProperty()).getEmissionTexture) == null ? void 0 : _n3.call(_m)) {
        const l = [
          "Emission",
          a.getProperty().getEmissionTexture()
        ];
        o.push(l);
      }
      if ((_o = s.getEnvironmentTexture) == null ? void 0 : _o.call(s)) {
        const l = [
          "Environment",
          s.getEnvironmentTexture()
        ];
        o.push(l);
      }
      for (let l = 0; l < o.length; l++) (o[l][1].getInputData() || o[l][1].getJsImageData() || o[l][1].getCanvas()) && r.push(o[l]), o[l][1].getImage() && o[l][1].getImageLoaded() && r.push(o[l]);
      for (let l = 0; l < r.length; l++) {
        const c = r[l][1], f = r[l][0], u = e.device.getTextureManager().getTextureForVTKTexture(c);
        if (u.getReady()) {
          let h = false;
          for (let g = 0; g < e.textures.length; g++) e.textures[g] === u && (h = true, n[g] = true);
          if (!h) {
            n[e.textures.length] = true;
            const g = u.createView(`${f}Texture`);
            e.textures.push(u), e.textureViews.push(g);
            const v = c.getInterpolate() ? "linear" : "nearest";
            let m = null;
            !m && c.getEdgeClamp() && c.getRepeat() && (m = "mirror-repeat"), !m && c.getEdgeClamp() && (m = "clamp-to-edge"), !m && c.getRepeat() && (m = "repeat"), f !== "Environment" ? g.addSampler(e.device, {
              addressModeU: m,
              addressModeV: m,
              addressModeW: m,
              minFilter: v,
              magFilter: v
            }) : g.addSampler(e.device, {
              addressModeU: "repeat",
              addressModeV: "clamp-to-edge",
              addressModeW: "repeat",
              minFilter: v,
              magFilter: v,
              mipmapFilter: "linear"
            });
          }
        }
      }
      for (let l = e.textures.length - 1; l >= 0; l--) n[l] || (e.textures.splice(l, 1), e.textureViews.splice(l, 1));
    }, t.computePipelineHash = () => {
      let n = `pd${e.useRendererMatrix ? "r" : ""}${e.forceZValue ? "z" : ""}`;
      if (e.primitiveType === Li.TriangleEdges || e.primitiveType === Li.TriangleStripEdges) n += "edge";
      else {
        if (e.vertexInput.hasAttribute("normalMC") && (n += "n"), e.vertexInput.hasAttribute("colorVI") && (n += "c"), e.vertexInput.hasAttribute("tcoord")) {
          const i = e.vertexInput.getBuffer("tcoord"), a = ui.getNumberOfComponentsFromBufferFormat(i.getArrayInformation()[0].format);
          n += `t${a}`;
        }
        e.textures.length && (n += `tx${e.textures.length}`);
      }
      e._usesCellNormals && (n += "cn"), e.SSBO && (n += "ssbo");
      const r = t.getHashFromUsage(e.usage);
      n += r, n += e.renderEncoder.getPipelineHash(), e.pipelineHash = n;
    }, t.updateBuffers = () => {
      e.primitiveType !== Li.TriangleEdges && e.primitiveType !== Li.TriangleStripEdges && t.updateTextures();
      const n = e.WebGPUActor.getRenderable(), r = n.getProperty().getRepresentation();
      e.usage = t.getUsage(r, e.primitiveType), t.buildVertexInput();
      const i = e.vertexInput.getBuffer("vertexBC");
      if (t.setNumberOfVertices(i.getSizeInBytes() / i.getStrideInBytes()), t.setTopology(t.getTopologyFromUsage(e.usage)), t.updateUBO(), t.haveWideLines()) {
        const a = n.getProperty();
        t.setNumberOfInstances(Math.ceil(a.getLineWidth() * 2));
      } else t.setNumberOfInstances(1);
    };
  }
  const _le = {
    is2D: false,
    cellArray: null,
    currentInput: null,
    cellOffset: 0,
    primitiveType: 0,
    colorTexture: null,
    renderEncoder: null,
    textures: null
  };
  function rV(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, _le, n), PO.extend(t, e, n), e.fragmentShaderTemplate = Fle, e.vertexShaderTemplate = Ule, e._tmpMat3 = Fa(new Float64Array(9)), e._tmpMat4 = gt(new Float64Array(16)), e.UBO = wu.newInstance({
      label: "mapperUBO"
    }), e.UBO.addEntry("BCWCMatrix", "mat4x4<f32>"), e.UBO.addEntry("BCSCMatrix", "mat4x4<f32>"), e.UBO.addEntry("MCWCNormals", "mat4x4<f32>"), e.UBO.addEntry("AmbientColor", "vec4<f32>"), e.UBO.addEntry("DiffuseColor", "vec4<f32>"), e.UBO.addEntry("EdgeColor", "vec4<f32>"), e.UBO.addEntry("SpecularColor", "vec4<f32>"), e.UBO.addEntry("AmbientIntensity", "f32"), e.UBO.addEntry("DiffuseIntensity", "f32"), e.UBO.addEntry("Roughness", "f32"), e.UBO.addEntry("Metallic", "f32"), e.UBO.addEntry("Ambient", "f32"), e.UBO.addEntry("Normal", "f32"), e.UBO.addEntry("Emission", "f32"), e.UBO.addEntry("NormalStrength", "f32"), e.UBO.addEntry("BaseIOR", "f32"), e.UBO.addEntry("SpecularIntensity", "f32"), e.UBO.addEntry("LineWidth", "f32"), e.UBO.addEntry("Opacity", "f32"), e.UBO.addEntry("ZValue", "f32"), e.UBO.addEntry("PropID", "u32"), e.UBO.addEntry("ClipNear", "f32"), e.UBO.addEntry("ClipFar", "f32"), e.UBO.addEntry("Time", "u32"), pr(t, e, [
      "cellArray",
      "currentInput",
      "cellOffset",
      "is2D",
      "primitiveType",
      "renderEncoder"
    ]), e.textures = [], Ble(t, e);
  }
  const kle = pn(rV, "vtkWebGPUCellArrayMapper");
  var iV = {
    newInstance: kle,
    extend: rV
  };
  const { PrimitiveTypes: ig } = tf;
  function Ple(t, e) {
    e.classHierarchy.push("vtkWebGPUPolyDataMapper"), t.createCellArrayMapper = () => iV.newInstance(), t.buildPass = (n) => {
      if (n) {
        e.WebGPUActor = t.getFirstAncestorOfType("vtkWebGPUActor"), e.renderable.getStatic() || e.renderable.update();
        const r = e.renderable.getInputData();
        e.renderable.mapScalars(r, 1), t.updateCellArrayMappers(r);
      }
    }, t.updateCellArrayMappers = (n) => {
      const r = [
        n.getVerts(),
        n.getLines(),
        n.getPolys(),
        n.getStrips()
      ], i = [];
      let a = 0;
      for (let s = ig.Points; s <= ig.Triangles; s++) if (r[s].getNumberOfValues() > 0) {
        e.primitives[s] || (e.primitives[s] = t.createCellArrayMapper());
        const o = e.primitives[s];
        o.setCellArray(r[s]), o.setCurrentInput(n), o.setCellOffset(a), o.setPrimitiveType(s), o.setRenderable(e.renderable), a += r[s].getNumberOfCells(), i.push(o);
      } else e.primitives[s] = null;
      if (e.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) for (let s = ig.TriangleEdges; s <= ig.TriangleStripEdges; s++) if (r[s - 2].getNumberOfValues() > 0) {
        e.primitives[s] || (e.primitives[s] = t.createCellArrayMapper());
        const o = e.primitives[s];
        o.setCellArray(r[s - 2]), o.setCurrentInput(n), o.setCellOffset(e.primitives[s - 2].getCellOffset()), o.setPrimitiveType(s), o.setRenderable(e.renderable), i.push(o);
      } else e.primitives[s] = null;
      t.prepareNodes(), t.addMissingChildren(i), t.removeUnusedNodes();
    };
  }
  const Gle = {
    primitives: null
  };
  function zle(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Gle, n), Rn.extend(t, e, n), e.primitives = [], Ple(t, e);
  }
  const Wle = pn(zle, "vtkWebGPUPolyDataMapper");
  ka("vtkMapper", Wle);
  const { PrimitiveTypes: zS } = tf;
  function Hle(t, e) {
    e.classHierarchy.push("vtkWebGPUPolyDataMapper2D"), t.createCellArrayMapper = () => iV.newInstance(), t.buildPass = (n) => {
      if (n) {
        e.WebGPUActor = t.getFirstAncestorOfType("vtkWebGPUActor2D"), e.renderable.getStatic() || e.renderable.update();
        const r = e.renderable.getInputData();
        e.renderable.mapScalars(r, 1), t.updateCellArrayMappers(r);
      }
    }, t.updateCellArrayMappers = (n) => {
      const r = [
        n.getVerts(),
        n.getLines(),
        n.getPolys(),
        n.getStrips()
      ], i = [];
      let a = 0;
      for (let s = zS.Points; s <= zS.Triangles; s++) if (r[s].getNumberOfValues() > 0) {
        e.primitives[s] || (e.primitives[s] = t.createCellArrayMapper());
        const o = e.primitives[s];
        o.setCellArray(r[s]), o.setCurrentInput(n), o.setCellOffset(a), o.setPrimitiveType(s), o.setRenderable(e.renderable), o.setIs2D(true), a += r[s].getNumberOfCells(), i.push(o);
      } else e.primitives[s] = null;
      t.prepareNodes(), t.addMissingChildren(i), t.removeUnusedNodes();
    };
  }
  function jle(t) {
    return {
      primitives: [],
      ...t
    };
  }
  function Kle(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, jle(n)), Rn.extend(t, e, n), e.primitives = [], Hle(t, e);
  }
  const Yle = pn(Kle, "vtkWebGPUPolyDataMapper2D");
  ka("vtkMapper2D", Yle);
  function qle(t, e) {
    e.classHierarchy.push("vtkWebGPUScalarBarActor"), t.buildPass = (n) => {
      n && (e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getParent(), e.scalarBarActorHelper.getRenderable() || e.scalarBarActorHelper.setRenderable(e.renderable), t.prepareNodes(), t.addMissingNode(e.scalarBarActorHelper.getBarActor()), t.addMissingNode(e.scalarBarActorHelper.getTmActor()), t.removeUnusedNodes());
    }, t.opaquePass = (n, r) => {
      if (n) {
        const i = e.WebGPURenderer ? e.WebGPURenderer.getRenderable().getActiveCamera() : null, a = e.WebGPURenderer.getTiledSizeAndOrigin();
        e.scalarBarActorHelper.updateAPISpecificData([
          a.usize,
          a.vsize
        ], i, e.WebGPURenderWindow.getRenderable());
      }
    };
  }
  const Xle = {};
  function Zle(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, Xle, n), Rn.extend(t, e, n), e.scalarBarActorHelper = nV.newScalarBarActorHelper(), qle(t, e);
  }
  const Qle = pn(Zle, "vtkWebGPUScalarBarActor");
  ka("vtkScalarBarActor", Qle);
  function Jle(t, e) {
    e.classHierarchy.push("vtkWebGPUTextureView"), t.create = (n, r) => {
      e.texture = n, e.options = r, e.options.dimension = e.options.dimension || "2d", e.options.label = e.label, e.textureHandle = n.getHandle(), e.handle = e.textureHandle.createView(e.options), e.bindGroupLayoutEntry.texture.viewDimension = e.options.dimension;
      const i = ui.getDetailsFromTextureFormat(e.texture.getFormat());
      e.bindGroupLayoutEntry.texture.sampleType = i.sampleType;
    }, t.createFromTextureHandle = (n, r) => {
      e.texture = null, e.options = r, e.options.dimension = e.options.dimension || "2d", e.options.label = e.label, e.textureHandle = n, e.handle = e.textureHandle.createView(e.options), e.bindGroupLayoutEntry.texture.viewDimension = e.options.dimension;
      const i = ui.getDetailsFromTextureFormat(r.format);
      e.bindGroupLayoutEntry.texture.sampleType = i.sampleType, e.bindGroupTime.modified();
    }, t.getBindGroupEntry = () => ({
      resource: t.getHandle()
    }), t.getShaderCode = (n, r) => {
      let i = "f32";
      e.bindGroupLayoutEntry.texture.sampleType === "sint" ? i = "i32" : e.bindGroupLayoutEntry.texture.sampleType === "uint" && (i = "u32");
      let a = `@binding(${n}) @group(${r}) var ${e.label}: texture_${e.options.dimension}<${i}>;`;
      return e.bindGroupLayoutEntry.texture.sampleType === "depth" && (a = `@binding(${n}) @group(${r}) var ${e.label}: texture_depth_${e.options.dimension};`), a;
    }, t.addSampler = (n, r) => {
      const i = YO.newInstance({
        label: `${e.label}Sampler`
      });
      i.create(n, r), t.setSampler(i);
    }, t.getBindGroupTime = () => (e.texture && e.texture.getHandle() !== e.textureHandle && (e.textureHandle = e.texture.getHandle(), e.handle = e.textureHandle.createView(e.options), e.bindGroupTime.modified()), e.bindGroupTime), t.getHandle = () => (e.texture && e.texture.getHandle() !== e.textureHandle && (e.textureHandle = e.texture.getHandle(), e.handle = e.textureHandle.createView(e.options), e.bindGroupTime.modified()), e.handle);
  }
  const $le = {
    texture: null,
    handle: null,
    sampler: null,
    label: null
  };
  function aV(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, $le, n), H.obj(t, e), e.bindGroupLayoutEntry = {
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      texture: {
        sampleType: "float",
        viewDimension: "2d"
      }
    }, e.bindGroupTime = {}, H.obj(e.bindGroupTime, {
      mtime: 0
    }), H.get(t, e, [
      "bindGroupTime",
      "texture"
    ]), H.setGet(t, e, [
      "bindGroupLayoutEntry",
      "label",
      "sampler"
    ]), Jle(t, e);
  }
  const ece = H.newInstance(aV);
  var tce = {
    newInstance: ece,
    extend: aV
  };
  const { BufferUsage: WS } = tf;
  function nce(t, e) {
    e.classHierarchy.push("vtkWebGPUTexture"), t.create = (n, r) => {
      e.device = n, e.width = r.width, e.height = r.height, e.depth = r.depth ? r.depth : 1;
      const i = e.depth === 1 ? "2d" : "3d";
      e.format = r.format ? r.format : "rgba8unorm", e.mipLevel = r.mipLevel ? r.mipLevel : 0, e.usage = r.usage ? r.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, e.handle = e.device.getHandle().createTexture({
        size: [
          e.width,
          e.height,
          e.depth
        ],
        format: e.format,
        usage: e.usage,
        label: e.label,
        dimension: i,
        mipLevelCount: e.mipLevel + 1
      });
    }, t.assignFromHandle = (n, r, i) => {
      e.device = n, e.handle = r, e.width = i.width, e.height = i.height, e.depth = i.depth ? i.depth : 1, e.format = i.format ? i.format : "rgba8unorm", e.usage = i.usage ? i.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    }, t.writeImageData = (n) => {
      let r = [];
      if (n.canvas) {
        e.device.getHandle().queue.copyExternalImageToTexture({
          source: n.canvas,
          flipY: n.flip
        }, {
          texture: e.handle,
          premultipliedAlpha: true
        }, [
          e.width,
          e.height,
          e.depth
        ]), e.ready = true;
        return;
      }
      n.jsImageData && !n.nativeArray && (n.width = n.jsImageData.width, n.height = n.jsImageData.height, n.depth = 1, n.format = "rgba8unorm", n.flip = true, n.nativeArray = n.jsImageData.data);
      const i = ui.getDetailsFromTextureFormat(e.format);
      let a = e.width * i.stride;
      const s = (l, c, f) => {
        const u = l.length / (c * f) * l.BYTES_PER_ELEMENT, h = i.elementSize === 2 && i.sampleType === "float";
        if (h || u % 256) {
          const g = l, v = u / g.BYTES_PER_ELEMENT, m = i.elementSize, y = 256 * Math.floor((v * m + 255) / 256), w = y / m, C = H.newTypedArray(h ? "Uint16Array" : g.constructor.name, w * c * f);
          for (let T = 0; T < c * f; T++) if (h) for (let S = 0; S < v; S++) C[T * w + S] = yl.toHalf(g[T * v + S]);
          else C.set(g.subarray(T * v, (T + 1) * v), T * w);
          return [
            C,
            y
          ];
        }
        return [
          l,
          u
        ];
      };
      if (n.nativeArray && (r = n.nativeArray), n.image) {
        const l = document.createElement("canvas");
        l.width = n.image.width, l.height = n.image.height;
        const c = l.getContext("2d");
        c.translate(0, l.height), c.scale(1, -1), c.drawImage(n.image, 0, 0, n.image.width, n.image.height, 0, 0, l.width, l.height), r = c.getImageData(0, 0, n.image.width, n.image.height).data;
      }
      const o = e.device.createCommandEncoder();
      if (t.getDimensionality() !== 3) {
        const l = N5.generateMipmaps(r, e.width, e.height, e.mipLevel);
        let c = e.width, f = e.height;
        for (let u = 0; u <= e.mipLevel; u++) {
          const h = s(l[u], f, 1);
          a = h[1];
          const g = {
            dataArray: n.dataArray ? n.dataArray : null,
            nativeArray: h[0],
            usage: WS.Texture
          }, v = e.device.getBufferManager().getBuffer(g);
          o.copyBufferToTexture({
            buffer: v.getHandle(),
            offset: 0,
            bytesPerRow: a,
            rowsPerImage: f
          }, {
            texture: e.handle,
            mipLevel: u
          }, [
            c,
            f,
            1
          ]), c /= 2, f /= 2;
        }
        e.device.submitCommandEncoder(o), e.ready = true;
      } else {
        const l = s(r, e.height, e.depth);
        a = l[1];
        const c = {
          dataArray: n.dataArray ? n.dataArray : null,
          usage: WS.Texture
        };
        c.nativeArray = l[0];
        const f = e.device.getBufferManager().getBuffer(c);
        o.copyBufferToTexture({
          buffer: f.getHandle(),
          offset: 0,
          bytesPerRow: a,
          rowsPerImage: e.height
        }, {
          texture: e.handle
        }, [
          e.width,
          e.height,
          e.depth
        ]), e.device.submitCommandEncoder(o), e.ready = true;
      }
    }, t.getScale = () => {
      const n = ui.getDetailsFromTextureFormat(e.format);
      return n.elementSize === 2 && n.sampleType === "float" ? 1 : 255;
    }, t.getNumberOfComponents = () => ui.getDetailsFromTextureFormat(e.format).numComponents, t.getDimensionality = () => {
      let n = 0;
      return e.width > 1 && n++, e.height > 1 && n++, e.depth > 1 && n++, n;
    }, t.resizeToMatch = (n) => {
      (n.getWidth() !== e.width || n.getHeight() !== e.height || n.getDepth() !== e.depth) && (e.width = n.getWidth(), e.height = n.getHeight(), e.depth = n.getDepth(), e.handle = e.device.getHandle().createTexture({
        size: [
          e.width,
          e.height,
          e.depth
        ],
        format: e.format,
        usage: e.usage,
        label: e.label
      }));
    }, t.resize = function(n, r) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      (n !== e.width || r !== e.height || i !== e.depth) && (e.width = n, e.height = r, e.depth = i, e.handle = e.device.getHandle().createTexture({
        size: [
          e.width,
          e.height,
          e.depth
        ],
        format: e.format,
        usage: e.usage,
        label: e.label
      }));
    }, t.createView = function(n) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      r.dimension || (r.dimension = e.depth === 1 ? "2d" : "3d");
      const i = tce.newInstance({
        label: n
      });
      return i.create(t, r), i;
    };
  }
  const rce = {
    device: null,
    handle: null,
    buffer: null,
    ready: false,
    label: null
  };
  function ice(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.assign(e, rce, n), H.obj(t, e), H.get(t, e, [
      "handle",
      "ready",
      "width",
      "height",
      "depth",
      "format",
      "usage"
    ]), H.setGet(t, e, [
      "device",
      "label"
    ]), nce(t, e);
  }
  H.newInstance(ice);
  function ace(t) {
    if (!t || t.data.length === 0) throw new Error("Invalid contour set data, see publicContourSetData type for more info");
    if (!t.id) throw new Error("Invalid contour set data, each contour set must have an id");
    if (!t.data || !Array.isArray(t.data)) throw new Error("Invalid contour set data, each contour set must have an array of contours");
    t.data.forEach((e) => {
      if (!e.points || !Array.isArray(e.points)) throw new Error("Invalid contour set data, each contour must have an array of points");
      e.points.forEach((n) => {
        if (!n || !Array.isArray(n) || n.length !== 3) throw new Error("Invalid contour set data, each point must be an array of length 3");
      });
    });
  }
  class sce {
    constructor(e) {
      const { points: n, type: r } = e.data;
      this.id = e.id, this.points = n, this.type = r, this.color = e.color, this.segmentIndex = e.segmentIndex, this.sizeInBytes = this._getSizeInBytes();
    }
    _getSizeInBytes() {
      let e = 0;
      return e += this.points.length * 3, e;
    }
    getPoints() {
      return this.points;
    }
    getFlatPointsArray() {
      return this.points.map((e) => [
        ...e
      ]).flat();
    }
    getColor() {
      return this.color;
    }
    getType() {
      return this.type;
    }
  }
  class oce {
    constructor(e) {
      this.color = [
        200,
        0,
        0
      ], this.id = e.id, this.contours = [], this.color = e.color ?? this.color, this.frameOfReferenceUID = e.frameOfReferenceUID, this.segmentIndex = e.segmentIndex, this._createEachContour(e.data), this.sizeInBytes = this._getSizeInBytes();
    }
    _createEachContour(e) {
      e.forEach((n) => {
        const { points: r, type: i, color: a } = n, s = new sce({
          id: `${this.id}-segment-${this.segmentIndex}`,
          data: {
            points: r,
            type: i,
            segmentIndex: this.segmentIndex,
            color: a ?? this.color
          },
          segmentIndex: this.segmentIndex,
          color: a ?? this.color
        });
        this.contours.push(s);
      }), this._updateContourSetCentroid();
    }
    _updateContourSetCentroid() {
      const e = this.getTotalNumberOfPoints(), n = this.getFlatPointsArray(), r = n.reduce((s, o) => [
        s[0] + o[0],
        s[1] + o[1],
        s[2] + o[2]
      ], [
        0,
        0,
        0
      ]), i = [
        r[0] / e,
        r[1] / e,
        r[2] / e
      ], a = n.reduce((s, o) => {
        const l = this._getDistance(i, o), c = this._getDistance(i, s);
        return l < c ? o : s;
      }, n[0]);
      this.centroid = a;
    }
    _getSizeInBytes() {
      return this.contours.reduce((e, n) => e + n.sizeInBytes, 0);
    }
    getCentroid() {
      return this.centroid;
    }
    getSegmentIndex() {
      return this.segmentIndex;
    }
    getColor() {
      return this.color;
    }
    getContours() {
      return this.contours;
    }
    getSizeInBytes() {
      return this.sizeInBytes;
    }
    getFlatPointsArray() {
      return this.contours.map((e) => e.getPoints()).flat();
    }
    getNumberOfContours() {
      return this.contours.length;
    }
    getTotalNumberOfPoints() {
      return this.contours.reduce((e, n) => e + n.getPoints().length, 0);
    }
    getNumberOfPointsArray() {
      return this.contours.reduce((e, n, r) => (e[r] = this.getNumberOfPointsInAContour(r), e), []);
    }
    getPointsInContour(e) {
      return this.contours[e].getPoints();
    }
    getNumberOfPointsInAContour(e) {
      return this.getPointsInContour(e).length;
    }
    _getDistance(e, n) {
      return Math.sqrt((e[0] - n[0]) ** 2 + (e[1] - n[1]) ** 2 + (e[2] - n[2]) ** 2);
    }
  }
  function lce(t, e) {
    ace(e);
    const n = new oce({
      id: e.id,
      data: e.data,
      color: e.color,
      frameOfReferenceUID: e.frameOfReferenceUID,
      segmentIndex: e.segmentIndex ?? 1
    });
    return {
      id: t,
      type: Ao.CONTOUR,
      data: n,
      sizeInBytes: n.getSizeInBytes()
    };
  }
  function cce(t) {
    const { data: e } = t;
    if (!e.points || !e.polys) throw new Error("Invalid surface data");
  }
  function uce(t, e) {
    cce(e);
    const n = new Fee({
      id: e.id,
      color: e.color,
      frameOfReferenceUID: e.frameOfReferenceUID,
      data: {
        points: e.data.points,
        polys: e.data.polys
      }
    });
    return {
      id: t,
      type: Ao.SURFACE,
      data: n,
      sizeInBytes: n.getSizeInBytes()
    };
  }
  async function fce(t, e) {
    let n = Ke.getGeometry(t);
    if (n) return n;
    if (e.type === Ao.CONTOUR) n = lce(t, e.geometryData);
    else if (e.type === Ao.SURFACE) n = uce(t, e.geometryData);
    else throw new Error("Unknown geometry type, Only CONTOUR is supported");
    const r = {
      promise: Promise.resolve(n)
    };
    return await Ke.putGeometryLoadObject(t, r), n;
  }
  var Bu;
  (function(t) {
    t[t.Primary = 1] = "Primary", t[t.Secondary = 2] = "Secondary", t[t.Primary_And_Secondary = 3] = "Primary_And_Secondary", t[t.Auxiliary = 4] = "Auxiliary", t[t.Primary_And_Auxiliary = 5] = "Primary_And_Auxiliary", t[t.Secondary_And_Auxiliary = 6] = "Secondary_And_Auxiliary", t[t.Primary_And_Secondary_And_Auxiliary = 7] = "Primary_And_Secondary_And_Auxiliary", t[t.Fourth_Button = 8] = "Fourth_Button", t[t.Fifth_Button = 16] = "Fifth_Button";
  })(Bu || (Bu = {}));
  var ga;
  (function(t) {
    t[t.Shift = 16] = "Shift", t[t.Ctrl = 17] = "Ctrl", t[t.Alt = 18] = "Alt", t[t.Meta = 91] = "Meta", t[t.ShiftCtrl = 1617] = "ShiftCtrl", t[t.ShiftAlt = 1618] = "ShiftAlt", t[t.ShiftMeta = 1691] = "ShiftMeta", t[t.CtrlAlt = 1718] = "CtrlAlt", t[t.CtrlMeta = 1791] = "CtrlMeta", t[t.AltMeta = 1891] = "AltMeta";
  })(ga || (ga = {}));
  var jn;
  (function(t) {
    t.Active = "Active", t.Passive = "Passive", t.Enabled = "Enabled", t.Disabled = "Disabled";
  })(jn || (jn = {}));
  var Cl;
  (function(t) {
    t.Default = "", t.Highlighted = "Highlighted", t.Selected = "Selected", t.Locked = "Locked", t.AutoGenerated = "AutoGenerated";
  })(Cl || (Cl = {}));
  var Re;
  (function(t) {
    t.TOOL_ACTIVATED = "CORNERSTONE_TOOLS_TOOL_ACTIVATED", t.TOOLGROUP_VIEWPORT_ADDED = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED", t.TOOLGROUP_VIEWPORT_REMOVED = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED", t.TOOL_MODE_CHANGED = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED", t.ANNOTATION_ADDED = "CORNERSTONE_TOOLS_ANNOTATION_ADDED", t.ANNOTATION_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED", t.ANNOTATION_MODIFIED = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED", t.ANNOTATION_REMOVED = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED", t.ANNOTATION_SELECTION_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE", t.ANNOTATION_LOCK_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE", t.ANNOTATION_VISIBILITY_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE", t.ANNOTATION_RENDERED = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED", t.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED", t.INTERPOLATED_ANNOTATIONS_REMOVED = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED", t.SEGMENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED", t.SEGMENTATION_RENDERED = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED", t.SEGMENTATION_REPRESENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED", t.SEGMENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED", t.SEGMENTATION_REPRESENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED", t.SEGMENTATION_DATA_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED", t.KEY_DOWN = "CORNERSTONE_TOOLS_KEY_DOWN", t.KEY_UP = "CORNERSTONE_TOOLS_KEY_UP", t.MOUSE_DOWN = "CORNERSTONE_TOOLS_MOUSE_DOWN", t.MOUSE_UP = "CORNERSTONE_TOOLS_MOUSE_UP", t.MOUSE_DOWN_ACTIVATE = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE", t.MOUSE_DRAG = "CORNERSTONE_TOOLS_MOUSE_DRAG", t.MOUSE_MOVE = "CORNERSTONE_TOOLS_MOUSE_MOVE", t.MOUSE_CLICK = "CORNERSTONE_TOOLS_MOUSE_CLICK", t.MOUSE_DOUBLE_CLICK = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK", t.MOUSE_WHEEL = "CORNERSTONE_TOOLS_MOUSE_WHEEL", t.TOUCH_START = "CORNERSTONE_TOOLS_TOUCH_START", t.TOUCH_START_ACTIVATE = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE", t.TOUCH_PRESS = "CORNERSTONE_TOOLS_TOUCH_PRESS", t.TOUCH_DRAG = "CORNERSTONE_TOOLS_TOUCH_DRAG", t.TOUCH_END = "CORNERSTONE_TOOLS_TOUCH_END", t.TOUCH_TAP = "CORNERSTONE_TOOLS_TAP", t.TOUCH_SWIPE = "CORNERSTONE_TOOLS_SWIPE";
  })(Re || (Re = {}));
  var Nt;
  (function(t) {
    t.Labelmap = "LABELMAP", t.Contour = "CONTOUR", t.Surface = "SURFACE";
  })(Nt || (Nt = {}));
  var du;
  (function(t) {
    t.UP = "UP", t.DOWN = "DOWN", t.LEFT = "LEFT", t.RIGHT = "RIGHT";
  })(du || (du = {}));
  var _l;
  (function(t) {
    t.Interaction = "Interaction", t.HandlesUpdated = "HandlesUpdated", t.StatsUpdated = "StatsUpdated", t.InitialSetup = "InitialSetup", t.Completed = "Completed", t.InterpolationUpdated = "InterpolationUpdated";
  })(_l || (_l = {}));
  var Xc;
  (function(t) {
    t.POLYSEG_CONTOUR_TO_LABELMAP = "polySeg/convertContourToVolumeLabelmap", t.POLYSEG_SURFACE_TO_LABELMAP = "polySeg/convertSurfacesToVolumeLabelmap", t.POLYSEG_CONTOUR_TO_SURFACE = "polySeg/convertContourToSurface", t.POLYSEG_LABELMAP_TO_SURFACE = "polySeg/convertLabelmapToSurface", t.SURFACE_CLIPPING = "surfaceClipping";
  })(Xc || (Xc = {}));
  const jg = /* @__PURE__ */ new Set();
  function sV(t, e = true) {
    const n = dce();
    t && (e ? gce(t, jg, n) : pce(t, jg, n)), mce(n, jg);
  }
  function _u(t) {
    return jg.has(t);
  }
  function hce(t) {
    if (t) {
      const e = !!t.isLocked;
      vce(t) && Object.defineProperty(t, "isLocked", {
        configurable: false,
        enumerable: true,
        set: oV,
        get: lV
      }), sV(t, e);
    }
  }
  function dce() {
    return Object.freeze({
      added: [],
      removed: [],
      locked: []
    });
  }
  function gce(t, e, n) {
    e.has(t) || (e.add(t), n.added.push(t));
  }
  function pce(t, e, n) {
    e.delete(t) && n.removed.push(t);
  }
  function mce(t, e) {
    (t.added.length > 0 || t.removed.length > 0) && (e.forEach((n) => void t.locked.push(n)), qe(je, Re.ANNOTATION_LOCK_CHANGE, t));
  }
  function vce(t) {
    const e = Object.getOwnPropertyDescriptor(t, "isLocked");
    return e ? e.configurable && (e.set !== oV || e.get !== lV) : Object.isExtensible(t);
  }
  function oV(t) {
    sV(this, t);
  }
  function lV() {
    return _u(this);
  }
  const Dl = /* @__PURE__ */ new Set();
  function Ol(t, e = true, n = false) {
    e ? yce(t, n) : cV(t);
  }
  function yce(t, e = false) {
    const n = uV();
    e || fV(Dl, n), t && !Dl.has(t) && (Dl.add(t), n.added.push(t)), hV(n, Dl);
  }
  function cV(t) {
    const e = uV();
    t ? Dl.delete(t) && e.removed.push(t) : fV(Dl, e), hV(e, Dl);
  }
  function L5(t) {
    return Dl.has(t);
  }
  function uV() {
    return Object.freeze({
      added: [],
      removed: [],
      selection: []
    });
  }
  function fV(t, e) {
    t.forEach((n) => {
      t.delete(n) && e.removed.push(n);
    });
  }
  function hV(t, e) {
    (t.added.length > 0 || t.removed.length > 0) && (e.forEach((n) => void t.selection.push(n)), qe(je, Re.ANNOTATION_SELECTION_CHANGE, t));
  }
  const Wp = /* @__PURE__ */ new Set();
  function dV(t, e = true) {
    const n = wce();
    t && (e ? Cce(t, Wp, n) : Tce(t, Wp, n)), Sce(n);
  }
  function Vh(t) {
    if (Ua(t)) return !Wp.has(t);
  }
  function xce(t) {
    if (t) {
      const e = t.isVisible ?? true;
      Ace(t) && Object.defineProperty(t, "isVisible", {
        configurable: false,
        enumerable: true,
        set: gV,
        get: pV
      }), dV(t.annotationUID, e);
    }
  }
  function wce() {
    return Object.freeze({
      lastVisible: [],
      lastHidden: [],
      hidden: []
    });
  }
  function Cce(t, e, n) {
    e.delete(t) && n.lastVisible.push(t);
  }
  function Tce(t, e, n) {
    e.has(t) || (e.add(t), L5(t) && cV(t), n.lastHidden.push(t));
  }
  function Sce(t) {
    (t.lastHidden.length > 0 || t.lastVisible.length > 0) && (Wp.forEach((e) => void t.hidden.push(e)), qe(je, Re.ANNOTATION_VISIBILITY_CHANGE, t));
  }
  function Ace(t) {
    const e = Object.getOwnPropertyDescriptor(t, "isVisible");
    return e ? e.configurable && (e.set !== gV || e.get !== pV) : Object.isExtensible(t);
  }
  function gV(t) {
    dV(this.annotationUID, t);
  }
  function pV() {
    return Vh(this.annotationUID);
  }
  const Ece = (t) => (t.data || (t.data = {}), t.data.handles || (t.data.handles = {}), t.data.handles.textBox || (t.data.handles.textBox = {}), t), bce = (t) => (t.data || (t.data = {}), t.data.cachedStats || (t.data.cachedStats = {}), t);
  class Dce {
    constructor(e) {
      this.getGroupKey = (n) => {
        if (typeof n == "string") return n;
        const i = pt(n);
        if (!i) throw new Error("Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID");
        return i.FrameOfReferenceUID;
      }, this._imageVolumeModifiedHandler = (n) => {
        const r = n.detail, { FrameOfReferenceUID: i } = r, s = this.annotations[i];
        s && Object.keys(s).forEach((o) => {
          s[o].forEach((c) => {
            c.invalidated !== void 0 && (c.invalidated = true);
          });
        });
      }, this.getFramesOfReference = () => Object.keys(this.annotations), this.getAnnotations = (n, r) => {
        const i = this.annotations;
        return i[n] ? r ? i[n][r] ? i[n][r] : [] : i[n] : [];
      }, this.getAnnotation = (n) => {
        const r = this.annotations;
        for (const i in r) {
          const a = r[i];
          for (const s in a) {
            const o = a[s];
            for (const l of o) if (n === l.annotationUID) return l;
          }
        }
      }, this.getNumberOfAnnotations = (n, r) => {
        const i = this.getAnnotations(n, r);
        if (!i.length) return 0;
        if (r) return i.length;
        let a = 0;
        for (const s in i) a += i[s].length;
        return a;
      }, this.addAnnotation = (n, r) => {
        const { metadata: i } = n, { FrameOfReferenceUID: a, toolName: s } = i;
        r = r || a;
        const o = this.annotations;
        let l = o[r];
        l || (o[r] = {}, l = o[r]);
        let c = l[s];
        c || (l[s] = [], c = l[s]), c.push(n), hce(n), xce(n), Ece(n), bce(n);
      }, this.removeAnnotation = (n) => {
        const { annotations: r } = this;
        for (const i in r) {
          const a = r[i];
          for (const s in a) {
            const o = a[s], l = o.findIndex((c) => c.annotationUID === n);
            l !== -1 && (o.splice(l, 1), o.length === 0 && delete a[s]);
          }
          Object.keys(a).length === 0 && delete r[i];
        }
      }, this.removeAnnotations = (n, r) => {
        const i = this.annotations, a = [];
        if (!i[n]) return a;
        if (r) {
          const s = i[n][r];
          for (const o of s) this.removeAnnotation(o.annotationUID), a.push(o);
        } else for (const s in i[n]) {
          const o = i[n][s];
          for (const l of o) this.removeAnnotation(l.annotationUID), a.push(l);
        }
        return a;
      }, this.saveAnnotations = (n, r) => {
        const i = this.annotations;
        if (n && r) {
          const a = i[n];
          if (!a) return;
          const s = a[r];
          return Ar(s);
        } else if (n) {
          const a = i[n];
          return Ar(a);
        }
        return Ar(i);
      }, this.restoreAnnotations = (n, r, i) => {
        const a = this.annotations;
        if (r && i) {
          let s = a[r];
          s || (a[r] = {}, s = a[r]), s[i] = n;
        } else r ? a[r] = n : this.annotations = Ar(n);
      }, this.getAllAnnotations = () => Object.values(this.annotations).map((n) => Object.values(n)).flat(2), this.getNumberOfAllAnnotations = () => {
        let n = 0;
        const r = this.annotations;
        for (const i in r) {
          const a = r[i];
          for (const s in a) {
            const o = a[s];
            n += o.length;
          }
        }
        return n;
      }, this.removeAllAnnotations = () => {
        const n = [];
        for (const r of this.getAllAnnotations()) this.removeAnnotation(r.annotationUID), n.push(r);
        return n;
      }, e || (e = gi()), this.annotations = {}, this.uid = e, je.addEventListener(ze.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
    }
  }
  const Mce = new Dce("DEFAULT");
  let Rce = {}, yt = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: Rce,
    enabledElements: []
  };
  function eh(t) {
    const e = t.toolName, n = yt.tools[e] !== void 0;
    if (!e) throw new Error(`No Tool Found for the ToolClass ${t.name}`);
    if (n) throw new Error(`${e} has already been added globally`);
    yt.tools[e] = {
      toolClass: t
    };
  }
  function Oce(t) {
    const e = t.toolName;
    return !!(e && yt.tools[e]);
  }
  function s0(t, e) {
    const n = e || t.currentTarget, { viewport: r } = pt(n), i = Nce(t), a = Vce(t), s = Ice(n, a), o = r.canvasToWorld(s);
    return {
      page: a,
      client: i,
      canvas: s,
      world: o
    };
  }
  function Ice(t, e) {
    const n = t.getBoundingClientRect();
    return [
      e[0] - n.left - window.pageXOffset,
      e[1] - n.top - window.pageYOffset
    ];
  }
  function Vce(t) {
    return [
      t.pageX,
      t.pageY
    ];
  }
  function Nce(t) {
    return [
      t.clientX,
      t.clientY
    ];
  }
  function mV(t) {
    const e = t.currentTarget, { viewportId: n, renderingEngineId: r } = pt(e), i = s0(t, e), a = {
      page: [
        0,
        0
      ],
      client: [
        0,
        0
      ],
      canvas: [
        0,
        0
      ],
      world: [
        0,
        0,
        0
      ]
    }, s = {
      event: t,
      eventName: Re.MOUSE_DOUBLE_CLICK,
      viewportId: n,
      renderingEngineId: r,
      camera: {},
      element: e,
      startPoints: i,
      lastPoints: i,
      currentPoints: i,
      deltaPoints: a
    };
    !qe(e, Re.MOUSE_DOUBLE_CLICK, s) && (t.stopImmediatePropagation(), t.preventDefault());
  }
  const HS = Re.MOUSE_MOVE;
  function od(t) {
    const e = t.currentTarget, n = pt(e), { renderingEngineId: r, viewportId: i } = n, a = s0(t);
    !qe(e, HS, {
      renderingEngineId: r,
      viewportId: i,
      camera: {},
      element: e,
      currentPoints: a,
      eventName: HS,
      event: t
    }) && (t.stopImmediatePropagation(), t.preventDefault());
  }
  const { MOUSE_DOWN: jS, MOUSE_DOWN_ACTIVATE: Lce, MOUSE_CLICK: Uce, MOUSE_UP: Fce, MOUSE_DRAG: KS } = Re, Bce = 400, _ce = 150, kce = 3, Pce = {
    mouseButton: void 0,
    element: null,
    renderingEngineId: void 0,
    viewportId: void 0,
    isClickEvent: true,
    clickDelay: 200,
    preventClickTimeout: null,
    startPoints: {
      page: [
        0,
        0
      ],
      client: [
        0,
        0
      ],
      canvas: [
        0,
        0
      ],
      world: [
        0,
        0,
        0
      ]
    },
    lastPoints: {
      page: [
        0,
        0
      ],
      client: [
        0,
        0
      ],
      canvas: [
        0,
        0
      ],
      world: [
        0,
        0,
        0
      ]
    }
  };
  let Ot = {
    mouseButton: void 0,
    renderingEngineId: void 0,
    viewportId: void 0,
    isClickEvent: true,
    clickDelay: 200,
    element: null,
    preventClickTimeout: null,
    startPoints: {
      page: [
        0,
        0
      ],
      client: [
        0,
        0
      ],
      canvas: [
        0,
        0
      ],
      world: [
        0,
        0,
        0
      ]
    },
    lastPoints: {
      page: [
        0,
        0
      ],
      client: [
        0,
        0
      ],
      canvas: [
        0,
        0
      ],
      world: [
        0,
        0,
        0
      ]
    }
  };
  const Ir = {
    doubleClickTimeout: null,
    mouseDownEvent: null,
    mouseUpEvent: null,
    ignoreDoubleClick: false
  };
  function vV(t) {
    if (Ir.doubleClickTimeout) {
      if (t.buttons === Ir.mouseDownEvent.buttons) return;
      Ir.mouseDownEvent = t, Hp();
      return;
    }
    Ir.doubleClickTimeout = setTimeout(Hp, t.buttons === 1 ? Bce : _ce), Ir.mouseDownEvent = t, Ir.ignoreDoubleClick = false, Ot.element = t.currentTarget, Ot.mouseButton = t.buttons;
    const e = pt(Ot.element), { renderingEngineId: n, viewportId: r } = e;
    Ot.renderingEngineId = n, Ot.viewportId = r, Ot.preventClickTimeout = setTimeout(zce, Ot.clickDelay), Ot.element.removeEventListener("mousemove", od);
    const i = s0(t, Ot.element);
    Ot.startPoints = Il(i), Ot.lastPoints = Il(i), document.addEventListener("mouseup", My), document.addEventListener("mousemove", yV);
  }
  function Gce(t) {
    const e = U5(Ot.startPoints, Ot.startPoints), n = {
      event: t,
      eventName: jS,
      element: Ot.element,
      mouseButton: Ot.mouseButton,
      renderingEngineId: Ot.renderingEngineId,
      viewportId: Ot.viewportId,
      camera: {},
      startPoints: Ot.startPoints,
      lastPoints: Ot.startPoints,
      currentPoints: Ot.startPoints,
      deltaPoints: e
    };
    Ot.lastPoints = Il(n.lastPoints), qe(n.element, jS, n) && qe(n.element, Lce, n);
  }
  function yV(t) {
    const e = s0(t, Ot.element), n = TV(Ot.element, Ot.lastPoints), r = U5(e, n);
    if (Ir.doubleClickTimeout) if (wV(r.canvas)) Hp();
    else return;
    const i = {
      event: t,
      eventName: KS,
      mouseButton: Ot.mouseButton,
      renderingEngineId: Ot.renderingEngineId,
      viewportId: Ot.viewportId,
      camera: {},
      element: Ot.element,
      startPoints: Il(Ot.startPoints),
      lastPoints: Il(n),
      currentPoints: e,
      deltaPoints: r
    };
    !qe(Ot.element, KS, i) && (t.stopImmediatePropagation(), t.preventDefault()), Ot.lastPoints = Il(e);
  }
  function My(t) {
    if (clearTimeout(Ot.preventClickTimeout), Ir.doubleClickTimeout) Ir.mouseUpEvent ? b6() : (Ir.mouseUpEvent = t, Ot.element.addEventListener("mousemove", xV));
    else {
      const e = Ot.isClickEvent ? Uce : Fce, n = s0(t, Ot.element), r = U5(n, Ot.lastPoints), i = {
        event: t,
        eventName: e,
        mouseButton: Ot.mouseButton,
        element: Ot.element,
        renderingEngineId: Ot.renderingEngineId,
        viewportId: Ot.viewportId,
        camera: {},
        startPoints: Il(Ot.startPoints),
        lastPoints: Il(Ot.lastPoints),
        currentPoints: n,
        deltaPoints: r
      };
      qe(i.element, e, i), b6();
    }
    document.removeEventListener("mousemove", yV);
  }
  function xV(t) {
    const e = s0(t, Ot.element), n = TV(Ot.element, Ot.lastPoints), r = U5(e, n);
    wV(r.canvas) && (Hp(), od(t));
  }
  function wV(t) {
    return Math.abs(t[0]) + Math.abs(t[1]) > kce;
  }
  function zce() {
    Ot.isClickEvent = false;
  }
  function Hp() {
    Ir.ignoreDoubleClick = true;
    const t = Ir.mouseDownEvent, e = Ir.mouseUpEvent;
    CV(), Gce(t), e && My(e);
  }
  function CV() {
    Ir.doubleClickTimeout && (clearTimeout(Ir.doubleClickTimeout), Ir.doubleClickTimeout = null), Ir.mouseDownEvent = null, Ir.mouseUpEvent = null;
  }
  function b6() {
    var _a3, _b3;
    document.removeEventListener("mouseup", My), (_a3 = Ot.element) == null ? void 0 : _a3.removeEventListener("mousemove", xV), (_b3 = Ot.element) == null ? void 0 : _b3.addEventListener("mousemove", od), CV(), Ot = JSON.parse(JSON.stringify(Pce));
  }
  function Il(t) {
    return JSON.parse(JSON.stringify(t));
  }
  function TV(t, e) {
    const { viewport: n } = pt(t), r = n.canvasToWorld(e.canvas);
    return {
      page: e.page,
      client: e.client,
      canvas: e.canvas,
      world: r
    };
  }
  function U5(t, e) {
    return {
      page: sv(t.page, e.page),
      client: sv(t.client, e.client),
      canvas: sv(t.canvas, e.canvas),
      world: Wce(t.world, e.world)
    };
  }
  function sv(t, e) {
    return [
      t[0] - e[0],
      t[1] - e[1]
    ];
  }
  function Wce(t, e) {
    return [
      t[0] - e[0],
      t[1] - e[1],
      t[2] - e[2]
    ];
  }
  function Hce() {
    return Ot.mouseButton;
  }
  function SV(t) {
    Ir.ignoreDoubleClick ? (Ir.ignoreDoubleClick = false, t.stopImmediatePropagation(), t.preventDefault()) : b6();
  }
  function AV(t) {
    t.removeEventListener("dblclick", mV), t.removeEventListener("mousedown", vV), t.removeEventListener("mousemove", od), t.removeEventListener("dblclick", SV, {
      capture: true
    });
  }
  function jce(t) {
    AV(t), t.addEventListener("dblclick", mV), t.addEventListener("mousedown", vV), t.addEventListener("mousemove", od), t.addEventListener("dblclick", SV, {
      capture: true
    });
  }
  const EV = {
    enable: jce,
    disable: AV
  }, Kce = 2e3, ku = {
    mouse: 0,
    touch: 1
  };
  let YS, qS;
  function bV(t, e) {
    const n = Date.now();
    if (t !== YS) {
      if (n - qS <= Kce) return e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), false;
      YS = t;
    }
    qS = n;
  }
  const DV = bV.bind(null, ku.mouse), MV = bV.bind(null, ku.touch);
  function XS(t, e, n) {
    const r = n ? DV : MV;
    e.forEach(function(i) {
      t.addEventListener(i, r, {
        passive: false
      });
    });
  }
  function ZS(t, e, n) {
    const r = n ? DV : MV;
    e.forEach(function(i) {
      t.removeEventListener(i, r);
    });
  }
  const RV = [
    "mousedown",
    "mouseup",
    "mousemove"
  ], OV = [
    "touchstart",
    "touchend"
  ];
  function IV(t) {
    ZS(t, RV, ku.mouse), ZS(t, OV, ku.touch);
  }
  function Yce(t) {
    IV(t), XS(t, RV, ku.mouse), XS(t, OV, ku.touch);
  }
  const VV = {
    enable: Yce,
    disable: IV
  };
  function F5(t, e) {
    const n = e || t.currentTarget, r = t.type === "touchend" ? t.changedTouches : t.touches;
    return Object.keys(r).map((i) => {
      const a = Zce(r[i]), s = Xce(r[i]), o = qce(n, s), { viewport: l } = pt(n), c = l.canvasToWorld(o);
      return {
        page: s,
        client: a,
        canvas: o,
        world: c,
        touch: {
          identifier: i,
          radiusX: r[i].radiusX,
          radiusY: r[i].radiusY,
          force: r[i].force,
          rotationAngle: r[i].rotationAngle
        }
      };
    });
  }
  function qce(t, e) {
    const n = t.getBoundingClientRect();
    return [
      e[0] - n.left - window.pageXOffset,
      e[1] - n.top - window.pageYOffset
    ];
  }
  function Xce(t) {
    return [
      t.pageX,
      t.pageY
    ];
  }
  function Zce(t) {
    return [
      t.clientX,
      t.clientY
    ];
  }
  function D6(t, e) {
    const n = jp(t), r = jp(e);
    return {
      page: ov(n.page, r.page),
      client: ov(n.client, r.client),
      canvas: ov(n.canvas, r.canvas),
      world: Qce(n.world, r.world)
    };
  }
  function NV(t, e) {
    const n = jp(t), r = jp(e);
    return {
      page: Su(n.page, r.page),
      client: Su(n.client, r.client),
      canvas: Su(n.canvas, r.canvas),
      world: LV(n.world, r.world)
    };
  }
  function M6(t, e) {
    const n = JS(t), r = JS(e);
    return {
      page: n.page - r.page,
      client: n.client - r.client,
      canvas: n.canvas - r.canvas,
      world: n.world - r.world
    };
  }
  function Co(t) {
    return JSON.parse(JSON.stringify(t));
  }
  function QS(t) {
    return JSON.parse(JSON.stringify(t));
  }
  function jp(t) {
    return t.reduce((e, n) => ({
      page: [
        e.page[0] + n.page[0] / t.length,
        e.page[1] + n.page[1] / t.length
      ],
      client: [
        e.client[0] + n.client[0] / t.length,
        e.client[1] + n.client[1] / t.length
      ],
      canvas: [
        e.canvas[0] + n.canvas[0] / t.length,
        e.canvas[1] + n.canvas[1] / t.length
      ],
      world: [
        e.world[0] + n.world[0] / t.length,
        e.world[1] + n.world[1] / t.length,
        e.world[2] + n.world[2] / t.length
      ]
    }), {
      page: [
        0,
        0
      ],
      client: [
        0,
        0
      ],
      canvas: [
        0,
        0
      ],
      world: [
        0,
        0,
        0
      ]
    });
  }
  function Is(t) {
    return t.reduce((e, n) => ({
      page: [
        e.page[0] + n.page[0] / t.length,
        e.page[1] + n.page[1] / t.length
      ],
      client: [
        e.client[0] + n.client[0] / t.length,
        e.client[1] + n.client[1] / t.length
      ],
      canvas: [
        e.canvas[0] + n.canvas[0] / t.length,
        e.canvas[1] + n.canvas[1] / t.length
      ],
      world: [
        e.world[0] + n.world[0] / t.length,
        e.world[1] + n.world[1] / t.length,
        e.world[2] + n.world[2] / t.length
      ],
      touch: {
        identifier: null,
        radiusX: e.touch.radiusX + n.touch.radiusX / t.length,
        radiusY: e.touch.radiusY + n.touch.radiusY / t.length,
        force: e.touch.force + n.touch.force / t.length,
        rotationAngle: e.touch.rotationAngle + n.touch.rotationAngle / t.length
      }
    }), {
      page: [
        0,
        0
      ],
      client: [
        0,
        0
      ],
      canvas: [
        0,
        0
      ],
      world: [
        0,
        0,
        0
      ],
      touch: {
        identifier: null,
        radiusX: 0,
        radiusY: 0,
        force: 0,
        rotationAngle: 0
      }
    });
  }
  function ov(t, e) {
    return [
      t[0] - e[0],
      t[1] - e[1]
    ];
  }
  function Qce(t, e) {
    return [
      t[0] - e[0],
      t[1] - e[1],
      t[2] - e[2]
    ];
  }
  function JS(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) for (let r = 0; r < t.length; r++) n < r && e.push({
      page: Su(t[n].page, t[r].page),
      client: Su(t[n].client, t[r].client),
      canvas: Su(t[n].canvas, t[r].canvas),
      world: LV(t[n].world, t[r].world)
    });
    return e.reduce((n, r) => ({
      page: n.page + r.page / e.length,
      client: n.client + r.client / e.length,
      canvas: n.canvas + r.canvas / e.length,
      world: n.world + r.world / e.length
    }), {
      page: 0,
      client: 0,
      canvas: 0,
      world: 0
    });
  }
  function Su(t, e) {
    return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2));
  }
  function LV(t, e) {
    return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2));
  }
  Pn.getRuntimeSettings();
  const { TOUCH_START: $S, TOUCH_START_ACTIVATE: Jce, TOUCH_PRESS: eA, TOUCH_DRAG: tA, TOUCH_END: nA, TOUCH_TAP: rA, TOUCH_SWIPE: lv } = Re, Nh = {
    page: [
      0,
      0
    ],
    client: [
      0,
      0
    ],
    canvas: [
      0,
      0
    ],
    world: [
      0,
      0,
      0
    ]
  }, Kp = {
    page: 0,
    client: 0,
    canvas: 0,
    world: 0
  }, UV = {
    renderingEngineId: void 0,
    viewportId: void 0,
    element: null,
    startPointsList: [
      {
        ...Nh,
        touch: null
      }
    ],
    lastPointsList: [
      {
        ...Nh,
        touch: null
      }
    ],
    isTouchStart: false,
    startTime: null,
    pressTimeout: null,
    pressDelay: 700,
    pressMaxDistance: 5,
    accumulatedDistance: Kp,
    swipeDistanceThreshold: 48,
    swiped: false,
    swipeToleranceMs: 300
  }, FV = {
    renderingEngineId: void 0,
    viewportId: void 0,
    element: null,
    startPointsList: [
      {
        ...Nh,
        touch: null
      }
    ],
    taps: 0,
    tapTimeout: null,
    tapMaxDistance: 24,
    tapToleranceMs: 300
  };
  let st = JSON.parse(JSON.stringify(UV)), dr = JSON.parse(JSON.stringify(FV));
  function kl(t, e, n) {
    return qe(t, e, n);
  }
  function BV(t) {
    st.element = t.currentTarget;
    const e = pt(st.element), { renderingEngineId: n, viewportId: r } = e;
    st.renderingEngineId = n, st.viewportId = r, !st.isTouchStart && (clearTimeout(st.pressTimeout), st.pressTimeout = setTimeout(() => $ce(t), st.pressDelay), e0e(t), document.addEventListener("touchmove", _V), document.addEventListener("touchend", kV));
  }
  function $ce(t) {
    if (st.accumulatedDistance.canvas > st.pressMaxDistance) return;
    const n = {
      event: t,
      eventName: eA,
      renderingEngineId: st.renderingEngineId,
      viewportId: st.viewportId,
      camera: {},
      element: st.element,
      startPointsList: Co(st.startPointsList),
      lastPointsList: Co(st.lastPointsList),
      startPoints: QS(Is(st.startPointsList)),
      lastPoints: QS(Is(st.lastPointsList))
    };
    kl(n.element, eA, n);
  }
  function e0e(t) {
    st.isTouchStart = true, st.startTime = /* @__PURE__ */ new Date();
    const e = F5(t, st.element), n = Is(e), r = Nh, i = Kp, a = {
      event: t,
      eventName: $S,
      element: st.element,
      renderingEngineId: st.renderingEngineId,
      viewportId: st.viewportId,
      camera: {},
      startPointsList: e,
      lastPointsList: e,
      currentPointsList: e,
      startPoints: n,
      lastPoints: n,
      currentPoints: n,
      deltaPoints: r,
      deltaDistance: i
    };
    st.startPointsList = Co(a.startPointsList), st.lastPointsList = Co(a.lastPointsList), kl(a.element, $S, a) && kl(a.element, Jce, a);
  }
  function _V(t) {
    const e = F5(t, st.element), n = PV(st.element, st.lastPointsList), r = e.length === n.length ? D6(e, n) : Nh, i = e.length === n.length ? M6(e, n) : Kp, a = e.length === n.length ? NV(e, st.lastPointsList) : Kp;
    st.accumulatedDistance = {
      page: st.accumulatedDistance.page + a.page,
      client: st.accumulatedDistance.client + a.client,
      canvas: st.accumulatedDistance.canvas + a.canvas,
      world: st.accumulatedDistance.world + a.world
    };
    const s = {
      event: t,
      eventName: tA,
      renderingEngineId: st.renderingEngineId,
      viewportId: st.viewportId,
      camera: {},
      element: st.element,
      startPoints: Is(st.startPointsList),
      lastPoints: Is(n),
      currentPoints: Is(e),
      startPointsList: Co(st.startPointsList),
      lastPointsList: Co(n),
      currentPointsList: e,
      deltaPoints: r,
      deltaDistance: i
    };
    kl(st.element, tA, s), n0e(t, r), st.lastPointsList = Co(e);
  }
  function kV(t) {
    clearTimeout(st.pressTimeout);
    const e = F5(t, st.element), n = PV(st.element, st.lastPointsList), r = e.length === n.length ? D6(e, n) : D6(e, e), i = e.length === n.length ? M6(e, n) : M6(e, e), a = {
      event: t,
      eventName: nA,
      element: st.element,
      renderingEngineId: st.renderingEngineId,
      viewportId: st.viewportId,
      camera: {},
      startPointsList: Co(st.startPointsList),
      lastPointsList: Co(n),
      currentPointsList: e,
      startPoints: Is(st.startPointsList),
      lastPoints: Is(n),
      currentPoints: Is(e),
      deltaPoints: r,
      deltaDistance: i
    };
    kl(a.element, nA, a), t0e(t), st = JSON.parse(JSON.stringify(UV)), document.removeEventListener("touchmove", _V), document.removeEventListener("touchend", kV);
  }
  function t0e(t) {
    const e = (/* @__PURE__ */ new Date()).getTime(), n = st.startTime.getTime();
    if (e - n > dr.tapToleranceMs || (dr.taps === 0 && (dr.element = st.element, dr.renderingEngineId = st.renderingEngineId, dr.viewportId = st.viewportId, dr.startPointsList = st.startPointsList), dr.taps > 0 && !(dr.element == st.element && dr.renderingEngineId == st.renderingEngineId && dr.viewportId == st.viewportId))) return;
    const r = F5(t, dr.element);
    NV(r, dr.startPointsList).canvas > dr.tapMaxDistance || (clearTimeout(dr.tapTimeout), dr.taps += 1, dr.tapTimeout = setTimeout(() => {
      const a = {
        event: t,
        eventName: rA,
        element: dr.element,
        renderingEngineId: dr.renderingEngineId,
        viewportId: dr.viewportId,
        camera: {},
        currentPointsList: r,
        currentPoints: Is(r),
        taps: dr.taps
      };
      kl(a.element, rA, a), dr = JSON.parse(JSON.stringify(FV));
    }, dr.tapToleranceMs));
  }
  function n0e(t, e) {
    const n = (/* @__PURE__ */ new Date()).getTime(), r = st.startTime.getTime();
    if (st.swiped || n - r > st.swipeToleranceMs) return;
    const [i, a] = e.canvas, s = {
      event: t,
      eventName: lv,
      renderingEngineId: st.renderingEngineId,
      viewportId: st.viewportId,
      camera: {},
      element: st.element,
      swipe: null
    };
    Math.abs(i) > st.swipeDistanceThreshold && (s.swipe = i > 0 ? du.RIGHT : du.LEFT, kl(s.element, lv, s), st.swiped = true), Math.abs(a) > st.swipeDistanceThreshold && (s.swipe = a > 0 ? du.DOWN : du.UP, kl(s.element, lv, s), st.swiped = true);
  }
  function PV(t, e) {
    const { viewport: n } = pt(t);
    return e.map((r) => {
      const i = n.canvasToWorld(r.canvas);
      return {
        page: r.page,
        client: r.client,
        canvas: r.canvas,
        world: i,
        touch: r.touch
      };
    });
  }
  function GV(t) {
    VV.disable(t), t.removeEventListener("touchstart", BV);
  }
  function r0e(t) {
    GV(t), VV.enable(t), t.addEventListener("touchstart", BV, {
      passive: false
    });
  }
  const zV = {
    enable: r0e,
    disable: GV
  }, iA = 10, aA = 40, sA = 800;
  function i0e(t) {
    let e = 0, n = 0, r = 0, i = 0;
    return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), r = e * iA, i = n * iA, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (t.deltaMode === 1 ? (r *= aA, i *= aA) : (r *= sA, i *= sA)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
      spinX: e,
      spinY: n,
      pixelX: r,
      pixelY: i
    };
  }
  function WV(t) {
    const e = t.currentTarget, n = pt(e), { renderingEngineId: r, viewportId: i } = n;
    if (t.deltaY > -1 && t.deltaY < 1) return;
    t.preventDefault();
    const { spinX: a, spinY: s, pixelX: o, pixelY: l } = i0e(t), c = s < 0 ? -1 : 1, f = {
      event: t,
      eventName: Re.MOUSE_WHEEL,
      renderingEngineId: r,
      viewportId: i,
      element: e,
      camera: {},
      detail: t,
      wheel: {
        spinX: a,
        spinY: s,
        pixelX: o,
        pixelY: l,
        direction: c
      },
      points: s0(t)
    };
    qe(e, Re.MOUSE_WHEEL, f);
  }
  function a0e(t) {
    HV(t), t.addEventListener("wheel", WV, {
      passive: false
    });
  }
  function HV(t) {
    t.removeEventListener("wheel", WV);
  }
  const jV = {
    enable: a0e,
    disable: HV
  }, s0e = {
    renderingEngineId: void 0,
    viewportId: void 0,
    key: void 0,
    keyCode: void 0,
    element: null
  };
  let Sr = {
    renderingEngineId: void 0,
    viewportId: void 0,
    key: void 0,
    keyCode: void 0,
    element: null
  };
  function B5(t) {
    Sr.element = t.currentTarget;
    const e = pt(Sr.element), { renderingEngineId: n, viewportId: r } = e;
    Sr.renderingEngineId = n, Sr.viewportId = r, Sr.key = t.key, Sr.keyCode = t.keyCode, t.preventDefault();
    const i = {
      renderingEngineId: Sr.renderingEngineId,
      viewportId: Sr.viewportId,
      element: Sr.element,
      key: Sr.key,
      keyCode: Sr.keyCode
    };
    qe(i.element, Re.KEY_DOWN, i), document.addEventListener("keyup", KV), document.addEventListener("visibilitychange", Ry), Sr.element.removeEventListener("keydown", B5);
  }
  function Ry() {
    document.removeEventListener("visibilitychange", Ry), document.visibilityState === "hidden" && YV();
  }
  function KV(t) {
    const e = {
      renderingEngineId: Sr.renderingEngineId,
      viewportId: Sr.viewportId,
      element: Sr.element,
      key: Sr.key,
      keyCode: Sr.keyCode
    };
    document.removeEventListener("keyup", KV), document.removeEventListener("visibilitychange", Ry), Sr.element.addEventListener("keydown", B5), Sr = Ar(s0e), qe(e.element, Re.KEY_UP, e);
  }
  function o0e() {
    return Sr.keyCode;
  }
  function YV() {
    Sr.keyCode = void 0;
  }
  function l0e(t) {
    qV(t), t.addEventListener("keydown", B5);
  }
  function qV(t) {
    t.removeEventListener("keydown", B5);
  }
  const sf = {
    enable: l0e,
    disable: qV,
    getModifierKey: o0e
  };
  class of {
    constructor(e, n) {
      const r = zi(n, e), { configuration: i = {}, supportedInteractionTypes: a, toolGroupId: s } = r;
      i.strategies || (i.strategies = {}, i.defaultStrategy = void 0, i.activeStrategy = void 0, i.strategyOptions = {}), this.toolGroupId = s, this.supportedInteractionTypes = a || [], this.configuration = Object.assign({}, i), this.mode = jn.Disabled;
    }
    getToolName() {
      return this.constructor.toolName;
    }
    applyActiveStrategy(e, n) {
      var _a3;
      const { strategies: r, activeStrategy: i } = this.configuration;
      return (_a3 = r[i]) == null ? void 0 : _a3.call(this, e, n);
    }
    applyActiveStrategyCallback(e, n, r) {
      var _a3;
      const { strategies: i, activeStrategy: a } = this.configuration;
      if (!i[a]) throw new Error(`applyActiveStrategyCallback: active strategy ${a} not found, check tool configuration or spellings`);
      return (_a3 = i[a][r]) == null ? void 0 : _a3.call(this, e, n);
    }
    setConfiguration(e) {
      this.configuration = zi(this.configuration, e);
    }
    setActiveStrategy(e) {
      this.setConfiguration({
        activeStrategy: e
      });
    }
    getTargetVolumeId(e) {
      var _a3;
      if (this.configuration.volumeId) return this.configuration.volumeId;
      const n = e.getActors();
      if (n) return (_a3 = n.find((r) => r.actor.getClassName() === "vtkVolume")) == null ? void 0 : _a3.uid;
    }
    getTargetIdImage(e, n) {
      if (e.startsWith("imageId:")) {
        const r = e.split("imageId:")[1], i = va(r);
        let a = x6(i, n.id);
        return !a || !a.length || (a = a.filter((s) => s.getCurrentImageId() === r), !a || !a.length) ? void 0 : a[0].getImageData();
      } else if (e.startsWith("volumeId:")) {
        const r = nf(e), i = nI(r, n.id);
        return !i || !i.length ? void 0 : i[0].getImageData();
      } else if (e.startsWith("videoId:")) {
        const r = va(e), i = x6(r, n.id);
        return !i || !i.length ? void 0 : i[0].getImageData();
      } else throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
    }
    getTargetId(e) {
      var _a3;
      const n = (_a3 = e.getReferenceId) == null ? void 0 : _a3.call(e);
      if (n) return n;
      if (e instanceof Ga) return `volumeId:${this.getTargetVolumeId(e)}`;
      throw new Error("getTargetId: viewport must have a getReferenceId method");
    }
  }
  of.toolName = "BaseTool";
  const c0e = "viewport-element";
  function u0e(t) {
    const e = pt(t), { viewportId: n, renderingEngineId: r } = e, i = `${n}:${r}`, a = f0e(t);
    return Object.keys(yt.svgNodeCache[i]).forEach((s) => {
      yt.svgNodeCache[i][s].touched = false;
    }), {
      svgLayerElement: a,
      svgNodeCacheForCanvas: yt.svgNodeCache,
      getSvgNode: h0e.bind(this, i),
      appendNode: d0e.bind(this, a, i),
      setNodeTouched: g0e.bind(this, i),
      clearUntouched: p0e.bind(this, a, i)
    };
  }
  function f0e(t) {
    const e = `.${c0e}`;
    return t.querySelector(e).querySelector(":scope > .svg-layer");
  }
  function h0e(t, e) {
    if (yt.svgNodeCache[t] && yt.svgNodeCache[t][e]) return yt.svgNodeCache[t][e].domRef;
  }
  function d0e(t, e, n, r) {
    if (!yt.svgNodeCache[e]) return null;
    yt.svgNodeCache[e][r] = {
      touched: true,
      domRef: n
    }, t.appendChild(n);
  }
  function g0e(t, e) {
    yt.svgNodeCache[t] && yt.svgNodeCache[t][e] && (yt.svgNodeCache[t][e].touched = true);
  }
  function p0e(t, e) {
    yt.svgNodeCache[e] && Object.keys(yt.svgNodeCache[e]).forEach((n) => {
      const r = yt.svgNodeCache[e][n];
      !r.touched && r.domRef && (t.removeChild(r.domRef), delete yt.svgNodeCache[e][n]);
    });
  }
  function m0e(t, e) {
    const n = u0e(t);
    e(n), n.clearUntouched();
  }
  function ld(t, e, n) {
    return `${t}::${e}::${n}`;
  }
  function Zc(t, e) {
    Object.keys(t).forEach((n) => {
      const r = e.getAttribute(n), i = t[n];
      i === void 0 || i === "" ? e.removeAttribute(n) : r !== i && e.setAttribute(n, i);
    });
  }
  function _5(t, e) {
    Object.keys(t).forEach((n) => {
      const r = t[n];
      r !== void 0 && r !== "" && e.setAttribute(n, r);
    });
  }
  function v0e(t, e, n, r, i = {}, a) {
    const { color: s, handleRadius: o, width: l, lineWidth: c, fill: f, type: u, opacity: h } = Object.assign({
      color: "rgb(0, 255, 0)",
      handleRadius: "6",
      width: "2",
      lineWidth: void 0,
      fill: "transparent",
      type: "circle",
      opacity: 1
    }, i), g = c || l, v = "http://www.w3.org/2000/svg", m = ld(e, "handle", `hg-${n}-index-${a}`);
    let y;
    if (u === "circle") y = {
      cx: `${r[0]}`,
      cy: `${r[1]}`,
      r: o,
      stroke: s,
      fill: f,
      "stroke-width": g,
      opacity: h
    };
    else if (u === "rect") {
      const T = parseFloat(o) * 1.5, S = r[0] - T * 0.5, E = r[1] - T * 0.5;
      y = {
        x: `${S}`,
        y: `${E}`,
        width: `${T}`,
        height: `${T}`,
        stroke: s,
        fill: f,
        "stroke-width": g,
        rx: `${T * 0.1}`,
        opacity: h
      };
    } else throw new Error(`Unsupported handle type: ${u}`);
    const w = t.getSvgNode(m);
    if (w) Zc(y, w), t.setNodeTouched(m);
    else {
      const C = document.createElementNS(v, u);
      _5(y, C), t.appendNode(C, m);
    }
  }
  function R6(t, e, n, r, i = {}) {
    r.forEach((a, s) => {
      v0e(t, e, n, a, i, s);
    });
  }
  function y0e(t, e, n, r, i, a = {}, s = "") {
    if (isNaN(r[0]) || isNaN(r[1]) || isNaN(i[0]) || isNaN(i[1])) return;
    const { color: o, width: l, lineWidth: c, lineDash: f, shadow: u } = Object.assign({
      color: "rgb(0, 255, 0)",
      width: "2",
      lineWidth: void 0,
      lineDash: void 0,
      shadow: void 0
    }, a), h = c || l, g = "http://www.w3.org/2000/svg", v = ld(e, "line", n), m = t.getSvgNode(v), y = u ? `filter:url(#shadow-${t.svgLayerElement.id});` : "", w = {
      x1: `${r[0]}`,
      y1: `${r[1]}`,
      x2: `${i[0]}`,
      y2: `${i[1]}`,
      stroke: o,
      style: y,
      "stroke-width": h,
      "stroke-dasharray": f
    };
    if (m) Zc(w, m), t.setNodeTouched(v);
    else {
      const C = document.createElementNS(g, "line");
      s !== "" && C.setAttribute("data-id", s), _5(w, C), t.appendNode(C, v);
    }
  }
  function Pu(t, e, n, r, i) {
    if (r.length < 2) return;
    const { color: a = "rgb(0, 255, 0)", width: s = 10, fillColor: o = "none", fillOpacity: l = 0, lineWidth: c, lineDash: f, closePath: u = false } = i, h = c || s, g = "http://www.w3.org/2000/svg", v = ld(e, "polyline", n), m = t.getSvgNode(v);
    let y = "";
    for (const C of r) y += `${C[0].toFixed(1)}, ${C[1].toFixed(1)} `;
    if (u) {
      const C = r[0];
      y += `${C[0]}, ${C[1]}`;
    }
    const w = {
      points: y,
      stroke: a,
      fill: o,
      "fill-opacity": l,
      "stroke-width": h,
      "stroke-dasharray": f
    };
    if (m) Zc(w, m), t.setNodeTouched(v);
    else {
      const C = document.createElementNS(g, "polyline");
      _5(w, C), t.appendNode(C, v);
    }
  }
  function Au(t, e, n, r, i) {
    const s = r.length && r[0].length && Array.isArray(r[0][0]) ? r : [
      r
    ], { color: o = "rgb(0, 255, 0)", width: l = 10, fillColor: c = "none", fillOpacity: f = 0, lineWidth: u, lineDash: h, closePath: g = false } = i, v = u || l, m = "http://www.w3.org/2000/svg", y = ld(e, "path", n), w = t.getSvgNode(y);
    let C = "";
    for (let S = 0, E = s.length; S < E; S++) {
      const b = s[S], D = b.length;
      if (!(D < 2)) {
        for (let R = 0; R < D; R++) {
          const I = b[R];
          C += `${R ? "L" : "M"} ${I[0].toFixed(1)}, ${I[1].toFixed(1)} `;
        }
        g && (C += "Z ");
      }
    }
    if (!C) return;
    const T = {
      d: C,
      stroke: o,
      fill: c,
      "fill-opacity": f,
      "stroke-width": v,
      "stroke-dasharray": h
    };
    if (w) Zc(T, w), t.setNodeTouched(y);
    else {
      const S = document.createElementNS(m, "path");
      _5(T, S), t.appendNode(S, y);
    }
  }
  function x0e(t, e, n, r, i, a = {}) {
    const s = Object.assign({
      fontFamily: "Helvetica, Arial, sans-serif",
      fontSize: "14px",
      color: "rgb(255, 255, 0)",
      background: "",
      padding: 25,
      centerX: false,
      centerY: true
    }, a);
    return w0e(t, e, n, r, i, s);
  }
  function w0e(t, e, n, r = [
    ""
  ], i, a) {
    const { padding: s, color: o, fontFamily: l, fontSize: c, background: f } = a;
    let u;
    const [h, g] = [
      i[0] + s,
      i[1] + s
    ], v = "http://www.w3.org/2000/svg", m = ld(e, "text", n), y = t.getSvgNode(m);
    if (y) {
      const w = y.querySelector("text"), C = Array.from(w.children);
      for (let E = 0; E < C.length; E++) {
        const b = C[E], D = r[E] || "";
        b.textContent = D;
      }
      if (r.length > C.length) {
        for (let E = 0; E < r.length - C.length; E++) {
          const b = r[E + C.length], D = oA(b);
          w.appendChild(D);
        }
        y.appendChild(w), t.appendNode(y, m);
      }
      const T = {
        fill: o,
        "font-size": c,
        "font-family": l
      }, S = {
        transform: `translate(${h} ${g})`
      };
      Zc(T, w), Zc(S, y), u = lA(y, f), t.setNodeTouched(m);
    } else {
      const w = document.createElementNS(v, "g");
      w.setAttribute("transform", `translate(${h} ${g})`);
      const C = C0e(t, a);
      for (let T = 0; T < r.length; T++) {
        const S = r[T], E = oA(S);
        C.appendChild(E);
      }
      w.appendChild(C), t.appendNode(w, m), u = lA(w, f);
    }
    return Object.assign({}, u, {
      x: h,
      y: g,
      height: u.height + s,
      width: u.width + s
    });
  }
  function C0e(t, e) {
    const { color: n, fontFamily: r, fontSize: i } = e, s = document.createElementNS("http://www.w3.org/2000/svg", "text"), o = "user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);", l = `filter:url(#shadow-${t.svgLayerElement.id});`, c = `${o}${l}`;
    return s.setAttribute("x", "0"), s.setAttribute("y", "0"), s.setAttribute("fill", n), s.setAttribute("font-family", r), s.setAttribute("font-size", i), s.setAttribute("style", c), s;
  }
  function oA(t) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    return n.setAttribute("x", "0"), n.setAttribute("dy", "1.2em"), n.textContent = t, n;
  }
  function lA(t, e) {
    let n = t.querySelector("rect.background");
    if (!e) return n && t.removeChild(n), t.getBBox();
    n || (n = document.createElementNS("http://www.w3.org/2000/svg", "rect"), n.setAttribute("class", "background"), t.insertBefore(n, t.firstChild));
    const r = t.getBBox(), i = {
      x: `${r.x}`,
      y: `${r.y}`,
      width: `${r.width}`,
      height: `${r.height}`,
      fill: e
    };
    return Zc(i, n), r;
  }
  function cA(t, e) {
    let n = [
      0,
      0
    ], r = Number.MAX_SAFE_INTEGER;
    return t.forEach(function(i) {
      const a = T0e(e, i);
      a < r && (r = a, n = [
        ...i
      ]);
    }), n;
  }
  function T0e(t, e) {
    const [n, r] = t, [i, a] = e;
    return Math.sqrt(Math.pow(n - i, 2) + Math.pow(r - a, 2));
  }
  function S0e(t, e, n, r, i, a, s = {}) {
    const o = r.length > 0 ? cA(r, i) : i, l = A0e(a), c = cA(l, o), f = Object.assign({
      color: "rgb(255, 255, 0)",
      lineWidth: "1",
      lineDash: "2,3"
    }, s);
    y0e(t, e, `link-${n}`, o, c, f);
  }
  function A0e(t) {
    const { x: e, y: n, height: r, width: i } = t, a = i / 2, s = r / 2, o = [
      e + a,
      n
    ], l = [
      e,
      n + s
    ], c = [
      e + a,
      n + r
    ], f = [
      e + i,
      n + s
    ];
    return [
      o,
      l,
      c,
      f
    ];
  }
  function E0e(t, e, n, r, i, a, s, o = {}) {
    const l = Object.assign({
      handleRadius: "6",
      centering: {
        x: false,
        y: true
      }
    }, o), c = x0e(t, e, n, r, i, l);
    return S0e(t, e, n, a, i, c, l), c;
  }
  function b0e(t, e) {
    const n = pt(t), { renderingEngineId: r, viewportId: i } = n, a = pi(i, r);
    if (!a) return [];
    const s = [], o = Object.keys(a.toolOptions);
    for (let l = 0; l < o.length; l++) {
      const c = o[l], f = a.toolOptions[c];
      if (f && e.includes(f.mode)) {
        const u = a.getToolInstance(c);
        s.push(u);
      }
    }
    return s;
  }
  const { Active: D0e, Passive: M0e, Enabled: R0e } = jn;
  class O0e {
    constructor() {
      this._needsRender = /* @__PURE__ */ new Set(), this._animationFrameSet = false, this._animationFrameHandle = null, this._renderFlaggedViewports = () => {
        this._throwIfDestroyed();
        const e = Array.from(this._viewportElements.values());
        for (let n = 0; n < e.length; n++) {
          const r = e[n];
          if (this._needsRender.has(r) && (this._triggerRender(r), this._needsRender.delete(r), this._needsRender.size === 0)) break;
        }
        this._animationFrameSet = false, this._animationFrameHandle = null, this._render();
      }, this._viewportElements = /* @__PURE__ */ new Map();
    }
    addViewportElement(e, n) {
      this._viewportElements.set(e, n);
    }
    removeViewportElement(e, n) {
      this._viewportElements.delete(e), this._needsRender.delete(n), this._reset();
    }
    renderViewport(e) {
      this._setViewportsToBeRenderedNextFrame([
        e
      ]);
    }
    _throwIfDestroyed() {
      if (this.hasBeenDestroyed) throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
    }
    _setAllViewportsToBeRenderedNextFrame() {
      [
        ...this._viewportElements.values()
      ].forEach((n) => {
        this._needsRender.add(n);
      }), this._renderFlaggedViewports();
    }
    _setViewportsToBeRenderedNextFrame(e) {
      const n = [
        ...this._viewportElements.values()
      ];
      e.forEach((r) => {
        n.indexOf(r) !== -1 && this._needsRender.add(r);
      }), this._render();
    }
    _render() {
      this._needsRender.size > 0 && this._animationFrameSet === false && (this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports), this._animationFrameSet = true);
    }
    _triggerRender(e) {
      const n = pt(e);
      if (!n) return;
      if (!_a(n.renderingEngineId)) {
        console.warn("rendering Engine has been destroyed");
        return;
      }
      const i = b0e(e, [
        D0e,
        M0e,
        R0e
      ]), { renderingEngineId: a, viewportId: s } = n, o = {
        element: e,
        renderingEngineId: a,
        viewportId: s
      };
      m0e(e, (l) => {
        let c = false;
        const f = (u) => {
          if (u.renderAnnotation) {
            const h = u.renderAnnotation(n, l);
            c = c || h;
          }
        };
        i.forEach(f), c && qe(e, Re.ANNOTATION_RENDERED, {
          ...o
        });
      });
    }
    _reset() {
      window.cancelAnimationFrame(this._animationFrameHandle), this._needsRender.clear(), this._animationFrameSet = false, this._animationFrameHandle = null, this._setAllViewportsToBeRenderedNextFrame();
    }
  }
  const Oy = new O0e();
  function cd(t) {
    Oy.renderViewport(t);
  }
  const { EPSILON: I0e } = xb, V0e = 1 - I0e;
  function N0e(t, e, n) {
    const { viewPlaneNormal: r } = e, i = t.filter((l) => {
      let c = l.metadata.viewPlaneNormal;
      if (!c) {
        const { referencedImageId: u } = l.metadata, { imageOrientationPatient: h } = Ct("imagePlaneModule", u), g = Ue(h[0], h[1], h[2]), v = Ue(h[3], h[4], h[5]);
        c = He(), Vr(c, g, v), l.metadata.viewPlaneNormal = c;
      }
      const f = Math.abs(Bt(r, c)) > V0e;
      return c && f;
    });
    if (!i.length) return [];
    const a = n / 2, { focalPoint: s } = e, o = [];
    for (const l of i) {
      const f = l.data.handles.points[0];
      if (!l.isVisible) continue;
      const u = He();
      hi(u, s, f);
      const h = Bt(u, r);
      Math.abs(h) < a && o.push(l);
    }
    return o;
  }
  function XV(t, e, n = {}) {
    if (t instanceof Ba) {
      const r = t.getCamera(), { spacingInNormalDirection: i } = ad(t, r);
      return N0e(e, r, i);
    }
    if (t instanceof bo) {
      const r = t.getCurrentImageId(), i = r.indexOf(":");
      n.imageURI = r.substring(i + 1);
    }
    return e.filter((r) => r.isVisible ? r.data.isCanvasAnnotation ? true : t.isReferenceViewable(r.metadata, n) : false);
  }
  class L0e {
    constructor() {
      const e = {
        color: "rgb(255, 255, 0)",
        colorHighlighted: "rgb(0, 255, 0)",
        colorSelected: "rgb(0, 220, 0)",
        colorLocked: "rgb(255, 255, 0)",
        lineWidth: "1",
        lineDash: "",
        shadow: true,
        textBoxVisibility: true,
        textBoxFontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif",
        textBoxFontSize: "14px",
        textBoxColor: "rgb(255, 255, 0)",
        textBoxColorHighlighted: "rgb(0, 255, 0)",
        textBoxColorSelected: "rgb(0, 255, 0)",
        textBoxColorLocked: "rgb(255, 255, 0)",
        textBoxBackground: "",
        textBoxLinkLineWidth: "1",
        textBoxLinkLineDash: "2,3",
        textBoxShadow: true
      };
      this._initializeConfig(e);
    }
    getAnnotationToolStyles(e) {
      return this.config.annotations && this.config.annotations[e];
    }
    getViewportToolStyles(e) {
      return this.config.viewports && this.config.viewports[e];
    }
    getToolGroupToolStyles(e) {
      return this.config.toolGroups && this.config.toolGroups[e];
    }
    getDefaultToolStyles() {
      return this.config.default;
    }
    setAnnotationStyles(e, n) {
      let r = this.config.annotations;
      r || (this.config = {
        ...this.config,
        annotations: {}
      }, r = this.config.annotations), r[e] = n;
    }
    setViewportToolStyles(e, n) {
      let r = this.config.viewports;
      r || (this.config = {
        ...this.config,
        viewports: {}
      }, r = this.config.viewports), r[e] = n;
    }
    setToolGroupToolStyles(e, n) {
      let r = this.config.toolGroups;
      r || (this.config = {
        ...this.config,
        toolGroups: {}
      }, r = this.config.toolGroups), r[e] = n;
    }
    setDefaultToolStyles(e) {
      this.config.default = e;
    }
    getStyleProperty(e, n) {
      const { annotationUID: r, viewportId: i, toolGroupId: a, toolName: s } = n;
      return this._getToolStyle(e, r, i, a, s);
    }
    _getToolStyle(e, n, r, i, a) {
      if (n) {
        const o = this.getAnnotationToolStyles(n);
        if (o && o[e] !== void 0) return o[e];
      }
      if (r) {
        const o = this.getViewportToolStyles(r);
        if (o) {
          if (o[a] && o[a][e] !== void 0) return o[a][e];
          if (o.global && o.global[e] !== void 0) return o.global[e];
        }
      }
      if (i) {
        const o = this.getToolGroupToolStyles(i);
        if (o) {
          if (o[a] && o[a][e] !== void 0) return o[a][e];
          if (o.global && o.global[e] !== void 0) return o.global[e];
        }
      }
      const s = this.getDefaultToolStyles();
      if (s[a] && s[a][e] !== void 0) return s[a][e];
      if (s.global && s.global[e] !== void 0) return s.global[e];
    }
    _initializeConfig(e) {
      const n = {};
      for (const r in e) n[r] = e[r];
      this.config = {
        default: {
          global: n
        }
      };
    }
  }
  const U0e = new L0e();
  function F0e(t, e, n) {
    const r = [
      `${t}`
    ];
    return e && r.push(`${r[0]}${e}`), n && r.push(`${r[r.length - 1]}${n}`), r;
  }
  function ZV(t, e, n, r) {
    const i = F0e(t, n, r);
    for (let a = i.length - 1; a >= 0; --a) {
      const s = U0e.getStyleProperty(i[a], e);
      if (s !== void 0) return s;
    }
  }
  function B0e(t) {
    if (t) {
      if (t.data && t.highlighted) return Cl.Highlighted;
      if (L5(t.annotationUID)) return Cl.Selected;
      if (_u(t)) return Cl.Locked;
      if (t.data && t.autoGenerated) return Cl.AutoGenerated;
    }
    return Cl.Default;
  }
  class QV extends of {
    constructor() {
      super(...arguments), this.onImageSpacingCalibrated = (e) => {
        const { element: n, imageId: r } = e.detail, i = va(r), a = cf();
        a.getFramesOfReference().forEach((o) => {
          const c = a.getAnnotations(o)[this.getToolName()];
          !c || !c.length || (c.forEach((f) => {
            var _a3;
            if (!((_a3 = f.metadata) == null ? void 0 : _a3.referencedImageId)) return;
            va(f.metadata.referencedImageId) === i && (f.invalidated = true, f.data.cachedStats = {});
          }), cd(n));
        });
      };
    }
    filterInteractableAnnotationsForElement(e, n) {
      if (!n || !n.length) return;
      const r = pt(e), { viewport: i } = r;
      return XV(i, n);
    }
    getReferencedImageId(e, n, r, i) {
      const a = this.getTargetId(e);
      let s = a.split(/^[a-zA-Z]+:/)[1];
      if (e instanceof Ga) {
        const o = nf(a), l = Ke.getVolume(o);
        s = bp(l, n, r);
      }
      return s;
    }
    getStyle(e, n, r) {
      return ZV(e, n, B0e(r), this.mode);
    }
  }
  QV.toolName = "AnnotationDisplayTool";
  class JV extends QV {
    constructor(e, n) {
      var _a3, _b3;
      super(e, n), this.mouseMoveCallback = (r, i) => {
        if (!i) return false;
        const { element: a, currentPoints: s } = r.detail, o = s.canvas;
        let l = false;
        for (const c of i) {
          if (_u(c) || !Vh(c.annotationUID)) continue;
          const { data: f } = c, u = f.handles ? f.handles.activeHandleIndex : void 0, h = this._imagePointNearToolOrHandle(a, c, o, 6), g = h && !c.highlighted, v = !h && c.highlighted;
          g || v ? (c.highlighted = !c.highlighted, l = true) : f.handles && f.handles.activeHandleIndex !== u && (l = true);
        }
        return l;
      }, ((_a3 = e.configuration) == null ? void 0 : _a3.getTextLines) && (this.configuration.getTextLines = e.configuration.getTextLines), ((_b3 = e.configuration) == null ? void 0 : _b3.statsCalculator) && (this.configuration.statsCalculator = e.configuration.statsCalculator);
    }
    static createAnnotation(...e) {
      let n = {
        annotationUID: null,
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.toolName
        },
        data: {
          text: "",
          handles: {
            points: new Array(),
            textBox: {
              hasMoved: false,
              worldPosition: [
                0,
                0,
                0
              ],
              worldBoundingBox: {
                topLeft: [
                  0,
                  0,
                  0
                ],
                topRight: [
                  0,
                  0,
                  0
                ],
                bottomLeft: [
                  0,
                  0,
                  0
                ],
                bottomRight: [
                  0,
                  0,
                  0
                ]
              }
            }
          },
          label: ""
        }
      };
      for (const r of e) n = zi(n, r);
      return n;
    }
    static createAnnotationForViewport(e, ...n) {
      return this.createAnnotation({
        metadata: e.getViewReference()
      }, ...n);
    }
    static createAndAddAnnotation(e, ...n) {
      const r = this.createAnnotationForViewport(e, ...n);
      uf(r, e.element), Wl(r, e.element);
    }
    getHandleNearImagePoint(e, n, r, i) {
      const a = pt(e), { viewport: s } = a, { data: o } = n, { isCanvasAnnotation: l } = o, { points: c, textBox: f } = o.handles;
      if (f) {
        const { worldBoundingBox: u } = f;
        if (u) {
          const h = {
            topLeft: s.worldToCanvas(u.topLeft),
            topRight: s.worldToCanvas(u.topRight),
            bottomLeft: s.worldToCanvas(u.bottomLeft),
            bottomRight: s.worldToCanvas(u.bottomRight)
          };
          if (r[0] >= h.topLeft[0] && r[0] <= h.bottomRight[0] && r[1] >= h.topLeft[1] && r[1] <= h.bottomRight[1]) return o.handles.activeHandleIndex = null, f;
        }
      }
      for (let u = 0; u < (c == null ? void 0 : c.length); u++) {
        const h = c[u], g = l ? h.slice(0, 2) : s.worldToCanvas(h);
        if (Jr(r, g) < i === true) return o.handles.activeHandleIndex = u, h;
      }
      o.handles.activeHandleIndex = null;
    }
    getLinkedTextBoxStyle(e, n) {
      return {
        visibility: this.getStyle("textBoxVisibility", e, n),
        fontFamily: this.getStyle("textBoxFontFamily", e, n),
        fontSize: this.getStyle("textBoxFontSize", e, n),
        color: this.getStyle("textBoxColor", e, n),
        shadow: this.getStyle("textBoxShadow", e, n),
        background: this.getStyle("textBoxBackground", e, n),
        lineWidth: this.getStyle("textBoxLinkLineWidth", e, n),
        lineDash: this.getStyle("textBoxLinkLineDash", e, n)
      };
    }
    isSuvScaled(e, n, r) {
      var _a3, _b3, _c3;
      if (e instanceof Ga) {
        const a = nf(n);
        return ((_b3 = (_a3 = Ke.getVolume(a)) == null ? void 0 : _a3.scaling) == null ? void 0 : _b3.PT) !== void 0;
      }
      return typeof ((_c3 = r && Ct("scalingModule", r)) == null ? void 0 : _c3.suvbw) == "number";
    }
    getAnnotationStyle(e) {
      const { annotation: n, styleSpecifier: r } = e, i = (g) => this.getStyle(g, r, n), { annotationUID: a } = n, s = Vh(a), o = _u(n), l = i("lineWidth"), c = i("lineDash"), f = i("color"), u = i("shadow"), h = this.getLinkedTextBoxStyle(r, n);
      return {
        visibility: s,
        locked: o,
        color: f,
        lineWidth: l,
        lineDash: c,
        lineOpacity: 1,
        fillColor: f,
        fillOpacity: 0,
        shadow: u,
        textbox: h
      };
    }
    _imagePointNearToolOrHandle(e, n, r, i) {
      if (this.getHandleNearImagePoint(e, n, r, i) || this.isPointNearTool(e, n, r, i, "mouse")) return true;
    }
  }
  JV.toolName = "AnnotationTool";
  class Yp extends of {
    constructor(e = {}, n = {
      supportedInteractionTypes: [
        "Mouse",
        "Touch"
      ]
    }) {
      super(e, n);
    }
    touchDragCallback(e) {
      this._dragCallback(e);
    }
    mouseDragCallback(e) {
      this._dragCallback(e);
    }
    _dragCallback(e) {
      const { element: n, deltaPoints: r } = e.detail, i = pt(n), a = r.world;
      if (a[0] === 0 && a[1] === 0 && a[2] === 0) return;
      const s = i.viewport.getCamera(), { focalPoint: o, position: l } = s, c = [
        l[0] - a[0],
        l[1] - a[1],
        l[2] - a[2]
      ], f = [
        o[0] - a[0],
        o[1] - a[1],
        o[2] - a[2]
      ];
      i.viewport.setCamera({
        focalPoint: f,
        position: c
      }), i.viewport.render();
    }
  }
  Yp.toolName = "Pan";
  const _0e = {
    renderOutline: true,
    outlineWidthAutoGenerated: 3,
    outlineWidthActive: 1,
    outlineWidthInactive: 1,
    outlineOpacity: 1,
    outlineOpacityInactive: 0.85,
    outlineDashActive: void 0,
    outlineDashInactive: void 0,
    outlineDashAutoGenerated: "5,3",
    activeSegmentOutlineWidthDelta: 0,
    renderFill: true,
    fillAlpha: 0.5,
    fillAlphaInactive: 0.3,
    fillAlphaAutoGenerated: 0.3
  };
  function k0e() {
    return _0e;
  }
  const P0e = {
    renderOutline: true,
    outlineWidthActive: 3,
    outlineWidthInactive: 2,
    activeSegmentOutlineWidthDelta: 0,
    renderFill: true,
    renderFillInactive: true,
    fillAlpha: 0.7,
    fillAlphaInactive: 0.65,
    outlineOpacity: 1,
    outlineOpacityInactive: 0.85
  };
  function G0e() {
    return P0e;
  }
  const z0e = {
    renderFill: true,
    fillAlpha: 1
  };
  function W0e() {
    return z0e;
  }
  const H0e = G0e(), j0e = k0e(), K0e = W0e(), Y0e = {
    renderInactiveSegmentations: true,
    representations: {
      [Nt.Labelmap]: H0e,
      [Nt.Contour]: j0e,
      [Nt.Surface]: K0e
    }
  }, uA = {
    colorLUT: [],
    segmentations: [],
    globalConfig: Y0e,
    toolGroups: {}
  };
  class q0e {
    constructor(e) {
      e || (e = gi()), this.state = Ar(uA), this.uid = e;
    }
    getState() {
      return this.state;
    }
    getToolGroups() {
      return Object.keys(this.state.toolGroups);
    }
    getColorLUT(e) {
      return this.state.colorLUT[e];
    }
    getNextColorLUTIndex() {
      return this.state.colorLUT.length;
    }
    resetState() {
      this.state = Ar(uA);
    }
    getSegmentation(e) {
      return this.state.segmentations.find((n) => n.segmentationId === e);
    }
    addSegmentation(e) {
      if (this.getSegmentation(e.segmentationId)) throw new Error(`Segmentation with id ${e.segmentationId} already exists`);
      this.state.segmentations.push(e);
    }
    getSegmentationRepresentations(e) {
      const n = this.state.toolGroups[e];
      if (n) return n.segmentationRepresentations;
    }
    getAllSegmentationRepresentations() {
      const e = {};
      return Object.entries(this.state.toolGroups).forEach(([n, r]) => {
        e[n] = r.segmentationRepresentations;
      }), e;
    }
    addSegmentationRepresentation(e, n) {
      this.state.toolGroups[e] || (this.state.toolGroups[e] = {
        segmentationRepresentations: [],
        config: {}
      }), this.state.toolGroups[e].segmentationRepresentations.push(n), this._handleActiveSegmentation(e, n);
    }
    getGlobalConfig() {
      return this.state.globalConfig;
    }
    setGlobalConfig(e) {
      this.state.globalConfig = e;
    }
    getSegmentationRepresentationByUID(e, n) {
      var _a3;
      return (_a3 = this.getSegmentationRepresentations(e)) == null ? void 0 : _a3.find((a) => a.segmentationRepresentationUID === n);
    }
    removeSegmentation(e) {
      this.state.segmentations = this.state.segmentations.filter((n) => n.segmentationId !== e);
    }
    removeSegmentationRepresentation(e, n) {
      const r = this.getSegmentationRepresentations(e);
      if (!r || !r.length) throw new Error(`No viewport specific segmentation state found for viewport ${e}`);
      const a = r.findIndex((o) => o.segmentationRepresentationUID === n);
      a === -1 && console.warn(`No viewport specific segmentation state data found for viewport ${e} and segmentation data UID ${n}`);
      const s = r[a];
      r.splice(a, 1), this._handleActiveSegmentation(e, s);
    }
    setActiveSegmentationRepresentation(e, n) {
      const r = this.getSegmentationRepresentations(e);
      if (!r || !r.length) throw new Error(`No segmentation data found for toolGroupId: ${e}`);
      const i = r.find((a) => a.segmentationRepresentationUID === n);
      if (!i) throw new Error(`No segmentation data found for segmentation data UID ${n}`);
      i.active = true, this._handleActiveSegmentation(e, i);
    }
    getToolGroupSpecificConfig(e) {
      const n = this.state.toolGroups[e];
      if (n) return n.config;
    }
    getSegmentationRepresentationSpecificConfig(e, n) {
      const r = this.getSegmentationRepresentationByUID(e, n);
      if (r) return r.segmentationRepresentationSpecificConfig;
    }
    setSegmentationRepresentationSpecificConfig(e, n, r) {
      const i = this.getSegmentationRepresentationByUID(e, n);
      i && (i.segmentationRepresentationSpecificConfig = r);
    }
    getSegmentSpecificConfig(e, n, r) {
      const i = this.getSegmentationRepresentationByUID(e, n);
      if (i) return i.segmentSpecificConfig[r];
    }
    setSegmentSpecificConfig(e, n, r, i) {
      const a = this.getSegmentationRepresentationByUID(e, n);
      a && ((!a.segmentSpecificConfig || (i == null ? void 0 : i.clear)) && (a.segmentSpecificConfig = {}), Object.keys(r).forEach((s) => {
        a.segmentSpecificConfig[s] = r[s];
      }));
    }
    setSegmentationRepresentationConfig(e, n) {
      let r = this.state.toolGroups[e];
      r || (this.state.toolGroups[e] = {
        segmentationRepresentations: [],
        config: {
          renderInactiveSegmentations: true,
          representations: {}
        }
      }, r = this.state.toolGroups[e]), r.config = {
        ...r.config,
        ...n
      };
    }
    addColorLUT(e, n) {
      this.state.colorLUT[n] && console.warn("Color LUT table already exists, overwriting"), this.state.colorLUT[n] = Ar(e);
    }
    removeColorLUT(e) {
      delete this.state.colorLUT[e];
    }
    _handleActiveSegmentation(e, n) {
      const r = this.getSegmentationRepresentations(e);
      if (r.length === 0) return;
      if (r.length === 1) {
        r[0].active = true;
        return;
      }
      if (r.filter((a) => a.active).length === 0) {
        r[0].active = true;
        return;
      }
      n.active && r.forEach((a) => {
        a.segmentationRepresentationUID !== n.segmentationRepresentationUID && (a.active = false);
      });
    }
  }
  const X0e = new q0e("DEFAULT");
  function ud(t, e) {
    const { imageIdReferenceMap: n } = t, { volumeId: r } = t;
    if (r && !n) return true;
    if (n && !r) return false;
    if (r && n && !e) throw new Error("isVolumeSegmentation: viewport is required when both volumeId and imageIdReferenceMap are provided");
    return e instanceof Ba;
  }
  const Iy = /* @__PURE__ */ new Map(), Z0e = (t) => {
    const e = Iy.get(t);
    e && (e.isDirty = true);
  };
  function Q0e(t) {
    const e = Iy.get(t);
    return e && !e.isDirty ? e.indices : null;
  }
  function us(t) {
    const e = Q0e(t);
    if (e) return e;
    const n = Kn(t);
    if (!n) throw new Error(`No segmentation found for segmentationId ${t}`);
    let r;
    switch (n.type) {
      case Nt.Labelmap:
        r = J0e(n, t);
        break;
      case Nt.Contour:
        r = tue(n);
        break;
      case Nt.Surface:
        r = nue(n);
        break;
      default:
        throw new Error(`Unsupported segmentation type: ${n.type}`);
    }
    return Iy.set(t, {
      indices: r,
      isDirty: false
    }), r;
  }
  function J0e(t, e) {
    const n = t.representationData[Nt.Labelmap], r = /* @__PURE__ */ new Set();
    return ud(n) ? $0e(r, e) : eue(r, n.imageIdReferenceMap), Array.from(r).map(Number).sort((i, a) => i - a);
  }
  function $0e(t, e) {
    Ke.getVolume(e).getScalarData().forEach((i) => {
      i !== 0 && t.add(i);
    });
  }
  function eue(t, e) {
    e.forEach((n) => {
      Ke.getImage(n).getPixelData().forEach((a) => {
        a !== 0 && t.add(a);
      });
    });
  }
  function tue(t) {
    const { annotationUIDsMap: e, geometryIds: n } = t.representationData.CONTOUR || {};
    if (!n) throw new Error(`No geometryIds found for segmentationId ${t.segmentationId}`);
    const r = /* @__PURE__ */ new Set([
      ...e.keys()
    ]);
    return n.forEach((i) => {
      const a = Ke.getGeometry(i);
      r.add(a.data.getSegmentIndex());
    }), Array.from(r).sort((i, a) => i - a);
  }
  function nue(t) {
    var _a3;
    const e = ((_a3 = t.representationData.SURFACE) == null ? void 0 : _a3.geometryIds) ?? [];
    return Array.from(e.keys()).map(Number).sort((n, r) => n - r);
  }
  function rue(t) {
    const e = {
      segmentationId: t
    };
    qe(je, Re.SEGMENTATION_REMOVED, e);
  }
  function iue(t, e) {
    const n = {
      toolGroupId: t,
      segmentationRepresentationUID: e
    };
    qe(je, Re.SEGMENTATION_REPRESENTATION_REMOVED, n);
  }
  function lf(t, e) {
    const n = {
      toolGroupId: t,
      segmentationRepresentationUID: e
    };
    if (e) {
      qe(je, Re.SEGMENTATION_REPRESENTATION_MODIFIED, n);
      return;
    }
    (ya(t) || []).forEach((i) => {
      const { segmentationRepresentationUID: a } = i, s = {
        toolGroupId: t,
        segmentationRepresentationUID: a
      };
      qe(je, Re.SEGMENTATION_REPRESENTATION_MODIFIED, s);
    });
  }
  function Lh(t) {
    let e;
    t ? e = [
      t
    ] : e = sue().map(({ segmentationId: n }) => n), e.forEach((n) => {
      const r = {
        segmentationId: n
      };
      qe(je, Re.SEGMENTATION_MODIFIED, r);
    });
  }
  function $V(t, e) {
    const n = {
      segmentationId: t,
      modifiedSlicesToUse: e
    };
    Z0e(t), qe(je, Re.SEGMENTATION_DATA_MODIFIED, n);
  }
  function aue(t) {
    const { segmentationId: e, representation: n } = t, r = n.type === Nt.Contour;
    let i = n.data ? {
      ...n.data
    } : null;
    if (i = !i && r ? {} : i, !i) throw new Error("Segmentation representation data may not be undefined");
    if (r) {
      const a = i;
      a.geometryIds = a.geometryIds ?? [], a.annotationUIDsMap = a.annotationUIDsMap ?? /* @__PURE__ */ new Map();
    }
    return {
      segmentationId: e,
      cachedStats: {},
      segmentLabels: {},
      label: null,
      segmentsLocked: /* @__PURE__ */ new Set(),
      type: n.type,
      activeSegmentIndex: 1,
      representationData: {
        [n.type]: {
          ...i
        }
      }
    };
  }
  function Lr() {
    return X0e;
  }
  function Kn(t) {
    return Lr().getSegmentation(t);
  }
  function sue() {
    return Lr().getState().segmentations;
  }
  function oue(t, e) {
    const n = Lr(), r = aue(t);
    n.addSegmentation(r), Lh(r.segmentationId);
  }
  function ya(t) {
    return Lr().getSegmentationRepresentations(t);
  }
  function fA() {
    return Lr().getAllSegmentationRepresentations();
  }
  function eN(t) {
    const e = fA() || [], n = Object.keys(e);
    for (const r of n) {
      const a = fA()[r].find((s) => s.segmentationRepresentationUID === t);
      if (a) return {
        segmentationRepresentation: a,
        toolGroupId: r
      };
    }
  }
  function fd(t) {
    if (!t) throw new Error("getToolGroupIdsWithSegmentation: segmentationId is empty");
    const e = Lr(), n = e.getState(), r = Object.keys(n.toolGroups), i = [];
    return r.forEach((a) => {
      e.getSegmentationRepresentations(a).forEach((o) => {
        o.segmentationId === t && i.push(a);
      });
    }), i;
  }
  function lue(t) {
    return Lr().getToolGroupSpecificConfig(t);
  }
  function cue(t, e, n) {
    Lr().setSegmentationRepresentationConfig(t, e), lf(t);
  }
  function uue(t, e, n, r = false) {
    Lr().setSegmentationRepresentationSpecificConfig(t, e, n), r || lf(t, e);
  }
  function fue(t, e) {
    return Lr().getSegmentationRepresentationSpecificConfig(t, e);
  }
  function hue(t, e, n) {
    return Lr().getSegmentSpecificConfig(t, e, n);
  }
  function due(t, e, n) {
    Lr().addSegmentationRepresentation(t, e), lf(t, e.segmentationRepresentationUID);
  }
  function gue() {
    return Lr().getGlobalConfig();
  }
  function hd(t, e) {
    return Lr().getSegmentationRepresentationByUID(t, e);
  }
  function pue(t) {
    Lr().removeSegmentation(t), rue(t);
  }
  function Vy(t, e) {
    Lr().removeSegmentationRepresentation(t, e), iue(t, e);
  }
  function Ny(t) {
    return Lr().getColorLUT(t);
  }
  function mue() {
    return Lr().getNextColorLUTIndex();
  }
  function vue(t, e) {
    Lr().addColorLUT(t, e);
  }
  async function yue(t, e, n) {
    const r = pt(t), { renderingEngine: i, viewport: a } = r, { id: s } = a, o = true, l = false, c = true;
    if (ud(e, a)) {
      const f = [
        {
          volumeId: e.volumeId,
          actorUID: n,
          visibility: o,
          blendMode: ip.MAXIMUM_INTENSITY_BLEND
        }
      ];
      await Eae(i, f, [
        s
      ], l, c);
    } else {
      const u = [
        {
          imageId: e.imageIdReferenceMap.get(a.getCurrentImageId()),
          actorUID: n
        }
      ];
      await bae(i, u, [
        s
      ]);
    }
  }
  function xue(t, e, n = false) {
    const r = pt(t), { viewport: i } = r;
    i.removeActors([
      e
    ]);
  }
  const cv = 255, uv = /* @__PURE__ */ new Map();
  function tN() {
    const t = Ul.newInstance(), e = Iu.newInstance();
    return e.addPoint(0, 0), {
      ofun: e,
      cfun: t
    };
  }
  let fv = false;
  function wue(t, e, n = false) {
    Eue(t, e), Vy(t, e), n && ta(t).getViewportsInfo().forEach(({ viewportId: i, renderingEngineId: a }) => {
      Pa(i, a).viewport.render();
    });
  }
  function Cue(t, e) {
    if (!e) return true;
    const n = t.getDefaultActor();
    if (!n) return false;
    const { uid: r } = n, i = Ke.getVolume(r);
    if (i) {
      const a = Ke.getVolume(e);
      if (a && i.metadata.FrameOfReferenceUID === a.metadata.FrameOfReferenceUID) return true;
    }
    return false;
  }
  async function Tue(t, e, n) {
    const { colorLUTIndex: r, active: i, segmentationId: a, segmentationRepresentationUID: s, segmentsHidden: o, config: l } = e, c = Kn(a);
    if (!c) {
      console.warn("No segmentation found for segmentationId: ", a);
      return;
    }
    let f = c.representationData[Nt.Labelmap], u = t.getActor(s);
    if (!f && Xy(s) && !fv) {
      if (fv = true, f = await the(a, {
        segmentationRepresentationUID: s,
        viewport: t
      }), !f) throw new Error(`No labelmap data found for segmentationId ${a}.`);
      fv = false;
    }
    if (!f) return;
    if (ud(f, t)) {
      if (t instanceof bo) return;
      const { volumeId: m } = f;
      if (!Ke.getVolume(m)) throw new Error(`No Labelmap found for volumeId: ${m}`);
      if (!Cue(t, f == null ? void 0 : f.referencedVolumeId)) return;
      u || await dA(t, f, s), u = t.getActor(s);
    } else {
      if (t instanceof Ba) return;
      const m = t.getCurrentImageId(), { imageIdReferenceMap: y } = f;
      if (!y.has(m)) return;
      u || await dA(t, f, s), u = t.getActor(s);
    }
    if (!u) return;
    const { cfun: h, ofun: g } = l, v = n.renderInactiveSegmentations;
    Sue(t.id, u, h, g, r, n.representations[Nt.Labelmap], e, i, v, o);
  }
  function Sue(t, e, n, r, i, a, s, o, l, c) {
    var _a3;
    const { segmentSpecificConfig: f, segmentationRepresentationSpecificConfig: u } = s, h = u[Nt.Labelmap], g = Ny(i), v = Math.min(256, g.length), { uid: m } = e, { outlineWidth: y, renderOutline: w, outlineOpacity: C } = hA(a, h, o);
    for (let D = 0; D < v; D++) {
      const R = D, I = g[R], O = (_a3 = f[R]) == null ? void 0 : _a3[Nt.Labelmap], { fillAlpha: L, outlineWidth: N, renderFill: F, renderOutline: V } = hA(a, h, o, O), { forceOpacityUpdate: k, forceColorUpdate: _ } = Aue(t, m, R, {
        fillAlpha: L,
        renderFill: F,
        renderOutline: V,
        segmentColor: I,
        outlineWidth: N,
        segmentsHidden: c
      });
      if (_ && n.addRGBPoint(R, I[0] / cv, I[1] / cv, I[2] / cv), k) if (F) {
        const K = c.has(R) ? 0 : I[3] / 255 * L;
        r.removePoint(R), r.addPointLong(R, K, 0.5, 1);
      } else r.addPointLong(R, 0.01, 0.5, 1);
    }
    const T = e.actor;
    T.getProperty().setRGBTransferFunction(0, n), r.setClamping(false), T.getProperty().setScalarOpacity(0, r), T.getProperty().setInterpolationTypeToNearest(), T.getProperty().setUseLabelOutline(w), T.getProperty().setLabelOutlineOpacity(C);
    const { activeSegmentIndex: S } = Kn(s.segmentationId), E = new Array(v - 1);
    for (let D = 1; D < v; D++) {
      if (c.has(D)) {
        E[D - 1] = 0;
        continue;
      }
      E[D - 1] = D === S ? y + a.activeSegmentOutlineWidthDelta : y;
    }
    T.getProperty().setLabelOutlineThickness(E);
    const b = o || l;
    T.setVisibility(b);
  }
  function hA(t, e, n, r) {
    const a = {
      ...t,
      ...e,
      ...r || {}
    }, s = n ? a.fillAlpha : a.fillAlphaInactive, o = n ? a.outlineWidthActive : a.outlineWidthInactive, l = n ? a.renderFill : a.renderFillInactive, c = a.renderOutline, f = n ? a.outlineOpacity : a.outlineOpacityInactive;
    return {
      fillAlpha: s,
      outlineWidth: o,
      renderFill: l,
      renderOutline: c,
      outlineOpacity: f
    };
  }
  function Aue(t, e, n, { fillAlpha: r, renderFill: i, renderOutline: a, segmentColor: s, outlineWidth: o, segmentsHidden: l }) {
    const c = `${t}-${e}-${n}`, f = uv.get(c);
    if (!f) return uv.set(c, {
      fillAlpha: r,
      renderFill: i,
      renderOutline: a,
      outlineWidth: o,
      segmentColor: s.slice(),
      segmentsHidden: new Set(l)
    }), {
      forceOpacityUpdate: true,
      forceColorUpdate: true
    };
    const { fillAlpha: u, renderFill: h, renderOutline: g, outlineWidth: v, segmentColor: m, segmentsHidden: y } = f, w = m[0] !== s[0] || m[1] !== s[1] || m[2] !== s[2], C = m[3] !== s[3] || u !== r || h !== i || g !== a || v !== o || y.has(n) !== l.has(n);
    return uv.set(c, {
      fillAlpha: r,
      renderFill: i,
      renderOutline: a,
      outlineWidth: o,
      segmentColor: s.slice(),
      segmentsHidden: new Set(l)
    }), {
      forceOpacityUpdate: C,
      forceColorUpdate: w
    };
  }
  function Eue(t, e) {
    const n = ta(t);
    if (n === void 0) throw new Error(`ToolGroup with ToolGroupId ${t} does not exist`);
    const { viewportsInfo: r } = n;
    for (const i of r) {
      const { viewportId: a, renderingEngineId: s } = i, o = Pa(a, s);
      xue(o.viewport.element, e);
    }
  }
  async function dA(t, e, n) {
    await yue(t.element, e, n);
  }
  const nN = {
    getRepresentationRenderingConfig: tN,
    render: Tue,
    removeSegmentationRepresentation: wue
  };
  function rN(t) {
    if ("volumeId" in t) {
      if (t = t, !Ke.getVolume(t.volumeId)) throw new Error(`volumeId of ${t.volumeId} not found in cache, you should load and cache volume before adding segmentation`);
    } else if ("imageIdReferenceMap" in t) {
      if (t = t, !t.imageIdReferenceMap) throw new Error("The segmentationInput.representationData.imageIdReferenceMap is undefined, please provide a valid representationData.imageIdReferenceMap");
    } else throw new Error("The segmentationInput.representationData is undefined, please provide a valid representationData");
  }
  function bue(t) {
    if (!t.representation.data) throw new Error("The segmentationInput.representationData.data is undefined, please provide a valid representationData.data");
    const e = t.representation.data;
    rN(e);
  }
  function Due(t) {
    rN(t);
  }
  function Mue(t, e, n = false) {
    const r = hd(e, t), { segmentationId: i } = r, a = Kn(i), { annotationUIDsMap: s } = a.representationData.CONTOUR;
    s.forEach((o) => {
      o.forEach((l) => {
        Hu(l);
      });
    });
  }
  const Ly = /* @__PURE__ */ new Map();
  function iN(t) {
    return Ly.get(t);
  }
  function O6(t, e) {
    Ly.set(t, e);
  }
  function Rue(t) {
    Ly.delete(t);
  }
  function Oue(t, e, n) {
    const r = t.getImageIds();
    if (!r || !r.length) return;
    const i = r.map((a) => {
      const { imagePositionPatient: s } = Ct("imagePlaneModule", a), o = Iue(e, s, n);
      return {
        imageId: a,
        distance: o
      };
    });
    return i.sort((a, s) => a.distance - s.distance), i[0].imageId;
  }
  function Iue(t, e, n) {
    const r = He();
    hi(r, t, e);
    const i = Bt(r, n);
    return Math.abs(i);
  }
  function aN(t, e, n) {
    var _a3, _b3;
    let r = (_a3 = t.segmentSpecificConfig) == null ? void 0 : _a3[e];
    return r || (r = (_b3 = t.segmentSpecificConfig) == null ? void 0 : _b3[n]), r ? r.CONTOUR : null;
  }
  function Vue(t) {
    if (!t) throw new Error(`No contours found for geometryId ${t.id}`);
    const e = t.id;
    if (t.type !== Ao.CONTOUR) throw new Error(`Geometry type ${t.type} not supported for rendering.`);
    if (!t.data) {
      console.warn(`No contours found for geometryId ${e}. Skipping render.`);
      return;
    }
  }
  function Nue(t, e) {
    const { segmentation: n } = t.data, { segmentation: r } = e.data;
    return n.segmentationId === r.segmentationId && n.segmentIndex === r.segmentIndex;
  }
  function k5(t) {
    var _a3;
    return !!((_a3 = t.data) == null ? void 0 : _a3.segmentation);
  }
  function Uh(t) {
    if (t.parentAnnotationUID) return;
    if (!t.data.segmentation) throw new Error("addContourSegmentationAnnotation: annotation does not have a segmentation data");
    const { segmentationId: e, segmentIndex: n } = t.data.segmentation, r = Kn(e);
    r.representationData.CONTOUR || (r.representationData.CONTOUR = {
      annotationUIDsMap: /* @__PURE__ */ new Map()
    });
    const { annotationUIDsMap: i } = r.representationData.CONTOUR;
    let a = i.get(n);
    a || (a = /* @__PURE__ */ new Set(), i.set(n, a)), i.set(n, a.add(t.annotationUID));
  }
  function Uy(t) {
    if (!t.data.segmentation) throw new Error("removeContourSegmentationAnnotation: annotation does not have a segmentation data");
    const { segmentationId: e, segmentIndex: n } = t.data.segmentation, r = Kn(e), { annotationUIDsMap: i } = (r == null ? void 0 : r.representationData.CONTOUR) || {}, a = i == null ? void 0 : i.get(n);
    a && (a.delete(t.annotationUID), a.size || i.delete(n));
  }
  function Lue(t, e, n, r, i) {
    (n.size ? Uue : Fue)(t, e, r, i);
  }
  function Uue(t, e, n, r) {
    const { segmentationRepresentationUID: i, segmentsHidden: a } = n, s = r.representations.CONTOUR, o = iN(i), l = s.outlineWidthActive;
    (o == null ? void 0 : o.outlineWidthActive) !== l && O6(i, Object.assign({}, o, {
      outlineWidthActive: l
    }));
    const c = [], f = [];
    for (const m of a) o.segmentsHidden.has(m) || c.push(m);
    for (const m of o.segmentsHidden) a.has(m) || f.push(m);
    const u = Array.from(o.segmentsHidden).filter((m) => !f.includes(m)).concat(c), { segmentSpecificConfigs: h } = e.reduce((m, y) => {
      const w = Ke.getGeometry(y), { data: C } = w, T = C.getSegmentIndex(), S = aN(n, y, T);
      return m.segmentSpecificConfigs[T] = S ?? {}, m;
    }, {
      contourSets: [],
      segmentSpecificConfigs: {}
    }), g = [
      ...u,
      ...f
    ], v = Object.values(h).some((m) => Object.keys(m).length > 0);
    (g.length || v) && O6(i, Object.assign({}, o, {
      segmentsHidden: new Set(a)
    })), t.render();
  }
  function Fue(t, e, n, r) {
    const { segmentationRepresentationUID: i, segmentationId: a, segmentsHidden: s } = n, o = /* @__PURE__ */ new Map();
    e.forEach((c) => {
      const f = Ke.getGeometry(c);
      if (!f) {
        console.warn(`No geometry found for geometryId ${c}. Skipping render.`);
        return;
      }
      const u = f.data.getSegmentIndex();
      Vue(f);
      const h = aN(n, c, u);
      f.data.contours.forEach((v) => {
        const { points: m, color: y, id: w } = v, C = {
          annotationUID: gi(),
          data: {
            contour: {
              closed: true,
              polyline: m
            },
            segmentation: {
              segmentationId: a,
              segmentIndex: u,
              color: y,
              id: w
            },
            handles: {}
          },
          handles: {},
          highlighted: false,
          autoGenerated: false,
          invalidated: false,
          isLocked: true,
          isVisible: true,
          metadata: {
            referencedImageId: Oue(t, m[0], t.getCamera().viewPlaneNormal),
            toolName: "PlanarFreehandContourSegmentationTool",
            FrameOfReferenceUID: t.getFrameOfReferenceUID(),
            viewPlaneNormal: t.getCamera().viewPlaneNormal
          }
        }, T = t.element;
        uf(C, T), Uh(C);
      }), h && o.set(u, h);
    });
    const l = r.representations.CONTOUR.outlineWidthActive;
    O6(i, Object.assign({}, iN(i), {
      segmentsHidden: new Set(s),
      segmentSpecificMap: o,
      outlineWidthActive: l
    })), t.resetCamera(), t.render();
  }
  let gA = false;
  function Bue(t, e, n = false) {
    kue(t, e), Vy(t, e), Rue(e), n && ta(t).getViewportsInfo().forEach(({ viewportId: i, renderingEngineId: a }) => {
      Pa(i, a).viewport.render();
    });
  }
  async function _ue(t, e, n) {
    var _a3;
    const { segmentationId: r } = e, i = Kn(r);
    if (!i) return;
    let a = i.representationData[Nt.Contour];
    !a && Xy(e.segmentationRepresentationUID) && !gA && (gA = true, a = await fhe(r, {
      segmentationRepresentationUID: e.segmentationRepresentationUID,
      viewport: t
    })), a && ((_a3 = a == null ? void 0 : a.geometryIds) == null ? void 0 : _a3.length) && Lue(t, a.geometryIds, a.annotationUIDsMap, e, n);
  }
  function kue(t, e) {
    const n = ta(t);
    if (n === void 0) throw new Error(`ToolGroup with ToolGroupId ${t} does not exist`);
    const { viewportsInfo: r } = n;
    for (const i of r) {
      const { viewportId: a, renderingEngineId: s } = i;
      Pa(a, s), Mue(e, t);
    }
  }
  const sN = {
    render: _ue,
    removeSegmentationRepresentation: Bue
  };
  function Pue(t, e, n) {
    const r = ya(t);
    if (!r || r.length === 0) return;
    const i = r.map((s) => s.segmentationRepresentationUID);
    let a = e;
    if (a) {
      const s = e.filter((o) => !i.includes(o));
      if (s.length > 0) throw new Error(`The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(s)}`);
    } else a = i;
    a.forEach((s) => {
      Gue(t, s, n);
    });
  }
  function Gue(t, e, n) {
    const r = hd(t, e), { type: i } = r;
    if (i === Nt.Labelmap) nN.removeSegmentationRepresentation(t, e, n);
    else if (i === Nt.Contour) sN.removeSegmentationRepresentation(t, e, n);
    else throw new Error(`The representation ${i} is not supported yet`);
  }
  function zue(t) {
    if (!t || t.length === 0) throw new Error("The segmentationInputArray is undefined or an empty array");
    t.forEach((e) => {
      if (e.segmentationId === void 0) throw new Error("Undefined segmentationInput.segmentationId. Please provide a valid segmentationId");
      if (e.representation === void 0) throw new Error("Undefined segmentationInput.representation. Please provide a valid representation");
      e.representation.type === Nt.Labelmap && bue(e);
    });
  }
  function Wue(t) {
    zue(t), t.map((e) => {
      const n = Ar(e);
      oue(n);
    });
  }
  function oN() {
    return gue();
  }
  function Fy(t) {
    return lue(t);
  }
  function lN(t, e) {
    cue(t, e);
  }
  function Hue(t, e) {
    return fue(t, e);
  }
  function jue(t, e, n) {
    return hue(t, e, n);
  }
  function Kue(t) {
    const { type: e } = t;
    return e === Nt.Labelmap ? tN() : {};
  }
  const Yue = [
    [
      0,
      0,
      0,
      0
    ],
    [
      221,
      84,
      84,
      255
    ],
    [
      77,
      228,
      121,
      255
    ],
    [
      166,
      70,
      235,
      255
    ],
    [
      189,
      180,
      116,
      255
    ],
    [
      109,
      182,
      196,
      255
    ],
    [
      204,
      101,
      157,
      255
    ],
    [
      123,
      211,
      94,
      255
    ],
    [
      93,
      87,
      218,
      255
    ],
    [
      225,
      128,
      80,
      255
    ],
    [
      73,
      232,
      172,
      255
    ],
    [
      181,
      119,
      186,
      255
    ],
    [
      176,
      193,
      112,
      255
    ],
    [
      105,
      153,
      200,
      255
    ],
    [
      208,
      97,
      120,
      255
    ],
    [
      90,
      215,
      101,
      255
    ],
    [
      135,
      83,
      222,
      255
    ],
    [
      229,
      178,
      76,
      255
    ],
    [
      122,
      183,
      181,
      255
    ],
    [
      190,
      115,
      171,
      255
    ],
    [
      149,
      197,
      108,
      255
    ],
    [
      100,
      118,
      205,
      255
    ],
    [
      212,
      108,
      93,
      255
    ],
    [
      86,
      219,
      141,
      255
    ],
    [
      183,
      79,
      226,
      255
    ],
    [
      233,
      233,
      72,
      255
    ],
    [
      118,
      167,
      187,
      255
    ],
    [
      194,
      111,
      146,
      255
    ],
    [
      116,
      201,
      104,
      255
    ],
    [
      115,
      96,
      209,
      255
    ],
    [
      216,
      147,
      89,
      255
    ],
    [
      82,
      223,
      188,
      255
    ],
    [
      230,
      75,
      224,
      255
    ],
    [
      163,
      184,
      121,
      255
    ],
    [
      114,
      143,
      191,
      255
    ],
    [
      198,
      107,
      114,
      255
    ],
    [
      99,
      206,
      122,
      255
    ],
    [
      153,
      92,
      213,
      255
    ],
    [
      220,
      192,
      85,
      255
    ],
    [
      78,
      215,
      227,
      255
    ],
    [
      234,
      71,
      173,
      255
    ],
    [
      141,
      188,
      117,
      255
    ],
    [
      110,
      113,
      195,
      255
    ],
    [
      202,
      128,
      103,
      255
    ],
    [
      95,
      210,
      157,
      255
    ],
    [
      195,
      88,
      217,
      255
    ],
    [
      206,
      224,
      81,
      255
    ],
    [
      74,
      166,
      231,
      255
    ],
    [
      185,
      120,
      139,
      255
    ],
    [
      113,
      192,
      113,
      255
    ],
    [
      133,
      106,
      199,
      255
    ],
    [
      207,
      162,
      98,
      255
    ],
    [
      91,
      214,
      198,
      255
    ],
    [
      221,
      84,
      198,
      255
    ],
    [
      159,
      228,
      77,
      255
    ],
    [
      70,
      111,
      235,
      255
    ],
    [
      189,
      119,
      116,
      255
    ],
    [
      109,
      196,
      138,
      255
    ],
    [
      165,
      101,
      204,
      255
    ],
    [
      211,
      201,
      94,
      255
    ],
    [
      87,
      191,
      218,
      255
    ],
    [
      225,
      80,
      153,
      255
    ],
    [
      106,
      232,
      73,
      255
    ],
    [
      124,
      119,
      186,
      255
    ],
    [
      193,
      142,
      112,
      255
    ],
    [
      105,
      200,
      168,
      255
    ],
    [
      203,
      97,
      208,
      255
    ],
    [
      184,
      215,
      90,
      255
    ],
    [
      83,
      147,
      222,
      255
    ],
    [
      229,
      76,
      101,
      255
    ],
    [
      122,
      183,
      130,
      255
    ],
    [
      146,
      115,
      190,
      255
    ],
    [
      197,
      171,
      108,
      255
    ],
    [
      100,
      205,
      205,
      255
    ],
    [
      212,
      93,
      177,
      255
    ],
    [
      141,
      219,
      86,
      255
    ],
    [
      79,
      97,
      226,
      255
    ],
    [
      233,
      99,
      72,
      255
    ],
    [
      118,
      187,
      150,
      255
    ],
    [
      173,
      111,
      194,
      255
    ],
    [
      197,
      201,
      104,
      255
    ],
    [
      96,
      171,
      209,
      255
    ],
    [
      216,
      89,
      137,
      255
    ],
    [
      94,
      223,
      82,
      255
    ],
    [
      107,
      75,
      230,
      255
    ],
    [
      184,
      153,
      121,
      255
    ],
    [
      114,
      191,
      175,
      255
    ],
    [
      198,
      107,
      191,
      255
    ],
    [
      166,
      206,
      99,
      255
    ],
    [
      92,
      132,
      213,
      255
    ],
    [
      220,
      85,
      91,
      255
    ],
    [
      78,
      227,
      115,
      255
    ],
    [
      159,
      71,
      234,
      255
    ],
    [
      188,
      176,
      117,
      255
    ],
    [
      110,
      185,
      195,
      255
    ],
    [
      202,
      103,
      161,
      255
    ],
    [
      129,
      210,
      95,
      255
    ],
    [
      88,
      88,
      217,
      255
    ],
    [
      224,
      123,
      81,
      255
    ],
    [
      74,
      231,
      166,
      255
    ],
    [
      177,
      120,
      185,
      255
    ],
    [
      179,
      192,
      113,
      255
    ],
    [
      106,
      156,
      199,
      255
    ],
    [
      207,
      98,
      125,
      255
    ],
    [
      91,
      214,
      96,
      255
    ],
    [
      130,
      84,
      221,
      255
    ],
    [
      228,
      171,
      77,
      255
    ],
    [
      70,
      235,
      221,
      255
    ],
    [
      189,
      116,
      174,
      255
    ],
    [
      153,
      196,
      109,
      255
    ],
    [
      101,
      123,
      204,
      255
    ],
    [
      211,
      104,
      94,
      255
    ],
    [
      87,
      218,
      136,
      255
    ],
    [
      177,
      80,
      225,
      255
    ],
    [
      232,
      225,
      73,
      255
    ],
    [
      119,
      169,
      186,
      255
    ],
    [
      193,
      112,
      149,
      255
    ],
    [
      121,
      200,
      105,
      255
    ],
    [
      111,
      97,
      208,
      255
    ],
    [
      215,
      142,
      90,
      255
    ],
    [
      83,
      222,
      181,
      255
    ],
    [
      229,
      76,
      229,
      255
    ],
    [
      165,
      183,
      122,
      255
    ],
    [
      115,
      146,
      190,
      255
    ],
    [
      197,
      108,
      119,
      255
    ],
    [
      100,
      205,
      118,
      255
    ],
    [
      148,
      93,
      212,
      255
    ],
    [
      219,
      186,
      86,
      255
    ],
    [
      79,
      220,
      226,
      255
    ],
    [
      233,
      72,
      179,
      255
    ],
    [
      144,
      187,
      118,
      255
    ],
    [
      111,
      118,
      194,
      255
    ],
    [
      201,
      124,
      104,
      255
    ],
    [
      96,
      209,
      153,
      255
    ],
    [
      189,
      89,
      216,
      255
    ],
    [
      211,
      223,
      82,
      255
    ],
    [
      75,
      172,
      230,
      255
    ],
    [
      184,
      121,
      142,
      255
    ],
    [
      117,
      191,
      114,
      255
    ],
    [
      130,
      107,
      198,
      255
    ],
    [
      206,
      157,
      99,
      255
    ],
    [
      92,
      213,
      193,
      255
    ],
    [
      220,
      85,
      203,
      255
    ],
    [
      165,
      227,
      78,
      255
    ],
    [
      71,
      118,
      234,
      255
    ],
    [
      188,
      117,
      117,
      255
    ],
    [
      110,
      195,
      135,
      255
    ],
    [
      161,
      103,
      202,
      255
    ],
    [
      210,
      195,
      95,
      255
    ],
    [
      88,
      195,
      217,
      255
    ],
    [
      224,
      81,
      158,
      255
    ],
    [
      113,
      231,
      74,
      255
    ],
    [
      123,
      120,
      185,
      255
    ],
    [
      192,
      139,
      113,
      255
    ],
    [
      106,
      199,
      164,
      255
    ],
    [
      198,
      98,
      207,
      255
    ],
    [
      188,
      214,
      91,
      255
    ],
    [
      84,
      153,
      221,
      255
    ],
    [
      228,
      77,
      108,
      255
    ],
    [
      70,
      235,
      84,
      255
    ],
    [
      143,
      116,
      189,
      255
    ],
    [
      196,
      167,
      109,
      255
    ],
    [
      101,
      204,
      199,
      255
    ],
    [
      211,
      94,
      182,
      255
    ],
    [
      147,
      218,
      87,
      255
    ],
    [
      80,
      104,
      225,
      255
    ],
    [
      232,
      93,
      73,
      255
    ],
    [
      119,
      186,
      147,
      255
    ],
    [
      170,
      112,
      193,
      255
    ],
    [
      200,
      200,
      105,
      255
    ],
    [
      97,
      175,
      208,
      255
    ],
    [
      215,
      90,
      142,
      255
    ],
    [
      100,
      222,
      83,
      255
    ],
    [
      101,
      76,
      229,
      255
    ],
    [
      183,
      150,
      122,
      255
    ],
    [
      115,
      190,
      171,
      255
    ],
    [
      197,
      108,
      194,
      255
    ],
    [
      170,
      205,
      100,
      255
    ],
    [
      93,
      138,
      212,
      255
    ],
    [
      219,
      86,
      97,
      255
    ],
    [
      79,
      226,
      110,
      255
    ],
    [
      153,
      72,
      233,
      255
    ],
    [
      187,
      173,
      118,
      255
    ],
    [
      111,
      187,
      194,
      255
    ],
    [
      201,
      104,
      165,
      255
    ],
    [
      134,
      209,
      96,
      255
    ],
    [
      89,
      95,
      216,
      255
    ],
    [
      223,
      117,
      82,
      255
    ],
    [
      75,
      230,
      159,
      255
    ],
    [
      174,
      121,
      184,
      255
    ],
    [
      182,
      191,
      114,
      255
    ],
    [
      107,
      160,
      198,
      255
    ],
    [
      206,
      99,
      130,
      255
    ],
    [
      92,
      213,
      92,
      255
    ],
    [
      124,
      85,
      220,
      255
    ],
    [
      227,
      165,
      78,
      255
    ],
    [
      71,
      234,
      214,
      255
    ],
    [
      188,
      117,
      176,
      255
    ],
    [
      156,
      195,
      110,
      255
    ],
    [
      103,
      128,
      202,
      255
    ],
    [
      210,
      100,
      95,
      255
    ],
    [
      88,
      217,
      131,
      255
    ],
    [
      170,
      81,
      224,
      255
    ],
    [
      231,
      218,
      74,
      255
    ],
    [
      120,
      172,
      185,
      255
    ],
    [
      192,
      113,
      153,
      255
    ],
    [
      125,
      199,
      106,
      255
    ],
    [
      107,
      98,
      207,
      255
    ],
    [
      214,
      137,
      91,
      255
    ],
    [
      84,
      221,
      175,
      255
    ],
    [
      222,
      77,
      228,
      255
    ],
    [
      194,
      235,
      70,
      255
    ],
    [
      116,
      149,
      189,
      255
    ],
    [
      196,
      109,
      123,
      255
    ],
    [
      101,
      204,
      114,
      255
    ],
    [
      143,
      94,
      211,
      255
    ],
    [
      218,
      180,
      87,
      255
    ],
    [
      80,
      225,
      225,
      255
    ],
    [
      232,
      73,
      186,
      255
    ],
    [
      147,
      186,
      119,
      255
    ],
    [
      112,
      122,
      193,
      255
    ],
    [
      200,
      121,
      105,
      255
    ],
    [
      97,
      208,
      148,
      255
    ],
    [
      184,
      90,
      215,
      255
    ],
    [
      216,
      222,
      83,
      255
    ],
    [
      76,
      178,
      229,
      255
    ],
    [
      183,
      122,
      145,
      255
    ],
    [
      121,
      190,
      115,
      255
    ],
    [
      126,
      108,
      197,
      255
    ],
    [
      205,
      153,
      100,
      255
    ],
    [
      93,
      212,
      187,
      255
    ],
    [
      219,
      86,
      208,
      255
    ],
    [
      171,
      226,
      79,
      255
    ],
    [
      72,
      126,
      233,
      255
    ],
    [
      187,
      118,
      121,
      255
    ],
    [
      111,
      194,
      132,
      255
    ],
    [
      157,
      104,
      201,
      255
    ],
    [
      209,
      190,
      96,
      255
    ],
    [
      89,
      200,
      216,
      255
    ],
    [
      223,
      82,
      164,
      255
    ],
    [
      120,
      230,
      75,
      255
    ],
    [
      121,
      121,
      184,
      255
    ],
    [
      191,
      136,
      114,
      255
    ],
    [
      107,
      198,
      160,
      255
    ],
    [
      192,
      99,
      206,
      255
    ],
    [
      193,
      213,
      92,
      255
    ],
    [
      85,
      158,
      220,
      255
    ],
    [
      227,
      78,
      115,
      255
    ],
    [
      71,
      234,
      78,
      255
    ],
    [
      141,
      117,
      188,
      255
    ],
    [
      195,
      163,
      110,
      255
    ],
    [
      103,
      202,
      194,
      255
    ],
    [
      210,
      95,
      186,
      255
    ],
    [
      153,
      217,
      88,
      255
    ],
    [
      81,
      111,
      224,
      255
    ]
  ];
  function cN(t) {
    const e = typeof t;
    return t !== null && (e === "object" || e === "function");
  }
  function uN(t, e, n) {
    let r, i, a, s, o, l, c = 0, f = false, u = false, h = true;
    const g = !e && e !== 0 && typeof window.requestAnimationFrame == "function";
    if (typeof t != "function") throw new TypeError("Expected a function");
    e = Number(e) || 0, cN(n) && (f = !!n.leading, u = "maxWait" in n, a = u ? Math.max(Number(n.maxWait) || 0, e) : a, h = "trailing" in n ? !!n.trailing : h);
    function v(O) {
      const L = r, N = i;
      return r = i = void 0, c = O, s = t.apply(N, L), s;
    }
    function m(O, L) {
      return g ? window.requestAnimationFrame(O) : setTimeout(O, L);
    }
    function y(O) {
      if (g) return window.cancelAnimationFrame(O);
      clearTimeout(O);
    }
    function w(O) {
      return c = O, o = m(S, e), f ? v(O) : s;
    }
    function C(O) {
      const L = O - l, N = O - c, F = e - L;
      return u ? Math.min(F, a - N) : F;
    }
    function T(O) {
      const L = O - l, N = O - c;
      return l === void 0 || L >= e || L < 0 || u && N >= a;
    }
    function S() {
      const O = Date.now();
      if (T(O)) return E(O);
      o = m(S, C(O));
    }
    function E(O) {
      return o = void 0, h && r ? v(O) : (r = i = void 0, s);
    }
    function b() {
      o !== void 0 && y(o), c = 0, r = l = i = o = void 0;
    }
    function D() {
      return o === void 0 ? s : E(Date.now());
    }
    function R() {
      return o !== void 0;
    }
    function I(...O) {
      const L = Date.now(), N = T(L);
      if (r = O, i = this, l = L, N) {
        if (o === void 0) return w(l);
        if (u) return o = m(S, e), v(l);
      }
      return o === void 0 && (o = m(S, e)), s;
    }
    return I.cancel = b, I.flush = D, I.pending = R, I;
  }
  function que(t, e, n) {
    let r = true, i = true;
    if (typeof t != "function") throw new TypeError("Expected a function");
    return cN(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), uN(t, e, {
      leading: r,
      trailing: i,
      maxWait: e
    });
  }
  const { CalibrationTypes: A1 } = OW, Sc = "px", Xue = [
    1
  ], Zue = [
    "3,3"
  ], Que = {
    0: "px",
    1: "percent",
    2: "dB",
    3: "cm",
    4: "seconds",
    5: "hertz",
    6: "dB/seconds",
    7: "cm/sec",
    8: "cm\xB2",
    9: "cm\xB2/s",
    12: "degrees"
  }, Jue = 1e-3, E1 = "\xB2", $ue = (t, e) => {
    const { calibration: n, hasPixelSpacing: r } = t;
    let i = r ? "mm" : Sc, a = i + E1, s = 1, o = "";
    if (!n || !n.type && !n.sequenceOfUltrasoundRegions) return {
      units: i,
      areaUnits: a,
      scale: s
    };
    if (n.type === A1.UNCALIBRATED) return {
      units: Sc,
      areaUnits: Sc + E1,
      scale: s
    };
    if (n.sequenceOfUltrasoundRegions) {
      let c, f;
      if (Array.isArray(e) && e.length === 2) [c, f] = e;
      else if (typeof e == "function") {
        const y = e();
        c = y[0], f = y[1];
      }
      let u = n.sequenceOfUltrasoundRegions.filter((y) => c[0] >= y.regionLocationMinX0 && c[0] <= y.regionLocationMaxX1 && c[1] >= y.regionLocationMinY0 && c[1] <= y.regionLocationMaxY1 && f[0] >= y.regionLocationMinX0 && f[0] <= y.regionLocationMaxX1 && f[1] >= y.regionLocationMinY0 && f[1] <= y.regionLocationMaxY1);
      if (!(u == null ? void 0 : u.length)) return {
        units: i,
        areaUnits: a,
        scale: s
      };
      if (u = u.filter((y) => Xue.includes(y.regionDataType) && Zue.includes(`${y.physicalUnitsXDirection},${y.physicalUnitsYDirection}`)), !u.length) return {
        units: Sc,
        areaUnits: Sc + E1,
        scale: s
      };
      const h = u[0], g = Math.abs(h.physicalDeltaX), v = Math.abs(h.physicalDeltaY);
      if (zr(g, v, Jue)) s = 1 / g, o = "US Region", i = Que[h.physicalUnitsXDirection] || "unknown", a = i + E1;
      else return {
        units: Sc,
        areaUnits: Sc + E1,
        scale: s
      };
    } else n.scale && (s = n.scale);
    return [
      A1.ERMF,
      A1.USER,
      A1.ERROR,
      A1.PROJECTION
    ].includes(n == null ? void 0 : n.type) && (o = n.type), {
      units: i + (o ? ` ${o}` : ""),
      areaUnits: a + (o ? ` ${o}` : ""),
      scale: s
    };
  };
  function bi(t, e) {
    !e.length || !t || e.forEach((n) => {
      const r = t.getViewport(n);
      if (!r) {
        console.warn(`Viewport not available for ${n}`);
        return;
      }
      const { element: i } = r;
      cd(i);
    });
  }
  function efe(t) {
    t.forEach((e) => {
      const n = ta(e);
      if (!n) {
        console.warn(`ToolGroup not available for ${e}`);
        return;
      }
      n.getViewportsInfo().forEach((i) => {
        const { renderingEngineId: a, viewportId: s } = i, o = _a(a);
        if (!o) {
          console.warn(`RenderingEngine not available for ${a}`);
          return;
        }
        const l = o.getViewport(s);
        cd(l.element);
      });
    });
  }
  function tfe(t, e) {
    if (!pt(t.element)) throw new Error("Scroll::Viewport is not enabled (it might be disabled)");
    if (t instanceof bo && t.getImageIds().length === 0) throw new Error("Scroll::Stack Viewport has no images");
    const { volumeId: r, delta: i, scrollSlabs: a } = e;
    if (t instanceof Ba) nfe(t, r, i, a);
    else {
      const s = t.getCurrentImageIdIndex();
      if (s + i > t.getImageIds().length - 1 || s + i < 0) {
        const o = {
          imageIdIndex: s,
          direction: i
        };
        qe(je, ze.STACK_SCROLL_OUT_OF_BOUNDS, o);
      }
      t.scroll(i, e.debounceLoading, e.loop);
    }
  }
  function nfe(t, e, n, r = false) {
    const i = r, { numScrollSteps: a, currentStepIndex: s, sliceRangeInfo: o } = mh(t, e, i);
    if (!o) return;
    const { sliceRange: l, spacingInNormalDirection: c, camera: f } = o, { focalPoint: u, viewPlaneNormal: h, position: g } = f, { newFocalPoint: v, newPosition: m } = Cu(u, g, l, h, c, n);
    t.setCamera({
      focalPoint: v,
      position: m
    }), t.render();
    const y = s + n, w = {
      volumeId: e,
      viewport: t,
      delta: n,
      desiredStepIndex: y,
      currentStepIndex: s,
      numScrollSteps: a,
      currentImageId: t.getCurrentImageId()
    };
    (y > a || y < 0) && t.getCurrentImageId() ? qe(je, ze.VOLUME_SCROLL_OUT_OF_BOUNDS, w) : qe(je, ze.VOLUME_VIEWPORT_SCROLL, w);
  }
  function rfe(t, e, n, r) {
    let i, a, s, o, l, c, f;
    const { numComps: u } = t;
    if (t.getScalarData ? f = t.getScalarData() : f = t.getPointData().getScalars().getData(), !f) {
      console.warn("No scalar data found for imageData", t);
      return;
    }
    const h = t.getDimensions();
    r ? [[i, a], [s, o], [l, c]] = r : (i = 0, a = h[0], s = 0, o = h[1], l = 0, c = h[2]);
    const g = Ue(i, s, l), v = t.getDirection(), m = v.slice(0, 3), y = v.slice(3, 6), w = v.slice(6, 9), C = t.getSpacing(), [T, S, E] = C, b = t.indexToWorld(g), D = Ue(m[0] * T, m[1] * T, m[2] * T), R = Ue(y[0] * S, y[1] * S, y[2] * S), I = Ue(w[0] * E, w[1] * E, w[2] * E), O = u || f.length / h[2] / h[1] / h[0], L = h[0] * O, N = h[1] * L, F = [], V = ki(b);
    for (let k = l; k <= c; k++) {
      const _ = ki(V);
      for (let K = s; K <= o; K++) {
        const Z = ki(V);
        for (let j = i; j <= a; j++) {
          const B = [
            j,
            K,
            k
          ];
          if (e(V, B)) {
            const Y = k * N + K * L + j * O;
            let X;
            O > 2 ? X = [
              f[Y],
              f[Y + 1],
              f[Y + 2]
            ] : X = f[Y], F.push({
              value: X,
              index: Y,
              pointIJK: B,
              pointLPS: V.slice()
            }), n && n({
              value: X,
              index: Y,
              pointIJK: B,
              pointLPS: V
            });
          }
          Ai(V, V, D);
        }
        Du(V, Z), Ai(V, V, R);
      }
      Du(V, _), Ai(V, V, I);
    }
    return F;
  }
  function ife(t, e = 5) {
    return parseFloat(t[0]).toFixed(e) + "," + parseFloat(t[1]).toFixed(e) + "," + parseFloat(t[2]).toFixed(e) + ",";
  }
  const { isEqual: pA } = a0;
  function fN(t) {
    const { metadata: e } = t;
    return jie().filter((n) => {
      if (n.FrameOfReferenceUID === e.FrameOfReferenceUID) {
        const r = n.viewport, { viewPlaneNormal: i, viewUp: a } = r.getCamera();
        return pA(i, e.viewPlaneNormal) && (!e.viewUp || pA(a, e.viewUp));
      }
    }).map((n) => n.viewport);
  }
  function hv(t) {
    const e = fN(t);
    return e.length ? e[0] : void 0;
  }
  function afe(t) {
    return (t.childAnnotationUIDs ?? []).map((n) => Ua(n).data.contour.polyline);
  }
  function P5(t, e) {
    const n = afe(t), r = [];
    return n.forEach((i) => {
      const a = i.length, s = new Array(a);
      for (let o = 0; o < a; o++) s[o] = e.worldToCanvas(i[o]);
      r.push(s);
    }), r;
  }
  function sfe(t, e) {
    return t.minX <= e.maxX && t.maxX >= e.minX && t.minY <= e.maxY && t.maxY >= e.minY;
  }
  class ofe {
  }
  const { PointsManager: mA } = a0;
  const _By = class _By extends ofe {
    static statsInit(e) {
      e.noPointsCollection && (_By.pointsInShape = null);
    }
  };
  _By.max = [
    -1 / 0
  ];
  _By.min = [
    1 / 0
  ];
  _By.sum = [
    0
  ];
  _By.count = 0;
  _By.runMean = [
    0
  ];
  _By.m2 = [
    0
  ];
  _By.pointsInShape = mA.create3(1024);
  _By.statsCallback = ({ value: e, pointLPS: n = null }) => {
    var _a3;
    Array.isArray(e) && e.length > 1 && _By.max.length === 1 && (_By.max.push(_By.max[0], _By.max[0]), _By.min.push(_By.min[0], _By.min[0]), _By.sum.push(_By.sum[0], _By.sum[0]), _By.runMean.push(0, 0), _By.m2.push(_By.m2[0], _By.m2[0])), (_a3 = _By.pointsInShape) == null ? void 0 : _a3.push(n);
    const r = Array.isArray(e) ? e : [
      e
    ];
    _By.count += 1, _By.max.map((i, a) => {
      const s = r[a], o = s - _By.runMean[a];
      _By.sum[a] += s, _By.runMean[a] += o / _By.count;
      const l = s - _By.runMean[a];
      _By.m2[a] += o * l, _By.min[a] = Math.min(_By.min[a], s), _By.max[a] = Math.max(i, s);
    });
  };
  _By.getStatistics = (e) => {
    const n = _By.sum.map((s) => s / _By.count), r = _By.m2.map((s) => Math.sqrt(s / _By.count)), i = (e == null ? void 0 : e.unit) || null, a = {
      max: {
        name: "max",
        label: "Max Pixel",
        value: ag(_By.max),
        unit: i
      },
      min: {
        name: "min",
        label: "Min Pixel",
        value: ag(_By.min),
        unit: i
      },
      mean: {
        name: "mean",
        label: "Mean Pixel",
        value: ag(n),
        unit: i
      },
      stdDev: {
        name: "stdDev",
        label: "Standard Deviation",
        value: ag(r),
        unit: i
      },
      count: {
        name: "count",
        label: "Pixel Count",
        value: _By.count,
        unit: null
      },
      pointsInShape: _By.pointsInShape,
      array: []
    };
    return a.array.push(a.max, a.mean, a.stdDev, a.stdDev, a.count), _By.max = [
      -1 / 0
    ], _By.min = [
      1 / 0
    ], _By.sum = [
      0
    ], _By.m2 = [
      0
    ], _By.runMean = [
      0
    ], _By.count = 0, _By.pointsInShape = mA.create3(1024), a;
  };
  let By = _By;
  function ag(t) {
    return t.length === 1 ? t[0] : t;
  }
  function lfe(t, e, n) {
    let r;
    const i = Qc(t, e);
    if (t[0] === e[0] && t[1] === e[1] && (r = t), !r) {
      const a = ((n[0] - t[0]) * (e[0] - t[0]) + (n[1] - t[1]) * (e[1] - t[1])) / i;
      a < 0 ? r = t : a > 1 ? r = e : r = [
        t[0] + a * (e[0] - t[0]),
        t[1] + a * (e[1] - t[1])
      ];
    }
    return {
      point: [
        ...r
      ],
      distanceSquared: Qc(n, r)
    };
  }
  function cfe(t, e, n) {
    return lfe(t, e, n).distanceSquared;
  }
  const b1 = 0.01;
  function dv(t, e, n) {
    const r = t[0] <= e[0] ? t[0] : e[0], i = t[0] >= e[0] ? t[0] : e[0], a = t[1] <= e[1] ? t[1] : e[1], s = t[1] >= e[1] ? t[1] : e[1];
    if (!(n[0] >= r - b1 && n[0] <= i + b1 && n[1] >= a - b1 && n[1] <= s + b1)) return false;
    const l = (e[1] - t[1]) * (n[0] - e[0]) - (e[0] - t[0]) * (n[1] - e[1]);
    return (l >= 0 ? l : -l) <= b1;
  }
  function Qc(t, e) {
    if (t.length !== e.length) throw Error("Both points should have the same dimensionality");
    const [n, r, i = 0] = t, [a, s, o = 0] = e, l = a - n, c = s - r, f = o - i;
    return l * l + c * c + f * f;
  }
  function hN(t, e) {
    return Math.sqrt(Qc(t, e));
  }
  function dN(t) {
    if (t.length < 3) return false;
    const e = t.length, n = t[0], r = t[e - 1], i = Qc(n, r);
    return xh(0, i);
  }
  function Jc(t, e, n = {
    closed: void 0
  }) {
    if (t.length < 3) return false;
    const r = t.length;
    let i = 0;
    const { closed: a, holes: s } = n;
    if (s == null ? void 0 : s.length) {
      for (const c of s) if (Jc(c, e)) return false;
    }
    const o = !(a === void 0 ? dN(t) : a), l = t.length - (o ? 1 : 2);
    for (let c = 0; c <= l; c++) {
      const f = t[c], u = c === r - 1 ? 0 : c + 1, h = t[u], g = f[0] >= h[0] ? f[0] : h[0], v = f[1] >= h[1] ? f[1] : h[1], m = f[1] <= h[1] ? f[1] : h[1];
      if (e[0] <= g && e[1] >= m && e[1] < v) {
        let C = f[0] === h[0];
        if (!C) {
          const T = (e[1] - f[1]) * (h[0] - f[0]) / (h[1] - f[1]) + f[0];
          C = e[0] <= T;
        }
        i += C ? 1 : 0;
      }
    }
    return !!(i % 2);
  }
  function _y(t, e) {
    for (let n = 0, r = e.length; n < r; n++) if (!Jc(t, e[n])) return false;
    return true;
  }
  function qp(t, e) {
    let n = t;
    const r = (e == null ? void 0 : e.numDimensions) || 2, i = r === 3;
    if (!Array.isArray(t[0])) {
      const u = t, h = u.length / r;
      n = new Array(u.length / r);
      for (let g = 0, v = h; g < v; g++) n[g] = [
        u[g * r],
        u[g * r + 1]
      ], i && n[g].push(u[g * r + 2]);
    }
    let a = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0, c = 1 / 0, f = -1 / 0;
    n = n;
    for (let u = 0, h = n.length; u < h; u++) {
      const [g, v, m] = n[u];
      a = a < g ? a : g, s = s < v ? s : v, o = o > g ? o : g, l = l > v ? l : v, i && (c = c < m ? c : m, f = f > m ? f : m);
    }
    return i ? {
      minX: a,
      maxX: o,
      minY: s,
      maxY: l,
      minZ: c,
      maxZ: f
    } : {
      minX: a,
      maxX: o,
      minY: s,
      maxY: l
    };
  }
  function ky(t) {
    const e = t.length;
    let n = 0, r = e - 1;
    for (let i = 0; i < e; i++) n += (t[r][0] + t[i][0]) * (t[r][1] - t[i][1]), r = i;
    return Math.abs(n / 2);
  }
  function Py(t) {
    if (t.length < 3) return 0;
    const e = t[0];
    let n = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const a = t[r], s = r === i - 1 ? 0 : r + 1, o = t[s], l = a[0] - e[0], c = a[1] - e[1], f = o[0] - e[0], u = o[1] - e[1];
      n += l * u - c * f;
    }
    return n *= 0.5, n;
  }
  function I6(t) {
    return Py(t) >= 0 ? 1 : -1;
  }
  function ufe(t) {
    const e = He(), n = t[0];
    for (let r = 0, i = t.length; r < i; r++) {
      const a = t[r], s = r === i - 1 ? 0 : r + 1, o = t[s], l = a[0] - n[0], c = a[1] - n[1], f = a[2] - n[2], u = o[0] - n[0], h = o[1] - n[1], g = o[2] - n[2];
      e[0] += c * g - f * h, e[1] += f * u - l * g, e[2] += l * h - c * u;
    }
    return a5(e, e, 0.5), e;
  }
  function ffe(t) {
    const e = ufe(t);
    return Pr(e, e);
  }
  function Fh(t) {
    const e = Py(t);
    return [
      0,
      0,
      e / Math.abs(e)
    ];
  }
  function Gy(t, e, n, r) {
    let i = false;
    const a = t[0] < e[0] ? t[0] : e[0], s = t[1] < e[1] ? t[1] : e[1], o = t[0] > e[0] ? t[0] : e[0], l = t[1] > e[1] ? t[1] : e[1], c = n[0] < r[0] ? n[0] : r[0], f = n[1] < r[1] ? n[1] : r[1], u = n[0] > r[0] ? n[0] : r[0], h = n[1] > r[1] ? n[1] : r[1];
    if (a > u || o < c || s > h || l < f) return false;
    const g = [
      sg(t, e, n),
      sg(t, e, r),
      sg(n, r, t),
      sg(n, r, e)
    ];
    return g[0] !== g[1] && g[2] !== g[3] ? true : ((g[0] === 0 && og(t, n, e) || g[1] === 0 && og(t, r, e) || g[2] === 0 && og(n, t, r) || g[3] === 0 && og(n, e, r)) && (i = true), i);
  }
  function sg(t, e, n) {
    const r = (e[1] - t[1]) * (n[0] - e[0]) - (e[0] - t[0]) * (n[1] - e[1]);
    return r === 0 ? 0 : r > 0 ? 1 : 2;
  }
  function og(t, e, n) {
    return e[0] <= Math.max(t[0], n[0]) && e[0] >= Math.min(t[0], n[0]) && e[1] <= Math.max(t[1], n[1]) && e[1] >= Math.min(t[1], n[1]);
  }
  function zy(t, e, n, r = true) {
    const i = [], a = t.length, s = a - (r ? 1 : 2);
    for (let o = 0; o <= s; o++) {
      const l = t[o], c = o === a - 1 ? 0 : o + 1, f = t[c];
      Gy(e, n, l, f) && i.push([
        o,
        c
      ]);
    }
    return i;
  }
  const hfe = 0.01;
  function gN(t, e, n, r) {
    const i = [
      e[0] - t[0],
      e[1] - t[1]
    ], a = [
      r[0] - n[0],
      r[1] - n[1]
    ], s = a[1] * i[0] - a[0] * i[1];
    if ((s >= 0 ? s : -s) < hfe) {
      const v = [
        t[0] < e[0] ? t[0] : e[0],
        t[0] > e[0] ? t[0] : e[0],
        t[1] < e[1] ? t[1] : e[1],
        t[1] > e[1] ? t[1] : e[1]
      ], m = [
        n[0] < r[0] ? n[0] : r[0],
        n[0] > r[0] ? n[0] : r[0],
        n[1] < r[1] ? n[1] : r[1],
        n[1] > r[1] ? n[1] : r[1]
      ];
      if (!(v[0] <= m[1] && v[1] >= m[0] && v[2] <= m[3] && v[3] >= m[2]) || !(dv(t, e, n) || dv(t, e, r) || dv(n, r, t))) return;
      const C = v[0] > m[0] ? v[0] : m[0], T = v[1] < m[1] ? v[1] : m[1], S = v[2] > m[2] ? v[2] : m[2], E = v[3] < m[3] ? v[3] : m[3], b = (C + T) * 0.5, D = (S + E) * 0.5;
      return [
        b,
        D
      ];
    }
    let l = t[1] - n[1], c = t[0] - n[0];
    const f = a[0] * l - a[1] * c, u = i[0] * l - i[1] * c;
    l = f / s, c = u / s;
    const h = t[0] + l * i[0], g = t[1] + l * i[1];
    return [
      h,
      g
    ];
  }
  var kc;
  (function(t) {
    t[t.Vertex = 0] = "Vertex", t[t.Intersection = 1] = "Intersection";
  })(kc || (kc = {}));
  var Eu;
  (function(t) {
    t[t.Outside = -1] = "Outside", t[t.Edge = 0] = "Edge", t[t.Inside = 1] = "Inside";
  })(Eu || (Eu = {}));
  var gu;
  (function(t) {
    t[t.Exiting = -1] = "Exiting", t[t.Unknown = 0] = "Unknown", t[t.Entering = 1] = "Entering";
  })(gu || (gu = {}));
  function vA(t) {
    for (let e = 0, n = t.length; e < n; e++) {
      const r = t[e];
      r.next || (r.next = t[e === n - 1 ? 0 : e + 1]);
    }
  }
  function pN(t, e) {
    const n = [], r = [], i = /* @__PURE__ */ new Map();
    let s = Jc(e, t[0]) ? gu.Exiting : gu.Entering;
    for (let o = 0, l = t.length; o < l; o++) {
      const c = t[o], f = Jc(e, c), u = {
        type: kc.Vertex,
        coordinates: c,
        position: f ? Eu.Inside : Eu.Outside,
        visited: false,
        next: null
      };
      n.push(u);
      const h = t[o === l - 1 ? 0 : o + 1], g = zy(e, c, h).map((v) => {
        const m = v[0], y = e[v[0]], w = e[v[1]], C = gN(c, h, y, w), T = Qc(c, C);
        return {
          sourceLineSegmentId: m,
          coordinate: C,
          targetStartPointDistSquared: T
        };
      });
      g.sort((v, m) => v.targetStartPointDistSquared - m.targetStartPointDistSquared), g.forEach((v) => {
        const { sourceLineSegmentId: m, coordinate: y } = v, w = {
          type: kc.Intersection,
          coordinates: y,
          position: Eu.Edge,
          direction: s,
          visited: false,
          next: null
        }, C = {
          ...w,
          direction: gu.Unknown,
          cloned: true
        };
        s === gu.Entering ? w.next = C : C.next = w;
        let T = i.get(m);
        T || (T = [], i.set(m, T)), n.push(w), T.push(C), s *= -1;
      });
    }
    for (let o = 0, l = e.length; o < l; o++) {
      const c = o, f = e[o], u = {
        type: kc.Vertex,
        coordinates: f,
        visited: false,
        next: null
      };
      r.push(u);
      const h = i.get(c);
      (h == null ? void 0 : h.length) && h.map((g) => ({
        intersectionPoint: g,
        lineSegStartDistSquared: Qc(f, g.coordinates)
      })).sort((g, v) => g.lineSegStartDistSquared - v.lineSegStartDistSquared).map(({ intersectionPoint: g }) => g).forEach((g) => r.push(g));
    }
    return vA(n), vA(r), {
      targetPolylinePoints: n,
      sourcePolylinePoints: r
    };
  }
  function mN(t) {
    for (let e = 0, n = t.length; e < n; e++) {
      const r = t[e];
      if (!r.visited && r.position === Eu.Outside) return r;
    }
  }
  function vN(t, e) {
    const n = Fh(t), r = Fh(e), i = Bt(r, n);
    xh(1, i) || (e = e.slice().reverse());
    const { targetPolylinePoints: a } = pN(t, e), s = mN(a);
    if (!s) return t.slice();
    const o = [
      s.coordinates
    ];
    let l = s.next;
    for (; l !== s; ) {
      if (l.type === kc.Intersection && l.cloned) {
        l = l.next;
        continue;
      }
      o.push(l.coordinates), l = l.next;
    }
    return o;
  }
  function yN(t, e) {
    const n = Fh(t), r = Fh(e), i = Bt(r, n);
    xh(-1, i) || (e = e.slice().reverse());
    const { targetPolylinePoints: a } = pN(t, e);
    let s = null;
    const o = [];
    for (; s = mN(a); ) {
      const l = [
        s.coordinates
      ];
      let c = s.next;
      for (s.visited = true; c !== s; ) {
        if (c.visited = true, c.type === kc.Intersection && c.cloned) {
          c = c.next;
          continue;
        }
        l.push(c.coordinates), c = c.next;
      }
      o.push(l);
    }
    return o;
  }
  function xN(t, e, n, r = true) {
    let i, a;
    r ? (a = t.length - 1, i = 0) : (a = 0, i = 1);
    for (let s = i; s < t.length; s++) {
      const o = t[a], l = t[s];
      if (Gy(e, n, o, l)) return [
        a,
        s
      ];
      a = s;
    }
  }
  function wN(t, e) {
    var _a3;
    for (let n = 0, r = t.length; n < r; n++) {
      const i = t[n], a = n === r - 1 ? 0 : n + 1, s = t[a];
      if (((_a3 = xN(e, i, s)) == null ? void 0 : _a3.length) === 2) return true;
    }
    return false;
  }
  const dfe = 0.1;
  function CN(t, e = dfe) {
    const n = t.length;
    if (n < 3) return t;
    const r = e * e, i = [
      [
        0,
        n - 1
      ]
    ], a = new Array(n).fill(false);
    let s = 2;
    for (a[0] = true, a[n - 1] = true; i.length; ) {
      const [l, c] = i.pop();
      if (c - l === 1) continue;
      const f = t[l], u = t[c];
      let h = -1 / 0, g = -1;
      for (let v = l + 1; v < c; v++) {
        const m = t[v], y = cfe(f, u, m);
        y > h && (h = y, g = v);
      }
      h < r || (a[g] = true, s++, i.push([
        g,
        c
      ]), i.push([
        l,
        g
      ]));
    }
    const o = new Array(s);
    for (let l = 0, c = 0; l < n; l++) a[l] && (o[c++] = t[l]);
    return o;
  }
  function TN(t, e, n, r = true) {
    const i = [], a = zy(t, e, n, r);
    for (let s = 0; s < a.length; s++) {
      const o = t[a[s][0]], l = t[a[s][1]], c = gN(e, n, o, l);
      i.push(c);
    }
    return i;
  }
  function gfe(t, e, n, r = true) {
    let i, a;
    r ? (a = t.length - 1, i = 0) : (a = 0, i = 1);
    const s = [];
    for (let f = i; f < t.length; f++) {
      const u = t[a], h = t[f];
      Gy(e, n, u, h) && s.push([
        a,
        f
      ]), a = f;
    }
    if (s.length === 0) return;
    const o = [];
    s.forEach((f) => {
      const u = [
        t[f[0]],
        t[f[1]]
      ], h = [
        (u[0][0] + u[1][0]) / 2,
        (u[0][1] + u[1][1]) / 2
      ];
      o.push(Jr(h, e));
    });
    const l = Math.min(...o), c = o.indexOf(l);
    return {
      segment: s[c],
      distance: l
    };
  }
  const eu = 1e-3, pfe = (t, e) => {
    let n, r, i;
    if (t instanceof bo) {
      const s = t.getImageData();
      r = s.direction.slice(0, 3), i = s.direction.slice(3, 6), n = s.spacing;
    } else {
      const s = t.getImageData(), { direction: o, spacing: l } = s, { viewPlaneNormal: c, viewUp: f } = t.getCamera(), u = o.slice(0, 3), h = o.slice(3, 6), g = o.slice(6, 9), v = He();
      Vr(v, f, c);
      const m = Math.abs(Bt(v, u)), y = Math.abs(Bt(v, h)), w = Math.abs(Bt(v, g));
      let C;
      if (Math.abs(1 - m) < eu) C = l[0], r = u;
      else if (Math.abs(1 - y) < eu) C = l[1], r = h;
      else if (Math.abs(1 - w) < eu) C = l[2], r = g;
      else throw new Error("No support yet for oblique plane planar contours");
      const T = Math.abs(Bt(f, u)), S = Math.abs(Bt(f, h)), E = Math.abs(Bt(f, g));
      let b;
      if (Math.abs(1 - T) < eu) b = l[0], i = u;
      else if (Math.abs(1 - S) < eu) b = l[1], i = h;
      else if (Math.abs(1 - E) < eu) b = l[2], i = g;
      else throw new Error("No support yet for oblique plane planar contours");
      n = [
        C,
        b
      ];
    }
    return {
      spacing: [
        n[0] / e,
        n[1] / e
      ],
      xDir: r,
      yDir: i
    };
  }, mfe = (t, e, n) => K6(t, e) < n, vfe = (t, e, n, r) => {
    const { xDir: i, yDir: a, spacing: s } = r, o = pt(t), { viewport: l } = o;
    if (!e.length) return e.push(n), console.log(">>>>> !canvasPoints. :: RETURN"), 1;
    const c = l.canvasToWorld(e[e.length - 1]), f = l.canvasToWorld(n), u = He();
    Ft(u, f, c);
    const h = Math.abs(Bt(u, i)), g = Math.abs(Bt(u, a)), v = Math.max(Math.floor(h / s[0]), Math.floor(g / s[0]));
    if (v > 1) {
      const m = e[e.length - 1], y = K6(m, n), w = mo();
      Ru(w, n, m), mu(w, w[0] / y, w[1] / y);
      const C = y / v;
      for (let T = 1; T <= v; T++) e.push([
        m[0] + C * w[0] * T,
        m[1] + C * w[1] * T
      ]);
    } else e.push(n);
    return v;
  }, yfe = (t, e, n, r) => {
    const i = [
      t[0] - e[0],
      t[1] - e[1]
    ], a = [
      n[0] - e[0],
      n[1] - e[1]
    ], s = i[0] * a[0] + i[1] * a[1];
    if (s < 0) return false;
    const o = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
    if (o === 0) return false;
    const l = s / o, c = [
      a[0] / o,
      a[1] / o
    ], f = [
      c[0] * l,
      c[1] * l
    ], u = [
      e[0] + f[0],
      e[1] + f[1]
    ];
    return !(Jr(t, u) > r || Jr(e, u) > Jr(e, n));
  }, xfe = 1e-6;
  function SN(t) {
    let e;
    const n = DI(t, 50);
    for (let s = 0; s < 3; s++) if (n.every((o, l, c) => Math.abs(o[s] - c[0][s]) < xfe)) {
      e = s;
      break;
    }
    if (e === void 0) throw new Error("Cannot find a shared dimension index for polyline, probably oblique plane");
    const r = [], i = (e + 1) % 3, a = (e + 2) % 3;
    for (let s = 0; s < t.length; s++) r.push([
      t[s][i],
      t[s][a]
    ]);
    return {
      sharedDimensionIndex: e,
      projectedPolyline: r
    };
  }
  function wfe(t, e, n = {}) {
    const { sharedDimensionIndex: r, projectedPolyline: i } = SN(e), { holes: a } = n, s = [];
    if (a) for (let l = 0; l < a.length; l++) {
      const c = a[l], f = [];
      for (let u = 0; u < c.length; u++) f.push([
        c[u][(r + 1) % 3],
        c[u][(r + 2) % 3]
      ]);
      s.push(f);
    }
    const o = [
      t[(r + 1) % 3],
      t[(r + 2) % 3]
    ];
    return Jc(i, o, {
      holes: s
    });
  }
  const o0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    addCanvasPointsToArray: vfe,
    containsPoint: Jc,
    containsPoints: _y,
    decimate: CN,
    getAABB: qp,
    getArea: ky,
    getClosestLineSegmentIntersection: gfe,
    getFirstLineSegmentIntersectionIndexes: xN,
    getLineSegmentIntersectionsCoordinates: TN,
    getLineSegmentIntersectionsIndexes: zy,
    getNormal2: Fh,
    getNormal3: ffe,
    getSignedArea: Py,
    getSubPixelSpacingAndXYDirections: pfe,
    getWindingDirection: I6,
    intersectPolyline: wN,
    isClosed: dN,
    isPointInsidePolyline3D: wfe,
    mergePolylines: vN,
    pointCanProjectOnLine: yfe,
    pointsAreWithinCloseContourProximity: mfe,
    projectTo2D: SN,
    subtractPolylines: yN
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function zl(t, e, n, r) {
    var _a3, _b3;
    const { canvasToWorld: i, worldToCanvas: a } = n, { data: s } = t, { targetWindingDirection: o } = e;
    let { points: l } = e;
    ((_a3 = r == null ? void 0 : r.decimate) == null ? void 0 : _a3.enabled) && (l = CN(e.points, (_b3 = r == null ? void 0 : r.decimate) == null ? void 0 : _b3.epsilon));
    let { closed: c } = e;
    const f = l.length, u = new Array(f), h = I6(l), g = ige(t);
    if (c === void 0) {
      let y = false;
      if (l.length > 3) {
        const w = Qc(l[0], l[f - 1]);
        y = zr(0, w);
      }
      c = y;
    }
    let v = g ? g.data.contour.windingDirection * -1 : o;
    v === void 0 && (v = h), v !== h && l.reverse();
    const m = s.handles.points.map((y) => a(y));
    m.length > 2 && I6(m) !== v && s.handles.points.reverse();
    for (let y = 0; y < f; y++) u[y] = i(l[y]);
    s.contour.polyline = u, s.contour.closed = c, s.contour.windingDirection = v, age(t);
  }
  const yA = "PlanarFreehandContourSegmentationTool";
  function Wy(t, e = []) {
    const { viewport: n, sliceData: r, annotation: i } = t, a = /* @__PURE__ */ new Map(), { toolName: s, originalToolName: o } = i.metadata, l = o || s, c = (Wu(l, n.element) || []).filter((f) => !f.metadata.originalToolName || f.metadata.originalToolName === l);
    if (l !== yA) {
      const f = Wu(yA, n.element);
      (f == null ? void 0 : f.length) && f.forEach((u) => {
        const { metadata: h } = u;
        h.originalToolName === l && h.originalToolName !== h.toolName && c.push(u);
      });
    }
    if (!(c == null ? void 0 : c.length)) return a;
    for (let f = 0; f < r.numberOfSlices; f++) {
      const u = c.filter((g) => g.metadata.sliceIndex === f);
      if (!(u == null ? void 0 : u.length)) continue;
      const h = u.filter((g) => e.every((v) => {
        var _a3;
        const y = (_a3 = v.parentKey ? v.parentKey(g) : g) == null ? void 0 : _a3[v.key];
        return Array.isArray(y) ? y.every((w, C) => w === v.value[C]) : y === v.value;
      }));
      h.length && a.set(f, h);
    }
    return a;
  }
  function Cfe(t, e) {
    const n = Wy(t, e), r = [];
    if (!(n == null ? void 0 : n.size)) return r;
    for (const i of n.values()) i.forEach((a) => {
      r.push(a);
    });
    return r;
  }
  function AN(t, e, n) {
    const r = zi({
      data: {},
      metadata: {}
    }, n);
    return Object.assign(r, {
      highlighted: false,
      invalidated: true,
      autoGenerated: true,
      annotationUID: void 0,
      cachedStats: {},
      childAnnotationUIDs: [],
      parentAnnotationUID: void 0
    }), Object.assign(r.data, {
      handles: {
        points: e.points || e || [],
        interpolationSources: e.sources,
        activeHandleIndex: null,
        textBox: {
          hasMoved: false,
          worldPosition: [
            0,
            0,
            0
          ],
          worldBoundingBox: {
            topLeft: [
              0,
              0,
              0
            ],
            topRight: [
              0,
              0,
              0
            ],
            bottomLeft: [
              0,
              0,
              0
            ],
            bottomRight: [
              0,
              0,
              0
            ]
          }
        }
      },
      contour: {
        ...n.data.contour,
        polyline: t
      }
    }), r;
  }
  function Tfe(t, e) {
    const n = Wy(e, [
      {
        key: "interpolationUID",
        value: e.interpolationUID
      }
    ]), r = Sfe(n);
    if (!r) {
      console.warn("No annotations found to interpolate", n);
      return;
    }
    const i = Afe(n, t.annotationUID), a = [];
    for (let s = r[0] + 1; s < r[1]; s++) if (Efe(n, s)) {
      const o = Dfe(s, r, n);
      ((o == null ? void 0 : o[0]) === i || (o == null ? void 0 : o[1]) === i) && bfe(o, a, s);
    }
    return {
      interpolationData: n,
      interpolationList: a
    };
  }
  function Sfe(t) {
    let e = 1 / 0, n = -1 / 0, r = false;
    for (const [i, a] of t.entries()) a.length && (e = Math.min(i, e), n = Math.max(i, n), r = true);
    if (r) return [
      e,
      n
    ];
  }
  function Afe(t, e) {
    for (const [n, r] of t) for (let i = 0; i < r.length; i++) if (r[i].annotationUID === e) return n;
  }
  function Efe(t, e) {
    const n = t.get(e);
    return !(n == null ? void 0 : n.length) || n.length === 1 && n[0].autoGenerated;
  }
  function bfe(t, e, n) {
    const [r] = t;
    e[r] || (e[r] = {
      pair: t,
      list: []
    }), e[r].list.push(n);
  }
  function Dfe(t, e, n) {
    const r = [];
    let i = true;
    for (let a = t - 1; a >= e[0]; a--) {
      const s = n.get(a);
      if (s == null ? void 0 : s.length) {
        if (s[0].autoGenerated) continue;
        s.length > 1 && (i = false), r.push(a);
        break;
      }
    }
    if (!(!i || !r.length)) {
      for (let a = t + 1; a <= e[1]; a++) {
        const s = n.get(a);
        if (s == null ? void 0 : s.length) {
          if (s[0].autoGenerated) continue;
          s.length > 1 && (i = false), r.push(a);
          break;
        }
      }
      if (!(!i || r.length < 2)) return r;
    }
  }
  const { PointsManager: xA } = a0;
  function Mfe(t, e = 12) {
    const n = xA.create3(e);
    n.sources = [];
    const { sources: r } = n, { length: i, sources: a = [] } = t, s = 5;
    if (i < s * 3) return t.subselect(e);
    const o = Math.floor(Math.max(2 * i / e, s * 2));
    a.forEach(() => r.push(xA.create3(e)));
    const l = Rfe(t, s), c = Ofe(l, e), f = [];
    if ((c == null ? void 0 : c.length) > 2) {
      let u = -1;
      const h = o / 3;
      c.forEach((m) => {
        const [y, , w] = m, C = Math.ceil((y + w) / 2);
        w - u < h || (C - y > 2 * h ? (tu(f, u, y, o, i), u = tu(f, y, C, o, i)) : u = tu(f, u, C, o, i), w - u > h && (u = tu(f, u, w, o, i)));
      });
      const g = f[0];
      V6(g + i - u, i) > 2 * h && tu(f, u, g - h, o, i);
    } else {
      const u = Math.floor(i / e);
      tu(f, -1, i - u, u, i);
    }
    return f.forEach((u) => {
      const h = t.getPointArray(u);
      n.push(h), a.forEach((g, v) => r[v].push(g.getPoint(u)));
    }), n;
  }
  function Rfe(t, e = 6) {
    const { length: n } = t, r = He(), i = He(), a = new Float32Array(n);
    for (let s = 0; s < n; s++) {
      const o = t.getPoint(s), l = t.getPoint(s - e), c = t.getPoint((s + e) % n);
      hi(r, o, l), hi(i, c, o);
      const f = Bt(r, i) / (Pc(r) * Pc(i));
      a[s] = f;
    }
    return a;
  }
  function Ofe(t, e) {
    const { max: n, deviation: r } = Ife(t), { length: i } = t;
    if (r < 0.01 || i < e * 3) return [];
    const a = [];
    let s = null, o, l = 0;
    for (let c = 0; c < i; c++) {
      const f = t[c];
      f < n - r ? s ? (s[2] = c, f < o && (o = f, l = c), s[1] = l) : (o = f, l = c, s = [
        c,
        c,
        c
      ]) : s && (a.push(s), s = null);
    }
    return s && (a[0][0] === 0 ? a[0][0] = s[0] : (s[1] = l, s[2] = i - 1, a.push(s))), a;
  }
  function tu(t, e, n, r, i) {
    n < e && (n += i);
    const a = n - e, s = Math.ceil(a / r);
    if (s <= 0) return t[t.length - 1] !== n && t.push(V6(n, i)), n;
    for (let o = 1; o <= s; o++) {
      const l = V6(e + o * a / s, i);
      t.push(l);
    }
    return t[t.length - 1];
  }
  function V6(t, e) {
    return (Math.round(t) + e) % e;
  }
  function Ife(t) {
    const { length: e } = t;
    let n = 0, r = 1 / 0, i = -1 / 0, a = 0;
    for (let o = 0; o < e; o++) {
      const l = t[o];
      n += l, r = Math.min(r, l), i = Math.max(i, l);
    }
    const s = n / e;
    for (let o = 0; o < e; o++) {
      const l = t[o] - s;
      a += l * l;
    }
    return {
      mean: s,
      max: i,
      min: r,
      sumSq: a,
      deviation: Math.sqrt(a / e)
    };
  }
  function Vfe(t) {
    const { parentAnnotationUID: e, annotationUID: n } = t;
    if (!e) return t.interpolationUID;
    const r = Ua(e), { interpolationUID: i } = r, a = r.childAnnotationUIDs.indexOf(n);
    return t.interpolationUID = `${i}-${a}`, t.interpolationUID;
  }
  function Nfe(t, e) {
    const n = t.length, r = [];
    for (let i = 0; i < n; i++) {
      const a = t[i];
      a.getFrameOfReferenceUID() === e && r.push(a);
    }
    return r;
  }
  const { Active: Lfe, Passive: Ufe, Enabled: Ffe } = jn;
  function Bfe(t, e) {
    const n = t.length, r = [];
    for (let i = 0; i < n; i++) {
      const a = t[i], s = pi(a.id, a.renderingEngineId);
      if (!s) continue;
      _fe(s, e) && r.push(a);
    }
    return r;
  }
  function _fe(t, e) {
    const { toolOptions: n } = t, r = n[e];
    if (!r) return false;
    const i = r.mode;
    return i === Lfe || i === Ufe || i === Ffe;
  }
  function kfe(t, e, n = 0.999) {
    return t.filter((r) => {
      const i = r.getCamera();
      return Math.abs(Bt(i.viewPlaneNormal, e.viewPlaneNormal)) > n;
    });
  }
  function vh(t, e, n = true) {
    const r = pt(t), { renderingEngine: i, FrameOfReferenceUID: a } = r;
    let s = i.getViewports();
    s = Nfe(s, a), s = Bfe(s, e);
    const o = i.getViewport(r.viewportId);
    return n && (s = kfe(s, o.getCamera())), s.map((c) => c.id);
  }
  var Gu;
  (function(t) {
    t[t.CounterClockwise = -1] = "CounterClockwise", t[t.Unknown = 0] = "Unknown", t[t.Clockwise = 1] = "Clockwise";
  })(Gu || (Gu = {}));
  const Hy = "PlanarFreehandContourSegmentationTool";
  async function Pfe(t) {
    const e = t.detail.annotation;
    if (!k5(e)) return;
    const n = Gfe(e), r = zfe(n, e);
    if (!r.length) return;
    const i = G5(e.data.contour.polyline, n), a = Wfe(n, i, r);
    if (!a) return;
    const { targetAnnotation: s, targetPolyline: o, isContourHole: l } = a;
    if (l) {
      const { contourHoleProcessingEnabled: c = false } = t.detail;
      if (!c) return;
      bN(n, s, e);
    } else jfe(n, s, o, e, i);
  }
  function EN(t, e = false) {
    const { toolName: n } = e0, r = pi(t.id, t.renderingEngineId);
    let i;
    return r.hasTool(n) ? r.getToolOptions(n) || (i = `Tool ${n} must be in active/passive state`) : i = `Tool ${n} not added to ${r.id} toolGroup`, i && !e && console.warn(i), !i;
  }
  function Gfe(t) {
    const e = fN(t);
    return e.find((r) => EN(r, true)) ?? e[0];
  }
  function G5(t, e) {
    const n = t.length, r = new Array(n);
    for (let i = 0; i < n; i++) r[i] = e.worldToCanvas(t[i]);
    return r;
  }
  function zfe(t, e) {
    const { annotationUID: n } = e;
    return rge().filter((i) => i.annotationUID && i.annotationUID !== n && k5(i) && Nue(i, e) && t.isReferenceViewable(i.metadata));
  }
  function Wfe(t, e, n) {
    const r = qp(e);
    for (let i = 0; i < n.length; i++) {
      const a = n[i], s = G5(a.data.contour.polyline, t), o = qp(s), l = sfe(r, o), c = l && wN(e, s), f = l && !c && _y(s, e);
      if (c || f) return {
        targetAnnotation: a,
        targetPolyline: s,
        isContourHole: f
      };
    }
  }
  function bN(t, e, n) {
    const { windingDirection: r } = e.data.contour, { windingDirection: i } = n.data.contour;
    VL(e, n), Uy(n);
    const { contour: a } = n.data, s = G5(a.polyline, t);
    zl(n, {
      points: s,
      closed: a.closed
    }, t);
    const { element: o } = t, l = pt(o), { renderingEngine: c } = l, f = /* @__PURE__ */ new Set([
      Hy,
      e.metadata.toolName,
      n.metadata.toolName
    ]);
    for (const u of f.values()) {
      const h = vh(o, u);
      bi(c, h);
    }
  }
  function Hfe(t, e) {
    return NL(e).map((n) => {
      const r = G5(n.data.contour.polyline, t);
      return {
        annotation: n,
        polyline: r
      };
    });
  }
  function jfe(t, e, n, r, i) {
    var _a3;
    if (!Oce(e0)) {
      console.warn(`${e0.toolName} is not registered in cornerstone`);
      return;
    }
    if (!EN(t)) return;
    const a = i[0], s = Jc(n, a), o = Hfe(t, e), l = new Set(o), c = /* @__PURE__ */ new Map(), f = (T, S) => {
      let E = c.get(T);
      E || (E = [], c.set(T, E)), E.push(S), l.delete(S);
    }, u = [];
    if (s) {
      const T = vN(n, i);
      u.push(T), Array.from(l.keys()).forEach((S) => f(T, S));
    } else yN(n, i).forEach((S) => {
      u.push(S), Array.from(l.keys()).forEach((E) => {
        _y(S, E.polyline) && (f(S, E), l.delete(E));
      });
    });
    Array.from(c.values()).forEach((T) => T.forEach((S) => IL(S.annotation)));
    const { element: h } = t, g = pt(h), { metadata: v, data: m } = e, { handles: y, segmentation: w } = m, { textBox: C } = y;
    Hu(r.annotationUID), Hu(e.annotationUID);
    for (let T = 0; T < u.length; T++) {
      const S = u[T], E = t.canvasToWorld(S[0]), b = t.canvasToWorld(S[S.length - 1]), D = {
        metadata: {
          ...v,
          toolName: Hy,
          originalToolName: v.originalToolName || v.toolName
        },
        data: {
          cachedStats: {},
          handles: {
            points: [
              E,
              b
            ],
            textBox: C ? {
              ...C
            } : void 0
          },
          contour: {
            polyline: [],
            closed: true
          },
          spline: e.data.spline,
          segmentation: {
            ...w
          }
        },
        annotationUID: gi(),
        highlighted: true,
        invalidated: true,
        isLocked: false,
        isVisible: void 0,
        interpolationUID: e.interpolationUID,
        interpolationCompleted: e.interpolationCompleted
      };
      zl(D, {
        points: S,
        closed: true,
        targetWindingDirection: Gu.Clockwise
      }, t), uf(D, h), Uh(D), Wl(D, t.element), (_a3 = c.get(S)) == null ? void 0 : _a3.forEach((R) => VL(D, R.annotation));
    }
    Kfe(g, e, r);
  }
  function Kfe(t, e, n) {
    const { viewport: r } = t, { element: i } = r, { renderingEngine: a } = t, s = /* @__PURE__ */ new Set([
      Hy,
      e.metadata.toolName,
      n.metadata.toolName
    ]);
    for (const o of s.values()) {
      const l = vh(i, o);
      bi(a, l);
    }
    return new Promise((o) => window.requestAnimationFrame(o));
  }
  const { PointsManager: D1 } = a0, wA = 0.2;
  function Kg(t) {
    if (!t.annotation) return;
    const { isInterpolationUpdate: e, annotation: n } = t;
    queueMicrotask(() => {
      try {
        e && (n.isInterpolationUpdate = true, n.autoGenerated = false), Yfe(t);
      } finally {
        e && (n.autoGenerated = true);
      }
    });
  }
  function Yfe(t) {
    const { annotation: e } = t;
    Vfe(e);
    const { interpolationData: n, interpolationList: r } = Tfe(e, t) || {};
    if (!n || !r) return;
    const i = {
      toolName: e.metadata.toolName,
      toolType: e.metadata.toolName,
      viewport: t.viewport
    };
    for (let c = 0; c < r.length; c++) r[c] && qfe(r[c].list, r[c].pair, n, i);
    const { id: a, renderingEngineId: s, element: o } = t.viewport, l = {
      annotation: e,
      element: o,
      viewportId: a,
      renderingEngineId: s
    };
    r.length && qe(t.viewport.element, Re.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, l);
  }
  function qfe(t, e, n, r) {
    const i = n.get(e[0])[0], a = n.get(e[1])[0], s = DA(i.data.contour.polyline), o = DA(a.data.contour.polyline), { c1Interp: l, c2Interp: c } = $fe(s, o);
    l.kIndex = e[0], c.kIndex = e[1], t.forEach(function(f) {
      Xfe(l, c, f, e, n, s.x.length > o.x.length, r);
    });
  }
  function Xfe(t, e, n, r, i, a, s) {
    const [o, l] = r, c = (n - o) / (l - o), f = i.get(o)[0], u = i.get(l)[0], h = Jfe(t, e, c, a), g = c > 0.5 ? u : f, v = Mfe(h);
    i.has(n) ? Qfe(h, v, n, g, s) : Zfe(h, v, n, g, s);
  }
  function Zfe(t, e, n, r, i) {
    var _a3;
    const a = t.points, { viewport: s } = i, o = AN(a, e, r), l = s.getViewReference({
      sliceIndex: n
    });
    if (!l) throw new Error(`Can't find slice ${n}`);
    Object.assign(o.metadata, l), uf(o, s.element), (_a3 = r.onInterpolationComplete) == null ? void 0 : _a3.call(r, o, r);
    const { parentAnnotationUID: c } = r;
    if (c) {
      const f = Ua(c), u = DN(f, n, i);
      bN(s, u, o);
    }
  }
  function DN(t, e, n) {
    const { viewport: r } = n, i = Wu(t.metadata.toolName, r.element);
    for (let a = 0; a < i.length; a++) {
      const s = i[a];
      if (s.interpolationUID === t.interpolationUID && s.metadata.sliceIndex === e) return s;
    }
  }
  function Qfe(t, e, n, r, i) {
    const a = DN(r, n, i), s = t.points, o = AN(s, e, a);
    Object.assign(a, {
      metadata: o.metadata,
      data: o.data
    });
  }
  function Jfe(t, e, n, r) {
    const i = r ? t.I : e.I, a = D1.fromXYZ(t), s = D1.fromXYZ(e), { length: o } = a, l = D1.create3(o), c = He(), f = He(), u = D1.create3(o);
    u.kIndex = t.kIndex;
    const h = D1.create3(o);
    h.kIndex = e.kIndex;
    for (let g = 0; g < t.x.length; g++) if (i[g]) {
      const v = a.getPoint(g), m = s.getPoint(g);
      u.push(v), h.push(m), hi(c, m, v), l.push(Xr(f, v, c, n));
    }
    return l.sources = [
      u,
      h
    ], l;
  }
  function $fe(t, e) {
    const n = bA(t), r = bA(e), i = Math.max(Math.ceil(n[n.length - 1] / wA), Math.ceil(r[r.length - 1] / wA)), a = EA(n), s = EA(r), o = i + e.x.length, l = i + t.x.length, c = AA(o, a), f = AA(l, s), u = SA(o - 2, t.x.length), h = SA(l - 2, e.x.length), g = TA(c, u), v = TA(f, h), m = CA(t, g), y = CA(e, v);
    return t1e(m, y), e1e(m, y);
  }
  function e1e(t, e) {
    const n = {
      x: [],
      y: [],
      z: [],
      I: []
    }, r = {
      x: [],
      y: [],
      z: [],
      I: []
    };
    for (let i = 0; i < t.x.length; i++) (t.I[i] || e.I[i]) && (n.x.push(t.x[i]), n.y.push(t.y[i]), n.z.push(t.z[i]), n.I.push(t.I[i]), r.x.push(e.x[i]), r.y.push(e.y[i]), r.z.push(e.z[i]), r.I.push(e.I[i]));
    return {
      c1Interp: n,
      c2Interp: r
    };
  }
  function t1e(t, e) {
    const n = t.x.length, r = {
      startingNode: 0,
      totalSquaredXYLengths: 1 / 0
    };
    for (let a = 0; a < n; a++) {
      let s = a, o = 0;
      for (let l = 0; l < n; l++) o += (t.x[s] - e.x[l]) ** 2 + (t.y[s] - e.y[l]) ** 2 + (t.z[s] - e.z[l]) ** 2, s++, s === n && (s = 0);
      o < r.totalSquaredXYLengths && (r.totalSquaredXYLengths = o, r.startingNode = a);
    }
    const i = r.startingNode;
    lg(t.x, i), lg(t.y, i), lg(t.z, i), lg(t.I, i);
  }
  function lg(t, e) {
    e -= t.length * Math.floor(e / t.length);
    const n = t.splice(0, e);
    return t.push(...n), t;
  }
  function CA(t, e) {
    const n = {
      x: [],
      y: [],
      z: [],
      I: []
    };
    for (let r = 0; r < t.x.length - 1; r++) {
      n.x.push(t.x[r]), n.y.push(t.y[r]), n.z.push(t.z[r]), n.I.push(true);
      const i = (t.x[r + 1] - t.x[r]) / (e[r] + 1), a = (t.y[r + 1] - t.y[r]) / (e[r] + 1), s = (t.z[r + 1] - t.z[r]) / (e[r] + 1);
      for (let o = 0; o < e[r] - 1; o++) n.x.push(n.x[n.x.length - 1] + i), n.y.push(n.y[n.y.length - 1] + a), n.z.push(n.z[n.z.length - 1] + s), n.I.push(false);
    }
    return n;
  }
  function TA(t, e) {
    const n = [];
    for (let s = 0; s < t.length; ++s) n[s] = s;
    n.sort(function(s, o) {
      return t[s] < t[o] ? -1 : 1;
    });
    const r = [];
    for (let s = 0; s < e.length; s++) r.push(e[n[s]]);
    const i = r.reduce(function(s, o, l) {
      return o && s.push(l), s;
    }, []), a = [];
    for (let s = 0; s < i.length - 1; s++) a.push(i[s + 1] - i[s]);
    return a;
  }
  function SA(t, e) {
    const n = new Array(t + e);
    return n.fill(false, 0, t), n.fill(true, t, t + e), n;
  }
  function AA(t, e) {
    const n = 1 / (t - 1), r = [
      n
    ];
    for (let i = 1; i < t - 2; i++) r.push(r[r.length - 1] + n);
    return r.concat(e);
  }
  function EA(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) e.push(t[n] / t[t.length - 1]);
    return e;
  }
  function bA(t) {
    const e = [
      0
    ];
    for (let n = 1; n < t.x.length; n++) {
      const r = Math.sqrt((t.x[n] - t.x[n - 1]) ** 2 + (t.y[n] - t.y[n - 1]) ** 2 + (t.z[n] - t.z[n - 1]) ** 2);
      e.push(e[n - 1] + r);
    }
    return e;
  }
  function DA(t) {
    const e = {
      x: [],
      y: [],
      z: []
    };
    for (let n = 0; n < t.length; n++) e.x[n] = t[n][0], e.y[n] = t[n][1], e.z[n] = t[n][2];
    return e.x.push(e.x[0]), e.y.push(e.y[0]), e.z.push(e.z[0]), e;
  }
  function MA(t) {
    const { annotation: e } = t, n = Wy(t, [
      {
        key: "interpolationUID",
        value: t.interpolationUID
      }
    ]), r = e.metadata.sliceIndex;
    let i = -1, a = t.sliceData.numberOfSlices;
    for (const [o, l] of n.entries()) o === r || !l.find((f) => !f.autoGenerated) || (o < r ? i = Math.max(o, i) : a = Math.min(o, a));
    const s = [];
    for (const [o, l] of n.entries()) o <= i || o >= a || o === r || l.forEach((c) => {
      c.autoGenerated && (Hu(c.annotationUID), s.push(c));
    });
    if (s.length) {
      const o = {
        annotations: s,
        element: t.viewport.element,
        viewportId: t.viewport.id,
        renderingEngineId: t.viewport.getRenderingEngine().id
      };
      qe(t.viewport.element, Re.INTERPOLATED_ANNOTATIONS_REMOVED, o);
    }
    if (i >= 0 && a < t.sliceData.numberOfSlices) {
      const o = n.get(a)[0], l = {
        viewport: t.viewport,
        sliceData: {
          numberOfSlices: t.sliceData.numberOfSlices,
          imageIndex: o.metadata.sliceIndex
        },
        annotation: o,
        interpolationUID: o.interpolationUID
      };
      Kg(l);
    }
  }
  const { uuidv4: n1e } = a0, r1e = [
    _l.HandlesUpdated,
    _l.InterpolationUpdated
  ];
  const _To = class _To {
    static addTool(e) {
      this.toolNames.includes(e) || this.toolNames.push(e);
    }
    static acceptAutoGenerated(e, n = {}) {
      const { toolNames: r, segmentationId: i, segmentIndex: a, sliceIndex: s } = n;
      for (const o of r || _To.toolNames) {
        const l = Wu(o, e);
        if (l == null ? void 0 : l.length) for (const c of l) {
          const { interpolationUID: f, data: u, autoGenerated: h, metadata: g } = c;
          f && (c.interpolationCompleted = true), h && (a && a !== u.segmentation.segmentIndex || s !== void 0 && g && s !== g.sliceIndex || i && i !== u.segmentation.segmentationId || (Uh(c), c.autoGenerated = false));
        }
      }
    }
  };
  _To.toolNames = [];
  _To.handleAnnotationCompleted = (e) => {
    var _a3;
    const n = e.detail.annotation;
    if (!(n == null ? void 0 : n.metadata)) return;
    const { toolName: r, originalToolName: i } = n.metadata;
    if (!_To.toolNames.includes(r) && !_To.toolNames.includes(i)) return;
    const a = hv(n);
    if (!a) {
      console.warn("Unable to find viewport for", n);
      return;
    }
    const s = gv(a), o = {
      viewport: a,
      sliceData: s,
      annotation: n,
      interpolationUID: n.interpolationUID
    }, l = !!n.interpolationUID;
    if (n.autoGenerated = false, l) {
      MA(o), Kg(o);
      return;
    }
    const c = [
      {
        key: "segmentIndex",
        value: n.data.segmentation.segmentIndex,
        parentKey: (g) => g.data.segmentation
      },
      {
        key: "viewPlaneNormal",
        value: n.metadata.viewPlaneNormal,
        parentKey: (g) => g.metadata
      },
      {
        key: "viewUp",
        value: n.metadata.viewUp,
        parentKey: (g) => g.metadata
      }
    ];
    let f = Cfe(o, c);
    const { sliceIndex: u } = n.metadata, h = /* @__PURE__ */ new Set();
    f.forEach((g) => {
      if (g.interpolationCompleted || g.metadata.sliceIndex === u) {
        const { interpolationUID: v } = g;
        h.add(v);
      }
    }), f = f.filter((g) => !h.has(g.interpolationUID)), n.interpolationUID = ((_a3 = f[0]) == null ? void 0 : _a3.interpolationUID) || n1e(), o.interpolationUID = n.interpolationUID, Kg(o);
  };
  _To.handleAnnotationUpdate = (e) => {
    const n = e.detail.annotation, { changeType: r = _l.HandlesUpdated } = e.detail;
    if (!(n == null ? void 0 : n.metadata)) return;
    const { toolName: i, originalToolName: a } = n.metadata;
    if (!_To.toolNames.includes(i) && !_To.toolNames.includes(a) || !r1e.includes(r)) return;
    const s = hv(n);
    if (!s) {
      console.warn("Unable to find matching viewport for annotation interpolation", n);
      return;
    }
    n.autoGenerated && (Uh(n), n.autoGenerated = false);
    const o = gv(s), l = {
      viewport: s,
      sliceData: o,
      annotation: n,
      interpolationUID: n.interpolationUID,
      isInterpolationUpdate: r === _l.InterpolationUpdated
    };
    Kg(l);
  };
  _To.handleAnnotationDelete = (e) => {
    const n = e.detail.annotation;
    if (!(n == null ? void 0 : n.metadata)) return;
    const { toolName: r } = n.metadata;
    if (!_To.toolNames.includes(r) || n.autoGenerated) return;
    const i = hv(n);
    if (!i) {
      console.warn("No viewport, can't delete interpolated results", n);
      return;
    }
    const a = gv(i), s = {
      viewport: i,
      sliceData: a,
      annotation: n,
      interpolationUID: n.interpolationUID
    };
    n.autoGenerated = false, MA(s);
  };
  let To = _To;
  function gv(t) {
    return {
      numberOfSlices: t.getNumberOfSlices(),
      imageIndex: t.getCurrentImageIdIndex()
    };
  }
  function RA(t, e) {
    let n = 0;
    for (let r = 0; r < t.length - 1; r++) {
      const i = t[r], a = t[r + 1];
      n += Math.sqrt(Math.pow(a[0] - i[0], 2) + Math.pow(a[1] - i[1], 2));
    }
    if (e) {
      const r = t[0], i = t[t.length - 1];
      n += Math.sqrt(Math.pow(i[0] - r[0], 2) + Math.pow(i[1] - r[1], 2));
    }
    return n;
  }
  const OA = Symbol("DefinedCursors"), MN = /* @__PURE__ */ new Set([
    "alias",
    "all-scroll",
    "auto",
    "cell",
    "col-resize",
    "context-menu",
    "copy",
    "crosshair",
    "default",
    "e-resize",
    "ew-resize",
    "grab",
    "grabbing",
    "help",
    "move",
    "ne-resize",
    "nesw-resize",
    "no-drop",
    "none",
    "not-allowed",
    "n-resize",
    "ns-resize",
    "nw-resize",
    "nwse-resize",
    "pointer",
    "progress",
    "row-resize",
    "se-resize",
    "s-resize",
    "sw-resize",
    "text",
    "vertical-text",
    "wait",
    "w-resize",
    "zoom-in",
    "zoom-out"
  ]);
  class pa {
    constructor(e, n) {
      this.name = e + "", this.fallback = n;
    }
    getName() {
      return this.name + "";
    }
    addFallbackStyleProperty(e) {
      const { fallback: n } = this;
      return n instanceof pa ? `${e}, ${n.getStyleProperty()}` : e + "";
    }
    getStyleProperty() {
      return this.addFallbackStyleProperty(this.name) + "";
    }
    static getDefinedCursor(e) {
      const n = IA(pa, OA);
      let r = n.get(e);
      if (r instanceof pa) return r;
      if (MN.has(e)) return r = new pa(e), n.set(e, r), r;
    }
    static setDefinedCursor(e, n) {
      return n instanceof pa ? (IA(pa, OA).set(e, n), true) : false;
    }
  }
  function IA(t, e) {
    let n = t[e];
    return n instanceof Map || (n = /* @__PURE__ */ new Map(), Object.defineProperty(t, e, {
      value: n
    })), n;
  }
  const i1e = MN.values(), a1e = "image-cursor";
  class Xp extends pa {
    constructor(e, n, r, i, a) {
      super(i || Xp.getUniqueInstanceName(a1e), a), this.url = e, this.x = Number(n) || 0, this.y = Number(r) || 0;
    }
    getStyleProperty() {
      const { url: e, x: n, y: r } = this;
      let i = `url('${e}')`;
      return n >= 0 && r >= 0 && (n > 0 || r > 0) && (i += ` ${n} ${r}`), this.addFallbackStyleProperty(i);
    }
    static getUniqueInstanceName(e) {
      return `${e}-${AD(Xp)}`;
    }
  }
  const hn = {
    iconContent: "",
    iconSize: 16,
    viewBox: {
      x: 16,
      y: 16
    },
    mousePoint: {
      x: 8,
      y: 8
    },
    mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `
  }, qi = {
    x: 127,
    y: 60
  }, nu = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`, fl = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`, cg = '<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>', ru = '<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>', ug = '<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>', RN = {
    Angle: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    ArrowAnnotate: dn(hn, {
      iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
      viewBox: {
        x: 24,
        y: 24
      }
    }),
    Bidirectional: dn(hn, {
      iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
      viewBox: {
        x: 48,
        y: 48
      }
    }),
    CobbAngle: dn(hn, {
      iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
      viewBox: {
        x: 32,
        y: 32
      }
    }),
    CircleROI: dn(hn, {
      iconContent: '<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />',
      viewBox: {
        x: 32,
        y: 32
      }
    }),
    EllipticalROI: dn(hn, {
      iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
      viewBox: {
        x: 32,
        y: 32
      }
    }),
    FreehandROI: dn(hn, {
      iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
      viewBox: {
        x: 18,
        y: 18
      }
    }),
    FreehandROISculptor: dn(hn, {
      iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
      viewBox: {
        x: 18,
        y: 18
      }
    }),
    Length: dn(hn, {
      iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
      viewBox: {
        x: 24,
        y: 24
      }
    }),
    Height: dn(hn, {
      iconContent: '<path d="m 6 22 l 8.5 0 v -16 h 8" stroke-width="3" fill="none" stroke="{{color}}" />',
      viewBox: {
        x: 24,
        y: 24
      }
    }),
    Probe: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    RectangleROI: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    TextMarker: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    Crosshairs: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    Eraser: dn(hn, {
      iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
      viewBox: {
        x: 2048,
        y: 1792
      }
    }),
    Magnify: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
      viewBox: {
        x: 512,
        y: 512
      }
    }),
    Pan: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    Rotate: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    StackScroll: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
      viewBox: {
        x: 24,
        y: 28
      }
    }),
    WindowLevelRegion: dn(hn, {
      iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
      viewBox: {
        x: 1792,
        y: 1792
      }
    }),
    WindowLevel: dn(hn, {
      iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
      viewBox: {
        x: 18,
        y: 18
      }
    }),
    Zoom: dn(hn, {
      iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
      viewBox: {
        x: 640,
        y: 512
      }
    }),
    SegmentationFreeHandEraseInside: dn(hn, {
      iconContent: `${cg} ${nu}`,
      viewBox: qi
    }),
    SegmentationFreeHandFillInside: dn(hn, {
      iconContent: `${cg} ${fl}`,
      viewBox: qi
    }),
    SegmentationFreeHandEraseOutside: dn(hn, {
      iconContent: `${cg} ${nu}`,
      viewBox: qi
    }),
    SegmentationFreeHandFillOutside: dn(hn, {
      iconContent: `${cg} ${fl}`,
      viewBox: qi
    }),
    SegmentationRectangleEraseInside: dn(hn, {
      iconContent: `${ru} ${nu}`,
      viewBox: qi
    }),
    RectangleScissor: dn(hn, {
      iconContent: `${ru} ${fl}`,
      viewBox: qi
    }),
    "RectangleScissor.FILL_INSIDE": dn(hn, {
      iconContent: `${ru} ${fl}`,
      viewBox: qi
    }),
    "RectangleScissor.FILL_OUTSIDE": dn(hn, {
      iconContent: `${ru} ${fl}`,
      viewBox: qi
    }),
    "RectangleScissor.ERASE_OUTSIDE": dn(hn, {
      iconContent: `${ru} ${nu}`,
      viewBox: qi
    }),
    "RectangleScissor.ERASE_INSIDE": dn(hn, {
      iconContent: `${ru} ${nu}`,
      viewBox: qi
    }),
    CircleScissor: dn(hn, {
      iconContent: `${ug} ${fl}`,
      viewBox: qi
    }),
    "CircleScissor.FILL_INSIDE": dn(hn, {
      iconContent: `${ug} ${fl}`,
      viewBox: qi
    }),
    "CircleScissor.ERASE_OUTSIDE": dn(hn, {
      iconContent: `${ug} ${nu}`,
      viewBox: qi
    }),
    "CircleScissor.FILL_OUTSIDE": dn(hn, {
      iconContent: `${ug} ${fl}`,
      viewBox: qi
    })
  };
  function dn(t, e) {
    return Object.assign(Object.create(t), e);
  }
  function s1e(t) {
    return RN[t];
  }
  const o1e = Object.keys(RN), l1e = "color", c1e = Cl.Highlighted, u1e = jn.Active;
  class Yg extends Xp {
    constructor(e, n, r, i, a) {
      super(e, n, r, i, a);
    }
    static getDefinedCursor(e, n = false, r) {
      r || (r = ZV(l1e, {}, c1e, u1e));
      const i = f1e(e, n, r);
      let a = super.getDefinedCursor(i);
      if (!a) {
        const s = s1e(e);
        s && (a = h1e(s, i, n, r, super.getDefinedCursor("default")), super.setDefinedCursor(i, a));
      }
      return a;
    }
  }
  function ON(t, e) {
    const n = Object(e), r = Object.prototype.hasOwnProperty.bind(n);
    return (t + "").replace(/\{\{(\w+)\}\}/g, (i, a) => r(a) ? n[a] + "" : "");
  }
  function f1e(t, e, n) {
    return `${e ? "pointer" : "cursor"}:${t}/${n}`;
  }
  function h1e(t, e, n, r, i) {
    const { x: a, y: s } = t.mousePoint;
    return new Yg(d1e(t, n, {
      color: r
    }), a, s, e, i);
  }
  function d1e(t, e, n) {
    return URL.createObjectURL(g1e(t, e, n));
  }
  function g1e(t, e, n) {
    const r = (e ? m1e : p1e)(t, n);
    return new Blob([
      r
    ], {
      type: "image/svg+xml"
    });
  }
  function p1e(t, e) {
    const { iconContent: n, iconSize: r, viewBox: i } = t, a = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${r}" height="${r}" viewBox="0 0
      ${i.x} ${i.y}">
      ${n}
    </svg>`;
    return ON(a, e);
  }
  function m1e(t, e) {
    const { iconContent: n, iconSize: r, viewBox: i, mousePointerGroupString: a } = t, s = r / Math.max(i.x, i.y, 1), o = 16 + r, l = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${o}" height="${o}" viewBox="0 0 ${o} ${o}">
      <g>${a}</g>
      <g transform="translate(16, 16) scale(${s})">${n}</g>
    </svg>`;
    return ON(l, e);
  }
  [
    ...o1e,
    ...i1e
  ];
  const VA = Symbol("ElementCursorsMap");
  function v1e(t, e) {
    Bh(t)[0] = e, jy(t, e);
  }
  function jy(t, e) {
    const n = Bh(t);
    n[1] = n[0], n[0] = e, t.style.cursor = (e instanceof pa ? e : pa.getDefinedCursor("auto")).getStyleProperty();
  }
  function Ky(t) {
    jy(t, Bh(t)[1]);
  }
  function z5(t) {
    jy(t, pa.getDefinedCursor("none"));
  }
  function Bh(t) {
    let e = Bh[VA];
    e instanceof WeakMap || (e = /* @__PURE__ */ new WeakMap(), Object.defineProperty(Bh, VA, {
      value: e
    }));
    let n = e.get(t);
    return n || (n = [
      null,
      null
    ], e.set(t, n)), n;
  }
  function NA(t, e) {
    return new Map(t.map((r, i) => [
      r,
      e[i]
    ]));
  }
  function y1e(t, e) {
    if (t instanceof Ga) {
      const n = nf(e), r = Ke.getVolume(n);
      return !!(r == null ? void 0 : r.scaling) && Object.keys(r.scaling).length > 0;
    } else if (t instanceof bo) {
      const { preScale: n } = t.getImageData() || {};
      return !!(n == null ? void 0 : n.scaled);
    } else return false;
  }
  function x1e(t) {
    const e = w1e(t), n = (e.top[1] + e.bottom[1]) / 2;
    return [
      e.right[0],
      n
    ];
  }
  function w1e(t) {
    const e = [
      t[0],
      t[1]
    ].sort(s), n = [
      t[0],
      t[1]
    ].sort(o), r = e[e.length - 1], i = n[0], a = n[n.length - 1];
    return {
      top: i,
      bottom: a,
      right: r
    };
    function s(l, c) {
      return l[0] < c[0] ? -1 : 1;
    }
    function o(l, c) {
      return l[1] < c[1] ? -1 : 1;
    }
  }
  function C1e(t) {
    var _a3;
    return ((_a3 = t[0]) == null ? void 0 : _a3.length) === 3;
  }
  function T1e(t, e) {
    if (!e || e.length === 0 || e.length === t.length) return t;
    const n = e[e.length - 1] - e[0] + 1, r = ev(e.map((a) => t[a][0])), i = ev(e.map((a) => t[a][1]));
    if (C1e(t)) {
      const a = ev(e.map((s) => t[s][2]));
      return CS(S1(r, n), S1(i, n), S1(a, n));
    } else return CS(S1(r, n), S1(i, n));
  }
  function S1e(t, e) {
    const n = [], [r, i] = e, a = i - r + 1, s = Math.floor(a / t);
    let o = 0, l = Math.round((a - 1) / (s - 1) * o) + r;
    for (; l <= i; ) n.push(l), o++, l = Math.round((a - 1) / (s - 1) * o) + r;
    return n;
  }
  function A1e(t, e, n, r) {
    const i = n - e + 1, a = Math.floor(r / 100 * i) ?? 1, s = Math.floor(i / a) ?? 1;
    if (isNaN(i) || !i || !s || i / s < 2) return t;
    const o = Math.max(0, e), l = Math.min(t.length - 1, n), c = t.slice(0, o), f = t.slice(l + 1, t.length), u = S1e(s, [
      o,
      l
    ]), h = T1e(t, u);
    return [
      ...c,
      ...h,
      ...f
    ];
  }
  const iu = wy;
  async function E1e(t, e, n) {
    var _a3;
    const { segmentationId: r, options: i = {} } = e, a = ((_a3 = e.options) == null ? void 0 : _a3.segmentationRepresentationUID) || gi(), s = /* @__PURE__ */ new Set(), o = b1e(i), l = {
      segmentationId: r,
      segmentationRepresentationUID: a,
      type: e.type,
      segmentsHidden: s,
      colorLUTIndex: o,
      active: true,
      segmentationRepresentationSpecificConfig: {},
      segmentSpecificConfig: {},
      config: Kue(e),
      polySeg: i.polySeg
    };
    if (n) {
      const c = Fy(t), f = zi(c, n);
      lN(t, {
        renderInactiveSegmentations: f.renderInactiveSegmentations || true,
        representations: {
          ...f.representations
        }
      });
    }
    return due(t, l), e.type === Nt.Contour && ta(t).getViewportsInfo().forEach(({ viewportId: c, renderingEngineId: f }) => {
      const u = _a(f);
      bi(u, [
        c
      ]);
    }), a;
  }
  function b1e(t = {}) {
    const e = t.colorLUTOrIndex;
    let n;
    if (typeof e == "number") n = e;
    else {
      const r = mue(), i = Array.isArray(e) ? e : Yue;
      vue(i, r), n = r;
    }
    return n;
  }
  async function D1e(t, e, n) {
    if (!ta(t)) throw new Error(`No tool group found for toolGroupId: ${t}`);
    const i = e.map((s) => E1e(t, s, n));
    return await Promise.all(i);
  }
  function M1e({ segmentationId: t, type: e, data: n }) {
    const r = Kn(t);
    switch (r.representationData[e] && console.warn(`Representation data of type ${e} already exists for segmentation ${t}, overwriting it.`), e) {
      case Nt.Labelmap:
        n && (r.representationData[e] = n);
        break;
      case Nt.Contour:
        n && (r.representationData[e] = n);
        break;
      case Nt.Surface:
        n && (r.representationData[e] = n);
        break;
      default:
        throw new Error(`Invalid representation type ${e}`);
    }
  }
  async function R1e({ imageIdReferenceMap: t, options: e }) {
    const n = Array.from(t.values()), r = {
      imageIdReferenceMap: t
    }, i = (e == null ? void 0 : e.volumeId) ?? gi();
    return await Dre(i, n, {
      additionalDetails: r
    }), {
      volumeId: i
    };
  }
  async function O1e({ volumeId: t }) {
    const e = Ke.getVolume(t), n = e.imageCacheOffsetMap.size > 0;
    let r = false;
    n && (r = e.imageIds.every((o) => Ke.getImage(o)));
    const a = Pl()[0].getVolumeViewports().find((o) => o.hasVolumeId(t));
    return e.decache(!a && r), {
      imageIdReferenceMap: I1e(e)
    };
  }
  function I1e(t) {
    var _a3, _b3, _c3, _d;
    if ((_a3 = t.additionalDetails) == null ? void 0 : _a3.imageIdReferenceMap) return t.additionalDetails.imageIdReferenceMap;
    if (((_b3 = t.referencedImageIds) == null ? void 0 : _b3.length) && !t.referencedImageIds[0].startsWith("derived")) {
      const e = t.referencedImageIds, n = t.imageIds;
      return NA(e, [
        ...n
      ].reverse());
    } else {
      const e = t.referencedVolumeId, n = Ke.getVolume(e);
      if (!n) throw new Error("Cannot convert volumetric segmentation without referenced volume to stack segmentation yet");
      if (!((_c3 = n == null ? void 0 : n.imageIds) == null ? void 0 : _c3.length)) throw new Error("Cannot convert volumetric segmentation without imageIds to stack segmentation yet");
      if ((_d = n.imageIds) == null ? void 0 : _d[0].startsWith("derived")) throw new Error(`Cannot convert volume segmentation that is derived from another segmentation
         to stack segmentation yet, include the additionalDetails.imageIdReferenceMap
         in the volume segmentation in case you need it for the conversion`);
      const r = n.imageIds;
      let i = t.imageIds;
      return (i == null ? void 0 : i.length) || (i = t.convertToImageSlicesAndCache()), NA(r, [
        ...i
      ].reverse());
    }
  }
  function V1e(t) {
    const n = Lr().getSegmentationRepresentations(t);
    return n ? n.find((i) => i.active) : void 0;
  }
  function N1e(t) {
    const e = Kn(t);
    if (!e) throw new Error(`No segmentation state found for ${t}`);
    const { segmentsLocked: n } = e;
    return Array.from(n);
  }
  function IN(t, e, n) {
    const r = hd(t, e);
    if (!r) throw new Error(`segmentation representation with UID ${e} does not exist for tool group ${t}`);
    const { colorLUTIndex: i } = r, a = Ny(i);
    let s = a[n];
    if (!s) {
      if (typeof n != "number") throw new Error(`Can't create colour for LUT index ${n}`);
      s = a[n] = [
        0,
        0,
        0,
        0
      ];
    }
    return s;
  }
  function LA(t, e, n) {
    const r = ya(t);
    if (!r) return;
    const i = r.find((l) => l.segmentationRepresentationUID === e);
    if (!i) return;
    const { segmentsHidden: a, segmentationId: s } = i, o = us(s);
    n ? a.clear() : o.forEach((l) => {
      a.add(l);
    }), lf(t, i.segmentationRepresentationUID);
  }
  function L1e(t, e) {
    const r = ya(t).find((l) => l.segmentationRepresentationUID === e);
    if (!r) return;
    const { segmentsHidden: i, segmentationId: a } = r, s = us(a), o = new Set(s);
    return i.forEach((l) => o.delete(l)), !!o.size;
  }
  function U1e(t, e, n, r) {
    const i = hd(t, e);
    i && (r ? i.segmentsHidden.delete(n) : i.segmentsHidden.add(n), lf(t, e));
  }
  function F1e(t, e, n) {
    const r = hd(t, e);
    return r ? !r.segmentsHidden.has(n) : false;
  }
  function B1e(t) {
    const e = Kn(t);
    if (e) return e.activeSegmentIndex;
  }
  let UA = false;
  function VN() {
    if (UA) return;
    UA = true;
    const t = () => new Worker(new URL("/assets/polySegConverters-Ba4IF1xD.js", import.meta.url), {
      name: "polySeg"
    }), e = Ju(), n = {
      maxWorkerInstances: 1,
      autoTerminateOnIdle: {
        enabled: true,
        idleTimeThreshold: 2e3
      }
    };
    e.registerWorker("polySeg", t, n);
  }
  const qg = /* @__PURE__ */ new Map();
  async function Yy(t, e, n, r) {
    VN();
    const i = await n();
    M1e({
      segmentationId: t,
      type: e,
      data: i
    }), qg.has(t) || qg.set(t, []);
    const a = qg.get(t);
    return a.includes(e) || a.push(e), _1e(r), Lh(t), i;
  }
  function _1e(t) {
    const e = (n) => {
      k1e(n, t);
    };
    t._debouncedUpdateFunction = e, je.removeEventListener(Re.SEGMENTATION_DATA_MODIFIED, t._debouncedUpdateFunction), je.addEventListener(Re.SEGMENTATION_DATA_MODIFIED, t._debouncedUpdateFunction);
  }
  const k1e = uN((t, e) => {
    const n = t.detail.segmentationId, r = qg.get(n);
    !r || !r.length || (e(n), r.length && Lh(n));
  }, 300), P1e = Ju(), pv = (t, e) => {
    qe(t, ze.WEB_WORKER_PROGRESS, {
      progress: e,
      type: Xc.POLYSEG_CONTOUR_TO_SURFACE
    });
  };
  async function G1e(t, e) {
    const { annotationUIDsMap: n } = t, r = [], i = [], a = n.get(e);
    for (const o of a) {
      const l = Ua(o), { polyline: c } = l.data.contour;
      i.push(c.length), c.forEach((f) => r.push(...f));
    }
    pv(je, 0);
    const s = await P1e.executeTask("polySeg", "convertContourToSurface", {
      polylines: r,
      numPointsArray: i
    }, {
      callbacks: [
        (o) => {
          pv(je, o);
        }
      ]
    });
    return pv(je, 1), s;
  }
  async function NN(t, e, n = {}) {
    let r, i;
    n.segmentationRepresentationUID && ({ segmentationRepresentation: r, toolGroupId: i } = eN(n.segmentationRepresentationUID));
    const a = Kn(t), s = /* @__PURE__ */ new Map(), o = Object.keys(e).map(async (l) => {
      const c = e[l], f = c.segmentIndex, u = r;
      if (IN(i, r.segmentationRepresentationUID, f).slice(0, 3), !u) throw new Error("No color found for segment index, unable to create surface");
      const h = {
        id: `segmentation_${a.segmentationId}_surface_${f}`,
        color: u,
        frameOfReferenceUID: "test-frameOfReferenceUID",
        data: {
          points: c.data.points,
          polys: c.data.polys
        }
      }, g = h.id;
      return s.set(f, g), fce(g, {
        type: Ao.SURFACE,
        geometryData: h
      });
    });
    return await Promise.all(o), {
      geometryIds: s
    };
  }
  const z1e = Ju(), mv = (t, e) => {
    qe(t, ze.WEB_WORKER_PROGRESS, {
      progress: e,
      type: Xc.POLYSEG_LABELMAP_TO_SURFACE
    });
  };
  async function W1e(t, e, n = true) {
    let r;
    if (n) r = t.volumeId;
    else {
      const { imageIdReferenceMap: u } = t;
      ({ volumeId: r } = await R1e({
        imageIdReferenceMap: u
      }));
    }
    const i = Ke.getVolume(r), a = i.getScalarData(), { dimensions: s, spacing: o, origin: l, direction: c } = i;
    mv(je, 0);
    const f = await z1e.executeTask("polySeg", "convertLabelmapToSurface", {
      scalarData: a,
      dimensions: s,
      spacing: o,
      origin: l,
      direction: c,
      segmentIndex: e
    }, {
      callbacks: [
        (u) => {
          mv(je, u);
        }
      ]
    });
    return mv(je, 1), f;
  }
  async function H1e(t, e = {}) {
    var _a3;
    const n = ((_a3 = e.segmentIndices) == null ? void 0 : _a3.length) ? e.segmentIndices : us(t);
    let r;
    const i = Kn(t), a = i.representationData;
    try {
      a.CONTOUR ? r = await j1e(t, {
        segmentIndices: n,
        ...e
      }) : a.LABELMAP && (r = await qy(i.segmentationId, {
        segmentIndices: n,
        ...e
      }));
    } catch (o) {
      throw console.error(o), o;
    }
    if (!r) throw new Error("Not enough data to convert to surface, currently only support converting volume labelmap to surface if available");
    return await NN(t, r, e);
  }
  async function qy(t, e = {}) {
    var _a3;
    const n = Kn(t);
    if (!((_a3 = n == null ? void 0 : n.representationData) == null ? void 0 : _a3.LABELMAP)) {
      console.warn("Only support surface update from labelmaps");
      return;
    }
    const r = ud(n.representationData.LABELMAP), i = n.representationData.LABELMAP, a = e.segmentIndices || us(t), s = a.map((f) => W1e(i, f, r)), o = await Promise.allSettled(s), l = o.filter((f) => f.status === "rejected");
    if (l.length > 0) throw console.error(l), new Error("Failed to convert labelmap to surface");
    return o.map((f, u) => {
      if (f.status === "fulfilled") return {
        segmentIndex: a[u],
        data: f.value
      };
    }).filter(Boolean);
  }
  async function j1e(t, e = {}) {
    const r = Kn(t).representationData.CONTOUR, a = (e.segmentIndices || us(t)).map(async (o) => {
      const l = await G1e(r, o);
      return {
        segmentIndex: o,
        data: l
      };
    });
    return await Promise.all(a);
  }
  async function K1e(t) {
    const e = await qy(t);
    if (!e) return;
    const n = Kn(t), r = us(t);
    if (!r.length) {
      n.representationData.SURFACE.geometryIds.forEach((s) => {
        const l = Ke.getGeometry(s).data;
        l.setPoints([]), l.setPolys([]);
      }), Lh(t);
      return;
    }
    const i = e.map(({ data: a, segmentIndex: s }) => {
      const o = `segmentation_${t}_surface_${s}`, l = Ke.getGeometry(o);
      if (l) if (r.includes(s)) {
        const c = l.data;
        c.setPoints(a.points), c.setPolys(a.polys);
      } else {
        const c = l.data;
        c.setPoints([]), c.setPolys([]);
      }
      else return fd(t).map((f) => ya(f).map((h) => {
        if (h.type === Nt.Surface) return n.representationData.SURFACE.geometryIds.set(s, o), NN(t, [
          {
            segmentIndex: s,
            data: a
          }
        ], {
          segmentationRepresentationUID: h.segmentationRepresentationUID
        });
      }));
    });
    await Promise.all(i), Lh(t);
  }
  function Y1e(t, e = {}) {
    return Yy(t, Nt.Surface, () => H1e(t, e), () => K1e(t));
  }
  const LN = Ju(), bu = (t, e) => {
    qe(t, ze.WEB_WORKER_PROGRESS, {
      progress: e,
      type: Xc.POLYSEG_CONTOUR_TO_LABELMAP
    });
  };
  async function q1e(t, e = {}) {
    const { viewport: n } = e, r = bI(n);
    if (!r) throw new Error("No imageIds found, labelmap computation from contour requires viewports with imageIds");
    const i = gi(), a = O5(r, i), { metadata: s, dimensions: o, origin: l, direction: c, spacing: f, scalarData: u } = a, h = await $O({
      dimensions: o,
      origin: l,
      direction: c,
      spacing: f,
      metadata: s,
      imageIds: r.map((y) => `generated://${y}`),
      referencedImageIds: r
    }, i), { segmentIndices: g, annotationUIDsInSegmentMap: v } = UN(t, e);
    bu(je, 0);
    const m = await LN.executeTask("polySeg", "convertContourToVolumeLabelmap", {
      segmentIndices: g,
      dimensions: o,
      scalarData: u,
      origin: l,
      direction: c,
      spacing: f,
      annotationUIDsInSegmentMap: v
    }, {
      callbacks: [
        (y) => {
          bu(je, y);
        }
      ]
    });
    return bu(je, 1), h.imageData.getPointData().getScalars().setData(m), h.imageData.modified(), h.modified(), {
      volumeId: h.volumeId
    };
  }
  async function X1e(t, e = {}) {
    if (!e.viewport) throw new Error("No viewport provided, labelmap computation from contour requires viewports");
    const r = e.viewport.getImageIds();
    if (!r) throw new Error("No imageIds found, labelmap computation from contour requires viewports with imageIds");
    r.forEach((f) => {
      if (!Ke.getImageLoadObject(f)) throw new Error("ImageIds must be cached before converting contour to labelmap");
    });
    const { imageIds: i } = await Gre(r), { segmentIndices: a, annotationUIDsInSegmentMap: s } = UN(t, e), o = /* @__PURE__ */ new Map();
    i.forEach((f, u) => {
      const h = Ke.getImage(f), g = Ct(ma.IMAGE_PLANE, f);
      let { columnCosines: v, rowCosines: m, rowPixelSpacing: y, columnPixelSpacing: w, imagePositionPatient: C } = g;
      v = v ?? [
        0,
        1,
        0
      ], m = m ?? [
        1,
        0,
        0
      ], y = y ?? 1, w = w ?? 1, C = C ?? [
        0,
        0,
        0
      ];
      const T = Ue(m[0], m[1], m[2]), S = Ue(v[0], v[1], v[2]), E = He();
      Vr(E, T, S);
      const b = [
        ...T,
        ...S,
        ...E
      ], D = [
        y,
        w,
        1
      ], R = C;
      o.set(r[u], {
        direction: b,
        spacing: D,
        origin: R,
        scalarData: h.getPixelData(),
        imageId: f,
        dimensions: [
          h.width,
          h.height,
          1
        ]
      });
    }), bu(je, 0);
    const l = await LN.executeTask("polySeg", "convertContourToStackLabelmap", {
      segmentationsInfo: o,
      annotationUIDsInSegmentMap: s,
      segmentIndices: a
    }, {
      callbacks: [
        (f) => {
          bu(je, f);
        }
      ]
    });
    bu(je, 1);
    const c = /* @__PURE__ */ new Map();
    return l.forEach(({ scalarData: f }, u) => {
      var _a3, _b3;
      const h = o.get(u), { imageId: g } = h, v = Ke.getImage(g);
      v.getPixelData().set(f), (_b3 = (_a3 = v.imageFrame) == null ? void 0 : _a3.pixelData) == null ? void 0 : _b3.set(f), c.set(u, g);
    }), {
      imageIdReferenceMap: c
    };
  }
  function UN(t, e = {}) {
    var _a3;
    const n = t.annotationUIDsMap, r = ((_a3 = e.segmentIndices) == null ? void 0 : _a3.length) ? e.segmentIndices : Array.from(n.keys()), i = /* @__PURE__ */ new Map();
    return r.forEach((a) => {
      const s = n.get(a);
      let o = Array.from(s);
      o = o.filter((c) => !Ua(c).parentAnnotationUID);
      const l = o.map((c) => {
        var _a4;
        const f = Ua(c), u = (_a4 = f.childAnnotationUIDs) == null ? void 0 : _a4.length;
        return {
          polyline: f.data.contour.polyline,
          referencedImageId: f.metadata.referencedImageId,
          holesPolyline: u && f.childAnnotationUIDs.map((h) => Ua(h).data.contour.polyline)
        };
      });
      i.set(a, l);
    }), {
      segmentIndices: r,
      annotationUIDsInSegmentMap: i
    };
  }
  const Z1e = Ju(), vv = (t, e) => {
    qe(t, ze.WEB_WORKER_PROGRESS, {
      progress: e,
      type: Xc.POLYSEG_SURFACE_TO_LABELMAP
    });
  };
  async function Q1e(t, e) {
    const { geometryIds: n } = t;
    if (!(n == null ? void 0 : n.size)) throw new Error("No geometry IDs found for surface representation");
    const r = /* @__PURE__ */ new Map();
    n.forEach((c, f) => {
      const h = Ke.getGeometry(c).data, g = h.getPoints(), v = h.getPolys();
      r.set(f, {
        points: g,
        polys: v
      });
    });
    const { dimensions: i, direction: a, origin: s, spacing: o } = e;
    vv(je, 0);
    const l = await Z1e.executeTask("polySeg", "convertSurfacesToVolumeLabelmap", {
      segmentsInfo: r,
      dimensions: i,
      spacing: o,
      direction: a,
      origin: s
    }, {
      callbacks: [
        (c) => {
          vv(je, c);
        }
      ]
    });
    return vv(je, 1), e.imageData.getPointData().getScalars().setData(l), e.imageData.modified(), e.modified(), {
      volumeId: e.volumeId
    };
  }
  async function J1e(t, e = {}) {
    var _a3;
    const n = ((_a3 = e.segmentIndices) == null ? void 0 : _a3.length) ? e.segmentIndices : us(t);
    let r;
    const i = Kn(t), a = i.representationData;
    try {
      a.CONTOUR ? r = await $1e(t, {
        segmentIndices: n,
        ...e
      }) : a.SURFACE && (r = await ehe(i.segmentationId, {
        segmentIndices: n,
        ...e
      }));
    } catch (s) {
      throw console.error(s), s;
    }
    if (!r) throw new Error("Not enough data to convert to surface, currently only support converting volume labelmap to surface if available");
    return r;
  }
  async function $1e(t, e = {}) {
    var _a3;
    const n = e.viewport instanceof Ba;
    if (n && !e.viewport) throw new Error("Cannot compute labelmap from contour segmentation without providing the viewport");
    const r = ((_a3 = e.segmentIndices) == null ? void 0 : _a3.length) ? e.segmentIndices : us(t), a = Kn(t).representationData.CONTOUR;
    return await (n ? q1e : X1e)(a, {
      segmentIndices: r,
      segmentationRepresentationUID: e.segmentationRepresentationUID,
      viewport: e.viewport
    });
  }
  async function ehe(t, e = {}) {
    var _a3;
    const n = e.viewport instanceof Ba, r = ((_a3 = e.segmentIndices) == null ? void 0 : _a3.length) ? e.segmentIndices : us(t), i = Kn(t), a = /* @__PURE__ */ new Map();
    if (i.representationData.SURFACE.geometryIds.forEach((f, u) => {
      r.includes(u) && a.set(u, f);
    }), n && !e.viewport) throw new Error("Cannot compute labelmap from surface segmentation without providing the viewport");
    let o;
    if (n) {
      const f = e.viewport.getDefaultActor(), { uid: u } = f;
      o = await Ire(u);
    } else {
      const f = e.viewport.getImageIds(), u = "generatedSegmentationVolumeId", h = O5(f, u);
      delete h.imageIds, o = await $O({
        ...h,
        scalarData: h.scalarData,
        referencedImageIds: f
      }, u);
    }
    const l = await Q1e({
      geometryIds: a
    }, o);
    return n ? l : await O1e({
      volumeId: o.volumeId
    });
  }
  function the(t, e = {}) {
    return Yy(t, Nt.Labelmap, () => J1e(t, e), () => {
    });
  }
  const FN = Ju(), N6 = /* @__PURE__ */ new Map(), L6 = /* @__PURE__ */ new Map(), Xg = (t, e) => {
    qe(t, ze.WEB_WORKER_PROGRESS, {
      progress: e,
      type: Xc.SURFACE_CLIPPING
    });
  };
  async function BN(t, e, n) {
    var _a3;
    VN();
    const r = (_a3 = e.getSlicesClippingPlanes) == null ? void 0 : _a3.call(e);
    if (!r) return;
    const i = e.getSliceIndex();
    r.sort((o, l) => {
      const c = Math.abs(o.sliceIndex - i), f = Math.abs(l.sliceIndex - i);
      return c - f;
    }), Xg(je, 0), await nhe(t);
    const a = /* @__PURE__ */ new Map();
    t.forEach((o) => {
      a.set(o.id, L6.get(o.id));
    });
    const s = e.getCamera();
    return await FN.executeTask("polySeg", "cutSurfacesIntoPlanes", {
      surfacesInfo: t,
      planesInfo: r,
      surfacesAABB: a
    }, {
      callbacks: [
        ({ progress: o }) => {
          Xg(je, o);
        },
        ({ sliceIndex: o, polyDataResults: l }) => {
          l.forEach((c, f) => {
            const u = `${n}_${f}`, h = ihe(e, s.viewPlaneNormal, o);
            ahe(u, h, c);
          });
        }
      ]
    }).catch((o) => {
      console.error(o);
    }), Xg(je, 1), N6;
  }
  async function nhe(t) {
    const e = t.filter((r) => !L6.has(r.id));
    if (!e.length) return;
    (await FN.executeTask("polySeg", "getSurfacesAABBs", {
      surfacesInfo: e
    }, {
      callbacks: [
        ({ progress: r }) => {
          Xg(je, r);
        }
      ]
    })).forEach((r, i) => {
      L6.set(i, r);
    });
  }
  function rhe(t, e) {
    return `${t}_${e}`;
  }
  function ihe(t, e, n) {
    return `${t.id}-${ife(e)}-${n}`;
  }
  function ahe(t, e, n) {
    const { points: r, lines: i, numberOfCells: a } = n;
    let s = N6.get(t);
    s || (s = /* @__PURE__ */ new Map(), N6.set(t, s)), s.set(e, {
      points: r,
      lines: i,
      numberOfCells: a
    });
  }
  function _N(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const [r, i] of t) {
      const a = r.split("_")[1];
      for (const [s, o] of i) {
        if (!o) continue;
        const l = Number(a) || (e == null ? void 0 : e.get(a));
        l && (n.has(l) || n.set(l, []), n.get(l).push(o));
      }
    }
    return n;
  }
  function she(t, e, n) {
    const r = /* @__PURE__ */ new Map();
    for (const [i, a] of t) for (const s of a) {
      const { points: o } = s, { lineSegments: l, linesNumberOfPoints: c } = ohe(s);
      for (let f = 0; f < l.length; f++) {
        const u = l[f], h = [];
        for (let m = 0; m < c[f]; m++) {
          const y = u[m];
          h.push([
            o[3 * y],
            o[3 * y + 1],
            o[3 * y + 2]
          ]);
        }
        if (h.length < 3) continue;
        const g = {
          annotationUID: gi(),
          data: {
            contour: {
              closed: true,
              polyline: h
            },
            segmentation: {
              segmentationId: n,
              segmentIndex: i
            },
            handles: {}
          },
          handles: {},
          highlighted: false,
          autoGenerated: false,
          invalidated: false,
          isLocked: false,
          isVisible: true,
          metadata: {
            toolName: e0.toolName,
            ...e.getViewReference()
          }
        };
        uf(g, e.element);
        const v = r.get(i) || /* @__PURE__ */ new Set();
        v.add(g.annotationUID), r.set(i, v);
      }
    }
    return r;
  }
  const ohe = (t) => {
    const { numberOfCells: e, lines: n } = t, r = [], i = [];
    for (let a = 0; a < n.length; ) {
      const s = n[a];
      if (i.push(s), r.push(n.slice(a + 1, a + s + 1)), a += s + 1, r.length === e) break;
    }
    return {
      lineSegments: r,
      linesNumberOfPoints: i
    };
  };
  async function lhe(t, e = {}) {
    var _a3, _b3;
    const n = ((_a3 = e.segmentIndices) == null ? void 0 : _a3.length) ? e.segmentIndices : us(t);
    let r;
    const a = Kn(t).representationData;
    try {
      a.SURFACE ? r = await uhe(t, {
        segmentIndices: n,
        ...e
      }) : a.LABELMAP && (r = await che(t, {
        segmentIndices: n,
        ...e
      }));
    } catch (f) {
      throw console.error(f), f;
    }
    if (!r) throw new Error("Not enough data to convert to contour, currently only support converting volume labelmap to contour if available");
    const { viewport: s, segmentationRepresentationUID: o } = e, l = she(r, s, t), c = (_b3 = pi(s.id)) == null ? void 0 : _b3.id;
    return uue(c, o, {
      CONTOUR: {
        fillAlpha: 0
      }
    }), {
      annotationUIDsMap: l
    };
  }
  async function che(t, e = {}) {
    if (!e.viewport) throw new Error("Viewport is required to compute contour from labelmap");
    const n = await qy(t, e);
    if (!(n == null ? void 0 : n.length)) {
      console.error("Failed to convert labelmap to surface or labelmap is empty");
      return;
    }
    const { viewport: r, segmentationRepresentationUID: i } = e, a = n.map((l) => ({
      id: l.segmentIndex.toString(),
      points: l.data.points,
      polys: l.data.polys,
      segmentIndex: l.segmentIndex
    })), s = await BN(a, r, i);
    return _N(s);
  }
  async function uhe(t, e = {}) {
    var _a3;
    if (!e.viewport) throw new Error("Viewport is required to compute contour from surface");
    const { viewport: n, segmentationRepresentationUID: r } = e, i = ((_a3 = e.segmentIndices) == null ? void 0 : _a3.length) ? e.segmentIndices : us(t), a = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), l = Kn(t).representationData.SURFACE, c = [];
    l.geometryIds.forEach((h, g) => {
      var _a4;
      if (i.includes(g)) {
        a.set(g, h);
        const v = (_a4 = Ke.getGeometry(h)) == null ? void 0 : _a4.data;
        v && c.push({
          id: h,
          points: v.getPoints(),
          polys: v.getPolys()
        });
      }
    }), a.forEach((h, g) => {
      s.set(h, g);
    });
    const f = await BN(c, n, r);
    return _N(f, s);
  }
  function fhe(t, e = {}) {
    return Yy(t, Nt.Contour, () => lhe(t, e), () => {
    });
  }
  const hhe = /* @__PURE__ */ new Map([
    [
      Nt.Labelmap,
      /* @__PURE__ */ new Set([
        Nt.Surface,
        Nt.Contour
      ])
    ],
    [
      Nt.Contour,
      /* @__PURE__ */ new Set([
        Nt.Labelmap,
        Nt.Surface
      ])
    ],
    [
      Nt.Surface,
      /* @__PURE__ */ new Set([
        Nt.Labelmap
      ])
    ]
  ]);
  function Xy(t) {
    const e = eN(t);
    if (!(e == null ? void 0 : e.segmentationRepresentation)) return false;
    const { segmentationRepresentation: n } = e, { type: r, polySeg: i } = n;
    if (!i || !i.enabled) return false;
    const { representationData: a } = Kn(n.segmentationId);
    return dhe(a).some((o) => ghe(o, r));
  }
  function dhe(t) {
    const e = [];
    return Object.keys(t).forEach((n) => {
      const r = t[n];
      let i;
      switch (n) {
        case Nt.Labelmap:
          i = Due;
          break;
      }
      if (i) try {
        i(r), e.push(n);
      } catch {
        console.warn(`Validation failed for labelmap of type ${n}`);
      }
      else e.push(n);
    }), e;
  }
  async function ghe(t, e) {
    var _a3;
    return ((_a3 = hhe.get(t)) == null ? void 0 : _a3.has(e)) || false;
  }
  class Zp extends of {
    constructor(e = {}, n = {
      supportedInteractionTypes: [
        "Mouse",
        "Touch"
      ],
      configuration: {
        invert: false,
        debounceIfNotLoaded: true,
        loop: false,
        scrollSlabs: false
      }
    }) {
      super(e, n);
    }
    mouseWheelCallback(e) {
      const { wheel: n, element: r } = e.detail, { direction: i } = n, { invert: a } = this.configuration, { viewport: s } = pt(r), o = i * (a ? -1 : 1);
      let l;
      s instanceof Ga && (l = this.getTargetVolumeId(s)), tfe(s, {
        delta: o,
        debounceLoading: this.configuration.debounceIfNotLoaded,
        loop: this.configuration.loop,
        volumeId: l,
        scrollSlabs: this.configuration.scrollSlabs
      });
    }
  }
  Zp.toolName = "StackScrollMouseWheel";
  class Qp extends of {
    constructor(e = {}, n = {
      supportedInteractionTypes: [
        "Mouse",
        "Touch"
      ],
      configuration: {
        zoomToCenter: false,
        minZoomScale: 1e-3,
        maxZoomScale: 3e3,
        pinchToZoom: true,
        pan: true,
        invert: false
      }
    }) {
      super(e, n), this.preMouseDownCallback = (r) => {
        const i = r.detail, { element: a, currentPoints: s } = i, o = s.world, c = pt(a).viewport.getCamera(), { focalPoint: f } = c;
        this.initialMousePosWorld = o;
        let u = Ue(f[0] - o[0], f[1] - o[1], f[2] - o[2]);
        return u = Pr(He(), u), this.dirVec = u, false;
      }, this.preTouchStartCallback = (r) => {
        if (!this.configuration.pinchToZoom) return this.preMouseDownCallback(r);
      }, this._dragParallelProjection = (r, i, a, s = false) => {
        const { element: o, deltaPoints: l } = r.detail, c = s ? r.detail.deltaDistance.canvas : l.canvas[1], f = [
          o.clientWidth,
          o.clientHeight
        ], { parallelScale: u, focalPoint: h, position: g } = a, v = 5 / f[1], m = c * v * (this.configuration.invert ? -1 : 1), y = (1 - m) * u;
        let w = h, C = g;
        if (!this.configuration.zoomToCenter) {
          const L = Mu(h, this.initialMousePosWorld);
          C = Xr(He(), g, this.dirVec, -L * m), w = Xr(He(), h, this.dirVec, -L * m);
        }
        const T = i.getImageData();
        let S = [
          1,
          1,
          1
        ];
        T && (S = T.spacing);
        const { minZoomScale: E, maxZoomScale: b } = this.configuration, D = o.clientHeight * S[1] * 0.5, R = D / y;
        let I = y, O = false;
        T && (R < E ? (I = D / E, O = true) : R >= b && (I = D / b, O = true)), i.setCamera({
          parallelScale: I,
          focalPoint: O ? h : w,
          position: O ? g : C
        });
      }, this._dragPerspectiveProjection = (r, i, a, s = false) => {
        const { element: o, deltaPoints: l } = r.detail, c = s ? r.detail.deltaDistance.canvas : l.canvas[1], f = [
          o.clientWidth,
          o.clientHeight
        ], { position: u, focalPoint: h, viewPlaneNormal: g } = a, v = La.distance2BetweenPoints(u, h), m = Math.sqrt(v) / f[1], y = [
          -g[0],
          -g[1],
          -g[2]
        ], w = this.configuration.invert ? c / m : c * m;
        let C = w * y[0];
        u[0] += C, h[0] += C, C = w * y[1], u[1] += C, h[1] += C, C = w * y[2], u[2] += C, h[2] += C, i.setCamera({
          position: u,
          focalPoint: h
        });
      }, this.initialMousePosWorld = [
        0,
        0,
        0
      ], this.dirVec = [
        0,
        0,
        0
      ], this.configuration.pinchToZoom ? this.touchDragCallback = this._pinchCallback.bind(this) : this.touchDragCallback = this._dragCallback.bind(this), this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _pinchCallback(e) {
      if (e.detail.currentPointsList.length > 1) {
        const { element: r, currentPoints: i } = e.detail, a = pt(r), { viewport: s } = a, o = s.getCamera(), l = i.world, { focalPoint: c } = o;
        this.initialMousePosWorld = l;
        let f = Ue(c[0] - l[0], c[1] - l[1], c[2] - l[2]);
        f = Pr(He(), f), this.dirVec = f, o.parallelProjection ? this._dragParallelProjection(e, s, o, true) : this._dragPerspectiveProjection(e, s, o, true), s.render();
      }
      this.configuration.pan && this._panCallback(e);
    }
    _dragCallback(e) {
      const { element: n } = e.detail, r = pt(n), { viewport: i } = r, a = i.getCamera();
      a.parallelProjection ? this._dragParallelProjection(e, i, a) : this._dragPerspectiveProjection(e, i, a), i.render();
    }
    _panCallback(e) {
      const { element: n, deltaPoints: r } = e.detail, i = pt(n), a = r.world, s = i.viewport.getCamera(), { focalPoint: o, position: l } = s, c = [
        l[0] - a[0],
        l[1] - a[1],
        l[2] - a[2]
      ], f = [
        o[0] - a[0],
        o[1] - a[1],
        o[2] - a[2]
      ];
      i.viewport.setCamera({
        focalPoint: f,
        position: c
      }), i.viewport.render();
    }
  }
  Qp.toolName = "Zoom";
  function phe(t, e, n) {
    return t === "CT" ? "HU" : t === "PT" ? mhe(e, n) : "";
  }
  function mhe(t, e) {
    var _a3, _b3;
    if (!e.isPreScaled) return "raw";
    if (e.isSuvScaled) return "SUV";
    if (((_a3 = Ct("generalSeriesModule", t)) == null ? void 0 : _a3.modality) === "PT") return ((_b3 = Ct("petSeriesModule", t)) == null ? void 0 : _b3.units) || "unitless";
  }
  const W5 = (t) => {
    if (t.shiftKey) return t.ctrlKey ? ga.ShiftCtrl : t.altKey ? ga.ShiftAlt : t.metaKey ? ga.ShiftMeta : ga.Shift;
    if (t.ctrlKey) return t.altKey ? ga.CtrlAlt : t.metaKey ? ga.CtrlMeta : ga.Ctrl;
    if (t.altKey) return t.metaKey && ga.AltMeta || ga.Alt;
    if (t.metaKey) return ga.Meta;
  };
  class vhe extends JV {
    constructor(e, n) {
      super(e, n);
    }
    renderAnnotation(e, n) {
      let r = false;
      const { viewport: i } = e, { element: a } = i;
      if (!i.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), r;
      let s = Wu(this.getToolName(), a);
      if (!(s == null ? void 0 : s.length) || (s = this.filterInteractableAnnotationsForElement(a, s), !(s == null ? void 0 : s.length))) return r;
      const o = this.getTargetId(i), l = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: e.viewport.id
      };
      for (let c = 0; c < s.length; c++) {
        const f = s[c];
        l.annotationUID = f.annotationUID;
        const u = this.getAnnotationStyle({
          annotation: f,
          styleSpecifier: l
        });
        if (!u.visibility) continue;
        const h = this.renderAnnotationInstance({
          enabledElement: e,
          targetId: o,
          annotation: f,
          annotationStyle: u,
          svgDrawingHelper: n
        });
        r || (r = h), f.invalidated = false;
      }
      return r;
    }
    createAnnotation(e) {
      const n = e.detail, { currentPoints: r, element: i } = n, { world: a } = r, s = pt(i), { viewport: o } = s, l = o.getCamera(), { viewPlaneNormal: c, viewUp: f, position: u } = l, h = this.getReferencedImageId(o, a, c, f), g = o.getViewReference({
        points: [
          a
        ]
      });
      return {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          ...g,
          referencedImageId: h,
          viewUp: f,
          cameraPosition: u
        },
        data: {
          handles: {
            points: [],
            activeHandleIndex: null,
            textBox: {
              hasMoved: false,
              worldPosition: [
                0,
                0,
                0
              ],
              worldBoundingBox: {
                topLeft: [
                  0,
                  0,
                  0
                ],
                topRight: [
                  0,
                  0,
                  0
                ],
                bottomLeft: [
                  0,
                  0,
                  0
                ],
                bottomRight: [
                  0,
                  0,
                  0
                ]
              }
            }
          },
          contour: {
            polyline: [],
            closed: false
          }
        },
        interpolationUID: "",
        autoGenerated: false
      };
    }
    addAnnotation(e, n) {
      return uf(e, n);
    }
    cancelAnnotation(e) {
    }
    moveAnnotation(e, n) {
      const { points: r } = e.data.handles;
      for (let i = 0, a = r.length; i < a; i++) {
        const s = r[i];
        s[0] += n[0], s[1] += n[1], s[2] += n[2];
      }
      e.invalidated = true, NL(e).forEach((i) => this.moveAnnotation(i, n));
    }
    updateContourPolyline(e, n, r) {
      var _a3;
      const i = ((_a3 = this.configuration) == null ? void 0 : _a3.decimate) || {};
      zl(e, n, r, {
        decimate: {
          enabled: !!i.enabled,
          epsilon: i.epsilon
        }
      });
    }
    getPolylinePoints(e) {
      var _a3;
      return ((_a3 = e.data.contour) == null ? void 0 : _a3.polyline) ?? e.data.polyline;
    }
    renderAnnotationInstance(e) {
      const { enabledElement: n, annotationStyle: r, svgDrawingHelper: i } = e, a = e.annotation;
      if (a.parentAnnotationUID) return;
      const { annotationUID: s } = a, { viewport: o } = n, { worldToCanvas: l } = o, c = this.getPolylinePoints(a).map((w) => l(w)), { lineWidth: f, lineDash: u, color: h, fillColor: g, fillOpacity: v } = r, m = P5(a, o), y = [
        c,
        ...m
      ];
      return Au(i, s, "contourPolyline", y, {
        color: h,
        lineDash: u,
        lineWidth: Math.max(0.1, f),
        fillColor: g,
        fillOpacity: v
      }), true;
    }
  }
  class yhe extends vhe {
    constructor(e, n) {
      var _a3;
      super(e, n), ((_a3 = this.configuration.interpolation) == null ? void 0 : _a3.enabled) && To.addTool(this.getToolName());
    }
    isContourSegmentationTool() {
      return true;
    }
    createAnnotation(e) {
      const { toolGroupId: n } = this, r = super.createAnnotation(e);
      if (!this.isContourSegmentationTool()) return r;
      const i = V1e(n);
      if (!i) throw new Error("No active segmentation detected, create one before using scissors tool");
      const { type: a } = i;
      if (a !== Nt.Contour) throw new Error("A contour segmentation must be active");
      const { segmentationId: s } = i, o = B1e(s);
      return zi(r, {
        data: {
          segmentation: {
            segmentationId: s,
            segmentIndex: o
          }
        }
      });
    }
    addAnnotation(e, n) {
      const r = super.addAnnotation(e, n);
      return this.isContourSegmentationTool() && Uh(e), r;
    }
    cancelAnnotation(e) {
      this.isContourSegmentationTool() && Uy(e), super.cancelAnnotation(e);
    }
    getAnnotationStyle(e) {
      const n = super.getAnnotationStyle(e);
      if (!this.isContourSegmentationTool()) return n;
      const r = this._getContourSegmentationStyle(e);
      return zi(n, r);
    }
    renderAnnotationInstance(e) {
      const { annotation: n } = e, { invalidated: r } = n, i = super.renderAnnotationInstance(e);
      if (r && this.isContourSegmentationTool()) {
        const { segmentationId: a } = n.data.segmentation;
        $V(a);
        const s = fd(a);
        efe(s);
      }
      return i;
    }
    _getContourSegmentationStyle(e) {
      var _a3, _b3;
      const { toolGroupId: n } = this, r = e.annotation, { segmentationId: i, segmentIndex: a } = r.data.segmentation, s = Kn(i), o = this._getSegmentationRepresentation(i);
      if (!o) return {};
      const { segmentationRepresentationUID: l } = o, { active: c } = o, { autoGenerated: f } = r, h = N1e(i).includes(a), g = IN(n, l, a), v = L1e(n, l), m = oN(), y = Fy(n), w = Hue(n, l), C = jue(n, l, a), T = F1e(n, l, a), S = Object.assign({}, ((_a3 = m == null ? void 0 : m.representations) == null ? void 0 : _a3.CONTOUR) ?? {}, ((_b3 = y == null ? void 0 : y.representations) == null ? void 0 : _b3.CONTOUR) ?? {}, (w == null ? void 0 : w.CONTOUR) ?? {}, (C == null ? void 0 : C.CONTOUR) ?? {});
      let E = 1, b, D = 1, R = 0;
      f ? (E = S.outlineWidthAutoGenerated ?? E, b = S.outlineDashAutoGenerated ?? b, D = S.outlineOpacity ?? D, R = S.fillAlphaAutoGenerated ?? R) : c ? (E = S.outlineWidthActive ?? E, b = S.outlineDashActive ?? b, D = S.outlineOpacity ?? D, R = S.fillAlpha ?? R) : (E = S.outlineWidthInactive ?? E, b = S.outlineDashInactive ?? b, D = S.outlineOpacityInactive ?? D, R = S.fillAlphaInactive ?? R), s.activeSegmentIndex === a && (E += S.activeSegmentOutlineWidthDelta), E = S.renderOutline ? E : 0, R = S.renderFill ? R : 0;
      const I = `rgba(${g[0]}, ${g[1]}, ${g[2]}, ${D})`, O = `rgb(${g[0]}, ${g[1]}, ${g[2]})`;
      return {
        color: I,
        fillColor: O,
        lineWidth: E,
        fillOpacity: R,
        lineDash: b,
        textbox: {
          color: I
        },
        visibility: v && T,
        locked: h
      };
    }
    _getSegmentationRepresentation(e) {
      const r = ya(this.toolGroupId).filter((i) => i.segmentationId === e);
      if (!r) {
        console.warn(`No segmentation representation found for toolGroupId: ${this.toolGroupId}`);
        return;
      }
      return ya(this.toolGroupId).length > 1 && console.warn("Multiple segmentation representations detected for this tool group. The first one will be used."), r[0];
    }
  }
  function H5(t, e) {
    var _a3, _b3;
    return (e == null ? void 0 : e.autoGenerated) ? false : ((_a3 = t == null ? void 0 : t.smoothing) == null ? void 0 : _a3.smoothOnAdd) === true || ((_b3 = t == null ? void 0 : t.smoothing) == null ? void 0 : _b3.smoothOnEdit) === true;
  }
  function xhe(t, e) {
    return hN(t, e) < 1e-3;
  }
  function whe(t, e) {
    return hN(t, e) === 0;
  }
  function Che(t, e) {
    for (let n = 0; n < t.length; n++) for (let r = 0; r < e.length; r++) if (whe(t[n], e[r])) return [
      n,
      r
    ];
  }
  function pu(t, e, n) {
    return (t + e + n) % e;
  }
  function FA(t, e, n, r) {
    const [, i, a] = t, [, s, o] = e, l = a.length, c = o.length;
    let f = t[0], u = e[0];
    if (!a[f] || !o[u] || !a[i] || !o[s]) return [
      void 0,
      void 0
    ];
    for (; f !== i && u !== s; ) {
      if (n(o[u], a[f])) return [
        f,
        u
      ];
      f = pu(f, l, r), u = pu(u, c, r);
    }
    return [
      void 0,
      void 0
    ];
  }
  function The(t, e) {
    const [n, r] = Che(t, e) || [], i = (l, c) => xhe(l, c) === false, [a, s] = FA([
      pu(n, t.length, 1),
      n,
      t
    ], [
      pu(r, e.length, 1),
      r,
      e
    ], i, 1), [o] = FA([
      pu(a, t.length, -1),
      a,
      t
    ], [
      pu(s, e.length, -1),
      s,
      e
    ], i, -1);
    return [
      a,
      o
    ];
  }
  function j5(t, e, n) {
    const { interpolation: r, smoothing: i } = t, a = e;
    if (r) {
      const { knotsRatioPercentageOnAdd: s, knotsRatioPercentageOnEdit: o, smoothOnAdd: l = false, smoothOnEdit: c = false } = i, f = n ? o : s;
      if (n ? c : l) {
        const [h, g] = n ? The(e, n) : [
          0,
          e.length - 1
        ];
        return !e[h] || !e[g] ? e : A1e(e, h, g, f);
      }
    }
    return a;
  }
  function Zy(t, e) {
    const n = t[0], r = t[t.length - 1], i = mo();
    mu(i, r[0] - n[0], r[1] - n[1]), j6(i, i);
    const a = mo(), s = mo();
    mu(a, -i[1], i[0]), mu(s, i[1], -i[0]);
    const o = [
      (n[0] + r[0]) / 2,
      (n[1] + r[1]) / 2
    ], l = {
      dist: 0,
      index: null
    };
    for (let u = 0; u < t.length; u++) {
      const h = t[u], g = K6(h, o);
      g > l.dist && (l.dist = g, l.index = u);
    }
    return [
      t[l.index],
      o
    ].map(e.canvasToWorld);
  }
  function She(t, e) {
    const { viewport: n } = t, r = e.data.contour.polyline.map(n.worldToCanvas);
    return Zy(r, n);
  }
  const { addCanvasPointsToArray: Qy, pointsAreWithinCloseContourProximity: kN, getFirstLineSegmentIntersectionIndexes: PN, getSubPixelSpacingAndXYDirections: Ahe } = o0;
  function Ehe(t, e, n) {
    this.isDrawing = true;
    const r = t.detail, { currentPoints: i, element: a } = r, s = i.canvas, o = pt(a), { viewport: l } = o, c = W5(t.detail.event) === this.configuration.contourHoleAdditionModifierKey, { spacing: f, xDir: u, yDir: h } = Ahe(l, this.configuration.subPixelResolution);
    this.drawData = {
      canvasPoints: [
        s
      ],
      polylineIndex: 0,
      contourHoleProcessingEnabled: c
    }, this.commonData = {
      annotation: e,
      viewportIdsToRender: n,
      spacing: f,
      xDir: u,
      yDir: h,
      movingTextBox: false
    }, yt.isInteractingWithTool = true, a.addEventListener(Re.MOUSE_UP, this.mouseUpDrawCallback), a.addEventListener(Re.MOUSE_DRAG, this.mouseDragDrawCallback), a.addEventListener(Re.MOUSE_CLICK, this.mouseUpDrawCallback), a.addEventListener(Re.TOUCH_END, this.mouseUpDrawCallback), a.addEventListener(Re.TOUCH_DRAG, this.mouseDragDrawCallback), a.addEventListener(Re.TOUCH_TAP, this.mouseUpDrawCallback), z5(a);
  }
  function bhe(t) {
    yt.isInteractingWithTool = false, t.removeEventListener(Re.MOUSE_UP, this.mouseUpDrawCallback), t.removeEventListener(Re.MOUSE_DRAG, this.mouseDragDrawCallback), t.removeEventListener(Re.MOUSE_CLICK, this.mouseUpDrawCallback), t.removeEventListener(Re.TOUCH_END, this.mouseUpDrawCallback), t.removeEventListener(Re.TOUCH_DRAG, this.mouseDragDrawCallback), t.removeEventListener(Re.TOUCH_TAP, this.mouseUpDrawCallback), Ky(t);
  }
  function Dhe(t) {
    const e = t.detail, { currentPoints: n, element: r } = e, i = n.world, a = n.canvas, s = pt(r), { renderingEngine: o, viewport: l } = s, { annotation: c, viewportIdsToRender: f, xDir: u, yDir: h, spacing: g, movingTextBox: v } = this.commonData, { polylineIndex: m, canvasPoints: y } = this.drawData, w = y[y.length - 1], C = l.canvasToWorld(w), T = He();
    Ft(T, i, C);
    const S = Math.abs(Bt(T, u)), E = Math.abs(Bt(T, h));
    if (!(S <= g[0] && E <= g[1])) {
      if (v) {
        this.isDrawing = false;
        const { deltaPoints: b } = e, D = b.world, { textBox: R } = c.data.handles, { worldPosition: I } = R;
        I[0] += D[0], I[1] += D[1], I[2] += D[2], R.hasMoved = true;
      } else {
        const b = this.findCrossingIndexDuringCreate(t);
        if (b !== void 0) this.applyCreateOnCross(t, b);
        else {
          const D = Qy(r, y, a, this.commonData);
          this.drawData.polylineIndex = m + D;
        }
      }
      bi(o, f);
    }
  }
  function Mhe(t) {
    const { allowOpenContours: e } = this.configuration, { canvasPoints: n, contourHoleProcessingEnabled: r } = this.drawData, i = n[0], a = n[n.length - 1], s = t.detail, { element: o } = s;
    e && !kN(i, a, this.configuration.closeContourProximity) ? this.completeDrawOpenContour(o, {
      contourHoleProcessingEnabled: r
    }) : this.completeDrawClosedContour(o, {
      contourHoleProcessingEnabled: r
    });
  }
  function Rhe(t, e) {
    this.removeCrossedLinesOnCompleteDraw();
    const { canvasPoints: n } = this.drawData, { contourHoleProcessingEnabled: r, minPointsToSave: i } = e ?? {};
    if (i && n.length < i || this.haltDrawing(t, n)) return false;
    const { annotation: a, viewportIdsToRender: s } = this.commonData, o = pt(t), { viewport: l, renderingEngine: c } = o;
    Qy(t, n, n[0], this.commonData), n.pop();
    const f = H5(this.configuration, a) ? j5(this.configuration, n) : n;
    this.updateContourPolyline(a, {
      points: f,
      closed: true,
      targetWindingDirection: Gu.Clockwise
    }, l);
    const { textBox: u } = a.data.handles;
    return (u == null ? void 0 : u.hasMoved) || OL(a, r), this.isDrawing = false, this.drawData = void 0, this.commonData = void 0, bi(c, s), this.deactivateDraw(t), true;
  }
  function Ohe() {
    const { canvasPoints: t } = this.drawData, e = t.length, n = [
      t[0],
      t[e - 1]
    ], r = t.slice(0, -1).slice(1), i = PN(r, n[0], n[1], false);
    if (i) {
      const a = i[1];
      a === 1 ? this.drawData.canvasPoints = t.splice(1) : this.drawData.canvasPoints = t.splice(0, a);
    }
  }
  function Ihe(t, e) {
    const { canvasPoints: n } = this.drawData, { contourHoleProcessingEnabled: r } = e ?? {};
    if (this.haltDrawing(t, n)) return false;
    const { annotation: i, viewportIdsToRender: a } = this.commonData, s = pt(t), { viewport: o, renderingEngine: l } = s, c = H5(this.configuration, i) ? j5(this.configuration, n) : n;
    this.updateContourPolyline(i, {
      points: c,
      closed: false
    }, o);
    const { textBox: f } = i.data.handles, u = i.data.contour.polyline;
    return i.data.handles.points = [
      u[0],
      u[u.length - 1]
    ], i.data.isOpenUShapeContour && (i.data.openUShapeContourVectorToPeak = Zy(n, o)), f.hasMoved || OL(i, r), this.isDrawing = false, this.drawData = void 0, this.commonData = void 0, bi(l, a), this.deactivateDraw(t), true;
  }
  function Vhe(t) {
    const e = t.detail, { currentPoints: n, lastPoints: r } = e, i = n.canvas, a = r.canvas, { canvasPoints: s } = this.drawData, o = s.slice(0, -1), l = PN(o, i, a, false);
    return l === void 0 ? void 0 : l[0];
  }
  function Nhe(t, e) {
    const n = t.detail, { element: r } = n, { canvasPoints: i, contourHoleProcessingEnabled: a } = this.drawData, { annotation: s, viewportIdsToRender: o } = this.commonData;
    Qy(r, i, i[e], this.commonData), i.pop();
    const l = i.slice(e), c = ky(l);
    if (zr(c, 0)) {
      i.splice(e + 1);
      return;
    }
    i.splice(0, e);
    const f = {
      contourHoleProcessingEnabled: a,
      minPointsToSave: 3
    };
    this.completeDrawClosedContour(r, f) && this.activateClosedContourEdit(t, s, o);
  }
  function Lhe(t) {
    const { allowOpenContours: e } = this.configuration, { canvasPoints: n, contourHoleProcessingEnabled: r } = this.drawData, i = n[0], a = n[n.length - 1];
    e && !kN(i, a, this.configuration.closeContourProximity) ? this.completeDrawOpenContour(t, {
      contourHoleProcessingEnabled: r
    }) : this.completeDrawClosedContour(t, {
      contourHoleProcessingEnabled: r
    });
  }
  function Uhe(t, e) {
    const n = Math.max(e * 3, 3);
    return t.length < n;
  }
  function Fhe(t, e) {
    const { subPixelResolution: n } = this.configuration;
    if (Uhe(e, n)) {
      const { annotation: r, viewportIdsToRender: i } = this.commonData, a = pt(t), { renderingEngine: s } = a;
      return Hu(r.annotationUID), this.isDrawing = false, this.drawData = void 0, this.commonData = void 0, bi(s, i), this.deactivateDraw(t), true;
    }
    return false;
  }
  function Bhe(t) {
    t.activateDraw = Ehe.bind(t), t.deactivateDraw = bhe.bind(t), t.applyCreateOnCross = Nhe.bind(t), t.findCrossingIndexDuringCreate = Vhe.bind(t), t.completeDrawOpenContour = Ihe.bind(t), t.removeCrossedLinesOnCompleteDraw = Ohe.bind(t), t.mouseDragDrawCallback = Dhe.bind(t), t.mouseUpDrawCallback = Mhe.bind(t), t.completeDrawClosedContour = Rhe.bind(t), t.cancelDrawing = Lhe.bind(t), t.haltDrawing = Fhe.bind(t);
  }
  const { addCanvasPointsToArray: _he, getFirstLineSegmentIntersectionIndexes: $c } = o0;
  function khe(t, e) {
    const n = t.detail, { element: r, currentPoints: i, lastPoints: a } = n, s = i.canvas, o = a.canvas, { editCanvasPoints: l, prevCanvasPoints: c } = this.editData, f = $c(c, s, o, e);
    if (f) this.editData.startCrossingIndex = f[0], this.removePointsUpUntilFirstCrossing(e);
    else if (c.length >= 2) if (l.length > this.configuration.checkCanvasEditFallbackProximity) {
      const u = l[0], h = [];
      for (let m = 0; m < c.length; m++) {
        const y = c[m], w = Jr(y, u);
        h.push({
          distance: w,
          index: m
        });
      }
      h.sort((m, y) => m.distance - y.distance);
      const g = [
        h[0],
        h[1]
      ], v = Math.min(g[0].index, g[1].index);
      this.editData.startCrossingIndex = v;
    } else {
      const u = mo();
      Ru(u, l[1], l[0]), j6(u, u);
      const h = 6, g = [
        l[0][0] - u[0] * h,
        l[0][1] - u[1] * h
      ], v = $c(c, g, l[0], e);
      if (v) {
        const m = [
          g
        ];
        _he(r, m, l[0], this.commonData), l.unshift(...m), this.removePointsUpUntilFirstCrossing(e), this.editData.editIndex = l.length - 1, this.editData.startCrossingIndex = v[0];
      }
    }
  }
  function Phe(t) {
    const { editCanvasPoints: e, prevCanvasPoints: n } = this.editData;
    let r = 0;
    for (let i = 0; i < e.length - 1; i++) {
      const a = [
        e[i],
        e[i + 1]
      ], s = !!$c(n, a[0], a[1], t);
      if (r++, s) break;
    }
    e.splice(0, r), this.editData.editIndex = e.length - 1;
  }
  function Ghe(t, e) {
    const n = t.detail, { currentPoints: r, lastPoints: i } = n, a = r.canvas, s = i.canvas, { prevCanvasPoints: o } = this.editData;
    return !!$c(o, a, s, e);
  }
  function zhe(t) {
    const { prevCanvasPoints: e, editCanvasPoints: n } = this.editData;
    for (let r = n.length - 1; r > 0; r--) {
      const i = [
        n[r],
        n[r - 1]
      ], a = !!$c(e, i[0], i[1], t);
      if (n.pop(), a) break;
    }
  }
  function Whe() {
    const { editCanvasPoints: t, prevCanvasPoints: e, startCrossingIndex: n } = this.editData;
    if (n === void 0) return;
    const r = t[t.length - 1], i = [];
    for (let s = 0; s < e.length; s++) {
      const o = e[s], l = Jr(o, r);
      i.push({
        distance: l,
        index: s
      });
    }
    i.sort((s, o) => s.distance - o.distance);
    const a = t.slice(0, -1);
    for (let s = 0; s < i.length; s++) {
      const { index: o } = i[s], l = e[o], c = t[t.length - 1];
      if (!$c(a, l, c, false)) return o;
    }
    return -1;
  }
  function Hhe(t) {
    const e = t.detail, { currentPoints: n, lastPoints: r } = e, i = n.canvas, a = r.canvas, { editCanvasPoints: s } = this.editData, o = s.slice(0, -2), l = $c(o, i, a, false);
    if (!l) return;
    const c = l[0], f = s.length - c;
    for (let u = 0; u < f; u++) s.pop();
  }
  function jhe(t) {
    t.checkForFirstCrossing = khe.bind(t), t.removePointsUpUntilFirstCrossing = Phe.bind(t), t.checkForSecondCrossing = Ghe.bind(t), t.findSnapIndex = Whe.bind(t), t.removePointsAfterSecondCrossing = zhe.bind(t), t.checkAndRemoveCrossesOnEditLine = Hhe.bind(t);
  }
  const { getSubPixelSpacingAndXYDirections: Khe, addCanvasPointsToArray: GN, getArea: BA } = o0;
  function Yhe(t, e, n) {
    this.isEditingClosed = true;
    const r = t.detail, { currentPoints: i, element: a } = r, s = i.canvas, o = pt(a);
    if (!o) return;
    const { viewport: l } = o, c = e.data.contour.polyline.map(l.worldToCanvas), { spacing: f, xDir: u, yDir: h } = Khe(l, this.configuration.subPixelResolution);
    this.editData = {
      prevCanvasPoints: c,
      editCanvasPoints: [
        s
      ],
      startCrossingIndex: void 0,
      editIndex: 0
    }, this.commonData = {
      annotation: e,
      viewportIdsToRender: n,
      spacing: f,
      xDir: u,
      yDir: h,
      movingTextBox: false
    }, yt.isInteractingWithTool = true, a.addEventListener(Re.MOUSE_UP, this.mouseUpClosedContourEditCallback), a.addEventListener(Re.MOUSE_DRAG, this.mouseDragClosedContourEditCallback), a.addEventListener(Re.MOUSE_CLICK, this.mouseUpClosedContourEditCallback), a.addEventListener(Re.TOUCH_END, this.mouseUpClosedContourEditCallback), a.addEventListener(Re.TOUCH_DRAG, this.mouseDragClosedContourEditCallback), a.addEventListener(Re.TOUCH_TAP, this.mouseUpClosedContourEditCallback), z5(a);
  }
  function qhe(t) {
    yt.isInteractingWithTool = false, t.removeEventListener(Re.MOUSE_UP, this.mouseUpClosedContourEditCallback), t.removeEventListener(Re.MOUSE_DRAG, this.mouseDragClosedContourEditCallback), t.removeEventListener(Re.MOUSE_CLICK, this.mouseUpClosedContourEditCallback), t.removeEventListener(Re.TOUCH_END, this.mouseUpClosedContourEditCallback), t.removeEventListener(Re.TOUCH_DRAG, this.mouseDragClosedContourEditCallback), t.removeEventListener(Re.TOUCH_TAP, this.mouseUpClosedContourEditCallback), Ky(t);
  }
  function Xhe(t) {
    const e = t.detail, { currentPoints: n, element: r } = e, i = n.world, a = n.canvas, s = pt(r), { renderingEngine: o, viewport: l } = s, { viewportIdsToRender: c, xDir: f, yDir: u, spacing: h } = this.commonData, { editIndex: g, editCanvasPoints: v, startCrossingIndex: m } = this.editData, y = v[v.length - 1], w = l.canvasToWorld(y), C = He();
    Ft(C, i, w);
    const T = Math.abs(Bt(C, f)), S = Math.abs(Bt(C, u));
    if (T <= h[0] && S <= h[1]) return;
    m !== void 0 && this.checkAndRemoveCrossesOnEditLine(t);
    const E = GN(r, v, a, this.commonData), b = g + E;
    if (this.editData.editIndex = b, m === void 0 && v.length > 1 && this.checkForFirstCrossing(t, true), this.editData.snapIndex = this.findSnapIndex(), this.editData.snapIndex === -1) {
      this.finishEditAndStartNewEdit(t);
      return;
    }
    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(t), m !== void 0 && this.checkForSecondCrossing(t, true) && (this.removePointsAfterSecondCrossing(true), this.finishEditAndStartNewEdit(t)), bi(o, c);
  }
  function Zhe(t) {
    const e = t.detail, { element: n } = e, r = pt(n), { viewport: i, renderingEngine: a } = r, { annotation: s, viewportIdsToRender: o } = this.commonData, { fusedCanvasPoints: l, editCanvasPoints: c } = this.editData;
    zl(s, {
      points: l,
      closed: true,
      targetWindingDirection: Gu.Clockwise
    }, i), s.autoGenerated && (s.autoGenerated = false), Wl(s, n);
    const f = c.pop();
    this.editData = {
      prevCanvasPoints: l,
      editCanvasPoints: [
        f
      ],
      startCrossingIndex: void 0,
      editIndex: 0,
      snapIndex: void 0
    }, bi(a, o);
  }
  function Qhe(t) {
    const { prevCanvasPoints: e, editCanvasPoints: n, startCrossingIndex: r, snapIndex: i } = this.editData;
    if (r === void 0 || i === void 0) return;
    const a = t.detail, { element: s } = a, o = [
      ...n
    ];
    GN(s, o, e[i], this.commonData), o.length > n.length && o.pop();
    let l, c;
    r > i ? (l = i, c = r) : (l = r, c = i);
    const f = Jr(e[l], o[0]), u = Jr(e[l], o[o.length - 1]), h = Jr(e[c], o[0]), g = Jr(e[c], o[o.length - 1]), v = [];
    for (let E = 0; E < l; E++) {
      const b = e[E];
      v.push([
        b[0],
        b[1]
      ]);
    }
    let m = f + g, y = u + h;
    if (m < y) for (let E = 0; E < o.length; E++) {
      const b = o[E];
      v.push([
        b[0],
        b[1]
      ]);
    }
    else for (let E = o.length - 1; E >= 0; E--) {
      const b = o[E];
      v.push([
        b[0],
        b[1]
      ]);
    }
    for (let E = c; E < e.length; E++) {
      const b = e[E];
      v.push([
        b[0],
        b[1]
      ]);
    }
    const w = [];
    for (let E = l; E < c; E++) {
      const b = e[E];
      w.push([
        b[0],
        b[1]
      ]);
    }
    if (m = h + u, y = g + f, m < y) for (let E = 0; E < o.length; E++) {
      const b = o[E];
      w.push([
        b[0],
        b[1]
      ]);
    }
    else for (let E = o.length - 1; E >= 0; E--) {
      const b = o[E];
      w.push([
        b[0],
        b[1]
      ]);
    }
    const C = BA(v), T = BA(w);
    return C > T ? v : w;
  }
  function Jhe(t) {
    const e = t.detail, { element: n } = e;
    this.completeClosedContourEdit(n);
  }
  function $he(t) {
    var _a3;
    const e = pt(t), { viewport: n, renderingEngine: r } = e, { annotation: i, viewportIdsToRender: a } = this.commonData, { fusedCanvasPoints: s, prevCanvasPoints: o } = this.editData;
    if (s) {
      const l = H5(this.configuration, i) ? j5(this.configuration, s, o) : s, c = ((_a3 = this.configuration) == null ? void 0 : _a3.decimate) || {};
      zl(i, {
        points: l,
        closed: true,
        targetWindingDirection: Gu.Clockwise
      }, n, {
        decimate: {
          enabled: !!c.enabled,
          epsilon: c.epsilon
        }
      }), i.autoGenerated && (i.autoGenerated = false), Wl(i, t);
    }
    this.isEditingClosed = false, this.editData = void 0, this.commonData = void 0, bi(r, a), this.deactivateClosedContourEdit(t);
  }
  function ede(t) {
    this.completeClosedContourEdit(t);
  }
  function tde(t) {
    t.activateClosedContourEdit = Yhe.bind(t), t.deactivateClosedContourEdit = qhe.bind(t), t.mouseDragClosedContourEditCallback = Xhe.bind(t), t.mouseUpClosedContourEditCallback = Jhe.bind(t), t.finishEditAndStartNewEdit = Zhe.bind(t), t.fuseEditPointsWithClosedContour = Qhe.bind(t), t.cancelClosedContourEdit = ede.bind(t), t.completeClosedContourEdit = $he.bind(t);
  }
  const { addCanvasPointsToArray: zN, getSubPixelSpacingAndXYDirections: nde } = o0;
  function rde(t, e, n) {
    this.isEditingOpen = true;
    const r = t.detail, { currentPoints: i, element: a } = r, s = i.canvas, o = pt(a), { viewport: l } = o, c = e.data.contour.polyline.map(l.worldToCanvas), { spacing: f, xDir: u, yDir: h } = nde(l, this.configuration.subPixelResolution);
    this.editData = {
      prevCanvasPoints: c,
      editCanvasPoints: [
        s
      ],
      startCrossingIndex: void 0,
      editIndex: 0
    }, this.commonData = {
      annotation: e,
      viewportIdsToRender: n,
      spacing: f,
      xDir: u,
      yDir: h,
      movingTextBox: false
    }, yt.isInteractingWithTool = true, a.addEventListener(Re.MOUSE_UP, this.mouseUpOpenContourEditCallback), a.addEventListener(Re.MOUSE_DRAG, this.mouseDragOpenContourEditCallback), a.addEventListener(Re.MOUSE_CLICK, this.mouseUpOpenContourEditCallback), a.addEventListener(Re.TOUCH_END, this.mouseUpOpenContourEditCallback), a.addEventListener(Re.TOUCH_DRAG, this.mouseDragOpenContourEditCallback), a.addEventListener(Re.TOUCH_TAP, this.mouseUpOpenContourEditCallback), z5(a);
  }
  function ide(t) {
    yt.isInteractingWithTool = false, t.removeEventListener(Re.MOUSE_UP, this.mouseUpOpenContourEditCallback), t.removeEventListener(Re.MOUSE_DRAG, this.mouseDragOpenContourEditCallback), t.removeEventListener(Re.MOUSE_CLICK, this.mouseUpOpenContourEditCallback), t.removeEventListener(Re.TOUCH_END, this.mouseUpOpenContourEditCallback), t.removeEventListener(Re.TOUCH_DRAG, this.mouseDragOpenContourEditCallback), t.removeEventListener(Re.TOUCH_TAP, this.mouseUpOpenContourEditCallback), Ky(t);
  }
  function ade(t) {
    const e = t.detail, { currentPoints: n, element: r } = e, i = n.world, a = n.canvas, s = pt(r), { renderingEngine: o, viewport: l } = s, { viewportIdsToRender: c, xDir: f, yDir: u, spacing: h } = this.commonData, { editIndex: g, editCanvasPoints: v, startCrossingIndex: m } = this.editData, y = v[v.length - 1], w = l.canvasToWorld(y), C = He();
    Ft(C, i, w);
    const T = Math.abs(Bt(C, f)), S = Math.abs(Bt(C, u));
    if (T <= h[0] && S <= h[1]) return;
    m !== void 0 && this.checkAndRemoveCrossesOnEditLine(t);
    const E = zN(r, v, a, this.commonData), b = g + E;
    this.editData.editIndex = b, m === void 0 && v.length > 1 && this.checkForFirstCrossing(t, false), this.editData.snapIndex = this.findSnapIndex(), this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(t), m !== void 0 && this.checkForSecondCrossing(t, false) ? (this.removePointsAfterSecondCrossing(false), this.finishEditOpenOnSecondCrossing(t)) : this.checkIfShouldOverwriteAnEnd(t) && this.openContourEditOverwriteEnd(t), bi(o, c);
  }
  function sde(t) {
    const e = t.detail, { element: n } = e, r = pt(n), { viewport: i } = r, { annotation: a, viewportIdsToRender: s } = this.commonData, o = this.fuseEditPointsForOpenContourEndEdit();
    zl(a, {
      points: o,
      closed: false
    }, i);
    const l = a.data.contour.polyline;
    a.data.handles.points = [
      l[0],
      l[l.length - 1]
    ], a.data.handles.activeHandleIndex = 1, Wl(a, n), this.isEditingOpen = false, this.editData = void 0, this.commonData = void 0, this.deactivateOpenContourEdit(n), this.activateOpenContourEndEdit(t, a, s, null);
  }
  function ode(t) {
    const e = t.detail, { currentPoints: n, lastPoints: r } = e, i = n.canvas, a = r.canvas, { snapIndex: s, prevCanvasPoints: o, startCrossingIndex: l } = this.editData;
    if (l === void 0 || s === void 0) return false;
    if (s === -1) return true;
    if (s !== 0 && s !== o.length - 1) return false;
    const c = i, f = a, u = o[s], h = mo(), g = mo();
    mu(h, c[0] - f[0], c[1] - f[1]), mu(g, c[0] - u[0], c[1] - u[1]);
    const v = V_(h, g), m = Math.sqrt(h[0] * h[0] + h[1] * h[1]), y = Math.sqrt(g[0] * g[0] + g[1] * g[1]);
    return Math.acos(v / (m * y)) < Math.PI / 2;
  }
  function lde() {
    const { snapIndex: t, prevCanvasPoints: e, editCanvasPoints: n, startCrossingIndex: r } = this.editData, i = [];
    if (t === 0) for (let o = e.length - 1; o >= r; o--) {
      const l = e[o];
      i.push([
        l[0],
        l[1]
      ]);
    }
    else for (let o = 0; o < r; o++) {
      const l = e[o];
      i.push([
        l[0],
        l[1]
      ]);
    }
    const a = Jr(e[r], n[0]), s = Jr(e[r], n[n.length - 1]);
    if (a < s) for (let o = 0; o < n.length; o++) {
      const l = n[o];
      i.push([
        l[0],
        l[1]
      ]);
    }
    else for (let o = n.length - 1; o >= 0; o--) {
      const l = n[o];
      i.push([
        l[0],
        l[1]
      ]);
    }
    return i;
  }
  function cde(t) {
    const { prevCanvasPoints: e, editCanvasPoints: n, startCrossingIndex: r, snapIndex: i } = this.editData;
    if (r === void 0 || i === void 0) return;
    const a = t.detail, { element: s } = a, o = [
      ...n
    ];
    zN(s, o, e[i], this.commonData), o.length > n.length && o.pop();
    let l, c;
    r > i ? (l = i, c = r) : (l = r, c = i);
    const f = Jr(e[l], o[0]), u = Jr(e[l], o[o.length - 1]), h = Jr(e[c], o[0]), g = Jr(e[c], o[o.length - 1]), v = [];
    for (let w = 0; w < l; w++) {
      const C = e[w];
      v.push([
        C[0],
        C[1]
      ]);
    }
    const m = f + g, y = u + h;
    if (m < y) for (let w = 0; w < o.length; w++) {
      const C = o[w];
      v.push([
        C[0],
        C[1]
      ]);
    }
    else for (let w = o.length - 1; w >= 0; w--) {
      const C = o[w];
      v.push([
        C[0],
        C[1]
      ]);
    }
    for (let w = c; w < e.length; w++) {
      const C = e[w];
      v.push([
        C[0],
        C[1]
      ]);
    }
    return v;
  }
  function ude(t) {
    const e = t.detail, { element: n } = e, r = pt(n), { viewport: i, renderingEngine: a } = r, { annotation: s, viewportIdsToRender: o } = this.commonData, { fusedCanvasPoints: l, editCanvasPoints: c } = this.editData;
    zl(s, {
      points: l,
      closed: false
    }, i);
    const f = s.data.contour.polyline;
    s.data.handles.points = [
      f[0],
      f[f.length - 1]
    ], Wl(s, n);
    const u = c.pop();
    this.editData = {
      prevCanvasPoints: l,
      editCanvasPoints: [
        u
      ],
      startCrossingIndex: void 0,
      editIndex: 0
    }, bi(a, o);
  }
  function fde(t) {
    const e = t.detail, { element: n } = e;
    this.completeOpenContourEdit(n);
  }
  function hde(t) {
    var _a3;
    const e = pt(t), { viewport: n, renderingEngine: r } = e, { annotation: i, viewportIdsToRender: a } = this.commonData, { fusedCanvasPoints: s, prevCanvasPoints: o } = this.editData;
    if (s) {
      const l = H5(this.configuration) ? j5(this.configuration, s, o) : s, c = ((_a3 = this.configuration) == null ? void 0 : _a3.decimate) || {};
      zl(i, {
        points: l,
        closed: false
      }, n, {
        decimate: {
          enabled: !!c.enabled,
          epsilon: c.epsilon
        }
      });
      const f = i.data.contour.polyline;
      i.data.handles.points = [
        f[0],
        f[f.length - 1]
      ], i.data.isOpenUShapeContour && (i.data.openUShapeContourVectorToPeak = Zy(s, n)), Wl(i, t);
    }
    this.isEditingOpen = false, this.editData = void 0, this.commonData = void 0, bi(r, a), this.deactivateOpenContourEdit(t);
  }
  function dde(t) {
    this.completeOpenContourEdit(t);
  }
  function gde(t) {
    t.activateOpenContourEdit = rde.bind(t), t.deactivateOpenContourEdit = ide.bind(t), t.mouseDragOpenContourEditCallback = ade.bind(t), t.mouseUpOpenContourEditCallback = fde.bind(t), t.fuseEditPointsWithOpenContour = cde.bind(t), t.finishEditOpenOnSecondCrossing = ude.bind(t), t.checkIfShouldOverwriteAnEnd = ode.bind(t), t.fuseEditPointsForOpenContourEndEdit = lde.bind(t), t.openContourEditOverwriteEnd = sde.bind(t), t.cancelOpenContourEdit = dde.bind(t), t.completeOpenContourEdit = hde.bind(t);
  }
  const { getSubPixelSpacingAndXYDirections: pde } = o0;
  function mde(t, e, n, r) {
    this.isDrawing = true;
    const i = t.detail, { element: a } = i, s = pt(a), { viewport: o } = s, { spacing: l, xDir: c, yDir: f } = pde(o, this.configuration.subPixelResolution), u = e.data.contour.polyline.map(o.worldToCanvas);
    e.data.handles.activeHandleIndex === 0 && u.reverse();
    let g = false;
    (r == null ? void 0 : r.worldPosition) && (g = true), this.drawData = {
      canvasPoints: u,
      polylineIndex: u.length - 1
    }, this.commonData = {
      annotation: e,
      viewportIdsToRender: n,
      spacing: l,
      xDir: c,
      yDir: f,
      movingTextBox: g
    }, yt.isInteractingWithTool = true, a.addEventListener(Re.MOUSE_UP, this.mouseUpDrawCallback), a.addEventListener(Re.MOUSE_DRAG, this.mouseDragDrawCallback), a.addEventListener(Re.MOUSE_CLICK, this.mouseUpDrawCallback), a.addEventListener(Re.TOUCH_END, this.mouseUpDrawCallback), a.addEventListener(Re.TOUCH_DRAG, this.mouseDragDrawCallback), a.addEventListener(Re.TOUCH_TAP, this.mouseUpDrawCallback), z5(a);
  }
  function vde(t) {
    t.activateOpenContourEndEdit = mde.bind(t);
  }
  const { pointsAreWithinCloseContourProximity: yde } = o0;
  function xde(t, e) {
    const n = {
      toolGroupId: this.toolGroupId,
      toolName: this.getToolName(),
      viewportId: t.viewport.id,
      annotationUID: e.annotationUID
    }, { lineWidth: r, lineDash: i, color: a, fillColor: s, fillOpacity: o } = this.getAnnotationStyle({
      annotation: e,
      styleSpecifier: n
    }), { closed: l } = e.data.contour;
    return {
      color: a,
      width: r,
      lineDash: i,
      fillColor: s,
      fillOpacity: o,
      closePath: l
    };
  }
  function wde(t, e, n) {
    var _a3;
    ((_a3 = t == null ? void 0 : t.viewport) == null ? void 0 : _a3.getImageData()) && (n.data.contour.closed ? this.renderClosedContour(t, e, n) : n.data.isOpenUShapeContour ? (Cde(t, n), this.renderOpenUShapedContour(t, e, n)) : this.renderOpenContour(t, e, n));
  }
  function Cde(t, e) {
    e.data.openUShapeContourVectorToPeak || (e.data.openUShapeContourVectorToPeak = She(t, e));
  }
  function Tde(t, e, n) {
    if (n.parentAnnotationUID) return;
    const { viewport: r } = t, i = this._getRenderingOptions(t, n), a = n.data.contour.polyline.map((c) => r.worldToCanvas(c)), s = P5(n, r), o = [
      a,
      ...s
    ];
    Au(e, n.annotationUID, "1", o, i);
  }
  function Sde(t, e, n) {
    var _a3;
    const { viewport: r } = t, i = this._getRenderingOptions(t, n), a = n.data.contour.polyline.map((l) => r.worldToCanvas(l));
    Pu(e, n.annotationUID, "1", a, i);
    const o = n.data.handles.activeHandleIndex;
    if (((_a3 = this.configuration.alwaysRenderOpenContourHandles) == null ? void 0 : _a3.enabled) === true) {
      const l = this.configuration.alwaysRenderOpenContourHandles.radius, c = "0", f = [
        a[0],
        a[a.length - 1]
      ];
      o === 0 ? f.shift() : o === 1 && f.pop(), R6(e, n.annotationUID, c, f, {
        color: i.color,
        handleRadius: l
      });
    }
    if (o !== null) {
      const c = o === 0 ? 0 : a.length - 1, f = a[c];
      R6(e, n.annotationUID, "1", [
        f
      ], {
        color: i.color
      });
    }
  }
  function Ade(t, e, n) {
    const { viewport: r } = t, { openUShapeContourVectorToPeak: i } = n.data, { polyline: a } = n.data.contour;
    if (this.renderOpenContour(t, e, n), !i) return;
    const s = r.worldToCanvas(a[0]), o = r.worldToCanvas(a[a.length - 1]), l = [
      r.worldToCanvas(i[0]),
      r.worldToCanvas(i[1])
    ], c = this._getRenderingOptions(t, n);
    Pu(e, n.annotationUID, "first-to-last", [
      s,
      o
    ], {
      color: c.color,
      width: c.width,
      closePath: false,
      lineDash: "2,2"
    }), Pu(e, n.annotationUID, "midpoint-to-open-contour", [
      l[0],
      l[1]
    ], {
      color: c.color,
      width: c.width,
      closePath: false,
      lineDash: "2,2"
    });
  }
  function Ede(t, e, n) {
    const r = this._getRenderingOptions(t, n), { allowOpenContours: i } = this.configuration, { canvasPoints: a } = this.drawData;
    if (r.closePath = false, Pu(e, n.annotationUID, "1", a, r), i) {
      const s = a[0], o = a[a.length - 1];
      yde(s, o, this.configuration.closeContourProximity) ? Pu(e, n.annotationUID, "2", [
        o,
        s
      ], r) : R6(e, n.annotationUID, "0", [
        s
      ], {
        color: r.color,
        handleRadius: 2
      });
    }
  }
  function bde(t, e, n) {
    const { viewport: r } = t, { fusedCanvasPoints: i } = this.editData;
    if (i === void 0) {
      this.renderClosedContour(t, e, n);
      return;
    }
    const a = P5(n, r), s = [
      i,
      ...a
    ], o = this._getRenderingOptions(t, n), l = "preview-1";
    n.parentAnnotationUID && o.fillOpacity && (o.fillOpacity = 0), Au(e, n.annotationUID, l, s, o);
  }
  function Dde(t, e, n) {
    const { fusedCanvasPoints: r } = this.editData;
    if (r === void 0) {
      this.renderOpenContour(t, e, n);
      return;
    }
    const i = this._getRenderingOptions(t, n);
    Pu(e, n.annotationUID, "preview-1", r, i);
  }
  function Mde(t, e, n) {
    if (n.parentAnnotationUID) return;
    const { viewport: r } = t, i = this._getRenderingOptions(t, n), a = n.data.contour.polyline.map((v) => r.worldToCanvas(v)), s = P5(n, r), o = "1", l = a[0], c = 6, f = 100, u = [];
    for (let v = 0; v < f; v++) {
      const m = v / f * 2 * Math.PI, y = l[0] + c * Math.cos(m), w = l[1] + c * Math.sin(m);
      u.push([
        y,
        w
      ]);
    }
    const h = [
      [
        l[0] - c * 2,
        l[1]
      ],
      [
        l[0] + c * 2,
        l[1]
      ],
      [
        l[0],
        l[1] - c * 2
      ],
      [
        l[0],
        l[1] + c * 2
      ]
    ];
    Au(e, n.annotationUID, o + "-crosshair_v", [
      h[0],
      h[1]
    ], i), Au(e, n.annotationUID, o + "-crosshair_h", [
      h[2],
      h[3]
    ], i);
    const g = [
      u,
      ...s
    ];
    Au(e, n.annotationUID, o, g, i);
  }
  function Rde(t) {
    t.renderContour = wde.bind(t), t.renderClosedContour = Tde.bind(t), t.renderOpenContour = Sde.bind(t), t.renderPointContourWithMarker = Mde.bind(t), t.renderOpenUShapedContour = Ade.bind(t), t.renderContourBeingDrawn = Ede.bind(t), t.renderClosedContourBeingEdited = bde.bind(t), t.renderOpenContourBeingEdited = Dde.bind(t), t._getRenderingOptions = xde.bind(t);
  }
  const { pointCanProjectOnLine: _A } = o0, { EPSILON: Ode } = xb, Ide = 1 - Ode;
  class WN extends yhe {
    constructor(e = {}, n = {
      supportedInteractionTypes: [
        "Mouse",
        "Touch"
      ],
      configuration: {
        shadow: true,
        preventHandleOutsideImage: false,
        contourHoleAdditionModifierKey: ga.Shift,
        alwaysRenderOpenContourHandles: {
          enabled: false,
          radius: 2
        },
        allowOpenContours: true,
        closeContourProximity: 10,
        checkCanvasEditFallbackProximity: 6,
        makeClockWise: true,
        subPixelResolution: 4,
        smoothing: {
          smoothOnAdd: false,
          smoothOnEdit: false,
          knotsRatioPercentageOnAdd: 40,
          knotsRatioPercentageOnEdit: 40
        },
        interpolation: {
          enabled: false,
          onInterpolationComplete: null
        },
        decimate: {
          enabled: false,
          epsilon: 0.1
        },
        displayOnePointAsCrosshairs: false,
        calculateStats: true,
        getTextLines: Vde,
        statsCalculator: By
      }
    }) {
      super(e, n), this.isDrawing = false, this.isEditingClosed = false, this.isEditingOpen = false, this.addNewAnnotation = (r) => {
        const i = r.detail, { element: a } = i, s = pt(a), { renderingEngine: o } = s, l = this.createAnnotation(r);
        this.addAnnotation(l, a);
        const c = vh(a, this.getToolName());
        return this.activateDraw(r, l, c), r.preventDefault(), bi(o, c), l;
      }, this.handleSelectedCallback = (r, i, a) => {
        const s = r.detail, { element: o } = s, l = vh(o, this.getToolName());
        this.activateOpenContourEndEdit(r, i, l, a);
      }, this.toolSelectedCallback = (r, i) => {
        const a = r.detail, { element: s } = a, o = vh(s, this.getToolName());
        i.data.contour.closed ? this.activateClosedContourEdit(r, i, o) : this.activateOpenContourEdit(r, i, o), r.preventDefault();
      }, this.isPointNearTool = (r, i, a, s) => {
        const o = pt(r), { viewport: l } = o, { polyline: c } = i.data.contour;
        let f = l.worldToCanvas(c[0]);
        for (let g = 1; g < c.length; g++) {
          const v = f, m = l.worldToCanvas(c[g]);
          if (_A(a, v, m, s)) return true;
          f = m;
        }
        if (!i.data.contour.closed) return false;
        const u = l.worldToCanvas(c[0]), h = l.worldToCanvas(c[c.length - 1]);
        return _A(a, u, h, s);
      }, this.cancel = (r) => {
        const i = this.isDrawing, a = this.isEditingOpen, s = this.isEditingClosed;
        i ? this.cancelDrawing(r) : a ? this.cancelOpenContourEdit(r) : s && this.cancelClosedContourEdit(r);
      }, this._calculateCachedStats = (r, i, a, s) => {
        const { data: o } = r, { cachedStats: l } = o, { polyline: c, closed: f } = o.contour, u = Object.keys(l);
        for (let h = 0; h < u.length; h++) {
          const g = u[h], v = this.getTargetIdImage(g, a);
          if (!v) continue;
          const { imageData: m, metadata: y } = v, w = c.map((E) => i.worldToCanvas(E)), C = {
            isPreScaled: y1e(i, g),
            isSuvScaled: this.isSuvScaled(i, g, r.metadata.referencedImageId)
          }, T = phe(y.Modality, r.metadata.referencedImageId, C), S = $ue(v, () => {
            const E = o.contour.polyline, b = E.length, D = new Array(b);
            for (let _ = 0; _ < b; _++) D[_] = i.worldToCanvas(E[_]);
            const { maxX: R, maxY: I, minX: O, minY: L } = qp(D), N = i.canvasToWorld([
              O,
              L
            ]), F = wl(m, N), V = i.canvasToWorld([
              R,
              I
            ]), k = wl(m, V);
            return [
              F,
              k
            ];
          });
          f ? this.updateClosedCachedStats({
            targetId: g,
            viewport: i,
            canvasCoordinates: w,
            points: c,
            imageData: m,
            metadata: y,
            cachedStats: l,
            modalityUnit: T,
            calibratedScale: S
          }) : this.updateOpenCachedStats({
            metadata: y,
            canvasCoordinates: w,
            targetId: g,
            cachedStats: l,
            modalityUnit: T,
            calibratedScale: S
          });
        }
        return Wl(r, s.viewport.element, _l.StatsUpdated), r.invalidated = false, l;
      }, this._renderStats = (r, i, a, s) => {
        const { data: o } = r, l = this.getTargetId(i), c = {
          toolGroupId: this.toolGroupId,
          toolName: this.getToolName(),
          viewportId: a.viewport.id
        }, f = this.getLinkedTextBoxStyle(c, r);
        if (!f.visibility) return;
        const u = this.configuration.getTextLines(o, l);
        if (!u || u.length === 0) return;
        const h = o.contour.polyline.map((S) => i.worldToCanvas(S));
        if (!o.handles.textBox.hasMoved) {
          const S = x1e(h);
          o.handles.textBox.worldPosition = i.canvasToWorld(S);
        }
        const g = i.worldToCanvas(o.handles.textBox.worldPosition), m = E0e(s, r.annotationUID ?? "", "1", u, g, h, {}, f), { x: y, y: w, width: C, height: T } = m;
        o.handles.textBox.worldBoundingBox = {
          topLeft: i.canvasToWorld([
            y,
            w
          ]),
          topRight: i.canvasToWorld([
            y + C,
            w
          ]),
          bottomLeft: i.canvasToWorld([
            y,
            w + T
          ]),
          bottomRight: i.canvasToWorld([
            y + C,
            w + T
          ])
        };
      }, Bhe(this), jhe(this), tde(this), gde(this), vde(this), Rde(this), this._throttledCalculateCachedStats = que(this._calculateCachedStats, 100, {
        trailing: true
      });
    }
    filterInteractableAnnotationsForElement(e, n) {
      if (!n || !n.length) return;
      const r = pt(e), { viewport: i } = r;
      let a;
      if (i instanceof Ba) {
        const s = i.getCamera(), { spacingInNormalDirection: o } = ad(i, s);
        a = this.filterAnnotationsWithinSlice(n, s, o);
      } else a = XV(i, n);
      return a;
    }
    filterAnnotationsWithinSlice(e, n, r) {
      const { viewPlaneNormal: i } = n, a = e.filter((c) => {
        const f = c.metadata.viewPlaneNormal, u = Math.abs(Bt(i, f)) > Ide;
        return f && u;
      });
      if (!a.length) return [];
      const s = r / 2, { focalPoint: o } = n, l = [];
      for (const c of a) {
        const u = c.data.contour.polyline[0];
        if (!c.isVisible) continue;
        const h = He();
        hi(h, o, u);
        const g = Bt(h, i);
        Math.abs(g) < s && l.push(c);
      }
      return l;
    }
    isContourSegmentationTool() {
      return false;
    }
    createAnnotation(e) {
      const n = e.detail.currentPoints.world, r = super.createAnnotation(e), i = (s) => {
        s.data.handles.points.length = 0;
      };
      return zi(r, {
        data: {
          contour: {
            polyline: [
              [
                ...n
              ]
            ]
          },
          label: "",
          cachedStats: {}
        },
        onInterpolationComplete: i
      });
    }
    getAnnotationStyle(e) {
      return super.getAnnotationStyle(e);
    }
    renderAnnotationInstance(e) {
      const { enabledElement: n, targetId: r, svgDrawingHelper: i } = e, a = e.annotation;
      let s = false;
      const { viewport: o, renderingEngine: l } = n, c = this.isDrawing, f = this.isEditingOpen, u = this.isEditingClosed;
      if (!(c || f || u)) this.configuration.displayOnePointAsCrosshairs && a.data.contour.polyline.length === 1 ? this.renderPointContourWithMarker(n, i, a) : this.renderContour(n, i, a);
      else {
        const h = this.commonData.annotation.annotationUID;
        if (a.annotationUID === h) if (c) this.renderContourBeingDrawn(n, i, a);
        else if (u) this.renderClosedContourBeingEdited(n, i, a);
        else if (f) this.renderOpenContourBeingEdited(n, i, a);
        else throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
        else this.configuration.displayOnePointAsCrosshairs && a.data.contour.polyline.length === 1 ? this.renderPointContourWithMarker(n, i, a) : this.renderContour(n, i, a);
        s = true;
      }
      if (this.configuration.calculateStats) return this._calculateStatsIfActive(a, r, o, l, n), this._renderStats(a, o, n, i), s;
    }
    _calculateStatsIfActive(e, n, r, i, a) {
      var _a3, _b3, _c3;
      const s = (_a3 = this.commonData) == null ? void 0 : _a3.annotation.annotationUID;
      if (!(e.annotationUID === s && !((_b3 = this.commonData) == null ? void 0 : _b3.movingTextBox)) && !((_c3 = this.commonData) == null ? void 0 : _c3.movingTextBox)) {
        const { data: o } = e;
        !o.cachedStats[n] || o.cachedStats[n].areaUnit == null ? (o.cachedStats[n] = {
          Modality: null,
          area: null,
          max: null,
          mean: null,
          stdDev: null,
          areaUnit: null
        }, this._calculateCachedStats(e, r, i, a)) : e.invalidated && this._throttledCalculateCachedStats(e, r, i, a);
      }
    }
    updateClosedCachedStats({ viewport: e, points: n, imageData: r, metadata: i, cachedStats: a, targetId: s, modalityUnit: o, canvasCoordinates: l, calibratedScale: c }) {
      var _a3, _b3, _c3;
      const { scale: f, areaUnits: u, units: h } = c, g = l[0], v = e.canvasToWorld(g), m = e.canvasToWorld([
        g[0] + 1,
        g[1]
      ]), y = e.canvasToWorld([
        g[0],
        g[1] + 1
      ]), w = Mu(v, m), C = Mu(v, y), T = wl(r, n[0]);
      T[0] = Math.floor(T[0]), T[1] = Math.floor(T[1]), T[2] = Math.floor(T[2]);
      let S = T[0], E = T[0], b = T[1], D = T[1], R = T[2], I = T[2];
      for (let ie = 1; ie < n.length; ie++) {
        const oe = wl(r, n[ie]);
        oe[0] = Math.floor(oe[0]), oe[1] = Math.floor(oe[1]), oe[2] = Math.floor(oe[2]), S = Math.min(S, oe[0]), E = Math.max(E, oe[0]), b = Math.min(b, oe[1]), D = Math.max(D, oe[1]), R = Math.min(R, oe[2]), I = Math.max(I, oe[2]);
      }
      const O = wl(r, n[1]);
      O[0] = Math.floor(O[0]), O[1] = Math.floor(O[1]), O[2] = Math.floor(O[2]);
      let L = ky(l) / f / f;
      L *= w * C;
      const N = 0.01 * (E - S), F = 0.01 * (D - b), V = 0.01 * (I - R);
      S = Math.floor(S - N), E = Math.ceil(E + N), b = Math.floor(b - F), D = Math.ceil(D + F), R = Math.floor(R - V), I = Math.ceil(I + V);
      const k = [
        [
          S,
          E
        ],
        [
          b,
          D
        ],
        [
          R,
          I
        ]
      ], _ = r.indexToWorld([
        E,
        D,
        I
      ]), K = e.worldToCanvas(_);
      let Z = 0, j = [], B = 0;
      const Y = rfe(r, (ie, oe) => {
        let he = true;
        const Le = e.worldToCanvas(ie);
        return Le[1] != Z && (B = 0, Z = Le[1], j = TN(l, Le, [
          K[0],
          Le[1]
        ]), j.sort(/* @__PURE__ */ (function(Je) {
          return function(Pe, ot) {
            return Pe[Je] === ot[Je] ? 0 : Pe[Je] < ot[Je] ? -1 : 1;
          };
        })(0))), j.length && Le[0] > j[0][0] && (j.shift(), B++), B % 2 === 0 && (he = false), he;
      }, this.configuration.statsCalculator.statsCallback, k), X = this.configuration.statsCalculator.getStatistics();
      a[s] = {
        Modality: i.Modality,
        area: L,
        perimeter: RA(l, closed) / f,
        mean: (_a3 = X.mean) == null ? void 0 : _a3.value,
        max: (_b3 = X.max) == null ? void 0 : _b3.value,
        stdDev: (_c3 = X.stdDev) == null ? void 0 : _c3.value,
        statsArray: X.array,
        pointsInShape: Y,
        areaUnit: u,
        modalityUnit: o,
        unit: h
      };
    }
    updateOpenCachedStats({ targetId: e, metadata: n, canvasCoordinates: r, cachedStats: i, modalityUnit: a, calibratedScale: s }) {
      const { scale: o, units: l } = s;
      i[e] = {
        Modality: n.Modality,
        length: RA(r, false) / o,
        modalityUnit: a,
        unit: l
      };
    }
  }
  function Vde(t, e) {
    const n = t.cachedStats[e], { area: r, mean: i, stdDev: a, length: s, perimeter: o, max: l, isEmptyArea: c, areaUnit: f, modalityUnit: u, unit: h } = n || {}, g = [];
    if (r) {
      const v = c ? "Area: Oblique not supported" : `Area: ${iu(r)} ${f}`;
      g.push(v);
    }
    return i && g.push(`Mean: ${iu(i)} ${u}`), Number.isFinite(l) && g.push(`Max: ${iu(l)} ${u}`), a && g.push(`Std Dev: ${iu(a)} ${u}`), o && g.push(`Perimeter: ${iu(o)} ${h}`), s && g.push(`${iu(s)} ${h}`), g;
  }
  WN.toolName = "PlanarFreehandROI";
  class e0 extends WN {
    constructor(e) {
      const n = zi({
        configuration: {
          calculateStats: false,
          allowOpenContours: false
        }
      }, e);
      super(n);
    }
    isContourSegmentationTool() {
      return true;
    }
    renderAnnotationInstance(e) {
      const n = e.annotation, { invalidated: r } = n, i = super.renderAnnotationInstance(e);
      if (r) {
        const { segmentationId: a } = n.data.segmentation;
        $V(a);
      }
      return i;
    }
  }
  e0.toolName = "PlanarFreehandContourSegmentationTool";
  function Nde(t, e, n = false) {
    const r = pt(t), { viewport: i } = r, s = i.getActors().map(({ uid: o }) => o.startsWith(e) ? o : void 0).filter(Boolean);
    i.removeActors(s);
  }
  function Lde(t, e, n) {
    var _a3;
    const r = rhe(n, e.id), i = pt(t), { viewport: a } = i, s = (_a3 = a.getActor(r)) == null ? void 0 : _a3.actor;
    if (s) {
      const m = s.getMapper(), y = m.getInputData(), w = e.getPoints(), C = e.getPolys(), T = y.getPoints().getData(), S = y.getPolys().getData();
      if (w.length === T.length && C.length === S.length) return;
      const E = $i.newInstance();
      E.getPoints().setData(w, 3);
      const b = Yc.newInstance({
        values: Float32Array.from(C)
      });
      E.setPolys(b), m.setInputData(E), m.modified(), setTimeout(() => {
        a.getRenderer().resetCameraClippingRange();
      }, 0);
      return;
    }
    const o = e.getPoints(), l = e.getPolys(), c = e.getColor(), f = $i.newInstance();
    f.getPoints().setData(o, 3);
    const u = Yc.newInstance({
      values: Float32Array.from(l)
    });
    f.setPolys(u);
    const h = Kc.newInstance({});
    let g;
    h.setInputData(f);
    const v = qc.newInstance();
    v.setMapper(h), v.getProperty().setColor(c[0] / 255, c[1] / 255, c[2] / 255), v.getProperty().setLineWidth(2), a.addActor({
      actor: v,
      uid: r,
      clippingFilter: g
    }), a.resetCamera(), a.render(), setTimeout(() => {
      a.getRenderer().resetCameraClippingRange();
    }, 0);
  }
  function Ude(t, e, n = false) {
    Bde(t, e), Vy(t, e), n && ta(t).getViewportsInfo().forEach(({ viewportId: i, renderingEngineId: a }) => {
      Pa(i, a).viewport.render();
    });
  }
  async function Fde(t, e) {
    const { colorLUTIndex: n, segmentationId: r, segmentationRepresentationUID: i } = e, a = Kn(r);
    if (!a) return;
    if (!(t instanceof Cy)) throw new Error("Surface rendering is only supported in 3D viewports, if you need to visualize the surface cuts in 2D viewports, you can use the Contour representation, see polySeg converters");
    let s = a.representationData[Nt.Surface];
    if (!s && Xy(i) && (s = await Y1e(r, {
      segmentationRepresentationUID: i
    }), !s)) throw new Error(`No Surface data found for segmentationId ${r}.`);
    const { geometryIds: o } = s;
    (o == null ? void 0 : o.size) || console.warn(`No Surfaces found for segmentationId ${r}. Skipping render.`);
    const l = Ny(n);
    o.forEach((c, f) => {
      const u = Ke.getGeometry(c);
      if (!(u == null ? void 0 : u.data)) {
        console.warn(`No Surfaces found for geometryId ${c}. Skipping render.`);
        return;
      }
      const h = u.data, g = l[f];
      h.setColor(g.slice(0, 3)), Lde(t.element, h, i);
    }), t.render();
  }
  function Bde(t, e) {
    const n = ta(t);
    if (n === void 0) throw new Error(`ToolGroup with ToolGroupId ${t} does not exist`);
    const { viewportsInfo: r } = n;
    for (const i of r) {
      const { viewportId: a, renderingEngineId: s } = i, o = Pa(a, s);
      Nde(o.viewport.element, e);
    }
  }
  const _de = {
    render: Fde,
    removeSegmentationRepresentation: Ude
  }, fg = e0.toolName;
  class _h extends of {
    constructor(e = {}, n = {
      configuration: {}
    }) {
      super(e, n), this.renderSegmentation = (r) => {
        const i = ta(r);
        if (!i) return;
        const a = ya(r);
        if (!a || a.length === 0) return;
        const s = i.viewportsInfo.map(({ renderingEngineId: l, viewportId: c }) => {
          const f = Pa(c, l);
          if (f) return f.viewport;
        }), o = a.map((l) => {
          const c = this._getMergedRepresentationsConfig(r), f = [], u = {
            [Nt.Labelmap]: nN,
            [Nt.Contour]: sN,
            [Nt.Surface]: _de
          };
          l.type === Nt.Contour && this.addPlanarFreeHandToolIfAbsent(r);
          const h = u[l.type];
          for (const g of s) {
            const v = h.render(g, l, c);
            f.push(v);
          }
          return f;
        });
        Promise.allSettled(o).then(() => {
          s.forEach((l) => {
            l.render();
          });
        });
      };
    }
    onSetToolEnabled() {
      const e = this.toolGroupId, n = ya(e);
      !n || n.length === 0 || n.forEach((r) => {
        LA(e, r.segmentationRepresentationUID, true);
      });
    }
    onSetToolDisabled() {
      const e = this.toolGroupId, n = ya(e);
      !n || n.length === 0 || n.forEach((r) => {
        LA(e, r.segmentationRepresentationUID, false);
      });
    }
    addPlanarFreeHandToolIfAbsent(e) {
      fg in yt.tools || eh(e0);
      const n = ta(e);
      n.hasTool(fg) || (n.addTool(fg), n.setToolPassive(fg));
    }
    _getMergedRepresentationsConfig(e) {
      const n = Fy(e), r = oN();
      return zi(r, n);
    }
  }
  _h.toolName = "SegmentationDisplay";
  class kde {
    constructor() {
      this._needsRender = /* @__PURE__ */ new Set(), this._animationFrameSet = false, this._animationFrameHandle = null, this._renderFlaggedToolGroups = () => {
        this._throwIfDestroyed();
        const e = Array.from(this._needsRender.values());
        for (const n of e) if (this._triggerRender(n), this._needsRender.delete(n), this._needsRender.size === 0) {
          this._animationFrameSet = false, this._animationFrameHandle = null;
          return;
        }
      };
    }
    removeToolGroup(e) {
      this._needsRender.delete(e), this._needsRender.size === 0 && this._reset();
    }
    renderToolGroupSegmentations(e) {
      this._setToolGroupSegmentationToBeRenderedNextFrame([
        e
      ]);
    }
    _throwIfDestroyed() {
      if (this.hasBeenDestroyed) throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
    }
    _setToolGroupSegmentationToBeRenderedNextFrame(e) {
      e.forEach((n) => {
        this._needsRender.add(n);
      }), this._render();
    }
    _render() {
      this._needsRender.size > 0 && this._animationFrameSet === false && (this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedToolGroups), this._animationFrameSet = true);
    }
    _triggerRender(e) {
      const n = ta(e);
      if (!n) {
        console.warn(`No tool group found with toolGroupId: ${e}`);
        return;
      }
      const { viewportsInfo: r } = n, i = r.map(({ viewportId: o, renderingEngineId: l }) => {
        const c = _a(l);
        if (!c) {
          console.warn("rendering Engine has been destroyed");
          return;
        }
        const f = c.getViewport(o);
        if (f) return f;
      }).filter(Boolean), a = n.getToolInstance(_h.toolName);
      if (!a) {
        console.warn("No segmentation tool found inside", e);
        return;
      }
      function s(o) {
        const { element: l, viewportId: c, renderingEngineId: f } = o.detail;
        l.removeEventListener(ze.IMAGE_RENDERED, s);
        const u = pi(c, f);
        if (!u) {
          console.warn("toolGroup has been destroyed");
          return;
        }
        const h = {
          toolGroupId: u.id,
          viewportId: c
        };
        qe(je, Re.SEGMENTATION_RENDERED, {
          ...h
        });
      }
      i.forEach(({ element: o }) => {
        o.addEventListener(ze.IMAGE_RENDERED, s);
      }), a.renderSegmentation(e);
    }
    _reset() {
      window.cancelAnimationFrame(this._animationFrameHandle), this._needsRender.clear(), this._animationFrameSet = false, this._animationFrameHandle = null;
    }
  }
  const HN = new kde();
  function kh(t) {
    HN.renderToolGroupSegmentations(t);
  }
  const jN = function(t) {
    const { toolGroupId: e } = t.detail;
    kh(e);
  }, Pde = function(t) {
    const { segmentationId: e, modifiedSlicesToUse: n } = t.detail, { representationData: r, type: i } = Kn(e), a = fd(e), s = r[i];
    "volumeId" in s && Gde({
      modifiedSlicesToUse: n,
      representationData: r,
      type: i
    }), "imageIdReferenceMap" in s && zde({
      toolGroupIds: a,
      segmentationId: e,
      representationData: r,
      type: i
    });
  };
  function Gde({ modifiedSlicesToUse: t, representationData: e, type: n }) {
    const r = Ke.getVolume(e[n].volumeId);
    if (!r) {
      console.warn("segmentation not found in cache");
      return;
    }
    const { imageData: i, vtkOpenGLTexture: a } = r;
    let s;
    if (t && Array.isArray(t)) s = t;
    else {
      const o = i.getDimensions()[2];
      s = [
        ...Array(o).keys()
      ];
    }
    s.forEach((o) => {
      a.setUpdatedFrame(o);
    }), i.modified();
  }
  function zde({ toolGroupIds: t, segmentationId: e, representationData: n, type: r }) {
    t.forEach((i) => {
      const a = ya(i), o = ta(i).getViewportsInfo();
      a.forEach((l) => {
        l.segmentationId === e && o.forEach(({ viewportId: c, renderingEngineId: f }) => {
          const u = Pa(c, f).viewport;
          if (u instanceof Ba) return;
          const h = u.getActor(l.segmentationRepresentationUID);
          if (!h) return;
          const g = u.getCurrentImageId(), v = h.actor.getMapper().getInputData(), { imageIdReferenceMap: m } = n[r], y = m.get(g), w = Ke.getImage(y);
          v.modified(), M5(v, w);
        });
      });
    });
  }
  const KN = function(t) {
    const { segmentationId: e } = t.detail, { type: n } = Kn(e), r = fd(e);
    n === Nt.Labelmap && Pde(t), r.forEach((i) => {
      kh(i);
    });
  }, YN = function(t) {
    const { toolGroupId: e, segmentationRepresentationUID: n } = t.detail;
    kh(e);
  }, qN = function(t) {
    const { segmentationId: e } = t.detail;
    fd(e).forEach((r) => {
      ya(r).forEach((a) => {
        a.segmentationId === e && lf(r, a.segmentationRepresentationUID);
      });
    });
  }, Wde = function(t) {
    const { viewport: e } = pt(t);
    e instanceof Ga || (t.addEventListener(ze.STACK_NEW_IMAGE, Ph), t.addEventListener(ze.IMAGE_RENDERED, Ph));
  }, Hde = function(t) {
    t.removeEventListener(ze.STACK_NEW_IMAGE, Ph), t.removeEventListener(ze.IMAGE_RENDERED, Ph);
  }, kA = /* @__PURE__ */ new Map();
  function Ph(t) {
    const e = t.detail, { viewportId: n, renderingEngineId: r } = e, { viewport: i } = Pa(n, r), a = pi(n, r);
    if (!a) return;
    let s = ya(a.id) || [];
    if (s = s.filter((h) => h.type === Nt.Labelmap), !(s == null ? void 0 : s.length)) return;
    const o = {};
    s.forEach((h) => {
      var _a3;
      const g = Kn(h.segmentationId);
      if (!g || !((_a3 = g.representationData) == null ? void 0 : _a3.LABELMAP)) return;
      const v = g.representationData.LABELMAP;
      if (ud(v, i)) return;
      const { imageIdReferenceMap: m } = v;
      o[h.segmentationRepresentationUID] = {
        imageIdReferenceMap: m
      };
    });
    const l = Object.keys(o), c = i.getCurrentImageId(), f = i.getActors();
    if (!f.find((h) => !!l.includes(h.uid))) {
      kA.has(a.id) || (kA.set(a.id, true), kh(a.id));
      return;
    }
    f.forEach((h) => {
      if (!l.includes(h.uid)) return;
      const g = h.actor, { imageIdReferenceMap: v } = o[h.uid], m = v.get(c), y = g.getMapper().getInputData();
      if (!m) {
        if (y.setDerivedImage) {
          y.setDerivedImage(null);
          return;
        }
        const R = Tt.newInstance({
          name: "Pixels",
          numberOfComponents: 1,
          values: new Uint8Array(y.getNumberOfPoints())
        }), I = Bl.newInstance();
        I.getPointData().setScalars(R), g.getMapper().setInputData(I);
        return;
      }
      const w = Ke.getImage(m), { dimensions: C, spacing: T, direction: S } = i.getImageDataMetadata(w), E = Ke.getImage(c) || {
        imageId: c
      }, { origin: b } = i.getImageDataMetadata(E), D = b;
      if (y.setOrigin(D), y.modified(), y.getDimensions()[0] !== C[0] || y.getDimensions()[1] !== C[1]) {
        i.removeActors([
          h.uid
        ]), i.addImages([
          {
            imageId: m,
            actorUID: h.uid,
            callback: ({ imageActor: R }) => {
              const I = Tt.newInstance({
                name: "Pixels",
                numberOfComponents: 1,
                values: [
                  ...w.getPixelData()
                ]
              }), O = Bl.newInstance();
              O.setDimensions(C[0], C[1], 1), O.setSpacing(T), O.setDirection(S), O.setOrigin(D), O.getPointData().setScalars(I), R.getMapper().setInputData(O);
            }
          }
        ]), kh(a.id);
        return;
      }
      y.setDerivedImage ? y.setDerivedImage(w) : M5(y, w), i.render(), t.type === ze.IMAGE_RENDERED && i.element.removeEventListener(ze.IMAGE_RENDERED, Ph);
    });
  }
  const XN = {
    enable: Wde,
    disable: Hde
  };
  function jde(t) {
    const e = t.detail.annotation;
    Uy(e);
  }
  function ZN(t) {
    const e = t.detail.annotation;
    k5(e) && Pfe(t);
  }
  function Jp(t) {
    if (!t.detail.removed.length) return;
    Pl().forEach((r) => {
      const a = r.getViewports().map((s) => s.id);
      bi(r, a);
    });
  }
  function QN(t) {
    const { viewportId: e, renderingEngineId: n } = t.detail, r = _a(n);
    bi(r, [
      e
    ]);
  }
  function Kde(t) {
    const e = t.detail.annotation;
    k5(e) && jde(t);
  }
  const JN = function(t) {
    cd(t.detail.element);
  }, Yde = function(t) {
    t.addEventListener(ze.IMAGE_RENDERED, JN);
  }, qde = function(t) {
    t.removeEventListener(ze.IMAGE_RENDERED, JN);
  }, $N = {
    enable: Yde,
    disable: qde
  }, { Active: Xde } = jn;
  function l0(t, e, n) {
    if (yt.isInteractingWithTool) return false;
    const { renderingEngineId: r, viewportId: i } = n.detail, a = pi(i, r);
    if (!a) return false;
    let s;
    const o = Object.keys(a.toolOptions);
    for (let l = 0; l < o.length; l++) {
      const c = o[l], f = a.toolOptions[c], u = a.getToolInstance(c);
      if (f.mode === Xde && typeof u[e] == "function") {
        s = a.getToolInstance(c);
        break;
      }
    }
    s && s[e](n);
  }
  const eL = l0.bind(null, "Mouse", "mouseClickCallback"), tL = l0.bind(null, "Mouse", "doubleClickCallback");
  function nL(t, e, n, r = "mouse") {
    const i = r === "touch" ? 36 : 6, a = [];
    return e.forEach(({ tool: s, annotations: o }) => {
      for (const l of o) {
        if (l.isLocked || !l.isVisible) continue;
        const c = s.getHandleNearImagePoint(t, l, n, i);
        if (c) {
          a.push({
            tool: s,
            annotation: l,
            handle: c
          });
          break;
        }
      }
    }), a;
  }
  function K5(t, e) {
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      if (!i) {
        console.warn("undefined tool in filterToolsWithAnnotationsForElement");
        continue;
      }
      let a = Wu(i.constructor.toolName, t);
      (a == null ? void 0 : a.length) && (typeof i.filterInteractableAnnotationsForElement == "function" && (a = i.filterInteractableAnnotationsForElement(t, a)), a.length > 0 && n.push({
        tool: i,
        annotations: a
      }));
    }
    return n;
  }
  function Jy(t, e, n, r = "mouse") {
    const i = r === "touch" ? 36 : 6, a = [];
    return e.forEach(({ tool: s, annotations: o }) => {
      for (const l of o) {
        if (l.isLocked || !l.isVisible) continue;
        if (s.isPointNearTool(t, l, n, i, r)) {
          a.push({
            tool: s,
            annotation: l
          });
          break;
        }
      }
    }), a;
  }
  const { Active: Zde } = jn;
  function $y(t) {
    const { renderingEngineId: e, viewportId: n } = t.detail, r = t.detail.event, i = W5(r) || sf.getModifierKey(), a = pi(n, e);
    if (!a) return null;
    const s = Object.keys(a.toolOptions), o = a.getDefaultMousePrimary();
    for (let l = 0; l < s.length; l++) {
      const c = s[l], f = a.toolOptions[c], u = f.bindings.length && f.bindings.some((h) => h.mouseButton === (r ? r.buttons : o) && h.modifierKey === i);
      if (f.mode === Zde && u) return a.getToolInstance(c);
    }
  }
  function zu(t, e, n) {
    const { renderingEngineId: r, viewportId: i } = t.detail, a = pi(i, r);
    if (!a) return [];
    const s = [], o = Object.keys(a.toolOptions);
    for (let l = 0; l < o.length; l++) {
      const c = o[l], f = a.toolOptions[c], u = n != null && f.bindings.length && f.bindings.some((h) => h.mouseButton === n);
      if (e.includes(f.mode) && (!n || u)) {
        const h = a.getToolInstance(c);
        s.push(h);
      }
    }
    return s;
  }
  function Qde(t, e) {
    var _a3;
    const n = /* @__PURE__ */ new Map(), { renderingEngineId: r, viewportId: i } = t.detail, a = pi(i, r);
    if (!a) return n;
    const s = Object.keys(a.toolOptions), o = a.getDefaultMousePrimary(), l = t.detail.event, c = (l == null ? void 0 : l.buttons) ?? o, f = W5(l) || sf.getModifierKey();
    for (let u = 0; u < s.length; u++) {
      const h = s[u], g = a.getToolInstance(h), v = ((_a3 = g.configuration) == null ? void 0 : _a3.actions) ?? {}, m = Object.values(v);
      if (!(m == null ? void 0 : m.length) || !e.includes(g.mode)) continue;
      const y = m.find((w) => w.bindings.length && w.bindings.some((C) => C.mouseButton === c && C.modifierKey === f));
      y && n.set(g, y);
    }
    return n;
  }
  const { Active: Jde, Passive: $de } = jn;
  function e2e(t) {
    if (yt.isInteractingWithTool) return false;
    const e = t.detail, { element: n } = e, r = pt(n), { canvas: i } = e.currentPoints;
    if (!r) return false;
    const a = Qde(t, [
      Jde,
      $de
    ]), s = Array.from(a.keys()), o = K5(n, s), l = Jy(n, o, i);
    if (l.length > 0) {
      const { tool: c, annotation: f } = l[0], u = a.get(c);
      return (typeof u.method == "string" ? c[u.method] : u.method).call(c, t, f), true;
    }
    return false;
  }
  const { Active: t2e, Passive: n2e } = jn;
  function rL(t) {
    if (yt.isInteractingWithTool) return;
    const e = $y(t);
    if (e && typeof e.preMouseDownCallback == "function" && e.preMouseDownCallback(t)) return;
    const n = t.detail.event.buttons === 1, r = zu(t, [
      t2e
    ], t.detail.event.buttons), i = n ? zu(t, [
      n2e
    ]) : void 0, a = [
      ...r || [],
      ...i || []
    ];
    if (e2e(t)) return;
    const o = t.detail, { element: l } = o, c = K5(l, a), f = o.currentPoints.canvas, u = nL(l, c, f, "mouse"), h = !!t.detail.event.shiftKey;
    if (u.length > 0) {
      const { tool: v, annotation: m, handle: y } = PA(u);
      GA(m.annotationUID, h), v.handleSelectedCallback(t, m, y, "Mouse");
      return;
    }
    const g = Jy(l, c, f, "mouse");
    if (g.length > 0) {
      const { tool: v, annotation: m } = PA(g);
      GA(m.annotationUID, h), v.toolSelectedCallback(t, m, "Mouse", f);
      return;
    }
    e && typeof e.postMouseDownCallback == "function" && e.postMouseDownCallback(t);
  }
  function PA(t) {
    return t.length > 1 && t.find((e) => !_u(e.annotation) && Vh(e.annotation.annotationUID)) || t[0];
  }
  function GA(t, e = false) {
    e ? L5(t) ? Ol(t, false) : Ol(t, true, true) : Ol(t, true, false);
  }
  function iL(t) {
    if (yt.isInteractingWithTool) return;
    const e = $y(t);
    if (e && e.addNewAnnotation) {
      const n = e.addNewAnnotation(t, "mouse");
      Ol(n.annotationUID);
    }
  }
  function aL(t) {
    if (yt.isInteractingWithTool) return;
    const e = $y(t);
    !e || typeof e.mouseDragCallback != "function" || e.mouseDragCallback(t);
  }
  const { Active: r2e, Passive: i2e } = jn;
  function sL(t) {
    if (yt.isInteractingWithTool || yt.isMultiPartToolActive) return;
    const e = zu(t, [
      r2e,
      i2e
    ]), n = t.detail, { element: r } = n, i = K5(r, e), a = e.filter((o) => !i.some((c) => c.tool.getToolName() === o.getToolName()));
    let s = false;
    for (const { tool: o, annotations: l } of i) typeof o.mouseMoveCallback == "function" && (s = o.mouseMoveCallback(t, l) || s);
    a.forEach((o) => {
      typeof o.mouseMoveCallback == "function" && o.mouseMoveCallback(t);
    }), s === true && cd(r);
  }
  const oL = l0.bind(null, "Mouse", "mouseUpCallback"), lL = l0.bind(null, "MouseWheel", "mouseWheelCallback"), a2e = function(t) {
    t.addEventListener(Re.MOUSE_CLICK, eL), t.addEventListener(Re.MOUSE_DOWN, rL), t.addEventListener(Re.MOUSE_DOWN_ACTIVATE, iL), t.addEventListener(Re.MOUSE_DOUBLE_CLICK, tL), t.addEventListener(Re.MOUSE_DRAG, aL), t.addEventListener(Re.MOUSE_MOVE, sL), t.addEventListener(Re.MOUSE_UP, oL), t.addEventListener(Re.MOUSE_WHEEL, lL);
  }, s2e = function(t) {
    t.removeEventListener(Re.MOUSE_CLICK, eL), t.removeEventListener(Re.MOUSE_DOWN, rL), t.removeEventListener(Re.MOUSE_DOWN_ACTIVATE, iL), t.removeEventListener(Re.MOUSE_DOUBLE_CLICK, tL), t.removeEventListener(Re.MOUSE_DRAG, aL), t.removeEventListener(Re.MOUSE_MOVE, sL), t.removeEventListener(Re.MOUSE_UP, oL), t.removeEventListener(Re.MOUSE_WHEEL, lL);
  }, cL = {
    enable: a2e,
    disable: s2e
  }, { Active: o2e } = jn;
  function uL(t) {
    const { renderingEngineId: e, viewportId: n } = t.detail, r = Hce(), i = sf.getModifierKey(), a = pi(n, e);
    if (!a) return null;
    const s = Object.keys(a.toolOptions), o = a.getDefaultMousePrimary();
    for (let l = 0; l < s.length; l++) {
      const c = s[l], f = a.toolOptions[c];
      if (f.mode !== o2e) continue;
      if (f.bindings.length && f.bindings.some((h) => h.mouseButton === (r ?? o) && h.modifierKey === i)) return a.getToolInstance(c);
    }
  }
  function l2e(t, e) {
    var _a3;
    const n = /* @__PURE__ */ new Map(), { renderingEngineId: r, viewportId: i } = t.detail, a = pi(i, r);
    if (!a) return n;
    const s = Object.keys(a.toolOptions), o = t.detail.key;
    for (let l = 0; l < s.length; l++) {
      const c = s[l], f = a.getToolInstance(c), u = (_a3 = f.configuration) == null ? void 0 : _a3.actions;
      if (!u) continue;
      const h = Object.values(u);
      if (!(h == null ? void 0 : h.length) || !e.includes(f.mode)) continue;
      const g = h.find((v) => v.bindings.some((m) => m.key === o));
      g && n.set(f, g);
    }
    return n;
  }
  function fL(t) {
    const e = uL(t);
    if (e) {
      const { renderingEngineId: r, viewportId: i } = t.detail, a = pi(i, r), s = e.getToolName();
      Object.keys(a.toolOptions).includes(s) && a.setViewportsCursorByToolName(s);
    }
    const n = l2e(t, [
      jn.Active
    ]);
    if (n == null ? void 0 : n.size) {
      const { element: r } = t.detail;
      for (const [i, a] of [
        ...n.entries()
      ]) (typeof a.method == "function" ? a.method : i[a.method]).call(i, r, a, t);
    }
  }
  function hL(t) {
    const e = uL(t);
    if (!e) return;
    const { renderingEngineId: n, viewportId: r } = t.detail, i = pi(r, n);
    YV();
    const a = e.getToolName();
    Object.keys(i.toolOptions).includes(a) && i.setViewportsCursorByToolName(a);
  }
  const c2e = function(t) {
    t.addEventListener(Re.KEY_DOWN, fL), t.addEventListener(Re.KEY_UP, hL);
  }, u2e = function(t) {
    t.removeEventListener(Re.KEY_DOWN, fL), t.removeEventListener(Re.KEY_UP, hL);
  }, dL = {
    enable: c2e,
    disable: u2e
  }, { Active: f2e, Passive: h2e, Enabled: d2e } = jn, gL = function(t) {
    zu(t, [
      f2e,
      h2e,
      d2e
    ]).forEach((n) => {
      n.onCameraModified && n.onCameraModified(t);
    });
  }, g2e = function(t) {
    t.addEventListener(ze.CAMERA_MODIFIED, gL);
  }, p2e = function(t) {
    t.removeEventListener(ze.CAMERA_MODIFIED, gL);
  }, pL = {
    enable: g2e,
    disable: p2e
  }, { Active: m2e, Passive: v2e, Enabled: y2e } = jn, mL = function(t) {
    zu(t, [
      m2e,
      v2e,
      y2e
    ]).forEach((n) => {
      n.onImageSpacingCalibrated && n.onImageSpacingCalibrated(t);
    });
  }, x2e = function(t) {
    t.addEventListener(ze.IMAGE_SPACING_CALIBRATED, mL);
  }, w2e = function(t) {
    t.removeEventListener(ze.IMAGE_SPACING_CALIBRATED, mL);
  }, vL = {
    enable: x2e,
    disable: w2e
  }, { Active: C2e } = jn;
  function e9(t) {
    const { renderingEngineId: e, viewportId: n } = t.detail, r = t.detail.event, i = pi(n, e);
    if (!i) return null;
    const a = Object.keys(i.toolOptions), s = Object.keys(r.touches).length, o = W5(r) || sf.getModifierKey(), l = i.getDefaultMousePrimary();
    for (let c = 0; c < a.length; c++) {
      const f = a[c], u = i.toolOptions[f], h = u.bindings.length && u.bindings.some((g) => (g.numTouchPoints === s || s === 1 && g.mouseButton === l) && g.modifierKey === o);
      if (u.mode === C2e && h) return i.getToolInstance(f);
    }
  }
  function zA(t, e, n) {
    const { renderingEngineId: r, viewportId: i } = t.detail, a = pi(i, r);
    if (!a) return [];
    const s = [], o = Object.keys(a.toolOptions);
    for (let l = 0; l < o.length; l++) {
      const c = o[l], f = a.toolOptions[c], u = n != null && f.bindings.length && f.bindings.some((h) => h.numTouchPoints === n);
      if (e.includes(f.mode) && (!n || u)) {
        const h = a.getToolInstance(c);
        s.push(h);
      }
    }
    return s;
  }
  const { Active: T2e, Passive: S2e } = jn;
  function yL(t) {
    if (yt.isInteractingWithTool) return;
    const e = e9(t);
    if (e && typeof e.preTouchStartCallback == "function" && e.preTouchStartCallback(t)) return;
    const n = Object.keys(t.detail.event.touches).length === 1, r = zA(t, [
      T2e
    ], Object.keys(t.detail.event.touches).length), i = n ? zA(t, [
      S2e
    ]) : void 0, a = [
      ...r || [],
      ...i || [],
      e
    ], s = t.detail, { element: o } = s, l = K5(o, a), c = s.currentPoints.canvas, f = nL(o, l, c, "touch"), u = false;
    if (f.length > 0) {
      const { tool: g, annotation: v, handle: m } = WA(f);
      HA(v.annotationUID, u), g.handleSelectedCallback(t, v, m, "Touch");
      return;
    }
    const h = Jy(o, l, c, "touch");
    if (h.length > 0) {
      const { tool: g, annotation: v } = WA(h);
      HA(v.annotationUID, u), g.toolSelectedCallback(t, v, "Touch");
      return;
    }
    e && typeof e.postTouchStartCallback == "function" && e.postTouchStartCallback(t);
  }
  function WA(t) {
    return t.length > 1 && t.find((e) => !_u(e.annotation) && Vh(e.annotation.annotationUID)) || t[0];
  }
  function HA(t, e = false) {
    e ? L5(t) ? Ol(t, false) : Ol(t, true, true) : Ol(t, true, false);
  }
  function xL(t) {
    if (yt.isInteractingWithTool) return;
    const e = e9(t);
    if (e && e.addNewAnnotation) {
      const n = e.addNewAnnotation(t, "touch");
      Ol(n.annotationUID);
    }
  }
  function wL(t) {
    if (yt.isInteractingWithTool) return;
    const e = e9(t);
    !e || typeof e.touchDragCallback != "function" || e.touchDragCallback(t);
  }
  const CL = l0.bind(null, "Touch", "touchEndCallback"), A2e = l0.bind(null, "Touch", "touchTapCallback"), TL = l0.bind(null, "Touch", "touchPressCallback"), E2e = function(t) {
    t.addEventListener(Re.TOUCH_START, yL), t.addEventListener(Re.TOUCH_START_ACTIVATE, xL), t.addEventListener(Re.TOUCH_DRAG, wL), t.addEventListener(Re.TOUCH_END, CL), t.addEventListener(Re.TOUCH_TAP, A2e), t.addEventListener(Re.TOUCH_PRESS, TL);
  }, b2e = function(t) {
    t.removeEventListener(Re.TOUCH_START, yL), t.removeEventListener(Re.TOUCH_START_ACTIVATE, xL), t.removeEventListener(Re.TOUCH_DRAG, wL), t.removeEventListener(Re.TOUCH_END, CL), t.removeEventListener(Re.TOUCH_PRESS, TL);
  }, SL = {
    enable: E2e,
    disable: b2e
  }, D2e = function() {
    je.addEventListener(Re.ANNOTATION_COMPLETED, To.handleAnnotationCompleted), je.addEventListener(Re.ANNOTATION_MODIFIED, To.handleAnnotationUpdate), je.addEventListener(Re.ANNOTATION_REMOVED, To.handleAnnotationDelete);
  }, M2e = function() {
    je.removeEventListener(Re.ANNOTATION_COMPLETED, To.handleAnnotationCompleted), je.removeEventListener(Re.ANNOTATION_MODIFIED, To.handleAnnotationUpdate), je.removeEventListener(Re.ANNOTATION_REMOVED, To.handleAnnotationDelete);
  }, AL = {
    enable: D2e,
    disable: M2e
  }, { Active: R2e, Passive: O2e, Enabled: I2e } = jn, EL = function(t) {
    zu(t, [
      R2e,
      O2e,
      I2e
    ]).forEach((n) => {
      n.onResetCamera && n.onResetCamera(t);
    });
  }, V2e = function(t) {
    t.addEventListener(ze.CAMERA_RESET, EL);
  }, N2e = function(t) {
    t.removeEventListener(ze.CAMERA_RESET, EL);
  }, bL = {
    enable: V2e,
    disable: N2e
  };
  function DL(t) {
    const { element: e, viewportId: n } = t.detail, r = L2e(n);
    U2e(e), F2e(r, e), Oy.addViewportElement(n, e), EV.enable(e), jV.enable(e), zV.enable(e), sf.enable(e), XN.enable(e), $N.enable(e), pL.enable(e), vL.enable(e), bL.enable(e), cL.enable(e), dL.enable(e), SL.enable(e), yt.enabledElements.push(e);
  }
  function L2e(t) {
    const e = "http://www.w3.org/2000/svg", n = document.createElementNS(e, "svg"), r = `svg-layer-${t}`;
    n.classList.add("svg-layer"), n.setAttribute("id", r), n.setAttribute("xmlns", "http://www.w3.org/2000/svg"), n.style.width = "100%", n.style.height = "100%", n.style.pointerEvents = "none", n.style.position = "absolute";
    const i = document.createElementNS(e, "defs"), a = document.createElementNS(e, "filter"), s = document.createElementNS(e, "feOffset"), o = document.createElementNS(e, "feColorMatrix"), l = document.createElementNS(e, "feBlend");
    return a.setAttribute("id", `shadow-${r}`), a.setAttribute("filterUnits", "userSpaceOnUse"), s.setAttribute("result", "offOut"), s.setAttribute("in", "SourceGraphic"), s.setAttribute("dx", "0.5"), s.setAttribute("dy", "0.5"), o.setAttribute("result", "matrixOut"), o.setAttribute("in", "offOut"), o.setAttribute("in2", "matrix"), o.setAttribute("values", "0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0"), l.setAttribute("in", "SourceGraphic"), l.setAttribute("in2", "matrixOut"), l.setAttribute("mode", "normal"), a.appendChild(s), a.appendChild(o), a.appendChild(l), i.appendChild(a), n.appendChild(i), n;
  }
  function U2e(t) {
    const { viewportUid: e, renderingEngineUid: n } = t.dataset, r = `${e}:${n}`;
    yt.svgNodeCache[r] = {};
  }
  function F2e(t, e) {
    e.querySelector("div.viewport-element").appendChild(t);
  }
  function B2e(t, e) {
    const n = [];
    if (!e && !t) throw new Error("At least one of renderingEngineId or viewportId should be given");
    for (let r = 0; r < yt.synchronizers.length; r++) {
      const i = yt.synchronizers[r], a = !i.isDisabled(), s = i.hasSourceViewport(e, t), o = i.hasTargetViewport(e, t);
      a && (s || o) && n.push(i);
    }
    return n;
  }
  function pi(t, e) {
    var _a3;
    e || (e = (_a3 = Pl().find((r) => r.getViewports().find((i) => i.id === t))) == null ? void 0 : _a3.id);
    const n = yt.toolGroups.filter((r) => r.viewportsInfo.some((i) => i.renderingEngineId === e && (!i.viewportId || i.viewportId === t)));
    if (n.length) {
      if (n.length > 1) throw new Error(`Multiple tool groups found for renderingEngineId: ${e} and viewportId: ${t}. You should only
      have one tool group per viewport in a renderingEngine.`);
      return n[0];
    }
  }
  const _2e = "viewport-element";
  function ML(t) {
    const { element: e, viewportId: n } = t.detail;
    G2e(e), z2e(e), Oy.removeViewportElement(n, e), EV.disable(e), jV.disable(e), zV.disable(e), sf.disable(e), XN.disable(e), $N.disable(e), pL.disable(e), vL.disable(e), bL.disable(e), cL.disable(e), dL.disable(e), SL.disable(e), k2e(e), P2e(e), W2e(e);
  }
  const k2e = (t) => {
    const e = pt(t);
    B2e(e.viewportId, e.renderingEngineId).forEach((r) => {
      r.remove(e);
    });
  }, P2e = (t) => {
    const { renderingEngineId: e, viewportId: n } = pt(t), r = pi(n, e);
    r && r.removeViewports(e, n);
  };
  function G2e(t) {
    const { viewportUid: e, renderingEngineUid: n } = t.dataset, r = `${e}:${n}`;
    delete yt.svgNodeCache[r];
  }
  function z2e(t) {
    const e = t.querySelector(`div.${_2e}`), n = e.querySelector("svg");
    n && e.removeChild(n);
  }
  const W2e = function(t) {
    const e = yt.enabledElements.findIndex((n) => n === t);
    e > -1 && yt.enabledElements.splice(e, 1);
  };
  var yv, jA;
  function H2e() {
    if (jA) return yv;
    jA = 1;
    var t = "Expected a function", e = "__lodash_hash_undefined__", n = "[object Function]", r = "[object GeneratorFunction]", i = "[object Symbol]", a = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, s = /^\w*$/, o = /^\./, l = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, c = /[\\^$.*+?()[\]{}|]/g, f = /\\(\\)?/g, u = /^\[object .+?Constructor\]$/, h = typeof ci == "object" && ci && ci.Object === Object && ci, g = typeof self == "object" && self && self.Object === Object && self, v = h || g || Function("return this")();
    function m(ye, ke) {
      return ye == null ? void 0 : ye[ke];
    }
    function y(ye) {
      var ke = false;
      if (ye != null && typeof ye.toString != "function") try {
        ke = !!(ye + "");
      } catch {
      }
      return ke;
    }
    var w = Array.prototype, C = Function.prototype, T = Object.prototype, S = v["__core-js_shared__"], E = (function() {
      var ye = /[^.]+$/.exec(S && S.keys && S.keys.IE_PROTO || "");
      return ye ? "Symbol(src)_1." + ye : "";
    })(), b = C.toString, D = T.hasOwnProperty, R = T.toString, I = RegExp("^" + b.call(D).replace(c, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), O = v.Symbol, L = w.splice, N = Oe(v, "Map"), F = Oe(Object, "create"), V = O ? O.prototype : void 0, k = V ? V.toString : void 0;
    function _(ye) {
      var ke = -1, rt = ye ? ye.length : 0;
      for (this.clear(); ++ke < rt; ) {
        var sn = ye[ke];
        this.set(sn[0], sn[1]);
      }
    }
    function K() {
      this.__data__ = F ? F(null) : {};
    }
    function Z(ye) {
      return this.has(ye) && delete this.__data__[ye];
    }
    function j(ye) {
      var ke = this.__data__;
      if (F) {
        var rt = ke[ye];
        return rt === e ? void 0 : rt;
      }
      return D.call(ke, ye) ? ke[ye] : void 0;
    }
    function B(ye) {
      var ke = this.__data__;
      return F ? ke[ye] !== void 0 : D.call(ke, ye);
    }
    function Y(ye, ke) {
      var rt = this.__data__;
      return rt[ye] = F && ke === void 0 ? e : ke, this;
    }
    _.prototype.clear = K, _.prototype.delete = Z, _.prototype.get = j, _.prototype.has = B, _.prototype.set = Y;
    function X(ye) {
      var ke = -1, rt = ye ? ye.length : 0;
      for (this.clear(); ++ke < rt; ) {
        var sn = ye[ke];
        this.set(sn[0], sn[1]);
      }
    }
    function ie() {
      this.__data__ = [];
    }
    function oe(ye) {
      var ke = this.__data__, rt = G(ke, ye);
      if (rt < 0) return false;
      var sn = ke.length - 1;
      return rt == sn ? ke.pop() : L.call(ke, rt, 1), true;
    }
    function he(ye) {
      var ke = this.__data__, rt = G(ke, ye);
      return rt < 0 ? void 0 : ke[rt][1];
    }
    function Le(ye) {
      return G(this.__data__, ye) > -1;
    }
    function Je(ye, ke) {
      var rt = this.__data__, sn = G(rt, ye);
      return sn < 0 ? rt.push([
        ye,
        ke
      ]) : rt[sn][1] = ke, this;
    }
    X.prototype.clear = ie, X.prototype.delete = oe, X.prototype.get = he, X.prototype.has = Le, X.prototype.set = Je;
    function Pe(ye) {
      var ke = -1, rt = ye ? ye.length : 0;
      for (this.clear(); ++ke < rt; ) {
        var sn = ye[ke];
        this.set(sn[0], sn[1]);
      }
    }
    function ot() {
      this.__data__ = {
        hash: new _(),
        map: new (N || X)(),
        string: new _()
      };
    }
    function vt(ye) {
      return ce(this, ye).delete(ye);
    }
    function wt(ye) {
      return ce(this, ye).get(ye);
    }
    function Qe(ye) {
      return ce(this, ye).has(ye);
    }
    function _t6(ye, ke) {
      return ce(this, ye).set(ye, ke), this;
    }
    Pe.prototype.clear = ot, Pe.prototype.delete = vt, Pe.prototype.get = wt, Pe.prototype.has = Qe, Pe.prototype.set = _t6;
    function G(ye, ke) {
      for (var rt = ye.length; rt--; ) if (it(ye[rt][0], ke)) return rt;
      return -1;
    }
    function Se(ye, ke) {
      ke = Ve(ke, ye) ? [
        ke
      ] : ne(ke);
      for (var rt = 0, sn = ke.length; ye != null && rt < sn; ) ye = ye[Ge(ke[rt++])];
      return rt && rt == sn ? ye : void 0;
    }
    function xe(ye) {
      if (!mr(ye) || We(ye)) return false;
      var ke = jt(ye) || y(ye) ? I : u;
      return ke.test(at(ye));
    }
    function re(ye) {
      if (typeof ye == "string") return ye;
      if (mn(ye)) return k ? k.call(ye) : "";
      var ke = ye + "";
      return ke == "0" && 1 / ye == -1 / 0 ? "-0" : ke;
    }
    function ne(ye) {
      return fn(ye) ? ye : Ze(ye);
    }
    function ce(ye, ke) {
      var rt = ye.__data__;
      return de(ke) ? rt[typeof ke == "string" ? "string" : "hash"] : rt.map;
    }
    function Oe(ye, ke) {
      var rt = m(ye, ke);
      return xe(rt) ? rt : void 0;
    }
    function Ve(ye, ke) {
      if (fn(ye)) return false;
      var rt = typeof ye;
      return rt == "number" || rt == "symbol" || rt == "boolean" || ye == null || mn(ye) ? true : s.test(ye) || !a.test(ye) || ke != null && ye in Object(ke);
    }
    function de(ye) {
      var ke = typeof ye;
      return ke == "string" || ke == "number" || ke == "symbol" || ke == "boolean" ? ye !== "__proto__" : ye === null;
    }
    function We(ye) {
      return !!E && E in ye;
    }
    var Ze = ut(function(ye) {
      ye = Wr(ye);
      var ke = [];
      return o.test(ye) && ke.push(""), ye.replace(l, function(rt, sn, ti, lr) {
        ke.push(ti ? lr.replace(f, "$1") : sn || rt);
      }), ke;
    });
    function Ge(ye) {
      if (typeof ye == "string" || mn(ye)) return ye;
      var ke = ye + "";
      return ke == "0" && 1 / ye == -1 / 0 ? "-0" : ke;
    }
    function at(ye) {
      if (ye != null) {
        try {
          return b.call(ye);
        } catch {
        }
        try {
          return ye + "";
        } catch {
        }
      }
      return "";
    }
    function ut(ye, ke) {
      if (typeof ye != "function" || ke && typeof ke != "function") throw new TypeError(t);
      var rt = function() {
        var sn = arguments, ti = ke ? ke.apply(this, sn) : sn[0], lr = rt.cache;
        if (lr.has(ti)) return lr.get(ti);
        var vn = ye.apply(this, sn);
        return rt.cache = lr.set(ti, vn), vn;
      };
      return rt.cache = new (ut.Cache || Pe)(), rt;
    }
    ut.Cache = Pe;
    function it(ye, ke) {
      return ye === ke || ye !== ye && ke !== ke;
    }
    var fn = Array.isArray;
    function jt(ye) {
      var ke = mr(ye) ? R.call(ye) : "";
      return ke == n || ke == r;
    }
    function mr(ye) {
      var ke = typeof ye;
      return !!ye && (ke == "object" || ke == "function");
    }
    function Di(ye) {
      return !!ye && typeof ye == "object";
    }
    function mn(ye) {
      return typeof ye == "symbol" || Di(ye) && R.call(ye) == i;
    }
    function Wr(ye) {
      return ye == null ? "" : re(ye);
    }
    function Ur(ye, ke, rt) {
      var sn = ye == null ? void 0 : Se(ye, ke);
      return sn === void 0 ? rt : sn;
    }
    return yv = Ur, yv;
  }
  var j2e = H2e();
  const K2e = t0(j2e), { Active: M1, Passive: xv, Enabled: wv, Disabled: Cv } = jn, Y2e = [
    {
      mouseButton: Bu.Primary
    }
  ];
  class q2e {
    constructor(e) {
      this.viewportsInfo = [], this.toolOptions = {}, this.currentActivePrimaryToolName = null, this.prevActivePrimaryToolName = null, this.restoreToolOptions = {}, this._toolInstances = {}, this.id = e;
    }
    getViewportIds() {
      return this.viewportsInfo.map(({ viewportId: e }) => e);
    }
    getViewportsInfo() {
      return this.viewportsInfo.slice();
    }
    getToolInstance(e) {
      const n = this._toolInstances[e];
      if (!n) {
        console.warn(`'${e}' is not registered with this toolGroup (${this.id}).`);
        return;
      }
      return n;
    }
    getToolInstances() {
      return this._toolInstances;
    }
    hasTool(e) {
      return !!this._toolInstances[e];
    }
    addTool(e, n = {}) {
      const r = yt.tools[e], i = typeof e < "u" && e !== "", a = this.toolOptions[e];
      if (!i) {
        console.warn("Tool with configuration did not produce a toolName: ", n);
        return;
      }
      if (!r) {
        console.warn(`'${e}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);
        return;
      }
      if (a) {
        console.warn(`'${e}' is already registered for ToolGroup ${this.id}.`);
        return;
      }
      const { toolClass: s } = r, o = {
        name: e,
        toolGroupId: this.id,
        configuration: n
      }, l = new s(o);
      this._toolInstances[e] = l;
    }
    addToolInstance(e, n, r = {}) {
      var _a3;
      let i = (_a3 = yt.tools[e]) == null ? void 0 : _a3.toolClass;
      if (!i) {
        const a = yt.tools[n].toolClass;
        class s extends a {
        }
        s.toolName = e, i = s, yt.tools[e] = {
          toolClass: s
        };
      }
      this.addTool(i.toolName, r);
    }
    addViewport(e, n) {
      if (typeof e != "string") throw new Error("viewportId must be defined and be a string");
      const r = Pl();
      if (!n && r.length > 1) throw new Error("You must specify a renderingEngineId when there are multiple rendering engines.");
      const i = n || r[0].id;
      this.viewportsInfo.some(({ viewportId: l }) => l === e) || this.viewportsInfo.push({
        viewportId: e,
        renderingEngineId: i
      });
      const a = this.getActivePrimaryMouseButtonTool();
      Pn.getRuntimeSettings().get("useCursors") && this.setViewportsCursorByToolName(a);
      const o = {
        toolGroupId: this.id,
        viewportId: e,
        renderingEngineId: i
      };
      qe(je, Re.TOOLGROUP_VIEWPORT_ADDED, o);
    }
    removeViewports(e, n) {
      const r = [];
      if (this.viewportsInfo.forEach((a, s) => {
        let o = false;
        a.renderingEngineId === e && (o = true, n && a.viewportId !== n && (o = false)), o && r.push(s);
      }), r.length) for (let a = r.length - 1; a >= 0; a--) this.viewportsInfo.splice(r[a], 1);
      const i = {
        toolGroupId: this.id,
        viewportId: n,
        renderingEngineId: e
      };
      qe(je, Re.TOOLGROUP_VIEWPORT_REMOVED, i);
    }
    setActiveStrategy(e, n) {
      const r = this._toolInstances[e];
      if (r === void 0) {
        console.warn(`Tool ${e} not added to toolGroup, can't set tool configuration.`);
        return;
      }
      r.setActiveStrategy(n);
    }
    setToolMode(e, n, r = {}) {
      if (!e) {
        console.warn("setToolMode: toolName must be defined");
        return;
      }
      if (n === jn.Active) {
        this.setToolActive(e, r || this.restoreToolOptions[e]);
        return;
      }
      if (n === jn.Passive) {
        this.setToolPassive(e);
        return;
      }
      if (n === jn.Enabled) {
        this.setToolEnabled(e);
        return;
      }
      if (n === jn.Disabled) {
        this.setToolDisabled(e);
        return;
      }
      console.warn("setToolMode: mode must be defined");
    }
    setToolActive(e, n = {}) {
      const r = this._toolInstances[e];
      if (r === void 0) {
        console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
        return;
      }
      if (!r) {
        console.warn(`'${e}' instance ${r} is not registered with this toolGroup, can't set tool mode.`);
        return;
      }
      const i = this.toolOptions[e] ? this.toolOptions[e].bindings : [], a = n.bindings ? n.bindings : [], o = {
        bindings: [
          ...i,
          ...a
        ].reduce((u, h) => {
          const g = h.numTouchPoints !== void 0, v = h.mouseButton !== void 0;
          return !u.some((m) => Tv(m, h)) && (g || v) && u.push(h), u;
        }, []),
        mode: M1
      };
      this.toolOptions[e] = o, this._toolInstances[e].mode = M1;
      const c = Pn.getRuntimeSettings().get("useCursors");
      if (this._hasMousePrimaryButtonBinding(n) && c) this.setViewportsCursorByToolName(e);
      else if (!this.getActivePrimaryMouseButtonTool() && c) {
        const h = pa.getDefinedCursor("default");
        this._setCursorForViewports(h);
      }
      this._hasMousePrimaryButtonBinding(n) && (this.prevActivePrimaryToolName === null ? this.prevActivePrimaryToolName = e : this.prevActivePrimaryToolName = this.currentActivePrimaryToolName, this.currentActivePrimaryToolName = e), typeof r.onSetToolActive == "function" && r.onSetToolActive(), this._renderViewports();
      const f = {
        toolGroupId: this.id,
        toolName: e,
        toolBindingsOptions: n
      };
      qe(je, Re.TOOL_ACTIVATED, f), this._triggerToolModeChangedEvent(e, M1, n);
    }
    setToolPassive(e, n) {
      const r = this._toolInstances[e];
      if (r === void 0) {
        console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
        return;
      }
      const i = this.getToolOptions(e), a = Object.assign({
        bindings: i ? i.bindings : []
      }, i, {
        mode: xv
      }), s = Array.isArray(n == null ? void 0 : n.removeAllBindings) ? n.removeAllBindings : this.getDefaultPrimaryBindings();
      a.bindings = a.bindings.filter((l) => (n == null ? void 0 : n.removeAllBindings) !== true && !s.some((c) => Tv(l, c)));
      let o = xv;
      a.bindings.length !== 0 && (o = M1, a.mode = o), this.toolOptions[e] = a, r.mode = o, typeof r.onSetToolPassive == "function" && r.onSetToolPassive(), this._renderViewports(), this._triggerToolModeChangedEvent(e, xv);
    }
    setToolEnabled(e) {
      const n = this._toolInstances[e];
      if (n === void 0) {
        console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
        return;
      }
      const r = {
        bindings: [],
        mode: wv
      };
      this.toolOptions[e] = r, n.mode = wv, typeof n.onSetToolEnabled == "function" && n.onSetToolEnabled(), this._renderViewports(), this._triggerToolModeChangedEvent(e, wv);
    }
    setToolDisabled(e) {
      const n = this._toolInstances[e];
      if (n === void 0) {
        console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
        return;
      }
      const r = {
        bindings: [],
        mode: Cv
      };
      this.restoreToolOptions[e] = this.toolOptions[e], this.toolOptions[e] = r, n.mode = Cv, typeof n.onSetToolDisabled == "function" && n.onSetToolDisabled(), this._renderViewports(), this._triggerToolModeChangedEvent(e, Cv);
    }
    getToolOptions(e) {
      const n = this.toolOptions[e];
      if (n !== void 0) return n;
    }
    getActivePrimaryMouseButtonTool() {
      return Object.keys(this.toolOptions).find((e) => {
        const n = this.toolOptions[e];
        return n.mode === M1 && this._hasMousePrimaryButtonBinding(n);
      });
    }
    setViewportsCursorByToolName(e, n) {
      const r = this._getCursor(e, n);
      this._setCursorForViewports(r);
    }
    _getCursor(e, n) {
      let r, i;
      return n && (r = `${e}.${n}`, i = Yg.getDefinedCursor(r, true), i) || (r = `${e}`, i = Yg.getDefinedCursor(r, true), i) || (r = e, i = Yg.getDefinedCursor(r, true), i) ? i : pa.getDefinedCursor("default");
    }
    _setCursorForViewports(e) {
      this.viewportsInfo.forEach(({ renderingEngineId: n, viewportId: r }) => {
        const i = Pa(r, n);
        if (!i) return;
        const { viewport: a } = i;
        v1e(a.element, e);
      });
    }
    setToolConfiguration(e, n, r) {
      const i = this._toolInstances[e];
      if (i === void 0) return console.warn(`Tool ${e} not present, can't set tool configuration.`), false;
      let a;
      return r ? a = n : a = Object.assign(i.configuration, n), i.configuration = a, typeof i.onSetToolConfiguration == "function" && i.onSetToolConfiguration(), this._renderViewports(), true;
    }
    getDefaultMousePrimary() {
      return Bu.Primary;
    }
    getDefaultPrimaryBindings() {
      return Y2e;
    }
    getToolConfiguration(e, n) {
      if (this._toolInstances[e] === void 0) {
        console.warn(`Tool ${e} not present, can't set tool configuration.`);
        return;
      }
      const r = K2e(this._toolInstances[e].configuration, n) || this._toolInstances[e].configuration;
      return Ar(r);
    }
    getPrevActivePrimaryToolName() {
      return this.prevActivePrimaryToolName;
    }
    clone(e, n = null) {
      let r = ta(e);
      return r ? (console.warn(`ToolGroup ${e} already exists`), r) : (r = RL(e), n = n ?? (() => true), Object.keys(this._toolInstances).filter(n).forEach((i) => {
        const a = this._toolInstances[i], s = this.toolOptions[i], o = a.mode;
        r.addTool(i), r.setToolMode(i, o, {
          bindings: s.bindings ?? []
        });
      }), r);
    }
    _hasMousePrimaryButtonBinding(e) {
      var _a3;
      const n = this.getDefaultPrimaryBindings();
      return (_a3 = e == null ? void 0 : e.bindings) == null ? void 0 : _a3.some((r) => n.some((i) => Tv(r, i)));
    }
    _renderViewports() {
      this.viewportsInfo.forEach(({ renderingEngineId: e, viewportId: n }) => {
        _a(e).renderViewport(n);
      });
    }
    _triggerToolModeChangedEvent(e, n, r) {
      const i = {
        toolGroupId: this.id,
        toolName: e,
        mode: n,
        toolBindingsOptions: r
      };
      qe(je, Re.TOOL_MODE_CHANGED, i);
    }
  }
  function Tv(t, e) {
    return t.mouseButton !== e.mouseButton || t.numTouchPoints !== e.numTouchPoints ? false : t.modifierKey === e.modifierKey;
  }
  function RL(t) {
    if (yt.toolGroups.some((r) => r.id === t)) {
      console.warn(`'${t}' already exists.`);
      return;
    }
    const n = new q2e(t);
    return yt.toolGroups.push(n), n;
  }
  function X2e(t) {
    const e = yt.toolGroups.findIndex((n) => n.id === t);
    e > -1 && (HN.removeToolGroup(t), Pue(t), yt.toolGroups.splice(e, 1));
  }
  function ta(t) {
    return yt.toolGroups.find((e) => e.id === t);
  }
  const Z2e = [
    jn.Active,
    jn.Passive,
    jn.Enabled
  ];
  function Q2e(t) {
    return yt.toolGroups.filter(({ toolOptions: e }) => {
      const n = Object.keys(e);
      for (let r = 0; r < n.length; r++) if (t === n[r] && e[t] && Z2e.includes(e[t].mode)) return true;
      return false;
    });
  }
  function J2e(t, e) {
    const n = pt(e), { renderingEngine: r, viewportId: i } = n, a = Re.ANNOTATION_ADDED, s = {
      annotation: t,
      viewportId: i,
      renderingEngineId: r.id
    };
    qe(je, a, s);
  }
  function $2e(t) {
    const { toolName: e } = t.metadata, n = Q2e(e);
    if (!n.length) return;
    const r = [];
    n.forEach((s) => {
      s.viewportsInfo.forEach((o) => {
        const { renderingEngineId: l, viewportId: c } = o, { FrameOfReferenceUID: f } = Pa(c, l);
        t.metadata.FrameOfReferenceUID === f && r.push(o);
      });
    });
    const i = Re.ANNOTATION_ADDED, a = {
      annotation: t
    };
    if (!r.length) {
      qe(je, i, a);
      return;
    }
    r.forEach(({ renderingEngineId: s, viewportId: o }) => {
      a.viewportId = o, a.renderingEngineId = s, qe(je, i, a);
    });
  }
  function ege(t) {
    const e = Re.ANNOTATION_REMOVED;
    qe(je, e, t);
  }
  function Wl(t, e, n = _l.HandlesUpdated) {
    const r = pt(e), { viewportId: i, renderingEngineId: a } = r, s = Re.ANNOTATION_MODIFIED;
    qe(je, s, {
      annotation: t,
      viewportId: i,
      renderingEngineId: a,
      changeType: n
    });
  }
  function OL(t, e = false) {
    tge({
      annotation: t,
      contourHoleProcessingEnabled: e
    });
  }
  function tge(t) {
    const e = Re.ANNOTATION_COMPLETED;
    qe(je, e, t);
  }
  let nge = Mce;
  function cf() {
    return nge;
  }
  function Wu(t, e) {
    const n = cf(), r = n.getGroupKey(e);
    return n.getAnnotations(r, t);
  }
  function rge() {
    return cf().getAllAnnotations();
  }
  function IL(t) {
    const { annotationUID: e, parentAnnotationUID: n } = t;
    if (!n) return;
    const r = Ua(n), i = r.childAnnotationUIDs.indexOf(e);
    r.childAnnotationUIDs.splice(i, 1), t.parentAnnotationUID = void 0;
  }
  function VL(t, e) {
    const { annotationUID: n } = t, { annotationUID: r } = e;
    IL(e), t.childAnnotationUIDs || (t.childAnnotationUIDs = []), !t.childAnnotationUIDs.includes(r) && (t.childAnnotationUIDs.push(r), e.parentAnnotationUID = n);
  }
  function ige(t) {
    return t.parentAnnotationUID ? Ua(t.parentAnnotationUID) : void 0;
  }
  function NL(t) {
    var _a3;
    return ((_a3 = t.childAnnotationUIDs) == null ? void 0 : _a3.map((e) => Ua(e))) ?? [];
  }
  function uf(t, e) {
    t.annotationUID || (t.annotationUID = gi());
    const n = cf();
    if (e instanceof HTMLDivElement) {
      const r = n.getGroupKey(e);
      n.addAnnotation(t, r), J2e(t, e);
    } else n.addAnnotation(t), $2e(t);
    return t.annotationUID;
  }
  function Hu(t) {
    var _a3;
    if (!t) return;
    const e = cf(), n = e.getAnnotation(t);
    n && ((_a3 = n.childAnnotationUIDs) == null ? void 0 : _a3.forEach((r) => Hu(r)), e.removeAnnotation(t), ege({
      annotation: n,
      annotationManagerUID: e.uid
    }));
  }
  function Ua(t) {
    return cf().getAnnotation(t);
  }
  function age(t) {
    let e = t;
    for (; e; ) e.invalidated = true, e = e.parentAnnotationUID ? Ua(e.parentAnnotationUID) : void 0;
  }
  let KA = false;
  function sge(t = {}) {
    KA || (oge(), cge(), KA = true);
  }
  function oge() {
    lge();
    const t = ze.ELEMENT_ENABLED, e = ze.ELEMENT_DISABLED;
    je.addEventListener(t, DL), je.addEventListener(e, ML), AL.enable();
  }
  function lge() {
    const t = ze.ELEMENT_ENABLED, e = ze.ELEMENT_DISABLED;
    je.removeEventListener(t, DL), je.removeEventListener(e, ML), AL.disable();
  }
  function cge() {
    uge(), je.addEventListener(Re.ANNOTATION_COMPLETED, ZN), je.addEventListener(Re.ANNOTATION_MODIFIED, QN), je.addEventListener(Re.ANNOTATION_SELECTION_CHANGE, Jp), je.addEventListener(Re.ANNOTATION_SELECTION_CHANGE, Jp), je.addEventListener(Re.ANNOTATION_REMOVED, Kde), je.addEventListener(Re.SEGMENTATION_MODIFIED, qN), je.addEventListener(Re.SEGMENTATION_DATA_MODIFIED, KN), je.addEventListener(Re.SEGMENTATION_REPRESENTATION_MODIFIED, jN), je.addEventListener(Re.SEGMENTATION_REPRESENTATION_REMOVED, YN);
  }
  function uge() {
    je.removeEventListener(Re.ANNOTATION_COMPLETED, ZN), je.removeEventListener(Re.ANNOTATION_MODIFIED, QN), je.removeEventListener(Re.ANNOTATION_SELECTION_CHANGE, Jp), je.removeEventListener(Re.ANNOTATION_SELECTION_CHANGE, Jp), je.removeEventListener(Re.SEGMENTATION_MODIFIED, qN), je.removeEventListener(Re.SEGMENTATION_DATA_MODIFIED, KN), je.removeEventListener(Re.SEGMENTATION_REPRESENTATION_MODIFIED, jN), je.removeEventListener(Re.SEGMENTATION_REPRESENTATION_REMOVED, YN);
  }
  const { windowLevel: fge } = a0;
  function hge(t, e, n, r) {
    const { numBitsPerVoxel: i, littleEndian: a, pixDims: s, dims: o } = t;
    let l = 1 / 0, c = -1 / 0;
    const f = o[1] * o[2], u = Math.floor(o[3] / 2), h = f * u;
    for (let C = h; C < h + f; C++) {
      const T = n[C];
      T > c && (c = T), T < l && (l = T);
    }
    const { windowWidth: g, windowCenter: v } = fge.toWindowLevel(l, c), m = He(), y = He(), w = He();
    return Ml(m, e[0], e[1], e[2]), Ml(y, e[3], e[4], e[5]), Ml(w, e[6], e[7], e[8]), {
      volumeMetadata: {
        BitsAllocated: i,
        BitsStored: i,
        SamplesPerPixel: 1,
        HighBit: a ? i - 1 : 1,
        PhotometricInterpretation: "MONOCHROME2",
        PixelRepresentation: r,
        ImageOrientationPatient: [
          m[0],
          m[1],
          m[2],
          y[0],
          y[1],
          y[2]
        ],
        PixelSpacing: [
          s[1],
          s[2]
        ],
        Columns: o[1],
        Rows: o[2],
        voiLut: [
          {
            windowCenter: v,
            windowWidth: g
          }
        ],
        FrameOfReferenceUID: "1.2.3",
        Modality: "MR",
        VOILUTFunction: "LINEAR"
      },
      dimensions: [
        o[1],
        o[2],
        o[3]
      ],
      direction: new Float32Array([
        m[0],
        m[1],
        m[2],
        y[0],
        y[1],
        y[2],
        w[0],
        w[1],
        w[2]
      ])
    };
  }
  const dge = 2, gge = 4, pge = 8, mge = 16, vge = 256, yge = 512, xge = 768, { createFloat32SharedArray: wge, createInt16SharedArray: YA, createUint8SharedArray: Cge, createUint16SharedArray: Tge } = a0;
  function Sge(t, e) {
    const { datatypeCode: n, scl_slope: r, scl_inter: i } = t;
    let a = r, s = i;
    (!r || r === 0 || Number.isNaN(r)) && (a = 1), (!i || Number.isNaN(i)) && (s = 0);
    const o = s < 0 || a < 0, l = s % 1 !== 0 || a % 1 !== 0;
    let c, f, u = 1;
    switch (n) {
      case dge:
        c = new Uint8Array(e), l ? f = Ia("Float32Array", c) : o ? f = Ia("Int16Array", c) : (u = 0, f = Ia("Uint8Array", c));
        break;
      case gge:
        c = new Int16Array(e), l ? f = Ia("Float32Array", c) : f = Ia("Int16Array", c);
        break;
      case pge:
        c = new Int32Array(e), f = Ia("Float32Array", c);
        break;
      case mge: {
        c = new Float32Array(e), f = Ia("Float32Array", c);
        break;
      }
      case vge:
        c = new Int8Array(e), l ? f = Ia("Float32Array", c) : f = Ia("Int8Array", c);
        break;
      case yge:
        c = new Uint16Array(e), l || o ? f = Ia("Float32Array", c) : (u = 0, f = Ia("Uint16Array", c));
        break;
      case xge:
        c = new Uint32Array(e), f = Ia("Float32Array", c);
        break;
      default:
        throw new Error(`NIFTI datatypeCode ${n} is not yet supported`);
    }
    const h = f.length;
    if (a !== 1 && s !== 0) for (let g = 0; g < h; g++) f[g] = Age(f[g], a, s);
    return t.numBitsPerVoxel = f.byteLength / f.length * 8, {
      scalarData: f,
      pixelRepresentation: u
    };
  }
  function Age(t, e, n) {
    return t * e + n;
  }
  function R1(t, e) {
    const n = t / 8 * e;
    if (!Ke.isCacheable(n)) throw new Error(ze.CACHE_SIZE_EXCEEDED);
    return Ke.decacheIfNecessaryUntilBytesAvailable(n), n;
  }
  function Ia(t, e) {
    let n, r;
    const i = Qu(), a = e.length;
    switch (t) {
      case "Float32Array":
        n = 32, R1(n, a), r = i ? wge(a) : new Float32Array(a);
        break;
      case "Int16Array":
        n = 16, R1(n, a), r = i ? YA(a) : new Int16Array(a);
        break;
      case "Int8Array":
        n = 8, R1(n, a), r = i ? YA(a) : new Int16Array(a);
        break;
      case "Uint16Array":
        n = 16, R1(n, a), r = i ? Tge(a) : new Uint16Array(a);
        break;
      case "Uint8Array":
        n = 8, R1(n, a), r = i ? Cge(a) : new Uint8Array(a);
        break;
      default:
        throw new Error(`TypedArray ${t} is not yet supported`);
    }
    return r.set(e), r;
  }
  var ao = {}, bt = {}, Sv = {}, qA;
  function Ege() {
    return qA || (qA = 1, (function(t) {
      var e = {};
      t.default = (function(n, r, i, a, s) {
        var o = new Worker(e[r] || (e[r] = URL.createObjectURL(new Blob([
          n + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
        ], {
          type: "text/javascript"
        }))));
        return o.onmessage = function(l) {
          var c = l.data, f = c.$e$;
          if (f) {
            var u = new Error(f[0]);
            u.code = f[1], u.stack = f[2], s(u, null);
          } else s(null, c);
        }, o.postMessage(i, a), o;
      });
    })(Sv)), Sv;
  }
  var XA;
  function bge() {
    if (XA) return bt;
    XA = 1;
    var t = Ege(), e = Uint8Array, n = Uint16Array, r = Uint32Array, i = new e([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      0,
      0,
      0
    ]), a = new e([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      0,
      0
    ]), s = new e([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]), o = function(z, P) {
      for (var q = new n(31), te = 0; te < 31; ++te) q[te] = P += 1 << z[te - 1];
      for (var ge = new r(q[30]), te = 1; te < 30; ++te) for (var Ae = q[te]; Ae < q[te + 1]; ++Ae) ge[Ae] = Ae - q[te] << 5 | te;
      return [
        q,
        ge
      ];
    }, l = o(i, 2), c = l[0], f = l[1];
    c[28] = 258, f[258] = 28;
    for (var u = o(a, 0), h = u[0], g = u[1], v = new n(32768), m = 0; m < 32768; ++m) {
      var y = (m & 43690) >>> 1 | (m & 21845) << 1;
      y = (y & 52428) >>> 2 | (y & 13107) << 2, y = (y & 61680) >>> 4 | (y & 3855) << 4, v[m] = ((y & 65280) >>> 8 | (y & 255) << 8) >>> 1;
    }
    for (var w = (function(z, P, q) {
      for (var te = z.length, ge = 0, Ae = new n(P); ge < te; ++ge) z[ge] && ++Ae[z[ge] - 1];
      var Ee = new n(P);
      for (ge = 0; ge < P; ++ge) Ee[ge] = Ee[ge - 1] + Ae[ge - 1] << 1;
      var De;
      if (q) {
        De = new n(1 << P);
        var Be = 15 - P;
        for (ge = 0; ge < te; ++ge) if (z[ge]) for (var Me = ge << 4 | z[ge], _e11 = P - z[ge], et = Ee[z[ge] - 1]++ << _e11, lt = et | (1 << _e11) - 1; et <= lt; ++et) De[v[et] >>> Be] = Me;
      } else for (De = new n(te), ge = 0; ge < te; ++ge) z[ge] && (De[ge] = v[Ee[z[ge] - 1]++] >>> 15 - z[ge]);
      return De;
    }), C = new e(288), m = 0; m < 144; ++m) C[m] = 8;
    for (var m = 144; m < 256; ++m) C[m] = 9;
    for (var m = 256; m < 280; ++m) C[m] = 7;
    for (var m = 280; m < 288; ++m) C[m] = 8;
    for (var T = new e(32), m = 0; m < 32; ++m) T[m] = 5;
    var S = w(C, 9, 0), E = w(C, 9, 1), b = w(T, 5, 0), D = w(T, 5, 1), R = function(z) {
      for (var P = z[0], q = 1; q < z.length; ++q) z[q] > P && (P = z[q]);
      return P;
    }, I = function(z, P, q) {
      var te = P / 8 | 0;
      return (z[te] | z[te + 1] << 8) >> (P & 7) & q;
    }, O = function(z, P) {
      var q = P / 8 | 0;
      return (z[q] | z[q + 1] << 8 | z[q + 2] << 16) >> (P & 7);
    }, L = function(z) {
      return (z + 7) / 8 | 0;
    }, N = function(z, P, q) {
      (P == null || P < 0) && (P = 0), (q == null || q > z.length) && (q = z.length);
      var te = new (z.BYTES_PER_ELEMENT == 2 ? n : z.BYTES_PER_ELEMENT == 4 ? r : e)(q - P);
      return te.set(z.subarray(P, q)), te;
    };
    bt.FlateErrorCode = {
      UnexpectedEOF: 0,
      InvalidBlockType: 1,
      InvalidLengthLiteral: 2,
      InvalidDistance: 3,
      StreamFinished: 4,
      NoStreamHandler: 5,
      InvalidHeader: 6,
      NoCallback: 7,
      InvalidUTF8: 8,
      ExtraFieldTooLong: 9,
      InvalidDate: 10,
      FilenameTooLong: 11,
      StreamFinishing: 12,
      InvalidZipData: 13,
      UnknownCompressionMethod: 14
    };
    var F = [
      "unexpected EOF",
      "invalid block type",
      "invalid length/literal",
      "invalid distance",
      "stream finished",
      "no stream handler",
      ,
      "no callback",
      "invalid UTF-8 data",
      "extra field too long",
      "date not in range 1980-2099",
      "filename too long",
      "stream finishing",
      "invalid zip data"
    ], V = function(z, P, q) {
      var te = new Error(P || F[z]);
      if (te.code = z, Error.captureStackTrace && Error.captureStackTrace(te, V), !q) throw te;
      return te;
    }, k = function(z, P, q) {
      var te = z.length;
      if (!te || q && q.f && !q.l) return P || new e(0);
      var ge = !P || q, Ae = !q || q.i;
      q || (q = {}), P || (P = new e(te * 3));
      var Ee = function(g0) {
        var Xl = P.length;
        if (g0 > Xl) {
          var Fo = new e(Math.max(Xl * 2, g0));
          Fo.set(P), P = Fo;
        }
      }, De = q.f || 0, Be = q.p || 0, Me = q.b || 0, _e11 = q.l, et = q.d, lt = q.m, St = q.n, At = te * 8;
      do {
        if (!_e11) {
          De = I(z, Be, 1);
          var Mt = I(z, Be + 1, 3);
          if (Be += 3, Mt) if (Mt == 1) _e11 = E, et = D, lt = 9, St = 5;
          else if (Mt == 2) {
            var Kt = I(z, Be, 31) + 257, xt = I(z, Be + 10, 15) + 4, on = Kt + I(z, Be + 5, 31) + 1;
            Be += 14;
            for (var Qt = new e(on), Pt = new e(19), nt = 0; nt < xt; ++nt) Pt[s[nt]] = I(z, Be + nt * 3, 7);
            Be += xt * 3;
            for (var Nn = R(Pt), Xt = (1 << Nn) - 1, $ = w(Pt, Nn, 1), nt = 0; nt < on; ) {
              var ue = $[I(z, Be, Xt)];
              Be += ue & 15;
              var $e = ue >>> 4;
              if ($e < 16) Qt[nt++] = $e;
              else {
                var Te = 0, Xe = 0;
                for ($e == 16 ? (Xe = 3 + I(z, Be, 3), Be += 2, Te = Qt[nt - 1]) : $e == 17 ? (Xe = 3 + I(z, Be, 7), Be += 3) : $e == 18 && (Xe = 11 + I(z, Be, 127), Be += 7); Xe--; ) Qt[nt++] = Te;
              }
            }
            var Ut = Qt.subarray(0, Kt), Wt = Qt.subarray(Kt);
            lt = R(Ut), St = R(Wt), _e11 = w(Ut, lt, 1), et = w(Wt, St, 1);
          } else V(1);
          else {
            var $e = L(Be) + 4, Lt = z[$e - 4] | z[$e - 3] << 8, It = $e + Lt;
            if (It > te) {
              Ae && V(0);
              break;
            }
            ge && Ee(Me + Lt), P.set(z.subarray($e, It), Me), q.b = Me += Lt, q.p = Be = It * 8, q.f = De;
            continue;
          }
          if (Be > At) {
            Ae && V(0);
            break;
          }
        }
        ge && Ee(Me + 131072);
        for (var nn = (1 << lt) - 1, wn = (1 << St) - 1, tr = Be; ; tr = Be) {
          var Te = _e11[O(z, Be) & nn], Xn = Te >>> 4;
          if (Be += Te & 15, Be > At) {
            Ae && V(0);
            break;
          }
          if (Te || V(2), Xn < 256) P[Me++] = Xn;
          else if (Xn == 256) {
            tr = Be, _e11 = null;
            break;
          } else {
            var xr = Xn - 254;
            if (Xn > 264) {
              var nt = Xn - 257, yi = i[nt];
              xr = I(z, Be, (1 << yi) - 1) + c[nt], Be += yi;
            }
            var Ii = et[O(z, Be) & wn], br = Ii >>> 4;
            Ii || V(3), Be += Ii & 15;
            var Wt = h[br];
            if (br > 3) {
              var yi = a[br];
              Wt += O(z, Be) & (1 << yi) - 1, Be += yi;
            }
            if (Be > At) {
              Ae && V(0);
              break;
            }
            ge && Ee(Me + 131072);
            for (var Yn = Me + xr; Me < Yn; Me += 4) P[Me] = P[Me - Wt], P[Me + 1] = P[Me + 1 - Wt], P[Me + 2] = P[Me + 2 - Wt], P[Me + 3] = P[Me + 3 - Wt];
            Me = Yn;
          }
        }
        q.l = _e11, q.p = tr, q.b = Me, q.f = De, _e11 && (De = 1, q.m = lt, q.d = et, q.n = St);
      } while (!De);
      return Me == P.length ? P : N(P, 0, Me);
    }, _ = function(z, P, q) {
      q <<= P & 7;
      var te = P / 8 | 0;
      z[te] |= q, z[te + 1] |= q >>> 8;
    }, K = function(z, P, q) {
      q <<= P & 7;
      var te = P / 8 | 0;
      z[te] |= q, z[te + 1] |= q >>> 8, z[te + 2] |= q >>> 16;
    }, Z = function(z, P) {
      for (var q = [], te = 0; te < z.length; ++te) z[te] && q.push({
        s: te,
        f: z[te]
      });
      var ge = q.length, Ae = q.slice();
      if (!ge) return [
        he,
        0
      ];
      if (ge == 1) {
        var Ee = new e(q[0].s + 1);
        return Ee[q[0].s] = 1, [
          Ee,
          1
        ];
      }
      q.sort(function(on, Qt) {
        return on.f - Qt.f;
      }), q.push({
        s: -1,
        f: 25001
      });
      var De = q[0], Be = q[1], Me = 0, _e11 = 1, et = 2;
      for (q[0] = {
        s: -1,
        f: De.f + Be.f,
        l: De,
        r: Be
      }; _e11 != ge - 1; ) De = q[q[Me].f < q[et].f ? Me++ : et++], Be = q[Me != _e11 && q[Me].f < q[et].f ? Me++ : et++], q[_e11++] = {
        s: -1,
        f: De.f + Be.f,
        l: De,
        r: Be
      };
      for (var lt = Ae[0].s, te = 1; te < ge; ++te) Ae[te].s > lt && (lt = Ae[te].s);
      var St = new n(lt + 1), At = j(q[_e11 - 1], St, 0);
      if (At > P) {
        var te = 0, Mt = 0, $e = At - P, Lt = 1 << $e;
        for (Ae.sort(function(Qt, Pt) {
          return St[Pt.s] - St[Qt.s] || Qt.f - Pt.f;
        }); te < ge; ++te) {
          var It = Ae[te].s;
          if (St[It] > P) Mt += Lt - (1 << At - St[It]), St[It] = P;
          else break;
        }
        for (Mt >>>= $e; Mt > 0; ) {
          var Kt = Ae[te].s;
          St[Kt] < P ? Mt -= 1 << P - St[Kt]++ - 1 : ++te;
        }
        for (; te >= 0 && Mt; --te) {
          var xt = Ae[te].s;
          St[xt] == P && (--St[xt], ++Mt);
        }
        At = P;
      }
      return [
        new e(St),
        At
      ];
    }, j = function(z, P, q) {
      return z.s == -1 ? Math.max(j(z.l, P, q + 1), j(z.r, P, q + 1)) : P[z.s] = q;
    }, B = function(z) {
      for (var P = z.length; P && !z[--P]; ) ;
      for (var q = new n(++P), te = 0, ge = z[0], Ae = 1, Ee = function(Be) {
        q[te++] = Be;
      }, De = 1; De <= P; ++De) if (z[De] == ge && De != P) ++Ae;
      else {
        if (!ge && Ae > 2) {
          for (; Ae > 138; Ae -= 138) Ee(32754);
          Ae > 2 && (Ee(Ae > 10 ? Ae - 11 << 5 | 28690 : Ae - 3 << 5 | 12305), Ae = 0);
        } else if (Ae > 3) {
          for (Ee(ge), --Ae; Ae > 6; Ae -= 6) Ee(8304);
          Ae > 2 && (Ee(Ae - 3 << 5 | 8208), Ae = 0);
        }
        for (; Ae--; ) Ee(ge);
        Ae = 1, ge = z[De];
      }
      return [
        q.subarray(0, te),
        P
      ];
    }, Y = function(z, P) {
      for (var q = 0, te = 0; te < P.length; ++te) q += z[te] * P[te];
      return q;
    }, X = function(z, P, q) {
      var te = q.length, ge = L(P + 2);
      z[ge] = te & 255, z[ge + 1] = te >>> 8, z[ge + 2] = z[ge] ^ 255, z[ge + 3] = z[ge + 1] ^ 255;
      for (var Ae = 0; Ae < te; ++Ae) z[ge + Ae + 4] = q[Ae];
      return (ge + 4 + te) * 8;
    }, ie = function(z, P, q, te, ge, Ae, Ee, De, Be, Me, _e11) {
      _(P, _e11++, q), ++ge[256];
      for (var et = Z(ge, 15), lt = et[0], St = et[1], At = Z(Ae, 15), Mt = At[0], $e = At[1], Lt = B(lt), It = Lt[0], Kt = Lt[1], xt = B(Mt), on = xt[0], Qt = xt[1], Pt = new n(19), nt = 0; nt < It.length; ++nt) Pt[It[nt] & 31]++;
      for (var nt = 0; nt < on.length; ++nt) Pt[on[nt] & 31]++;
      for (var Nn = Z(Pt, 7), Xt = Nn[0], $ = Nn[1], ue = 19; ue > 4 && !Xt[s[ue - 1]]; --ue) ;
      var Te = Me + 5 << 3, Xe = Y(ge, C) + Y(Ae, T) + Ee, Ut = Y(ge, lt) + Y(Ae, Mt) + Ee + 14 + 3 * ue + Y(Pt, Xt) + (2 * Pt[16] + 3 * Pt[17] + 7 * Pt[18]);
      if (Te <= Xe && Te <= Ut) return X(P, _e11, z.subarray(Be, Be + Me));
      var Wt, nn, wn, tr;
      if (_(P, _e11, 1 + (Ut < Xe)), _e11 += 2, Ut < Xe) {
        Wt = w(lt, St, 0), nn = lt, wn = w(Mt, $e, 0), tr = Mt;
        var Xn = w(Xt, $, 0);
        _(P, _e11, Kt - 257), _(P, _e11 + 5, Qt - 1), _(P, _e11 + 10, ue - 4), _e11 += 14;
        for (var nt = 0; nt < ue; ++nt) _(P, _e11 + 3 * nt, Xt[s[nt]]);
        _e11 += 3 * ue;
        for (var xr = [
          It,
          on
        ], yi = 0; yi < 2; ++yi) for (var Ii = xr[yi], nt = 0; nt < Ii.length; ++nt) {
          var br = Ii[nt] & 31;
          _(P, _e11, Xn[br]), _e11 += Xt[br], br > 15 && (_(P, _e11, Ii[nt] >>> 5 & 127), _e11 += Ii[nt] >>> 12);
        }
      } else Wt = S, nn = C, wn = b, tr = T;
      for (var nt = 0; nt < De; ++nt) if (te[nt] > 255) {
        var br = te[nt] >>> 18 & 31;
        K(P, _e11, Wt[br + 257]), _e11 += nn[br + 257], br > 7 && (_(P, _e11, te[nt] >>> 23 & 31), _e11 += i[br]);
        var Yn = te[nt] & 31;
        K(P, _e11, wn[Yn]), _e11 += tr[Yn], Yn > 3 && (K(P, _e11, te[nt] >>> 5 & 8191), _e11 += a[Yn]);
      } else K(P, _e11, Wt[te[nt]]), _e11 += nn[te[nt]];
      return K(P, _e11, Wt[256]), _e11 + nn[256];
    }, oe = new r([
      65540,
      131080,
      131088,
      131104,
      262176,
      1048704,
      1048832,
      2114560,
      2117632
    ]), he = new e(0), Le = function(z, P, q, te, ge, Ae) {
      var Ee = z.length, De = new e(te + Ee + 5 * (1 + Math.ceil(Ee / 7e3)) + ge), Be = De.subarray(te, De.length - ge), Me = 0;
      if (!P || Ee < 8) for (var _e11 = 0; _e11 <= Ee; _e11 += 65535) {
        var et = _e11 + 65535;
        et >= Ee && (Be[Me >> 3] = Ae), Me = X(Be, Me + 1, z.subarray(_e11, et));
      }
      else {
        for (var lt = oe[P - 1], St = lt >>> 13, At = lt & 8191, Mt = (1 << q) - 1, $e = new n(32768), Lt = new n(Mt + 1), It = Math.ceil(q / 3), Kt = 2 * It, xt = function(pf) {
          return (z[pf] ^ z[pf + 1] << It ^ z[pf + 2] << Kt) & Mt;
        }, on = new r(25e3), Qt = new n(288), Pt = new n(32), nt = 0, Nn = 0, _e11 = 0, Xt = 0, $ = 0, ue = 0; _e11 < Ee; ++_e11) {
          var Te = xt(_e11), Xe = _e11 & 32767, Ut = Lt[Te];
          if ($e[Xe] = Ut, Lt[Te] = Xe, $ <= _e11) {
            var Wt = Ee - _e11;
            if ((nt > 7e3 || Xt > 24576) && Wt > 423) {
              Me = ie(z, Be, 0, on, Qt, Pt, Nn, Xt, ue, _e11 - ue, Me), Xt = nt = Nn = 0, ue = _e11;
              for (var nn = 0; nn < 286; ++nn) Qt[nn] = 0;
              for (var nn = 0; nn < 30; ++nn) Pt[nn] = 0;
            }
            var wn = 2, tr = 0, Xn = At, xr = Xe - Ut & 32767;
            if (Wt > 2 && Te == xt(_e11 - xr)) for (var yi = Math.min(St, Wt) - 1, Ii = Math.min(32767, _e11), br = Math.min(258, Wt); xr <= Ii && --Xn && Xe != Ut; ) {
              if (z[_e11 + wn] == z[_e11 + wn - xr]) {
                for (var Yn = 0; Yn < br && z[_e11 + Yn] == z[_e11 + Yn - xr]; ++Yn) ;
                if (Yn > wn) {
                  if (wn = Yn, tr = xr, Yn > yi) break;
                  for (var g0 = Math.min(xr, Yn - 2), Xl = 0, nn = 0; nn < g0; ++nn) {
                    var Fo = _e11 - xr + nn + 32768 & 32767, Y5 = $e[Fo], dd = Fo - Y5 + 32768 & 32767;
                    dd > Xl && (Xl = dd, Ut = Fo);
                  }
                }
              }
              Xe = Ut, Ut = $e[Xe], xr += Xe - Ut + 32768 & 32767;
            }
            if (tr) {
              on[Xt++] = 268435456 | f[wn] << 18 | g[tr];
              var gf = f[wn] & 31, gd = g[tr] & 31;
              Nn += i[gf] + a[gd], ++Qt[257 + gf], ++Pt[gd], $ = _e11 + wn, ++nt;
            } else on[Xt++] = z[_e11], ++Qt[z[_e11]];
          }
        }
        Me = ie(z, Be, Ae, on, Qt, Pt, Nn, Xt, ue, _e11 - ue, Me), !Ae && Me & 7 && (Me = X(Be, Me + 1, he));
      }
      return N(De, 0, te + L(Me) + ge);
    }, Je = (function() {
      for (var z = new Int32Array(256), P = 0; P < 256; ++P) {
        for (var q = P, te = 9; --te; ) q = (q & 1 && -306674912) ^ q >>> 1;
        z[P] = q;
      }
      return z;
    })(), Pe = function() {
      var z = -1;
      return {
        p: function(P) {
          for (var q = z, te = 0; te < P.length; ++te) q = Je[q & 255 ^ P[te]] ^ q >>> 8;
          z = q;
        },
        d: function() {
          return ~z;
        }
      };
    }, ot = function() {
      var z = 1, P = 0;
      return {
        p: function(q) {
          for (var te = z, ge = P, Ae = q.length | 0, Ee = 0; Ee != Ae; ) {
            for (var De = Math.min(Ee + 2655, Ae); Ee < De; ++Ee) ge += te += q[Ee];
            te = (te & 65535) + 15 * (te >> 16), ge = (ge & 65535) + 15 * (ge >> 16);
          }
          z = te, P = ge;
        },
        d: function() {
          return z %= 65521, P %= 65521, (z & 255) << 24 | z >>> 8 << 16 | (P & 255) << 8 | P >>> 8;
        }
      };
    }, vt = function(z, P, q, te, ge) {
      return Le(z, P.level == null ? 6 : P.level, P.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(z.length))) * 1.5) : 12 + P.mem, q, te, !ge);
    }, wt = function(z, P) {
      var q = {};
      for (var te in z) q[te] = z[te];
      for (var te in P) q[te] = P[te];
      return q;
    }, Qe = function(z, P, q) {
      for (var te = z(), ge = z.toString(), Ae = ge.slice(ge.indexOf("[") + 1, ge.lastIndexOf("]")).replace(/\s+/g, "").split(","), Ee = 0; Ee < te.length; ++Ee) {
        var De = te[Ee], Be = Ae[Ee];
        if (typeof De == "function") {
          P += ";" + Be + "=";
          var Me = De.toString();
          if (De.prototype) if (Me.indexOf("[native code]") != -1) {
            var _e11 = Me.indexOf(" ", 8) + 1;
            P += Me.slice(_e11, Me.indexOf("(", _e11));
          } else {
            P += Me;
            for (var et in De.prototype) P += ";" + Be + ".prototype." + et + "=" + De.prototype[et].toString();
          }
          else P += Me;
        } else q[Be] = De;
      }
      return [
        P,
        q
      ];
    }, _t6 = [], G = function(z) {
      var P = [];
      for (var q in z) z[q].buffer && P.push((z[q] = new z[q].constructor(z[q])).buffer);
      return P;
    }, Se = function(z, P, q, te) {
      var ge;
      if (!_t6[q]) {
        for (var Ae = "", Ee = {}, De = z.length - 1, Be = 0; Be < De; ++Be) ge = Qe(z[Be], Ae, Ee), Ae = ge[0], Ee = ge[1];
        _t6[q] = Qe(z[De], Ae, Ee);
      }
      var Me = wt({}, _t6[q][1]);
      return t.default(_t6[q][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + P.toString() + "}", q, Me, G(Me), te);
    }, xe = function() {
      return [
        e,
        n,
        r,
        i,
        a,
        s,
        c,
        h,
        E,
        D,
        v,
        F,
        w,
        R,
        I,
        O,
        L,
        N,
        V,
        k,
        za,
        de,
        We
      ];
    }, re = function() {
      return [
        e,
        n,
        r,
        i,
        a,
        s,
        f,
        g,
        S,
        C,
        b,
        T,
        v,
        oe,
        he,
        w,
        _,
        K,
        Z,
        j,
        B,
        Y,
        X,
        ie,
        L,
        N,
        Le,
        vt,
        lr,
        de
      ];
    }, ne = function() {
      return [
        mr,
        Wr,
        jt,
        Pe,
        Je
      ];
    }, ce = function() {
      return [
        Di,
        mn
      ];
    }, Oe = function() {
      return [
        Ur,
        jt,
        ot
      ];
    }, Ve = function() {
      return [
        ye
      ];
    }, de = function(z) {
      return postMessage(z, [
        z.buffer
      ]);
    }, We = function(z) {
      return z && z.size && new e(z.size);
    }, Ze = function(z, P, q, te, ge, Ae) {
      var Ee = Se(q, te, ge, function(De, Be) {
        Ee.terminate(), Ae(De, Be);
      });
      return Ee.postMessage([
        z,
        P
      ], P.consume ? [
        z.buffer
      ] : []), function() {
        Ee.terminate();
      };
    }, Ge = function(z) {
      return z.ondata = function(P, q) {
        return postMessage([
          P,
          q
        ], [
          P.buffer
        ]);
      }, function(P) {
        return z.push(P.data[0], P.data[1]);
      };
    }, at = function(z, P, q, te, ge) {
      var Ae, Ee = Se(z, te, ge, function(De, Be) {
        De ? (Ee.terminate(), P.ondata.call(P, De)) : (Be[1] && Ee.terminate(), P.ondata.call(P, De, Be[0], Be[1]));
      });
      Ee.postMessage(q), P.push = function(De, Be) {
        P.ondata || V(5), Ae && P.ondata(V(4, 0, 1), null, !!Be), Ee.postMessage([
          De,
          Ae = Be
        ], [
          De.buffer
        ]);
      }, P.terminate = function() {
        Ee.terminate();
      };
    }, ut = function(z, P) {
      return z[P] | z[P + 1] << 8;
    }, it = function(z, P) {
      return (z[P] | z[P + 1] << 8 | z[P + 2] << 16 | z[P + 3] << 24) >>> 0;
    }, fn = function(z, P) {
      return it(z, P) + it(z, P + 4) * 4294967296;
    }, jt = function(z, P, q) {
      for (; q; ++P) z[P] = q, q >>>= 8;
    }, mr = function(z, P) {
      var q = P.filename;
      if (z[0] = 31, z[1] = 139, z[2] = 8, z[8] = P.level < 2 ? 4 : P.level == 9 ? 2 : 0, z[9] = 3, P.mtime != 0 && jt(z, 4, Math.floor(new Date(P.mtime || Date.now()) / 1e3)), q) {
        z[3] = 8;
        for (var te = 0; te <= q.length; ++te) z[te + 10] = q.charCodeAt(te);
      }
    }, Di = function(z) {
      (z[0] != 31 || z[1] != 139 || z[2] != 8) && V(6, "invalid gzip data");
      var P = z[3], q = 10;
      P & 4 && (q += z[10] | (z[11] << 8) + 2);
      for (var te = (P >> 3 & 1) + (P >> 4 & 1); te > 0; te -= !z[q++]) ;
      return q + (P & 2);
    }, mn = function(z) {
      var P = z.length;
      return (z[P - 4] | z[P - 3] << 8 | z[P - 2] << 16 | z[P - 1] << 24) >>> 0;
    }, Wr = function(z) {
      return 10 + (z.filename && z.filename.length + 1 || 0);
    }, Ur = function(z, P) {
      var q = P.level, te = q == 0 ? 0 : q < 6 ? 1 : q == 9 ? 3 : 2;
      z[0] = 120, z[1] = te << 6 | (te ? 32 - 2 * te : 1);
    }, ye = function(z) {
      ((z[0] & 15) != 8 || z[0] >>> 4 > 7 || (z[0] << 8 | z[1]) % 31) && V(6, "invalid zlib data"), z[1] & 32 && V(6, "invalid zlib data: preset dictionaries not supported");
    };
    function ke(z, P) {
      return !P && typeof z == "function" && (P = z, z = {}), this.ondata = P, z;
    }
    var rt = (function() {
      function z(P, q) {
        !q && typeof P == "function" && (q = P, P = {}), this.ondata = q, this.o = P || {};
      }
      return z.prototype.p = function(P, q) {
        this.ondata(vt(P, this.o, 0, 0, !q), q);
      }, z.prototype.push = function(P, q) {
        this.ondata || V(5), this.d && V(4), this.d = q, this.p(P, q || false);
      }, z;
    })();
    bt.Deflate = rt;
    var sn = /* @__PURE__ */ (function() {
      function z(P, q) {
        at([
          re,
          function() {
            return [
              Ge,
              rt
            ];
          }
        ], this, ke.call(this, P, q), function(te) {
          var ge = new rt(te.data);
          onmessage = Ge(ge);
        }, 6);
      }
      return z;
    })();
    bt.AsyncDeflate = sn;
    function ti(z, P, q) {
      return q || (q = P, P = {}), typeof q != "function" && V(7), Ze(z, P, [
        re
      ], function(te) {
        return de(lr(te.data[0], te.data[1]));
      }, 0, q);
    }
    bt.deflate = ti;
    function lr(z, P) {
      return vt(z, P || {}, 0, 0);
    }
    bt.deflateSync = lr;
    var vn = (function() {
      function z(P) {
        this.s = {}, this.p = new e(0), this.ondata = P;
      }
      return z.prototype.e = function(P) {
        this.ondata || V(5), this.d && V(4);
        var q = this.p.length, te = new e(q + P.length);
        te.set(this.p), te.set(P, q), this.p = te;
      }, z.prototype.c = function(P) {
        this.d = this.s.i = P || false;
        var q = this.s.b, te = k(this.p, this.o, this.s);
        this.ondata(N(te, q, this.s.b), this.d), this.o = N(te, this.s.b - 32768), this.s.b = this.o.length, this.p = N(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      }, z.prototype.push = function(P, q) {
        this.e(P), this.c(q);
      }, z;
    })();
    bt.Inflate = vn;
    var xa = /* @__PURE__ */ (function() {
      function z(P) {
        this.ondata = P, at([
          xe,
          function() {
            return [
              Ge,
              vn
            ];
          }
        ], this, 0, function() {
          var q = new vn();
          onmessage = Ge(q);
        }, 7);
      }
      return z;
    })();
    bt.AsyncInflate = xa;
    function Mo(z, P, q) {
      return q || (q = P, P = {}), typeof q != "function" && V(7), Ze(z, P, [
        xe
      ], function(te) {
        return de(za(te.data[0], We(te.data[1])));
      }, 1, q);
    }
    bt.inflate = Mo;
    function za(z, P) {
      return k(z, P);
    }
    bt.inflateSync = za;
    var fs = (function() {
      function z(P, q) {
        this.c = Pe(), this.l = 0, this.v = 1, rt.call(this, P, q);
      }
      return z.prototype.push = function(P, q) {
        rt.prototype.push.call(this, P, q);
      }, z.prototype.p = function(P, q) {
        this.c.p(P), this.l += P.length;
        var te = vt(P, this.o, this.v && Wr(this.o), q && 8, !q);
        this.v && (mr(te, this.o), this.v = 0), q && (jt(te, te.length - 8, this.c.d()), jt(te, te.length - 4, this.l)), this.ondata(te, q);
      }, z;
    })();
    bt.Gzip = fs, bt.Compress = fs;
    var Ro = /* @__PURE__ */ (function() {
      function z(P, q) {
        at([
          re,
          ne,
          function() {
            return [
              Ge,
              rt,
              fs
            ];
          }
        ], this, ke.call(this, P, q), function(te) {
          var ge = new fs(te.data);
          onmessage = Ge(ge);
        }, 8);
      }
      return z;
    })();
    bt.AsyncGzip = Ro, bt.AsyncCompress = Ro;
    function Oo(z, P, q) {
      return q || (q = P, P = {}), typeof q != "function" && V(7), Ze(z, P, [
        re,
        ne,
        function() {
          return [
            _s
          ];
        }
      ], function(te) {
        return de(_s(te.data[0], te.data[1]));
      }, 2, q);
    }
    bt.gzip = Oo, bt.compress = Oo;
    function _s(z, P) {
      P || (P = {});
      var q = Pe(), te = z.length;
      q.p(z);
      var ge = vt(z, P, Wr(P), 8), Ae = ge.length;
      return mr(ge, P), jt(ge, Ae - 8, q.d()), jt(ge, Ae - 4, te), ge;
    }
    bt.gzipSync = _s, bt.compressSync = _s;
    var vr = (function() {
      function z(P) {
        this.v = 1, vn.call(this, P);
      }
      return z.prototype.push = function(P, q) {
        if (vn.prototype.e.call(this, P), this.v) {
          var te = this.p.length > 3 ? Di(this.p) : 4;
          if (te >= this.p.length && !q) return;
          this.p = this.p.subarray(te), this.v = 0;
        }
        q && (this.p.length < 8 && V(6, "invalid gzip data"), this.p = this.p.subarray(0, -8)), vn.prototype.c.call(this, q);
      }, z;
    })();
    bt.Gunzip = vr;
    var yr = /* @__PURE__ */ (function() {
      function z(P) {
        this.ondata = P, at([
          xe,
          ce,
          function() {
            return [
              Ge,
              vn,
              vr
            ];
          }
        ], this, 0, function() {
          var q = new vr();
          onmessage = Ge(q);
        }, 9);
      }
      return z;
    })();
    bt.AsyncGunzip = yr;
    function Fr(z, P, q) {
      return q || (q = P, P = {}), typeof q != "function" && V(7), Ze(z, P, [
        xe,
        ce,
        function() {
          return [
            na
          ];
        }
      ], function(te) {
        return de(na(te.data[0]));
      }, 3, q);
    }
    bt.gunzip = Fr;
    function na(z, P) {
      return k(z.subarray(Di(z), -8), P || new e(mn(z)));
    }
    bt.gunzipSync = na;
    var ks = (function() {
      function z(P, q) {
        this.c = ot(), this.v = 1, rt.call(this, P, q);
      }
      return z.prototype.push = function(P, q) {
        rt.prototype.push.call(this, P, q);
      }, z.prototype.p = function(P, q) {
        this.c.p(P);
        var te = vt(P, this.o, this.v && 2, q && 4, !q);
        this.v && (Ur(te, this.o), this.v = 0), q && jt(te, te.length - 4, this.c.d()), this.ondata(te, q);
      }, z;
    })();
    bt.Zlib = ks;
    var ff = /* @__PURE__ */ (function() {
      function z(P, q) {
        at([
          re,
          Oe,
          function() {
            return [
              Ge,
              rt,
              ks
            ];
          }
        ], this, ke.call(this, P, q), function(te) {
          var ge = new ks(te.data);
          onmessage = Ge(ge);
        }, 10);
      }
      return z;
    })();
    bt.AsyncZlib = ff;
    function ra(z, P, q) {
      return q || (q = P, P = {}), typeof q != "function" && V(7), Ze(z, P, [
        re,
        Oe,
        function() {
          return [
            Io
          ];
        }
      ], function(te) {
        return de(Io(te.data[0], te.data[1]));
      }, 4, q);
    }
    bt.zlib = ra;
    function Io(z, P) {
      P || (P = {});
      var q = ot();
      q.p(z);
      var te = vt(z, P, 2, 4);
      return Ur(te, P), jt(te, te.length - 4, q.d()), te;
    }
    bt.zlibSync = Io;
    var wa = (function() {
      function z(P) {
        this.v = 1, vn.call(this, P);
      }
      return z.prototype.push = function(P, q) {
        if (vn.prototype.e.call(this, P), this.v) {
          if (this.p.length < 2 && !q) return;
          this.p = this.p.subarray(2), this.v = 0;
        }
        q && (this.p.length < 4 && V(6, "invalid zlib data"), this.p = this.p.subarray(0, -4)), vn.prototype.c.call(this, q);
      }, z;
    })();
    bt.Unzlib = wa;
    var Vo = /* @__PURE__ */ (function() {
      function z(P) {
        this.ondata = P, at([
          xe,
          Ve,
          function() {
            return [
              Ge,
              vn,
              wa
            ];
          }
        ], this, 0, function() {
          var q = new wa();
          onmessage = Ge(q);
        }, 11);
      }
      return z;
    })();
    bt.AsyncUnzlib = Vo;
    function Wa(z, P, q) {
      return q || (q = P, P = {}), typeof q != "function" && V(7), Ze(z, P, [
        xe,
        Ve,
        function() {
          return [
            ia
          ];
        }
      ], function(te) {
        return de(ia(te.data[0], We(te.data[1])));
      }, 5, q);
    }
    bt.unzlib = Wa;
    function ia(z, P) {
      return k((ye(z), z.subarray(2, -4)), P);
    }
    bt.unzlibSync = ia;
    var Mi = (function() {
      function z(P) {
        this.G = vr, this.I = vn, this.Z = wa, this.ondata = P;
      }
      return z.prototype.push = function(P, q) {
        if (this.ondata || V(5), this.s) this.s.push(P, q);
        else {
          if (this.p && this.p.length) {
            var te = new e(this.p.length + P.length);
            te.set(this.p), te.set(P, this.p.length);
          } else this.p = P;
          if (this.p.length > 2) {
            var ge = this, Ae = function() {
              ge.ondata.apply(ge, arguments);
            };
            this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(Ae) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(Ae) : new this.Z(Ae), this.s.push(this.p, q), this.p = null;
          }
        }
      }, z;
    })();
    bt.Decompress = Mi;
    var hs = (function() {
      function z(P) {
        this.G = yr, this.I = xa, this.Z = Vo, this.ondata = P;
      }
      return z.prototype.push = function(P, q) {
        Mi.prototype.push.call(this, P, q);
      }, z;
    })();
    bt.AsyncDecompress = hs;
    function cr(z, P, q) {
      return q || (q = P, P = {}), typeof q != "function" && V(7), z[0] == 31 && z[1] == 139 && z[2] == 8 ? Fr(z, P, q) : (z[0] & 15) != 8 || z[0] >> 4 > 7 || (z[0] << 8 | z[1]) % 31 ? Mo(z, P, q) : Wa(z, P, q);
    }
    bt.decompress = cr;
    function c0(z, P) {
      return z[0] == 31 && z[1] == 139 && z[2] == 8 ? na(z, P) : (z[0] & 15) != 8 || z[0] >> 4 > 7 || (z[0] << 8 | z[1]) % 31 ? za(z, P) : ia(z, P);
    }
    bt.decompressSync = c0;
    var No = function(z, P, q, te) {
      for (var ge in z) {
        var Ae = z[ge], Ee = P + ge, De = te;
        Array.isArray(Ae) && (De = wt(te, Ae[1]), Ae = Ae[0]), Ae instanceof e ? q[Ee] = [
          Ae,
          De
        ] : (q[Ee += "/"] = [
          new e(0),
          De
        ], No(Ae, Ee, q, te));
      }
    }, Ca = typeof TextEncoder < "u" && new TextEncoder(), ni = typeof TextDecoder < "u" && new TextDecoder(), u0 = 0;
    try {
      ni.decode(he, {
        stream: true
      }), u0 = 1;
    } catch {
    }
    var Hl = function(z) {
      for (var P = "", q = 0; ; ) {
        var te = z[q++], ge = (te > 127) + (te > 223) + (te > 239);
        if (q + ge > z.length) return [
          P,
          N(z, q - 1)
        ];
        ge ? ge == 3 ? (te = ((te & 15) << 18 | (z[q++] & 63) << 12 | (z[q++] & 63) << 6 | z[q++] & 63) - 65536, P += String.fromCharCode(55296 | te >> 10, 56320 | te & 1023)) : ge & 1 ? P += String.fromCharCode((te & 31) << 6 | z[q++] & 63) : P += String.fromCharCode((te & 15) << 12 | (z[q++] & 63) << 6 | z[q++] & 63) : P += String.fromCharCode(te);
      }
    }, f0 = (function() {
      function z(P) {
        this.ondata = P, u0 ? this.t = new TextDecoder() : this.p = he;
      }
      return z.prototype.push = function(P, q) {
        if (this.ondata || V(5), q = !!q, this.t) {
          this.ondata(this.t.decode(P, {
            stream: true
          }), q), q && (this.t.decode().length && V(8), this.t = null);
          return;
        }
        this.p || V(4);
        var te = new e(this.p.length + P.length);
        te.set(this.p), te.set(P, this.p.length);
        var ge = Hl(te), Ae = ge[0], Ee = ge[1];
        q ? (Ee.length && V(8), this.p = null) : this.p = Ee, this.ondata(Ae, q);
      }, z;
    })();
    bt.DecodeUTF8 = f0;
    var hf = (function() {
      function z(P) {
        this.ondata = P;
      }
      return z.prototype.push = function(P, q) {
        this.ondata || V(5), this.d && V(4), this.ondata(Ri(P), this.d = q || false);
      }, z;
    })();
    bt.EncodeUTF8 = hf;
    function Ri(z, P) {
      if (P) {
        for (var q = new e(z.length), te = 0; te < z.length; ++te) q[te] = z.charCodeAt(te);
        return q;
      }
      if (Ca) return Ca.encode(z);
      for (var ge = z.length, Ae = new e(z.length + (z.length >> 1)), Ee = 0, De = function(_e11) {
        Ae[Ee++] = _e11;
      }, te = 0; te < ge; ++te) {
        if (Ee + 5 > Ae.length) {
          var Be = new e(Ee + 8 + (ge - te << 1));
          Be.set(Ae), Ae = Be;
        }
        var Me = z.charCodeAt(te);
        Me < 128 || P ? De(Me) : Me < 2048 ? (De(192 | Me >> 6), De(128 | Me & 63)) : Me > 55295 && Me < 57344 ? (Me = 65536 + (Me & 1047552) | z.charCodeAt(++te) & 1023, De(240 | Me >> 18), De(128 | Me >> 12 & 63), De(128 | Me >> 6 & 63), De(128 | Me & 63)) : (De(224 | Me >> 12), De(128 | Me >> 6 & 63), De(128 | Me & 63));
      }
      return N(Ae, 0, Ee);
    }
    bt.strToU8 = Ri;
    function ds(z, P) {
      if (P) {
        for (var q = "", te = 0; te < z.length; te += 16384) q += String.fromCharCode.apply(null, z.subarray(te, te + 16384));
        return q;
      } else {
        if (ni) return ni.decode(z);
        var ge = Hl(z), Ae = ge[0], Ee = ge[1];
        return Ee.length && V(8), Ae;
      }
    }
    bt.strFromU8 = ds;
    var Oi = function(z) {
      return z == 1 ? 3 : z < 6 ? 2 : z == 9 ? 1 : 0;
    }, Ha = function(z, P) {
      return P + 30 + ut(z, P + 26) + ut(z, P + 28);
    }, jl = function(z, P, q) {
      var te = ut(z, P + 28), ge = ds(z.subarray(P + 46, P + 46 + te), !(ut(z, P + 8) & 2048)), Ae = P + 46 + te, Ee = it(z, P + 20), De = q && Ee == 4294967295 ? aa(z, Ae) : [
        Ee,
        it(z, P + 24),
        it(z, P + 42)
      ], Be = De[0], Me = De[1], _e11 = De[2];
      return [
        ut(z, P + 10),
        Be,
        Me,
        ge,
        Ae + ut(z, P + 30) + ut(z, P + 32),
        _e11
      ];
    }, aa = function(z, P) {
      for (; ut(z, P) != 1; P += 4 + ut(z, P + 2)) ;
      return [
        fn(z, P + 12),
        fn(z, P + 4),
        fn(z, P + 20)
      ];
    }, Hi = function(z) {
      var P = 0;
      if (z) for (var q in z) {
        var te = z[q].length;
        te > 65535 && V(9), P += te + 4;
      }
      return P;
    }, Ta = function(z, P, q, te, ge, Ae, Ee, De) {
      var Be = te.length, Me = q.extra, _e11 = De && De.length, et = Hi(Me);
      jt(z, P, Ee != null ? 33639248 : 67324752), P += 4, Ee != null && (z[P++] = 20, z[P++] = q.os), z[P] = 20, P += 2, z[P++] = q.flag << 1 | (Ae == null && 8), z[P++] = ge && 8, z[P++] = q.compression & 255, z[P++] = q.compression >> 8;
      var lt = new Date(q.mtime == null ? Date.now() : q.mtime), St = lt.getFullYear() - 1980;
      if ((St < 0 || St > 119) && V(10), jt(z, P, St << 25 | lt.getMonth() + 1 << 21 | lt.getDate() << 16 | lt.getHours() << 11 | lt.getMinutes() << 5 | lt.getSeconds() >>> 1), P += 4, Ae != null && (jt(z, P, q.crc), jt(z, P + 4, Ae), jt(z, P + 8, q.size)), jt(z, P + 12, Be), jt(z, P + 14, et), P += 16, Ee != null && (jt(z, P, _e11), jt(z, P + 6, q.attrs), jt(z, P + 10, Ee), P += 14), z.set(te, P), P += Be, et) for (var At in Me) {
        var Mt = Me[At], $e = Mt.length;
        jt(z, P, +At), jt(z, P + 2, $e), z.set(Mt, P + 4), P += 4 + $e;
      }
      return _e11 && (z.set(De, P), P += _e11), P;
    }, Kl = function(z, P, q, te, ge) {
      jt(z, P, 101010256), jt(z, P + 8, q), jt(z, P + 10, q), jt(z, P + 12, te), jt(z, P + 16, ge);
    }, gs = (function() {
      function z(P) {
        this.filename = P, this.c = Pe(), this.size = 0, this.compression = 0;
      }
      return z.prototype.process = function(P, q) {
        this.ondata(null, P, q);
      }, z.prototype.push = function(P, q) {
        this.ondata || V(5), this.c.p(P), this.size += P.length, q && (this.crc = this.c.d()), this.process(P, q || false);
      }, z;
    })();
    bt.ZipPassThrough = gs;
    var mi = (function() {
      function z(P, q) {
        var te = this;
        q || (q = {}), gs.call(this, P), this.d = new rt(q, function(ge, Ae) {
          te.ondata(null, ge, Ae);
        }), this.compression = 8, this.flag = Oi(q.level);
      }
      return z.prototype.process = function(P, q) {
        try {
          this.d.push(P, q);
        } catch (te) {
          this.ondata(te, null, q);
        }
      }, z.prototype.push = function(P, q) {
        gs.prototype.push.call(this, P, q);
      }, z;
    })();
    bt.ZipDeflate = mi;
    var h0 = (function() {
      function z(P, q) {
        var te = this;
        q || (q = {}), gs.call(this, P), this.d = new sn(q, function(ge, Ae, Ee) {
          te.ondata(ge, Ae, Ee);
        }), this.compression = 8, this.flag = Oi(q.level), this.terminate = this.d.terminate;
      }
      return z.prototype.process = function(P, q) {
        this.d.push(P, q);
      }, z.prototype.push = function(P, q) {
        gs.prototype.push.call(this, P, q);
      }, z;
    })();
    bt.AsyncZipDeflate = h0;
    var Yl = (function() {
      function z(P) {
        this.ondata = P, this.u = [], this.d = 1;
      }
      return z.prototype.add = function(P) {
        var q = this;
        if (this.ondata || V(5), this.d & 2) this.ondata(V(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
          var te = Ri(P.filename), ge = te.length, Ae = P.comment, Ee = Ae && Ri(Ae), De = ge != P.filename.length || Ee && Ae.length != Ee.length, Be = ge + Hi(P.extra) + 30;
          ge > 65535 && this.ondata(V(11, 0, 1), null, false);
          var Me = new e(Be);
          Ta(Me, 0, P, te, De);
          var _e11 = [
            Me
          ], et = function() {
            for (var $e = 0, Lt = _e11; $e < Lt.length; $e++) {
              var It = Lt[$e];
              q.ondata(null, It, false);
            }
            _e11 = [];
          }, lt = this.d;
          this.d = 0;
          var St = this.u.length, At = wt(P, {
            f: te,
            u: De,
            o: Ee,
            t: function() {
              P.terminate && P.terminate();
            },
            r: function() {
              if (et(), lt) {
                var $e = q.u[St + 1];
                $e ? $e.r() : q.d = 1;
              }
              lt = 1;
            }
          }), Mt = 0;
          P.ondata = function($e, Lt, It) {
            if ($e) q.ondata($e, Lt, It), q.terminate();
            else if (Mt += Lt.length, _e11.push(Lt), It) {
              var Kt = new e(16);
              jt(Kt, 0, 134695760), jt(Kt, 4, P.crc), jt(Kt, 8, Mt), jt(Kt, 12, P.size), _e11.push(Kt), At.c = Mt, At.b = Be + Mt + 16, At.crc = P.crc, At.size = P.size, lt && At.r(), lt = 1;
            } else lt && et();
          }, this.u.push(At);
        }
      }, z.prototype.end = function() {
        var P = this;
        if (this.d & 2) {
          this.ondata(V(4 + (this.d & 1) * 8, 0, 1), null, true);
          return;
        }
        this.d ? this.e() : this.u.push({
          r: function() {
            P.d & 1 && (P.u.splice(-1, 1), P.e());
          },
          t: function() {
          }
        }), this.d = 3;
      }, z.prototype.e = function() {
        for (var P = 0, q = 0, te = 0, ge = 0, Ae = this.u; ge < Ae.length; ge++) {
          var Ee = Ae[ge];
          te += 46 + Ee.f.length + Hi(Ee.extra) + (Ee.o ? Ee.o.length : 0);
        }
        for (var De = new e(te + 22), Be = 0, Me = this.u; Be < Me.length; Be++) {
          var Ee = Me[Be];
          Ta(De, P, Ee, Ee.f, Ee.u, Ee.c, q, Ee.o), P += 46 + Ee.f.length + Hi(Ee.extra) + (Ee.o ? Ee.o.length : 0), q += Ee.b;
        }
        Kl(De, P, this.u.length, te, q), this.ondata(null, De, true), this.d = 2;
      }, z.prototype.terminate = function() {
        for (var P = 0, q = this.u; P < q.length; P++) {
          var te = q[P];
          te.t();
        }
        this.d = 2;
      }, z;
    })();
    bt.Zip = Yl;
    function Lo(z, P, q) {
      q || (q = P, P = {}), typeof q != "function" && V(7);
      var te = {};
      No(z, "", te, P);
      var ge = Object.keys(te), Ae = ge.length, Ee = 0, De = 0, Be = Ae, Me = new Array(Ae), _e11 = [], et = function() {
        for (var $e = 0; $e < _e11.length; ++$e) _e11[$e]();
      }, lt = function($e, Lt) {
        Gs(function() {
          q($e, Lt);
        });
      };
      Gs(function() {
        lt = q;
      });
      var St = function() {
        var $e = new e(De + 22), Lt = Ee, It = De - Ee;
        De = 0;
        for (var Kt = 0; Kt < Be; ++Kt) {
          var xt = Me[Kt];
          try {
            var on = xt.c.length;
            Ta($e, De, xt, xt.f, xt.u, on);
            var Qt = 30 + xt.f.length + Hi(xt.extra), Pt = De + Qt;
            $e.set(xt.c, Pt), Ta($e, Ee, xt, xt.f, xt.u, on, De, xt.m), Ee += 16 + Qt + (xt.m ? xt.m.length : 0), De = Pt + on;
          } catch (nt) {
            return lt(nt, null);
          }
        }
        Kl($e, Ee, Me.length, It, Lt), lt(null, $e);
      };
      Ae || St();
      for (var At = function($e) {
        var Lt = ge[$e], It = te[Lt], Kt = It[0], xt = It[1], on = Pe(), Qt = Kt.length;
        on.p(Kt);
        var Pt = Ri(Lt), nt = Pt.length, Nn = xt.comment, Xt = Nn && Ri(Nn), $ = Xt && Xt.length, ue = Hi(xt.extra), Te = xt.level == 0 ? 0 : 8, Xe = function(Ut, Wt) {
          if (Ut) et(), lt(Ut, null);
          else {
            var nn = Wt.length;
            Me[$e] = wt(xt, {
              size: Qt,
              crc: on.d(),
              c: Wt,
              f: Pt,
              m: Xt,
              u: nt != Lt.length || Xt && Nn.length != $,
              compression: Te
            }), Ee += 30 + nt + ue + nn, De += 76 + 2 * (nt + ue) + ($ || 0) + nn, --Ae || St();
          }
        };
        if (nt > 65535 && Xe(V(11, 0, 1), null), !Te) Xe(null, Kt);
        else if (Qt < 16e4) try {
          Xe(null, lr(Kt, xt));
        } catch (Ut) {
          Xe(Ut, null);
        }
        else _e11.push(ti(Kt, xt, Xe));
      }, Mt = 0; Mt < Be; ++Mt) At(Mt);
      return et;
    }
    bt.zip = Lo;
    function d0(z, P) {
      P || (P = {});
      var q = {}, te = [];
      No(z, "", q, P);
      var ge = 0, Ae = 0;
      for (var Ee in q) {
        var De = q[Ee], Be = De[0], Me = De[1], _e11 = Me.level == 0 ? 0 : 8, et = Ri(Ee), lt = et.length, St = Me.comment, At = St && Ri(St), Mt = At && At.length, $e = Hi(Me.extra);
        lt > 65535 && V(11);
        var Lt = _e11 ? lr(Be, Me) : Be, It = Lt.length, Kt = Pe();
        Kt.p(Be), te.push(wt(Me, {
          size: Be.length,
          crc: Kt.d(),
          c: Lt,
          f: et,
          m: At,
          u: lt != Ee.length || At && St.length != Mt,
          o: ge,
          compression: _e11
        })), ge += 30 + lt + $e + It, Ae += 76 + 2 * (lt + $e) + (Mt || 0) + It;
      }
      for (var xt = new e(Ae + 22), on = ge, Qt = Ae - ge, Pt = 0; Pt < te.length; ++Pt) {
        var et = te[Pt];
        Ta(xt, et.o, et, et.f, et.u, et.c.length);
        var nt = 30 + et.f.length + Hi(et.extra);
        xt.set(et.c, et.o + nt), Ta(xt, ge, et, et.f, et.u, et.c.length, et.o, et.m), ge += 16 + nt + (et.m ? et.m.length : 0);
      }
      return Kl(xt, ge, te.length, Qt, on), xt;
    }
    bt.zipSync = d0;
    var Ps = (function() {
      function z() {
      }
      return z.prototype.push = function(P, q) {
        this.ondata(null, P, q);
      }, z.compression = 0, z;
    })();
    bt.UnzipPassThrough = Ps;
    var df = (function() {
      function z() {
        var P = this;
        this.i = new vn(function(q, te) {
          P.ondata(null, q, te);
        });
      }
      return z.prototype.push = function(P, q) {
        try {
          this.i.push(P, q);
        } catch (te) {
          this.ondata(te, null, q);
        }
      }, z.compression = 8, z;
    })();
    bt.UnzipInflate = df;
    var vi = (function() {
      function z(P, q) {
        var te = this;
        q < 32e4 ? this.i = new vn(function(ge, Ae) {
          te.ondata(null, ge, Ae);
        }) : (this.i = new xa(function(ge, Ae, Ee) {
          te.ondata(ge, Ae, Ee);
        }), this.terminate = this.i.terminate);
      }
      return z.prototype.push = function(P, q) {
        this.i.terminate && (P = N(P, 0)), this.i.push(P, q);
      }, z.compression = 8, z;
    })();
    bt.AsyncUnzipInflate = vi;
    var ql = (function() {
      function z(P) {
        this.onfile = P, this.k = [], this.o = {
          0: Ps
        }, this.p = he;
      }
      return z.prototype.push = function(P, q) {
        var te = this;
        if (this.onfile || V(5), this.p || V(4), this.c > 0) {
          var ge = Math.min(this.c, P.length), Ae = P.subarray(0, ge);
          if (this.c -= ge, this.d ? this.d.push(Ae, !this.c) : this.k[0].push(Ae), P = P.subarray(ge), P.length) return this.push(P, q);
        } else {
          var Ee = 0, De = 0, Be = void 0, Me = void 0;
          this.p.length ? P.length ? (Me = new e(this.p.length + P.length), Me.set(this.p), Me.set(P, this.p.length)) : Me = this.p : Me = P;
          for (var _e11 = Me.length, et = this.c, lt = et && this.d, St = function() {
            var Lt, It = it(Me, De);
            if (It == 67324752) {
              Ee = 1, Be = De, At.d = null, At.c = 0;
              var Kt = ut(Me, De + 6), xt = ut(Me, De + 8), on = Kt & 2048, Qt = Kt & 8, Pt = ut(Me, De + 26), nt = ut(Me, De + 28);
              if (_e11 > De + 30 + Pt + nt) {
                var Nn = [];
                At.k.unshift(Nn), Ee = 2;
                var Xt = it(Me, De + 18), $ = it(Me, De + 22), ue = ds(Me.subarray(De + 30, De += 30 + Pt), !on);
                Xt == 4294967295 ? (Lt = Qt ? [
                  -2
                ] : aa(Me, De), Xt = Lt[0], $ = Lt[1]) : Qt && (Xt = -1), De += nt, At.c = Xt;
                var Te, Xe = {
                  name: ue,
                  compression: xt,
                  start: function() {
                    if (Xe.ondata || V(5), !Xt) Xe.ondata(null, he, true);
                    else {
                      var Ut = te.o[xt];
                      Ut || Xe.ondata(V(14, "unknown compression type " + xt, 1), null, false), Te = Xt < 0 ? new Ut(ue) : new Ut(ue, Xt, $), Te.ondata = function(tr, Xn, xr) {
                        Xe.ondata(tr, Xn, xr);
                      };
                      for (var Wt = 0, nn = Nn; Wt < nn.length; Wt++) {
                        var wn = nn[Wt];
                        Te.push(wn, false);
                      }
                      te.k[0] == Nn && te.c ? te.d = Te : Te.push(he, true);
                    }
                  },
                  terminate: function() {
                    Te && Te.terminate && Te.terminate();
                  }
                };
                Xt >= 0 && (Xe.size = Xt, Xe.originalSize = $), At.onfile(Xe);
              }
              return "break";
            } else if (et) {
              if (It == 134695760) return Be = De += 12 + (et == -2 && 8), Ee = 3, At.c = 0, "break";
              if (It == 33639248) return Be = De -= 4, Ee = 3, At.c = 0, "break";
            }
          }, At = this; De < _e11 - 4; ++De) {
            var Mt = St();
            if (Mt === "break") break;
          }
          if (this.p = he, et < 0) {
            var $e = Ee ? Me.subarray(0, Be - 12 - (et == -2 && 8) - (it(Me, Be - 16) == 134695760 && 4)) : Me.subarray(0, De);
            lt ? lt.push($e, !!Ee) : this.k[+(Ee == 2)].push($e);
          }
          if (Ee & 2) return this.push(Me.subarray(De), q);
          this.p = Me.subarray(De);
        }
        q && (this.c && V(13), this.p = null);
      }, z.prototype.register = function(P) {
        this.o[P.compression] = P;
      }, z;
    })();
    bt.Unzip = ql;
    var Gs = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(z) {
      z();
    };
    function Uo(z, P, q) {
      q || (q = P, P = {}), typeof q != "function" && V(7);
      var te = [], ge = function() {
        for (var Mt = 0; Mt < te.length; ++Mt) te[Mt]();
      }, Ae = {}, Ee = function(Mt, $e) {
        Gs(function() {
          q(Mt, $e);
        });
      };
      Gs(function() {
        Ee = q;
      });
      for (var De = z.length - 22; it(z, De) != 101010256; --De) if (!De || z.length - De > 65558) return Ee(V(13, 0, 1), null), ge;
      var Be = ut(z, De + 8);
      if (Be) {
        var Me = Be, _e11 = it(z, De + 16), et = _e11 == 4294967295;
        if (et) {
          if (De = it(z, De - 12), it(z, De) != 101075792) return Ee(V(13, 0, 1), null), ge;
          Me = Be = it(z, De + 32), _e11 = it(z, De + 48);
        }
        for (var lt = P && P.filter, St = function(Mt) {
          var $e = jl(z, _e11, et), Lt = $e[0], It = $e[1], Kt = $e[2], xt = $e[3], on = $e[4], Qt = $e[5], Pt = Ha(z, Qt);
          _e11 = on;
          var nt = function(Xt, $) {
            Xt ? (ge(), Ee(Xt, null)) : ($ && (Ae[xt] = $), --Be || Ee(null, Ae));
          };
          if (!lt || lt({
            name: xt,
            size: It,
            originalSize: Kt,
            compression: Lt
          })) if (!Lt) nt(null, N(z, Pt, Pt + It));
          else if (Lt == 8) {
            var Nn = z.subarray(Pt, Pt + It);
            if (It < 32e4) try {
              nt(null, za(Nn, new e(Kt)));
            } catch (Xt) {
              nt(Xt, null);
            }
            else te.push(Mo(Nn, {
              size: Kt
            }, nt));
          } else nt(V(14, "unknown compression type " + Lt, 1), null);
          else nt(null, null);
        }, At = 0; At < Me; ++At) St(At);
      } else Ee(null, {});
      return ge;
    }
    bt.unzip = Uo;
    function ps(z, P) {
      for (var q = {}, te = z.length - 22; it(z, te) != 101010256; --te) (!te || z.length - te > 65558) && V(13);
      var ge = ut(z, te + 8);
      if (!ge) return {};
      var Ae = it(z, te + 16), Ee = Ae == 4294967295;
      Ee && (te = it(z, te - 12), it(z, te) != 101075792 && V(13), ge = it(z, te + 32), Ae = it(z, te + 48));
      for (var De = P && P.filter, Be = 0; Be < ge; ++Be) {
        var Me = jl(z, Ae, Ee), _e11 = Me[0], et = Me[1], lt = Me[2], St = Me[3], At = Me[4], Mt = Me[5], $e = Ha(z, Mt);
        Ae = At, (!De || De({
          name: St,
          size: et,
          originalSize: lt,
          compression: _e11
        })) && (_e11 ? _e11 == 8 ? q[St] = za(z.subarray($e, $e + et), new e(lt)) : V(14, "unknown compression type " + _e11) : q[St] = N(z, $e, $e + et));
      }
      return q;
    }
    return bt.unzipSync = ps, bt;
  }
  var O1 = {}, I1 = {}, V1 = {}, ZA;
  function LL() {
    if (ZA) return V1;
    ZA = 1, Object.defineProperty(V1, "__esModule", {
      value: true
    }), V1.NIFTIEXTENSION = void 0;
    class t {
      constructor(n, r, i, a) {
        __publicField(this, "esize");
        __publicField(this, "ecode");
        __publicField(this, "edata");
        __publicField(this, "littleEndian");
        if (n % 16 != 0) throw new Error("This does not appear to be a NIFTI extension");
        this.esize = n, this.ecode = r, this.edata = i, this.littleEndian = a;
      }
      toArrayBuffer() {
        let n = new Uint8Array(this.esize), r = new Uint8Array(this.edata);
        n.set(r, 8);
        let i = new DataView(n.buffer);
        return i.setInt32(0, this.esize, this.littleEndian), i.setInt32(4, this.ecode, this.littleEndian), n.buffer;
      }
    }
    return V1.NIFTIEXTENSION = t, V1;
  }
  var QA;
  function $p() {
    if (QA) return I1;
    QA = 1, Object.defineProperty(I1, "__esModule", {
      value: true
    }), I1.Utils = void 0;
    const t = LL();
    const _e11 = class _e11 {
      static getStringAt(r, i, a) {
        var s = "", o, l;
        for (o = i; o < a; o += 1) l = r.getUint8(o), l !== 0 && (s += String.fromCharCode(l));
        return s;
      }
      static getIntAt(r, i, a) {
        return r.getInt32(i, a);
      }
      static getFloatAt(r, i, a) {
        return r.getFloat32(i, a);
      }
      static getDoubleAt(r, i, a) {
        return r.getFloat64(i, a);
      }
      static getInt64At(r, i, a) {
        const s = r.getUint32(i, a), o = r.getInt32(i + 4, a);
        let l;
        return a ? l = o * 2 ** 32 + s : l = s * 2 ** 32 + o, o < 0 && (l += -1 * 2 ** 32 * 2 ** 32), l;
      }
      static getExtensionsAt(r, i, a, s) {
        let o = [], l = i;
        for (; l < s; ) {
          let c = a, f = _e11.getIntAt(r, l, a);
          if (!f) break;
          if (f + l > s && (c = !c, f = _e11.getIntAt(r, l, c), f + l > s)) throw new Error("This does not appear to be a valid NIFTI extension");
          if (f % 16 != 0) throw new Error("This does not appear to be a NIFTI extension");
          let u = _e11.getIntAt(r, l + 4, c), h = r.buffer.slice(l + 8, l + f);
          console.log("extensionByteIndex: " + (l + 8) + " esize: " + f), console.log(h);
          let g = new t.NIFTIEXTENSION(f, u, h, c);
          o.push(g), l += f;
        }
        return o;
      }
      static toArrayBuffer(r) {
        var i, a, s;
        for (i = new ArrayBuffer(r.length), a = new Uint8Array(i), s = 0; s < r.length; s += 1) a[s] = r[s];
        return i;
      }
      static isString(r) {
        return typeof r == "string" || r instanceof String;
      }
      static formatNumber(r, i = void 0) {
        let a;
        return _e11.isString(r) ? a = Number(r) : a = r, i ? a = a.toPrecision(5) : a = a.toPrecision(7), parseFloat(a);
      }
      static makeCRCTable() {
        let r, i = [];
        for (var a = 0; a < 256; a++) {
          r = a;
          for (var s = 0; s < 8; s++) r = r & 1 ? 3988292384 ^ r >>> 1 : r >>> 1;
          i[a] = r;
        }
        return i;
      }
      static crc32(r) {
        _e11.crcTable || (_e11.crcTable = _e11.makeCRCTable());
        const i = _e11.crcTable;
        let a = -1;
        for (var s = 0; s < r.byteLength; s++) a = a >>> 8 ^ i[(a ^ r.getUint8(s)) & 255];
        return (a ^ -1) >>> 0;
      }
    };
    __publicField(_e11, "crcTable", null);
    __publicField(_e11, "GUNZIP_MAGIC_COOKIE1", 31);
    __publicField(_e11, "GUNZIP_MAGIC_COOKIE2", 139);
    __publicField(_e11, "getByteAt", function(r, i) {
      return r.getUint8(i);
    });
    __publicField(_e11, "getShortAt", function(r, i, a) {
      return r.getInt16(i, a);
    });
    let e = _e11;
    return I1.Utils = e, I1;
  }
  var JA;
  function U6() {
    if (JA) return O1;
    JA = 1, Object.defineProperty(O1, "__esModule", {
      value: true
    }), O1.NIFTI1 = void 0;
    const t = $p();
    const _e11 = class _e11 {
      constructor() {
        __publicField(this, "littleEndian", false);
        __publicField(this, "dim_info", 0);
        __publicField(this, "dims", []);
        __publicField(this, "intent_p1", 0);
        __publicField(this, "intent_p2", 0);
        __publicField(this, "intent_p3", 0);
        __publicField(this, "intent_code", 0);
        __publicField(this, "datatypeCode", 0);
        __publicField(this, "numBitsPerVoxel", 0);
        __publicField(this, "slice_start", 0);
        __publicField(this, "slice_end", 0);
        __publicField(this, "slice_code", 0);
        __publicField(this, "pixDims", []);
        __publicField(this, "vox_offset", 0);
        __publicField(this, "scl_slope", 1);
        __publicField(this, "scl_inter", 0);
        __publicField(this, "xyzt_units", 0);
        __publicField(this, "cal_max", 0);
        __publicField(this, "cal_min", 0);
        __publicField(this, "slice_duration", 0);
        __publicField(this, "toffset", 0);
        __publicField(this, "description", "");
        __publicField(this, "aux_file", "");
        __publicField(this, "intent_name", "");
        __publicField(this, "qform_code", 0);
        __publicField(this, "sform_code", 0);
        __publicField(this, "quatern_a", 0);
        __publicField(this, "quatern_b", 0);
        __publicField(this, "quatern_c", 0);
        __publicField(this, "quatern_d", 0);
        __publicField(this, "qoffset_x", 0);
        __publicField(this, "qoffset_y", 0);
        __publicField(this, "qoffset_z", 0);
        __publicField(this, "affine", [
          [
            1,
            0,
            0,
            0
          ],
          [
            0,
            1,
            0,
            0
          ],
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            0,
            0,
            1
          ]
        ]);
        __publicField(this, "qfac", 1);
        __publicField(this, "quatern_R");
        __publicField(this, "magic", "0");
        __publicField(this, "isHDR", false);
        __publicField(this, "extensionFlag", [
          0,
          0,
          0,
          0
        ]);
        __publicField(this, "extensionSize", 0);
        __publicField(this, "extensionCode", 0);
        __publicField(this, "extensions", []);
        __publicField(this, "getDatatypeCodeString", function(r) {
          return r === _e11.TYPE_UINT8 ? "1-Byte Unsigned Integer" : r === _e11.TYPE_INT16 ? "2-Byte Signed Integer" : r === _e11.TYPE_INT32 ? "4-Byte Signed Integer" : r === _e11.TYPE_FLOAT32 ? "4-Byte Float" : r === _e11.TYPE_FLOAT64 ? "8-Byte Float" : r === _e11.TYPE_RGB24 ? "RGB" : r === _e11.TYPE_INT8 ? "1-Byte Signed Integer" : r === _e11.TYPE_UINT16 ? "2-Byte Unsigned Integer" : r === _e11.TYPE_UINT32 ? "4-Byte Unsigned Integer" : r === _e11.TYPE_INT64 ? "8-Byte Signed Integer" : r === _e11.TYPE_UINT64 ? "8-Byte Unsigned Integer" : "Unknown";
        });
        __publicField(this, "getTransformCodeString", function(r) {
          return r === _e11.XFORM_SCANNER_ANAT ? "Scanner" : r === _e11.XFORM_ALIGNED_ANAT ? "Aligned" : r === _e11.XFORM_TALAIRACH ? "Talairach" : r === _e11.XFORM_MNI_152 ? "MNI" : "Unknown";
        });
        __publicField(this, "getUnitsCodeString", function(r) {
          return r === _e11.UNITS_METER ? "Meters" : r === _e11.UNITS_MM ? "Millimeters" : r === _e11.UNITS_MICRON ? "Microns" : r === _e11.UNITS_SEC ? "Seconds" : r === _e11.UNITS_MSEC ? "Milliseconds" : r === _e11.UNITS_USEC ? "Microseconds" : r === _e11.UNITS_HZ ? "Hz" : r === _e11.UNITS_PPM ? "PPM" : r === _e11.UNITS_RADS ? "Rads" : "Unknown";
        });
        __publicField(this, "nifti_mat33_mul", function(r, i) {
          var a = [
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ]
          ], s, o;
          for (s = 0; s < 3; s += 1) for (o = 0; o < 3; o += 1) a[s][o] = r[s][0] * i[0][o] + r[s][1] * i[1][o] + r[s][2] * i[2][o];
          return a;
        });
        __publicField(this, "nifti_mat33_determ", function(r) {
          var i, a, s, o, l, c, f, u, h;
          return i = r[0][0], a = r[0][1], s = r[0][2], o = r[1][0], l = r[1][1], c = r[1][2], f = r[2][0], u = r[2][1], h = r[2][2], i * l * h - i * u * c - o * a * h + o * u * s + f * a * c - f * l * s;
        });
      }
      readHeader(r) {
        var i = new DataView(r), a = t.Utils.getIntAt(i, 0, this.littleEndian), s, o, l, c;
        if (a !== _e11.MAGIC_COOKIE && (this.littleEndian = true, a = t.Utils.getIntAt(i, 0, this.littleEndian)), a !== _e11.MAGIC_COOKIE) throw new Error("This does not appear to be a NIFTI file!");
        for (this.dim_info = t.Utils.getByteAt(i, 39), s = 0; s < 8; s += 1) c = 40 + s * 2, this.dims[s] = t.Utils.getShortAt(i, c, this.littleEndian);
        for (this.intent_p1 = t.Utils.getFloatAt(i, 56, this.littleEndian), this.intent_p2 = t.Utils.getFloatAt(i, 60, this.littleEndian), this.intent_p3 = t.Utils.getFloatAt(i, 64, this.littleEndian), this.intent_code = t.Utils.getShortAt(i, 68, this.littleEndian), this.datatypeCode = t.Utils.getShortAt(i, 70, this.littleEndian), this.numBitsPerVoxel = t.Utils.getShortAt(i, 72, this.littleEndian), this.slice_start = t.Utils.getShortAt(i, 74, this.littleEndian), s = 0; s < 8; s += 1) c = 76 + s * 4, this.pixDims[s] = t.Utils.getFloatAt(i, c, this.littleEndian);
        if (this.vox_offset = t.Utils.getFloatAt(i, 108, this.littleEndian), this.scl_slope = t.Utils.getFloatAt(i, 112, this.littleEndian), this.scl_inter = t.Utils.getFloatAt(i, 116, this.littleEndian), this.slice_end = t.Utils.getShortAt(i, 120, this.littleEndian), this.slice_code = t.Utils.getByteAt(i, 122), this.xyzt_units = t.Utils.getByteAt(i, 123), this.cal_max = t.Utils.getFloatAt(i, 124, this.littleEndian), this.cal_min = t.Utils.getFloatAt(i, 128, this.littleEndian), this.slice_duration = t.Utils.getFloatAt(i, 132, this.littleEndian), this.toffset = t.Utils.getFloatAt(i, 136, this.littleEndian), this.description = t.Utils.getStringAt(i, 148, 228), this.aux_file = t.Utils.getStringAt(i, 228, 252), this.qform_code = t.Utils.getShortAt(i, 252, this.littleEndian), this.sform_code = t.Utils.getShortAt(i, 254, this.littleEndian), this.quatern_b = t.Utils.getFloatAt(i, 256, this.littleEndian), this.quatern_c = t.Utils.getFloatAt(i, 260, this.littleEndian), this.quatern_d = t.Utils.getFloatAt(i, 264, this.littleEndian), this.quatern_a = Math.sqrt(1 - (Math.pow(this.quatern_b, 2) + Math.pow(this.quatern_c, 2) + Math.pow(this.quatern_d, 2))), this.qoffset_x = t.Utils.getFloatAt(i, 268, this.littleEndian), this.qoffset_y = t.Utils.getFloatAt(i, 272, this.littleEndian), this.qoffset_z = t.Utils.getFloatAt(i, 276, this.littleEndian), this.qform_code < 1 && this.sform_code < 1 && (this.affine[0][0] = this.pixDims[1], this.affine[1][1] = this.pixDims[2], this.affine[2][2] = this.pixDims[3]), this.qform_code > 0 && this.sform_code < this.qform_code) {
          const f = this.quatern_a, u = this.quatern_b, h = this.quatern_c, g = this.quatern_d;
          for (this.qfac = this.pixDims[0] === 0 ? 1 : this.pixDims[0], this.quatern_R = [
            [
              f * f + u * u - h * h - g * g,
              2 * u * h - 2 * f * g,
              2 * u * g + 2 * f * h
            ],
            [
              2 * u * h + 2 * f * g,
              f * f + h * h - u * u - g * g,
              2 * h * g - 2 * f * u
            ],
            [
              2 * u * g - 2 * f * h,
              2 * h * g + 2 * f * u,
              f * f + g * g - h * h - u * u
            ]
          ], o = 0; o < 3; o += 1) for (l = 0; l < 3; l += 1) this.affine[o][l] = this.quatern_R[o][l] * this.pixDims[l + 1], l === 2 && (this.affine[o][l] *= this.qfac);
          this.affine[0][3] = this.qoffset_x, this.affine[1][3] = this.qoffset_y, this.affine[2][3] = this.qoffset_z;
        } else if (this.sform_code > 0) for (o = 0; o < 3; o += 1) for (l = 0; l < 4; l += 1) c = 280 + (o * 4 + l) * 4, this.affine[o][l] = t.Utils.getFloatAt(i, c, this.littleEndian);
        if (this.affine[3][0] = 0, this.affine[3][1] = 0, this.affine[3][2] = 0, this.affine[3][3] = 1, this.intent_name = t.Utils.getStringAt(i, 328, 344), this.magic = t.Utils.getStringAt(i, 344, 348), this.isHDR = this.magic === String.fromCharCode.apply(null, _e11.MAGIC_NUMBER2), i.byteLength > _e11.MAGIC_COOKIE) {
          this.extensionFlag[0] = t.Utils.getByteAt(i, 348), this.extensionFlag[1] = t.Utils.getByteAt(i, 349), this.extensionFlag[2] = t.Utils.getByteAt(i, 350), this.extensionFlag[3] = t.Utils.getByteAt(i, 351);
          let f = true;
          !this.isHDR && this.vox_offset <= 352 && (f = false), i.byteLength <= 368 && (f = false), f && this.extensionFlag[0] && (this.extensions = t.Utils.getExtensionsAt(i, this.getExtensionLocation(), this.littleEndian, this.vox_offset), this.extensionSize = this.extensions[0].esize, this.extensionCode = this.extensions[0].ecode);
        }
      }
      toFormattedString() {
        var r = t.Utils.formatNumber, i = "";
        return i += "Dim Info = " + this.dim_info + `
`, i += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + `
`, i += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + `
`, i += "Intent Code = " + this.intent_code + `
`, i += "Datatype = " + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + `)
`, i += "Bits Per Voxel = " + this.numBitsPerVoxel + `
`, i += "Slice Start = " + this.slice_start + `
`, i += "Voxel Dimensions (1-8): " + r(this.pixDims[0]) + ", " + r(this.pixDims[1]) + ", " + r(this.pixDims[2]) + ", " + r(this.pixDims[3]) + ", " + r(this.pixDims[4]) + ", " + r(this.pixDims[5]) + ", " + r(this.pixDims[6]) + ", " + r(this.pixDims[7]) + `
`, i += "Image Offset = " + this.vox_offset + `
`, i += "Data Scale:  Slope = " + r(this.scl_slope) + "  Intercept = " + r(this.scl_inter) + `
`, i += "Slice End = " + this.slice_end + `
`, i += "Slice Code = " + this.slice_code + `
`, i += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(_e11.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(_e11.TEMPORAL_UNITS_MASK & this.xyzt_units) + `)
`, i += "Display Range:  Max = " + r(this.cal_max) + "  Min = " + r(this.cal_min) + `
`, i += "Slice Duration = " + this.slice_duration + `
`, i += "Time Axis Shift = " + this.toffset + `
`, i += 'Description: "' + this.description + `"
`, i += 'Auxiliary File: "' + this.aux_file + `"
`, i += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + `)
`, i += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + `)
`, i += "Quaternion Parameters:  b = " + r(this.quatern_b) + "  c = " + r(this.quatern_c) + "  d = " + r(this.quatern_d) + `
`, i += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + `
`, i += "S-Form Parameters X: " + r(this.affine[0][0]) + ", " + r(this.affine[0][1]) + ", " + r(this.affine[0][2]) + ", " + r(this.affine[0][3]) + `
`, i += "S-Form Parameters Y: " + r(this.affine[1][0]) + ", " + r(this.affine[1][1]) + ", " + r(this.affine[1][2]) + ", " + r(this.affine[1][3]) + `
`, i += "S-Form Parameters Z: " + r(this.affine[2][0]) + ", " + r(this.affine[2][1]) + ", " + r(this.affine[2][2]) + ", " + r(this.affine[2][3]) + `
`, i += 'Intent Name: "' + this.intent_name + `"
`, this.extensionFlag[0] && (i += "Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + `
`), i;
      }
      getQformMat() {
        return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x, this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
      }
      convertNiftiQFormToNiftiSForm(r, i, a, s, o, l, c, f, u, h) {
        var g = [
          [
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0
          ]
        ], v, m = r, y = i, w = a, C, T, S;
        return g[3][0] = g[3][1] = g[3][2] = 0, g[3][3] = 1, v = 1 - (m * m + y * y + w * w), v < 1e-7 ? (v = 1 / Math.sqrt(m * m + y * y + w * w), m *= v, y *= v, w *= v, v = 0) : v = Math.sqrt(v), C = c > 0 ? c : 1, T = f > 0 ? f : 1, S = u > 0 ? u : 1, h < 0 && (S = -S), g[0][0] = (v * v + m * m - y * y - w * w) * C, g[0][1] = 2 * (m * y - v * w) * T, g[0][2] = 2 * (m * w + v * y) * S, g[1][0] = 2 * (m * y + v * w) * C, g[1][1] = (v * v + y * y - m * m - w * w) * T, g[1][2] = 2 * (y * w - v * m) * S, g[2][0] = 2 * (m * w - v * y) * C, g[2][1] = 2 * (y * w + v * m) * T, g[2][2] = (v * v + w * w - y * y - m * m) * S, g[0][3] = s, g[1][3] = o, g[2][3] = l, g;
      }
      convertNiftiSFormToNEMA(r) {
        var i, a, s, o, l, c, f, u, h, g, v, m, y, w, C, T, S, E, b, D, R, I, O, L, N, F, V, k, _, K, Z, j, B, Y;
        if (C = 0, V = [
          [
            0,
            0,
            0
          ],
          [
            0,
            0,
            0
          ],
          [
            0,
            0,
            0
          ]
        ], k = [
          [
            0,
            0,
            0
          ],
          [
            0,
            0,
            0
          ],
          [
            0,
            0,
            0
          ]
        ], i = r[0][0], a = r[0][1], s = r[0][2], o = r[1][0], l = r[1][1], c = r[1][2], f = r[2][0], u = r[2][1], h = r[2][2], g = Math.sqrt(i * i + o * o + f * f), g === 0 || (i /= g, o /= g, f /= g, g = Math.sqrt(a * a + l * l + u * u), g === 0)) return null;
        if (a /= g, l /= g, u /= g, g = i * a + o * l + f * u, Math.abs(g) > 1e-4) {
          if (a -= g * i, l -= g * o, u -= g * f, g = Math.sqrt(a * a + l * l + u * u), g === 0) return null;
          a /= g, l /= g, u /= g;
        }
        if (g = Math.sqrt(s * s + c * c + h * h), g === 0 ? (s = o * u - f * l, c = f * a - u * i, h = i * l - o * a) : (s /= g, c /= g, h /= g), g = i * s + o * c + f * h, Math.abs(g) > 1e-4) {
          if (s -= g * i, c -= g * o, h -= g * f, g = Math.sqrt(s * s + c * c + h * h), g === 0) return null;
          s /= g, c /= g, h /= g;
        }
        if (g = a * s + l * c + u * h, Math.abs(g) > 1e-4) {
          if (s -= g * a, c -= g * l, h -= g * u, g = Math.sqrt(s * s + c * c + h * h), g === 0) return null;
          s /= g, c /= g, h /= g;
        }
        if (V[0][0] = i, V[0][1] = a, V[0][2] = s, V[1][0] = o, V[1][1] = l, V[1][2] = c, V[2][0] = f, V[2][1] = u, V[2][2] = h, v = this.nifti_mat33_determ(V), v === 0) return null;
        for (F = -666, b = I = O = L = 1, D = 2, R = 3, y = 1; y <= 3; y += 1) for (w = 1; w <= 3; w += 1) if (y !== w) {
          for (C = 1; C <= 3; C += 1) if (!(y === C || w === C)) for (k[0][0] = k[0][1] = k[0][2] = k[1][0] = k[1][1] = k[1][2] = k[2][0] = k[2][1] = k[2][2] = 0, T = -1; T <= 1; T += 2) for (S = -1; S <= 1; S += 2) for (E = -1; E <= 1; E += 2) k[0][y - 1] = T, k[1][w - 1] = S, k[2][C - 1] = E, m = this.nifti_mat33_determ(k), m * v > 0 && (N = this.nifti_mat33_mul(k, V), g = N[0][0] + N[1][1] + N[2][2], g > F && (F = g, b = y, D = w, R = C, I = T, O = S, L = E));
        }
        switch (_ = K = Z = j = B = Y = "", b * I) {
          case 1:
            _ = "X", j = "+";
            break;
          case -1:
            _ = "X", j = "-";
            break;
          case 2:
            _ = "Y", j = "+";
            break;
          case -2:
            _ = "Y", j = "-";
            break;
          case 3:
            _ = "Z", j = "+";
            break;
          case -3:
            _ = "Z", j = "-";
            break;
        }
        switch (D * O) {
          case 1:
            K = "X", B = "+";
            break;
          case -1:
            K = "X", B = "-";
            break;
          case 2:
            K = "Y", B = "+";
            break;
          case -2:
            K = "Y", B = "-";
            break;
          case 3:
            K = "Z", B = "+";
            break;
          case -3:
            K = "Z", B = "-";
            break;
        }
        switch (R * L) {
          case 1:
            Z = "X", Y = "+";
            break;
          case -1:
            Z = "X", Y = "-";
            break;
          case 2:
            Z = "Y", Y = "+";
            break;
          case -2:
            Z = "Y", Y = "-";
            break;
          case 3:
            Z = "Z", Y = "+";
            break;
          case -3:
            Z = "Z", Y = "-";
            break;
        }
        return _ + K + Z + j + B + Y;
      }
      getExtensionLocation() {
        return _e11.MAGIC_COOKIE + 4;
      }
      getExtensionSize(r) {
        return t.Utils.getIntAt(r, this.getExtensionLocation(), this.littleEndian);
      }
      getExtensionCode(r) {
        return t.Utils.getIntAt(r, this.getExtensionLocation() + 4, this.littleEndian);
      }
      addExtension(r, i = -1) {
        i == -1 ? this.extensions.push(r) : this.extensions.splice(i, 0, r), this.vox_offset += r.esize;
      }
      removeExtension(r) {
        let i = this.extensions[r];
        i && (this.vox_offset -= i.esize), this.extensions.splice(r, 1);
      }
      toArrayBuffer(r = false) {
        let s = 352;
        if (r) for (let f of this.extensions) s += f.esize;
        let o = new Uint8Array(s), l = new DataView(o.buffer);
        l.setInt32(0, 348, this.littleEndian), l.setUint8(39, this.dim_info);
        for (let f = 0; f < 8; f++) l.setUint16(40 + 2 * f, this.dims[f], this.littleEndian);
        l.setFloat32(56, this.intent_p1, this.littleEndian), l.setFloat32(60, this.intent_p2, this.littleEndian), l.setFloat32(64, this.intent_p3, this.littleEndian), l.setInt16(68, this.intent_code, this.littleEndian), l.setInt16(70, this.datatypeCode, this.littleEndian), l.setInt16(72, this.numBitsPerVoxel, this.littleEndian), l.setInt16(74, this.slice_start, this.littleEndian);
        for (let f = 0; f < 8; f++) l.setFloat32(76 + 4 * f, this.pixDims[f], this.littleEndian);
        l.setFloat32(108, this.vox_offset, this.littleEndian), l.setFloat32(112, this.scl_slope, this.littleEndian), l.setFloat32(116, this.scl_inter, this.littleEndian), l.setInt16(120, this.slice_end, this.littleEndian), l.setUint8(122, this.slice_code), l.setUint8(123, this.xyzt_units), l.setFloat32(124, this.cal_max, this.littleEndian), l.setFloat32(128, this.cal_min, this.littleEndian), l.setFloat32(132, this.slice_duration, this.littleEndian), l.setFloat32(136, this.toffset, this.littleEndian), o.set(Buffer.from(this.description), 148), o.set(Buffer.from(this.aux_file), 228), l.setInt16(252, this.qform_code, this.littleEndian), l.setInt16(254, this.sform_code, this.littleEndian), l.setFloat32(256, this.quatern_b, this.littleEndian), l.setFloat32(260, this.quatern_c, this.littleEndian), l.setFloat32(264, this.quatern_d, this.littleEndian), l.setFloat32(268, this.qoffset_x, this.littleEndian), l.setFloat32(272, this.qoffset_y, this.littleEndian), l.setFloat32(276, this.qoffset_z, this.littleEndian);
        const c = this.affine.flat();
        for (let f = 0; f < 12; f++) l.setFloat32(280 + 4 * f, c[f], this.littleEndian);
        if (o.set(Buffer.from(this.intent_name), 328), o.set(Buffer.from(this.magic), 344), r) {
          o.set(Uint8Array.from([
            1,
            0,
            0,
            0
          ]), 348);
          let f = this.getExtensionLocation();
          for (const u of this.extensions) l.setInt32(f, u.esize, u.littleEndian), l.setInt32(f + 4, u.ecode, u.littleEndian), o.set(new Uint8Array(u.edata), f + 8), f += u.esize;
        } else o.set(new Uint8Array(4).fill(0), 348);
        return o.buffer;
      }
    };
    __publicField(_e11, "TYPE_NONE", 0);
    __publicField(_e11, "TYPE_BINARY", 1);
    __publicField(_e11, "TYPE_UINT8", 2);
    __publicField(_e11, "TYPE_INT16", 4);
    __publicField(_e11, "TYPE_INT32", 8);
    __publicField(_e11, "TYPE_FLOAT32", 16);
    __publicField(_e11, "TYPE_COMPLEX64", 32);
    __publicField(_e11, "TYPE_FLOAT64", 64);
    __publicField(_e11, "TYPE_RGB24", 128);
    __publicField(_e11, "TYPE_INT8", 256);
    __publicField(_e11, "TYPE_UINT16", 512);
    __publicField(_e11, "TYPE_UINT32", 768);
    __publicField(_e11, "TYPE_INT64", 1024);
    __publicField(_e11, "TYPE_UINT64", 1280);
    __publicField(_e11, "TYPE_FLOAT128", 1536);
    __publicField(_e11, "TYPE_COMPLEX128", 1792);
    __publicField(_e11, "TYPE_COMPLEX256", 2048);
    __publicField(_e11, "XFORM_UNKNOWN", 0);
    __publicField(_e11, "XFORM_SCANNER_ANAT", 1);
    __publicField(_e11, "XFORM_ALIGNED_ANAT", 2);
    __publicField(_e11, "XFORM_TALAIRACH", 3);
    __publicField(_e11, "XFORM_MNI_152", 4);
    __publicField(_e11, "SPATIAL_UNITS_MASK", 7);
    __publicField(_e11, "TEMPORAL_UNITS_MASK", 56);
    __publicField(_e11, "UNITS_UNKNOWN", 0);
    __publicField(_e11, "UNITS_METER", 1);
    __publicField(_e11, "UNITS_MM", 2);
    __publicField(_e11, "UNITS_MICRON", 3);
    __publicField(_e11, "UNITS_SEC", 8);
    __publicField(_e11, "UNITS_MSEC", 16);
    __publicField(_e11, "UNITS_USEC", 24);
    __publicField(_e11, "UNITS_HZ", 32);
    __publicField(_e11, "UNITS_PPM", 40);
    __publicField(_e11, "UNITS_RADS", 48);
    __publicField(_e11, "MAGIC_COOKIE", 348);
    __publicField(_e11, "STANDARD_HEADER_SIZE", 348);
    __publicField(_e11, "MAGIC_NUMBER_LOCATION", 344);
    __publicField(_e11, "MAGIC_NUMBER", [
      110,
      43,
      49
    ]);
    __publicField(_e11, "MAGIC_NUMBER2", [
      110,
      105,
      49
    ]);
    __publicField(_e11, "EXTENSION_HEADER_SIZE", 8);
    let e = _e11;
    return O1.NIFTI1 = e, O1;
  }
  var N1 = {}, $A;
  function eE() {
    if ($A) return N1;
    $A = 1, Object.defineProperty(N1, "__esModule", {
      value: true
    }), N1.NIFTI2 = void 0;
    const t = U6(), e = $p();
    const _n3 = class _n3 {
      constructor() {
        __publicField(this, "littleEndian", false);
        __publicField(this, "dim_info", 0);
        __publicField(this, "dims", []);
        __publicField(this, "intent_p1", 0);
        __publicField(this, "intent_p2", 0);
        __publicField(this, "intent_p3", 0);
        __publicField(this, "intent_code", 0);
        __publicField(this, "datatypeCode", 0);
        __publicField(this, "numBitsPerVoxel", 0);
        __publicField(this, "slice_start", 0);
        __publicField(this, "slice_end", 0);
        __publicField(this, "slice_code", 0);
        __publicField(this, "pixDims", []);
        __publicField(this, "vox_offset", 0);
        __publicField(this, "scl_slope", 1);
        __publicField(this, "scl_inter", 0);
        __publicField(this, "xyzt_units", 0);
        __publicField(this, "cal_max", 0);
        __publicField(this, "cal_min", 0);
        __publicField(this, "slice_duration", 0);
        __publicField(this, "toffset", 0);
        __publicField(this, "description", "");
        __publicField(this, "aux_file", "");
        __publicField(this, "intent_name", "");
        __publicField(this, "qform_code", 0);
        __publicField(this, "sform_code", 0);
        __publicField(this, "quatern_b", 0);
        __publicField(this, "quatern_c", 0);
        __publicField(this, "quatern_d", 0);
        __publicField(this, "qoffset_x", 0);
        __publicField(this, "qoffset_y", 0);
        __publicField(this, "qoffset_z", 0);
        __publicField(this, "affine", [
          [
            1,
            0,
            0,
            0
          ],
          [
            0,
            1,
            0,
            0
          ],
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            0,
            0,
            1
          ]
        ]);
        __publicField(this, "magic", "0");
        __publicField(this, "extensionFlag", [
          0,
          0,
          0,
          0
        ]);
        __publicField(this, "extensions", []);
        __publicField(this, "extensionSize", 0);
        __publicField(this, "extensionCode", 0);
        __publicField(this, "getExtensionLocation", function() {
          return _n3.MAGIC_COOKIE + 4;
        });
        __publicField(this, "getExtensionSize", t.NIFTI1.prototype.getExtensionSize);
        __publicField(this, "getExtensionCode", t.NIFTI1.prototype.getExtensionCode);
        __publicField(this, "addExtension", t.NIFTI1.prototype.addExtension);
        __publicField(this, "removeExtension", t.NIFTI1.prototype.removeExtension);
        __publicField(this, "getDatatypeCodeString", t.NIFTI1.prototype.getDatatypeCodeString);
        __publicField(this, "getTransformCodeString", t.NIFTI1.prototype.getTransformCodeString);
        __publicField(this, "getUnitsCodeString", t.NIFTI1.prototype.getUnitsCodeString);
        __publicField(this, "getQformMat", t.NIFTI1.prototype.getQformMat);
        __publicField(this, "convertNiftiQFormToNiftiSForm", t.NIFTI1.prototype.convertNiftiQFormToNiftiSForm);
        __publicField(this, "convertNiftiSFormToNEMA", t.NIFTI1.prototype.convertNiftiSFormToNEMA);
        __publicField(this, "nifti_mat33_mul", t.NIFTI1.prototype.nifti_mat33_mul);
        __publicField(this, "nifti_mat33_determ", t.NIFTI1.prototype.nifti_mat33_determ);
      }
      readHeader(i) {
        var a = new DataView(i), s = e.Utils.getIntAt(a, 0, this.littleEndian), o, l, c, f;
        if (s !== _n3.MAGIC_COOKIE && (this.littleEndian = true, s = e.Utils.getIntAt(a, 0, this.littleEndian)), s !== _n3.MAGIC_COOKIE) throw new Error("This does not appear to be a NIFTI file!");
        for (this.magic = e.Utils.getStringAt(a, 4, 12), this.datatypeCode = e.Utils.getShortAt(a, 12, this.littleEndian), this.numBitsPerVoxel = e.Utils.getShortAt(a, 14, this.littleEndian), o = 0; o < 8; o += 1) f = 16 + o * 8, this.dims[o] = e.Utils.getInt64At(a, f, this.littleEndian);
        for (this.intent_p1 = e.Utils.getDoubleAt(a, 80, this.littleEndian), this.intent_p2 = e.Utils.getDoubleAt(a, 88, this.littleEndian), this.intent_p3 = e.Utils.getDoubleAt(a, 96, this.littleEndian), o = 0; o < 8; o += 1) f = 104 + o * 8, this.pixDims[o] = e.Utils.getDoubleAt(a, f, this.littleEndian);
        for (this.vox_offset = e.Utils.getInt64At(a, 168, this.littleEndian), this.scl_slope = e.Utils.getDoubleAt(a, 176, this.littleEndian), this.scl_inter = e.Utils.getDoubleAt(a, 184, this.littleEndian), this.cal_max = e.Utils.getDoubleAt(a, 192, this.littleEndian), this.cal_min = e.Utils.getDoubleAt(a, 200, this.littleEndian), this.slice_duration = e.Utils.getDoubleAt(a, 208, this.littleEndian), this.toffset = e.Utils.getDoubleAt(a, 216, this.littleEndian), this.slice_start = e.Utils.getInt64At(a, 224, this.littleEndian), this.slice_end = e.Utils.getInt64At(a, 232, this.littleEndian), this.description = e.Utils.getStringAt(a, 240, 320), this.aux_file = e.Utils.getStringAt(a, 320, 344), this.qform_code = e.Utils.getIntAt(a, 344, this.littleEndian), this.sform_code = e.Utils.getIntAt(a, 348, this.littleEndian), this.quatern_b = e.Utils.getDoubleAt(a, 352, this.littleEndian), this.quatern_c = e.Utils.getDoubleAt(a, 360, this.littleEndian), this.quatern_d = e.Utils.getDoubleAt(a, 368, this.littleEndian), this.qoffset_x = e.Utils.getDoubleAt(a, 376, this.littleEndian), this.qoffset_y = e.Utils.getDoubleAt(a, 384, this.littleEndian), this.qoffset_z = e.Utils.getDoubleAt(a, 392, this.littleEndian), l = 0; l < 3; l += 1) for (c = 0; c < 4; c += 1) f = 400 + (l * 4 + c) * 8, this.affine[l][c] = e.Utils.getDoubleAt(a, f, this.littleEndian);
        this.affine[3][0] = 0, this.affine[3][1] = 0, this.affine[3][2] = 0, this.affine[3][3] = 1, this.slice_code = e.Utils.getIntAt(a, 496, this.littleEndian), this.xyzt_units = e.Utils.getIntAt(a, 500, this.littleEndian), this.intent_code = e.Utils.getIntAt(a, 504, this.littleEndian), this.intent_name = e.Utils.getStringAt(a, 508, 524), this.dim_info = e.Utils.getByteAt(a, 524), a.byteLength > _n3.MAGIC_COOKIE && (this.extensionFlag[0] = e.Utils.getByteAt(a, 540), this.extensionFlag[1] = e.Utils.getByteAt(a, 541), this.extensionFlag[2] = e.Utils.getByteAt(a, 542), this.extensionFlag[3] = e.Utils.getByteAt(a, 543), this.extensionFlag[0] && (this.extensions = e.Utils.getExtensionsAt(a, this.getExtensionLocation(), this.littleEndian, this.vox_offset), this.extensionSize = this.extensions[0].esize, this.extensionCode = this.extensions[0].ecode));
      }
      toFormattedString() {
        var i = e.Utils.formatNumber, a = "";
        return a += "Datatype = " + +this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + `)
`, a += "Bits Per Voxel =  = " + this.numBitsPerVoxel + `
`, a += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + `
`, a += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + `
`, a += "Voxel Dimensions (1-8): " + i(this.pixDims[0]) + ", " + i(this.pixDims[1]) + ", " + i(this.pixDims[2]) + ", " + i(this.pixDims[3]) + ", " + i(this.pixDims[4]) + ", " + i(this.pixDims[5]) + ", " + i(this.pixDims[6]) + ", " + i(this.pixDims[7]) + `
`, a += "Image Offset = " + this.vox_offset + `
`, a += "Data Scale:  Slope = " + i(this.scl_slope) + "  Intercept = " + i(this.scl_inter) + `
`, a += "Display Range:  Max = " + i(this.cal_max) + "  Min = " + i(this.cal_min) + `
`, a += "Slice Duration = " + this.slice_duration + `
`, a += "Time Axis Shift = " + this.toffset + `
`, a += "Slice Start = " + this.slice_start + `
`, a += "Slice End = " + this.slice_end + `
`, a += 'Description: "' + this.description + `"
`, a += 'Auxiliary File: "' + this.aux_file + `"
`, a += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + `)
`, a += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + `)
`, a += "Quaternion Parameters:  b = " + i(this.quatern_b) + "  c = " + i(this.quatern_c) + "  d = " + i(this.quatern_d) + `
`, a += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + `
`, a += "S-Form Parameters X: " + i(this.affine[0][0]) + ", " + i(this.affine[0][1]) + ", " + i(this.affine[0][2]) + ", " + i(this.affine[0][3]) + `
`, a += "S-Form Parameters Y: " + i(this.affine[1][0]) + ", " + i(this.affine[1][1]) + ", " + i(this.affine[1][2]) + ", " + i(this.affine[1][3]) + `
`, a += "S-Form Parameters Z: " + i(this.affine[2][0]) + ", " + i(this.affine[2][1]) + ", " + i(this.affine[2][2]) + ", " + i(this.affine[2][3]) + `
`, a += "Slice Code = " + this.slice_code + `
`, a += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(t.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(t.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + `)
`, a += "Intent Code = " + this.intent_code + `
`, a += 'Intent Name: "' + this.intent_name + `"
`, a += "Dim Info = " + this.dim_info + `
`, a;
      }
      toArrayBuffer(i = false) {
        let o = 544;
        if (i) for (let u of this.extensions) o += u.esize;
        let l = new Uint8Array(o), c = new DataView(l.buffer);
        c.setInt32(0, 540, this.littleEndian), l.set(Buffer.from(this.magic), 4), c.setInt16(12, this.datatypeCode, this.littleEndian), c.setInt16(14, this.numBitsPerVoxel, this.littleEndian);
        for (let u = 0; u < 8; u++) c.setBigInt64(16 + 8 * u, BigInt(this.dims[u]), this.littleEndian);
        c.setFloat64(80, this.intent_p1, this.littleEndian), c.setFloat64(88, this.intent_p2, this.littleEndian), c.setFloat64(96, this.intent_p3, this.littleEndian);
        for (let u = 0; u < 8; u++) c.setFloat64(104 + 8 * u, this.pixDims[u], this.littleEndian);
        c.setBigInt64(168, BigInt(this.vox_offset), this.littleEndian), c.setFloat64(176, this.scl_slope, this.littleEndian), c.setFloat64(184, this.scl_inter, this.littleEndian), c.setFloat64(192, this.cal_max, this.littleEndian), c.setFloat64(200, this.cal_min, this.littleEndian), c.setFloat64(208, this.slice_duration, this.littleEndian), c.setFloat64(216, this.toffset, this.littleEndian), c.setBigInt64(224, BigInt(this.slice_start), this.littleEndian), c.setBigInt64(232, BigInt(this.slice_end), this.littleEndian), l.set(Buffer.from(this.description), 240), l.set(Buffer.from(this.aux_file), 320), c.setInt32(344, this.qform_code, this.littleEndian), c.setInt32(348, this.sform_code, this.littleEndian), c.setFloat64(352, this.quatern_b, this.littleEndian), c.setFloat64(360, this.quatern_c, this.littleEndian), c.setFloat64(368, this.quatern_d, this.littleEndian), c.setFloat64(376, this.qoffset_x, this.littleEndian), c.setFloat64(384, this.qoffset_y, this.littleEndian), c.setFloat64(392, this.qoffset_z, this.littleEndian);
        const f = this.affine.flat();
        for (let u = 0; u < 12; u++) c.setFloat64(400 + 8 * u, f[u], this.littleEndian);
        if (c.setInt32(496, this.slice_code, this.littleEndian), c.setInt32(500, this.xyzt_units, this.littleEndian), c.setInt32(504, this.intent_code, this.littleEndian), l.set(Buffer.from(this.intent_name), 508), c.setUint8(524, this.dim_info), i) {
          l.set(Uint8Array.from([
            1,
            0,
            0,
            0
          ]), 540);
          let u = this.getExtensionLocation();
          for (const h of this.extensions) c.setInt32(u, h.esize, h.littleEndian), c.setInt32(u + 4, h.ecode, h.littleEndian), l.set(new Uint8Array(h.edata), u + 8), u += h.esize;
        } else l.set(new Uint8Array(4).fill(0), 540);
        return l.buffer;
      }
    };
    __publicField(_n3, "MAGIC_COOKIE", 540);
    __publicField(_n3, "MAGIC_NUMBER_LOCATION", 4);
    __publicField(_n3, "MAGIC_NUMBER", [
      110,
      43,
      50,
      0,
      13,
      10,
      26,
      10
    ]);
    __publicField(_n3, "MAGIC_NUMBER2", [
      110,
      105,
      50,
      0,
      13,
      10,
      26,
      10
    ]);
    let n = _n3;
    return N1.NIFTI2 = n, N1;
  }
  var tE;
  function Dge() {
    return tE || (tE = 1, (function(t) {
      var e = ao && ao.__createBinding || (Object.create ? (function(b, D, R, I) {
        I === void 0 && (I = R);
        var O = Object.getOwnPropertyDescriptor(D, R);
        (!O || ("get" in O ? !D.__esModule : O.writable || O.configurable)) && (O = {
          enumerable: true,
          get: function() {
            return D[R];
          }
        }), Object.defineProperty(b, I, O);
      }) : (function(b, D, R, I) {
        I === void 0 && (I = R), b[I] = D[R];
      })), n = ao && ao.__setModuleDefault || (Object.create ? (function(b, D) {
        Object.defineProperty(b, "default", {
          enumerable: true,
          value: D
        });
      }) : function(b, D) {
        b.default = D;
      }), r = ao && ao.__importStar || function(b) {
        if (b && b.__esModule) return b;
        var D = {};
        if (b != null) for (var R in b) R !== "default" && Object.prototype.hasOwnProperty.call(b, R) && e(D, b, R);
        return n(D, b), D;
      };
      Object.defineProperty(t, "__esModule", {
        value: true
      }), t.readExtensionData = t.readExtension = t.readImage = t.hasExtension = t.readHeader = t.decompress = t.isCompressed = t.isNIFTI = t.isNIFTI2 = t.isNIFTI1 = t.NIFTIEXTENSION = t.Utils = t.NIFTI2 = t.NIFTI1 = void 0;
      const i = r(bge()), a = U6(), s = eE(), o = $p();
      var l = U6();
      Object.defineProperty(t, "NIFTI1", {
        enumerable: true,
        get: function() {
          return l.NIFTI1;
        }
      });
      var c = eE();
      Object.defineProperty(t, "NIFTI2", {
        enumerable: true,
        get: function() {
          return c.NIFTI2;
        }
      });
      var f = $p();
      Object.defineProperty(t, "Utils", {
        enumerable: true,
        get: function() {
          return f.Utils;
        }
      });
      var u = LL();
      Object.defineProperty(t, "NIFTIEXTENSION", {
        enumerable: true,
        get: function() {
          return u.NIFTIEXTENSION;
        }
      });
      function h(b, D = false) {
        var R, I, O, L;
        return b.byteLength < a.NIFTI1.STANDARD_HEADER_SIZE ? false : (R = new DataView(b), R && (I = R.getUint8(a.NIFTI1.MAGIC_NUMBER_LOCATION)), O = R.getUint8(a.NIFTI1.MAGIC_NUMBER_LOCATION + 1), L = R.getUint8(a.NIFTI1.MAGIC_NUMBER_LOCATION + 2), D && I === a.NIFTI1.MAGIC_NUMBER2[0] && O === a.NIFTI1.MAGIC_NUMBER2[1] && L === a.NIFTI1.MAGIC_NUMBER2[2] ? true : I === a.NIFTI1.MAGIC_NUMBER[0] && O === a.NIFTI1.MAGIC_NUMBER[1] && L === a.NIFTI1.MAGIC_NUMBER[2]);
      }
      t.isNIFTI1 = h;
      function g(b, D = false) {
        var R, I, O, L;
        return b.byteLength < a.NIFTI1.STANDARD_HEADER_SIZE ? false : (R = new DataView(b), I = R.getUint8(s.NIFTI2.MAGIC_NUMBER_LOCATION), O = R.getUint8(s.NIFTI2.MAGIC_NUMBER_LOCATION + 1), L = R.getUint8(s.NIFTI2.MAGIC_NUMBER_LOCATION + 2), D && I === s.NIFTI2.MAGIC_NUMBER2[0] && O === s.NIFTI2.MAGIC_NUMBER2[1] && L === s.NIFTI2.MAGIC_NUMBER2[2] ? true : I === s.NIFTI2.MAGIC_NUMBER[0] && O === s.NIFTI2.MAGIC_NUMBER[1] && L === s.NIFTI2.MAGIC_NUMBER[2]);
      }
      t.isNIFTI2 = g;
      function v(b, D = false) {
        return h(b, D) || g(b, D);
      }
      t.isNIFTI = v;
      function m(b) {
        var D, R, I;
        return !!(b && (D = new DataView(b), R = D.getUint8(0), I = D.getUint8(1), R === o.Utils.GUNZIP_MAGIC_COOKIE1 || I === o.Utils.GUNZIP_MAGIC_COOKIE2));
      }
      t.isCompressed = m;
      function y(b) {
        return i.decompressSync(new Uint8Array(b)).buffer;
      }
      t.decompress = y;
      function w(b, D = false) {
        var R = null;
        return m(b) && (b = y(b)), h(b, D) ? R = new a.NIFTI1() : g(b, D) && (R = new s.NIFTI2()), R ? R.readHeader(b) : console.error("That file does not appear to be NIFTI!"), R;
      }
      t.readHeader = w;
      function C(b) {
        return b.extensionFlag[0] != 0;
      }
      t.hasExtension = C;
      function T(b, D) {
        var R = b.vox_offset, I = 1, O = 1;
        b.dims[4] && (I = b.dims[4]), b.dims[5] && (O = b.dims[5]);
        var L = b.dims[1] * b.dims[2] * b.dims[3] * I * O * (b.numBitsPerVoxel / 8);
        return D.slice(R, R + L);
      }
      t.readImage = T;
      function S(b, D) {
        var R = b.getExtensionLocation(), I = b.extensionSize;
        return D.slice(R, R + I);
      }
      t.readExtension = S;
      function E(b, D) {
        var R = b.getExtensionLocation(), I = b.extensionSize;
        return D.slice(R + 8, R + I);
      }
      t.readExtensionData = E;
    })(ao)), ao;
  }
  var L1 = Dge();
  class Mge extends Gl {
    constructor(e, n) {
      super(e), this.cancelLoading = () => {
        const { loadStatus: r } = this;
        !r || !r.loading || (r.loading = false, this.clearLoadCallbacks(), this.controller.abort());
      }, this.load = (r, i = 5) => {
      }, this.loadStatus = n.loadStatus, this.controller = n.controller;
    }
    clearLoadCallbacks() {
      this.loadStatus.callbacks = [];
    }
    decache() {
      Ke.removeVolumeLoadObject(this.volumeId);
    }
  }
  function Rge(t) {
    const e = [
      t[0][3],
      t[1][3],
      t[2][3]
    ], n = [
      Math.sqrt(t[0][0] ** 2 + t[1][0] ** 2 + t[2][0] ** 2),
      Math.sqrt(t[0][1] ** 2 + t[1][1] ** 2 + t[2][1] ** 2),
      Math.sqrt(t[0][2] ** 2 + t[1][2] ** 2 + t[2][2] ** 2)
    ], r = [
      t[0][0] / n[0],
      t[0][1] / n[1],
      t[0][2] / n[2],
      t[1][0] / n[0],
      t[1][1] / n[1],
      t[1][2] / n[2],
      t[2][0] / n[0],
      t[2][1] / n[1],
      t[2][2] / n[2]
    ];
    return {
      origin: e,
      orientation: r,
      spacing: n
    };
  }
  function Oge(t) {
    const { affine: e } = t, { orientation: n, origin: r, spacing: i } = Rge(e), a = [
      -r[0],
      -r[1],
      r[2]
    ], s = [
      -n[0],
      -n[3],
      n[6],
      -n[1],
      -n[4],
      n[7],
      -n[2],
      -n[5],
      n[8]
    ];
    return {
      origin: a,
      orientation: s,
      spacing: i
    };
  }
  var e5;
  (function(t) {
    t.NIFTI_VOLUME_LOADED = "CORNERSTONE_NIFTI_VOLUME_LOADED", t.NIFTI_VOLUME_PROGRESS = "CORNERSTONE_NIFTI_VOLUME_PROGRESS";
  })(e5 || (e5 = {}));
  const Ige = "nifti", nE = /* @__PURE__ */ new Map();
  function Vge(t, e, n, r) {
    return new Promise((i, a) => {
      const s = new XMLHttpRequest();
      s.open("GET", t, true), s.responseType = "arraybuffer";
      const o = function(c) {
        r && typeof r == "function" && r(), n && n.removeEventListener("abort", l), i(s.response);
      }, l = () => {
        s.abort(), s.removeEventListener("load", o), a(new Error("Request aborted"));
      };
      s.addEventListener("load", o), e && typeof e == "function" && (s.onprogress = function(c) {
        e(c.loaded, c.total);
      }), n && n.aborted ? (s.abort(), a(new Error("Request aborted"))) : n && n.addEventListener("abort", l), s.send();
    });
  }
  async function Nge(t) {
    const e = t.substring(Ige.length + 1), n = (w, C) => {
      const T = {
        volumeId: t,
        loaded: w,
        total: C
      };
      qe(je, e5.NIFTI_VOLUME_PROGRESS, {
        data: T
      });
    }, r = () => {
      const w = {
        volumeId: t
      };
      qe(je, e5.NIFTI_VOLUME_LOADED, {
        data: w
      });
    }, i = new AbortController(), a = i.signal;
    nE.set(e, {
      controller: i,
      loading: true
    });
    let s = await Vge(e, n, a, r);
    nE.delete(e);
    let o = null, l = null;
    L1.isCompressed(s) && (s = L1.decompress(s)), L1.isNIFTI(s) && (o = L1.readHeader(s), l = L1.readImage(o, s));
    const { scalarData: c, pixelRepresentation: f } = Sge(o, l), { orientation: u, origin: h, spacing: g } = Oge(o), { volumeMetadata: v, dimensions: m, direction: y } = hge(o, u, c, f);
    return new Mge({
      volumeId: t,
      metadata: v,
      dimensions: m,
      spacing: g,
      origin: h,
      direction: y,
      scalarData: c,
      sizeInBytes: c.byteLength,
      imageIds: []
    }, {
      loadStatus: {
        loaded: false,
        loading: false,
        callbacks: []
      },
      controller: i
    });
  }
  function Lge(t) {
    return {
      promise: Nge(t),
      cancel: () => {
      }
    };
  }
  const Gh = "myToolGroup", Zg = "myRenderingEngine", Av = "combined_labels", UL = {
    fillAlpha: ls.DEFAULT_SEGMENTATION_OPACITY,
    fillAlphaInactive: ls.DEFAULT_SEGMENTATION_OPACITY,
    outlineOpacity: 1,
    outlineWidth: 1,
    renderOutline: false,
    outlineOpacityInactive: 0
  }, Uge = {
    renderInactiveSegmentations: true,
    representations: {
      [Nt.Labelmap]: UL
    }
  };
  async function Fge(t, e, n, r, i) {
    if (Ke.purgeCache(), sge(), await bK(), !t.current || !e.current || !n.current) return;
    t.current.oncontextmenu = (O) => O.preventDefault(), e.current.oncontextmenu = (O) => O.preventDefault(), n.current.oncontextmenu = (O) => O.preventDefault();
    const a = _ge();
    if (!a) return;
    Mre("nifti", Lge);
    const s = kge();
    console.log("\u{1F9E9} renderingEngine = ", s);
    const l = `nifti:${ls.API_ORIGIN}/api/get-main-nifti/${i}`, c = "CT_NIFTI_AXIAL", f = "CT_NIFTI_SAGITTAL", u = "CT_NIFTI_CORONAL";
    await (await m6(l)).load();
    const v = `nifti:${ls.API_ORIGIN}/api/get-segmentations/${i}`;
    console.log("combined_labels_Id:" + v);
    const m = await m6(v);
    console.log("pass");
    const y = m.getScalarData(), C = await (await fetch(`${ls.API_ORIGIN}/api/get-label-colormap/${i}`)).json();
    console.log("\u2705 Raw colorLUT = ", JSON.stringify(C, null, 2));
    const T = [], S = Object.keys(C).map((O) => parseInt(O)), E = Math.max(...S);
    for (let O = 0; O <= E; O++) T[O] = [
      0,
      0,
      0,
      0
    ];
    for (const O in C) {
      const L = parseInt(O), N = C[O];
      if (!N) {
        console.warn(`\u2757 Label ${L} has no color value`);
        continue;
      }
      const F = N.R, V = N.G, k = N.B, _ = N.A ?? 255;
      if ([
        F,
        V,
        k
      ].some((K) => K === void 0)) {
        console.warn(`\u2757 Invalid color format for label ${L}:`, N);
        continue;
      }
      T[L] = [
        F,
        V,
        k,
        _
      ], console.log(`\u2705 Label ${L}: RGB(${F}, ${V}, ${k}), A: ${_}`);
    }
    console.log("\u2705 convertedColorLUT = ", T);
    const b = [
      {
        viewportId: c,
        type: Hn.ORTHOGRAPHIC,
        element: t.current,
        defaultOptions: {
          orientation: vo.AXIAL
        }
      },
      {
        viewportId: f,
        type: Hn.ORTHOGRAPHIC,
        element: e.current,
        defaultOptions: {
          orientation: vo.SAGITTAL
        }
      },
      {
        viewportId: u,
        type: Hn.ORTHOGRAPHIC,
        element: n.current,
        defaultOptions: {
          orientation: vo.CORONAL
        }
      }
    ];
    s.setViewports(b), a.addViewport(c, Zg), a.addViewport(f, Zg), a.addViewport(u, Zg), AI(s, [
      {
        volumeId: l
      }
    ], [
      c,
      f,
      u
    ]);
    const D = 50, R = 500;
    b.forEach(({ viewportId: O }) => {
      const L = s.getViewport(O);
      try {
        L.setProperties({
          voiRange: {
            windowWidth: D,
            windowCenter: R
          }
        });
      } catch (N) {
        console.warn("[VOI Error]", N);
      }
    }), s.render(), pue(Av), Wue([
      {
        segmentationId: Av,
        representation: {
          type: Nt.Labelmap,
          data: {
            volumeId: v
          }
        }
      }
    ]);
    const I = await D1e(Gh, [
      {
        segmentationId: Av,
        type: Nt.Labelmap,
        options: {
          colorLUTOrIndex: T
        }
      }
    ], Uge);
    return console.log("labelmaps rendered"), {
      segRepUIDs: I,
      renderingEngine: s,
      viewportIds: [
        c,
        f,
        u
      ],
      volumeId: l,
      segmentationVolumeArray: y
    };
  }
  function Bge() {
    const t = yt.tools;
    t.StackScrollMouseWheel || eh(Zp), t.SegmentationDisplay || eh(_h), t.Zoom || eh(Qp), t.Pan || eh(Yp);
  }
  function _ge() {
    Bge(), X2e(Gh);
    const t = RL(Gh);
    if (t) return t.addTool(Zp.toolName), t.addTool(_h.toolName), t.addTool(Qp.toolName), t.addTool(Yp.toolName), t.setToolActive(Zp.toolName), t.setToolEnabled(_h.toolName), t.setToolActive(Yp.toolName, {
      bindings: [
        {
          mouseButton: Bu.Primary
        }
      ]
    }), t.setToolActive(Qp.toolName, {
      bindings: [
        {
          mouseButton: Bu.Secondary
        }
      ]
    }), t;
  }
  let hg = null;
  function kge() {
    if (console.log("[createRenderingEngine] called"), hg) {
      try {
        hg.destroy(), console.log("\u2705 Destroyed previous renderingEngine");
      } catch (e) {
        console.warn("\u26A0\uFE0F Failed to destroy old renderingEngine:", e);
      }
      hg = null;
    }
    const t = new BI(Zg);
    return hg = t, t;
  }
  function Pge(t, e) {
    const n = t[0];
    for (let r = 1; r < e.length; r++) U1e(Gh, n, r, e[r]);
  }
  function rE(t) {
    const e = {
      ...UL
    };
    e.fillAlpha = t, e.fillAlphaInactive = t, e.outlineOpacity = t, e.outlineOpacityInactive = t;
    const n = {
      renderInactiveSegmentations: true,
      representations: {
        [Nt.Labelmap]: e
      }
    };
    lN(Gh, n);
  }
  async function Gge(t, e) {
    console.log(e);
    const n = new aW({
      sliceType: cb.RENDER
    });
    if (!t.current) return {
      nv: n,
      nvImage: null,
      cmapCopy: {
        R: [],
        G: [],
        B: [],
        I: [],
        A: []
      }
    };
    n.attachToCanvas(t.current);
    const r = await Ci.loadFromUrl({
      name: "combined_labels.nii.gz",
      url: `${ls.API_ORIGIN}/api/get-segmentations/${e}`
    }), i = await fetch(`${ls.API_ORIGIN}/api/get-label-colormap/${e}`).then((g) => g.json());
    console.log("\u2705 Raw colorLUT = ", JSON.stringify(i, null, 2));
    const a = Object.keys(i).map((g) => parseInt(g)), s = Math.max(...a), o = Array(s + 1).fill(0), l = Array(s + 1).fill(0), c = Array(s + 1).fill(0), f = Array(s + 1).fill(0), u = Array(s + 1).fill(0);
    for (const g in i) {
      const v = parseInt(g), m = i[g];
      if (!m || [
        m.R,
        m.G,
        m.B
      ].some((y) => y === void 0)) {
        console.warn(`\u2757 Invalid color for label ${v}`);
        continue;
      }
      console.log(`\u2757 label ${v}  ${m.R}`), o[v] = m.R, l[v] = m.G, c[v] = m.B, f[v] = m.A ?? 128, u[v] = v;
    }
    const h = {
      R: o,
      G: l,
      B: c,
      A: f,
      I: u
    };
    return console.log(`\u2757 RGBA ${o}  ${l} ${c}  ${f} ${u} `), r.setColormapLabel({
      R: o,
      G: l,
      B: c,
      A: f,
      I: u
    }), n.addVolume(r), r.setColormapLabel({
      R: o,
      G: l,
      B: c,
      A: f,
      I: u
    }), r.colormap = "", n.updateGLVolume(), n.drawScene(), console.log("\u2705 Niivue volume created"), {
      nv: n,
      nvImage: null,
      cmapCopy: h
    };
  }
  function zge(t, e, n, r) {
    if (!(t.volumes && e && r)) {
      console.warn("\u274C updateVisibilities skipped: volumes or checkState undefined");
      return;
    }
    const i = t.volumes[0], a = {
      R: [
        ...r.R
      ],
      G: [
        ...r.G
      ],
      B: [
        ...r.B
      ],
      A: [
        ...r.A
      ],
      I: [
        ...r.I
      ]
    };
    console.log("\u{1F527} updateVisibilities: applying visibility mask for", e), console.log("\u2757 RGBA =", a.R, a.G, a.B, a.A, a.I);
    for (let s = 1; s < e.length; s++) e[s] === false && (a.A[s] = 0, console.log(`Label ${s} -> ${e[s] ? "visible" : "hidden"}`));
    i.setColormapLabel(a), t.updateGLVolume(), t.drawScene();
  }
  function iE(t, e) {
    t.current && (t.current.style.opacity = e.toString());
  }
  function dg(t) {
    throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var Ev = {
    exports: {}
  };
  var aE;
  function Wge() {
    return aE || (aE = 1, (function(t, e) {
      (function(n) {
        t.exports = n();
      })(function() {
        return (function n(r, i, a) {
          function s(c, f) {
            if (!i[c]) {
              if (!r[c]) {
                var u = typeof dg == "function" && dg;
                if (!f && u) return u(c, true);
                if (o) return o(c, true);
                var h = new Error("Cannot find module '" + c + "'");
                throw h.code = "MODULE_NOT_FOUND", h;
              }
              var g = i[c] = {
                exports: {}
              };
              r[c][0].call(g.exports, function(v) {
                var m = r[c][1][v];
                return s(m || v);
              }, g, g.exports, n, r, i, a);
            }
            return i[c].exports;
          }
          for (var o = typeof dg == "function" && dg, l = 0; l < a.length; l++) s(a[l]);
          return s;
        })({
          1: [
            function(n, r, i) {
              var a = n("./utils"), s = n("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              i.encode = function(l) {
                for (var c, f, u, h, g, v, m, y = [], w = 0, C = l.length, T = C, S = a.getTypeOf(l) !== "string"; w < l.length; ) T = C - w, u = S ? (c = l[w++], f = w < C ? l[w++] : 0, w < C ? l[w++] : 0) : (c = l.charCodeAt(w++), f = w < C ? l.charCodeAt(w++) : 0, w < C ? l.charCodeAt(w++) : 0), h = c >> 2, g = (3 & c) << 4 | f >> 4, v = 1 < T ? (15 & f) << 2 | u >> 6 : 64, m = 2 < T ? 63 & u : 64, y.push(o.charAt(h) + o.charAt(g) + o.charAt(v) + o.charAt(m));
                return y.join("");
              }, i.decode = function(l) {
                var c, f, u, h, g, v, m = 0, y = 0, w = "data:";
                if (l.substr(0, w.length) === w) throw new Error("Invalid base64 input, it looks like a data url.");
                var C, T = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
                if (l.charAt(l.length - 1) === o.charAt(64) && T--, l.charAt(l.length - 2) === o.charAt(64) && T--, T % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
                for (C = s.uint8array ? new Uint8Array(0 | T) : new Array(0 | T); m < l.length; ) c = o.indexOf(l.charAt(m++)) << 2 | (h = o.indexOf(l.charAt(m++))) >> 4, f = (15 & h) << 4 | (g = o.indexOf(l.charAt(m++))) >> 2, u = (3 & g) << 6 | (v = o.indexOf(l.charAt(m++))), C[y++] = c, g !== 64 && (C[y++] = f), v !== 64 && (C[y++] = u);
                return C;
              };
            },
            {
              "./support": 30,
              "./utils": 32
            }
          ],
          2: [
            function(n, r, i) {
              var a = n("./external"), s = n("./stream/DataWorker"), o = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
              function c(f, u, h, g, v) {
                this.compressedSize = f, this.uncompressedSize = u, this.crc32 = h, this.compression = g, this.compressedContent = v;
              }
              c.prototype = {
                getContentWorker: function() {
                  var f = new s(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), u = this;
                  return f.on("end", function() {
                    if (this.streamInfo.data_length !== u.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
                  }), f;
                },
                getCompressedWorker: function() {
                  return new s(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                }
              }, c.createWorkerFrom = function(f, u, h) {
                return f.pipe(new o()).pipe(new l("uncompressedSize")).pipe(u.compressWorker(h)).pipe(new l("compressedSize")).withStreamInfo("compression", u);
              }, r.exports = c;
            },
            {
              "./external": 6,
              "./stream/Crc32Probe": 25,
              "./stream/DataLengthProbe": 26,
              "./stream/DataWorker": 27
            }
          ],
          3: [
            function(n, r, i) {
              var a = n("./stream/GenericWorker");
              i.STORE = {
                magic: "\0\0",
                compressWorker: function() {
                  return new a("STORE compression");
                },
                uncompressWorker: function() {
                  return new a("STORE decompression");
                }
              }, i.DEFLATE = n("./flate");
            },
            {
              "./flate": 7,
              "./stream/GenericWorker": 28
            }
          ],
          4: [
            function(n, r, i) {
              var a = n("./utils"), s = (function() {
                for (var o, l = [], c = 0; c < 256; c++) {
                  o = c;
                  for (var f = 0; f < 8; f++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
                  l[c] = o;
                }
                return l;
              })();
              r.exports = function(o, l) {
                return o !== void 0 && o.length ? a.getTypeOf(o) !== "string" ? (function(c, f, u, h) {
                  var g = s, v = h + u;
                  c ^= -1;
                  for (var m = h; m < v; m++) c = c >>> 8 ^ g[255 & (c ^ f[m])];
                  return -1 ^ c;
                })(0 | l, o, o.length, 0) : (function(c, f, u, h) {
                  var g = s, v = h + u;
                  c ^= -1;
                  for (var m = h; m < v; m++) c = c >>> 8 ^ g[255 & (c ^ f.charCodeAt(m))];
                  return -1 ^ c;
                })(0 | l, o, o.length, 0) : 0;
              };
            },
            {
              "./utils": 32
            }
          ],
          5: [
            function(n, r, i) {
              i.base64 = false, i.binary = false, i.dir = false, i.createFolders = true, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
            },
            {}
          ],
          6: [
            function(n, r, i) {
              var a = null;
              a = typeof Promise < "u" ? Promise : n("lie"), r.exports = {
                Promise: a
              };
            },
            {
              lie: 37
            }
          ],
          7: [
            function(n, r, i) {
              var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", s = n("pako"), o = n("./utils"), l = n("./stream/GenericWorker"), c = a ? "uint8array" : "array";
              function f(u, h) {
                l.call(this, "FlateWorker/" + u), this._pako = null, this._pakoAction = u, this._pakoOptions = h, this.meta = {};
              }
              i.magic = "\b\0", o.inherits(f, l), f.prototype.processChunk = function(u) {
                this.meta = u.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(c, u.data), false);
              }, f.prototype.flush = function() {
                l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
              }, f.prototype.cleanUp = function() {
                l.prototype.cleanUp.call(this), this._pako = null;
              }, f.prototype._createPako = function() {
                this._pako = new s[this._pakoAction]({
                  raw: true,
                  level: this._pakoOptions.level || -1
                });
                var u = this;
                this._pako.onData = function(h) {
                  u.push({
                    data: h,
                    meta: u.meta
                  });
                };
              }, i.compressWorker = function(u) {
                return new f("Deflate", u);
              }, i.uncompressWorker = function() {
                return new f("Inflate", {});
              };
            },
            {
              "./stream/GenericWorker": 28,
              "./utils": 32,
              pako: 38
            }
          ],
          8: [
            function(n, r, i) {
              function a(g, v) {
                var m, y = "";
                for (m = 0; m < v; m++) y += String.fromCharCode(255 & g), g >>>= 8;
                return y;
              }
              function s(g, v, m, y, w, C) {
                var T, S, E = g.file, b = g.compression, D = C !== c.utf8encode, R = o.transformTo("string", C(E.name)), I = o.transformTo("string", c.utf8encode(E.name)), O = E.comment, L = o.transformTo("string", C(O)), N = o.transformTo("string", c.utf8encode(O)), F = I.length !== E.name.length, V = N.length !== O.length, k = "", _ = "", K = "", Z = E.dir, j = E.date, B = {
                  crc32: 0,
                  compressedSize: 0,
                  uncompressedSize: 0
                };
                v && !m || (B.crc32 = g.crc32, B.compressedSize = g.compressedSize, B.uncompressedSize = g.uncompressedSize);
                var Y = 0;
                v && (Y |= 8), D || !F && !V || (Y |= 2048);
                var X = 0, ie = 0;
                Z && (X |= 16), w === "UNIX" ? (ie = 798, X |= (function(he, Le) {
                  var Je = he;
                  return he || (Je = Le ? 16893 : 33204), (65535 & Je) << 16;
                })(E.unixPermissions, Z)) : (ie = 20, X |= (function(he) {
                  return 63 & (he || 0);
                })(E.dosPermissions)), T = j.getUTCHours(), T <<= 6, T |= j.getUTCMinutes(), T <<= 5, T |= j.getUTCSeconds() / 2, S = j.getUTCFullYear() - 1980, S <<= 4, S |= j.getUTCMonth() + 1, S <<= 5, S |= j.getUTCDate(), F && (_ = a(1, 1) + a(f(R), 4) + I, k += "up" + a(_.length, 2) + _), V && (K = a(1, 1) + a(f(L), 4) + N, k += "uc" + a(K.length, 2) + K);
                var oe = "";
                return oe += `
\0`, oe += a(Y, 2), oe += b.magic, oe += a(T, 2), oe += a(S, 2), oe += a(B.crc32, 4), oe += a(B.compressedSize, 4), oe += a(B.uncompressedSize, 4), oe += a(R.length, 2), oe += a(k.length, 2), {
                  fileRecord: u.LOCAL_FILE_HEADER + oe + R + k,
                  dirRecord: u.CENTRAL_FILE_HEADER + a(ie, 2) + oe + a(L.length, 2) + "\0\0\0\0" + a(X, 4) + a(y, 4) + R + k + L
                };
              }
              var o = n("../utils"), l = n("../stream/GenericWorker"), c = n("../utf8"), f = n("../crc32"), u = n("../signature");
              function h(g, v, m, y) {
                l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = v, this.zipPlatform = m, this.encodeFileName = y, this.streamFiles = g, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
              }
              o.inherits(h, l), h.prototype.push = function(g) {
                var v = g.meta.percent || 0, m = this.entriesCount, y = this._sources.length;
                this.accumulate ? this.contentBuffer.push(g) : (this.bytesWritten += g.data.length, l.prototype.push.call(this, {
                  data: g.data,
                  meta: {
                    currentFile: this.currentFile,
                    percent: m ? (v + 100 * (m - y - 1)) / m : 100
                  }
                }));
              }, h.prototype.openedSource = function(g) {
                this.currentSourceOffset = this.bytesWritten, this.currentFile = g.file.name;
                var v = this.streamFiles && !g.file.dir;
                if (v) {
                  var m = s(g, v, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                  this.push({
                    data: m.fileRecord,
                    meta: {
                      percent: 0
                    }
                  });
                } else this.accumulate = true;
              }, h.prototype.closedSource = function(g) {
                this.accumulate = false;
                var v = this.streamFiles && !g.file.dir, m = s(g, v, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                if (this.dirRecords.push(m.dirRecord), v) this.push({
                  data: (function(y) {
                    return u.DATA_DESCRIPTOR + a(y.crc32, 4) + a(y.compressedSize, 4) + a(y.uncompressedSize, 4);
                  })(g),
                  meta: {
                    percent: 100
                  }
                });
                else for (this.push({
                  data: m.fileRecord,
                  meta: {
                    percent: 0
                  }
                }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
                this.currentFile = null;
              }, h.prototype.flush = function() {
                for (var g = this.bytesWritten, v = 0; v < this.dirRecords.length; v++) this.push({
                  data: this.dirRecords[v],
                  meta: {
                    percent: 100
                  }
                });
                var m = this.bytesWritten - g, y = (function(w, C, T, S, E) {
                  var b = o.transformTo("string", E(S));
                  return u.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(w, 2) + a(w, 2) + a(C, 4) + a(T, 4) + a(b.length, 2) + b;
                })(this.dirRecords.length, m, g, this.zipComment, this.encodeFileName);
                this.push({
                  data: y,
                  meta: {
                    percent: 100
                  }
                });
              }, h.prototype.prepareNextSource = function() {
                this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
              }, h.prototype.registerPrevious = function(g) {
                this._sources.push(g);
                var v = this;
                return g.on("data", function(m) {
                  v.processChunk(m);
                }), g.on("end", function() {
                  v.closedSource(v.previous.streamInfo), v._sources.length ? v.prepareNextSource() : v.end();
                }), g.on("error", function(m) {
                  v.error(m);
                }), this;
              }, h.prototype.resume = function() {
                return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
              }, h.prototype.error = function(g) {
                var v = this._sources;
                if (!l.prototype.error.call(this, g)) return false;
                for (var m = 0; m < v.length; m++) try {
                  v[m].error(g);
                } catch {
                }
                return true;
              }, h.prototype.lock = function() {
                l.prototype.lock.call(this);
                for (var g = this._sources, v = 0; v < g.length; v++) g[v].lock();
              }, r.exports = h;
            },
            {
              "../crc32": 4,
              "../signature": 23,
              "../stream/GenericWorker": 28,
              "../utf8": 31,
              "../utils": 32
            }
          ],
          9: [
            function(n, r, i) {
              var a = n("../compressions"), s = n("./ZipFileWorker");
              i.generateWorker = function(o, l, c) {
                var f = new s(l.streamFiles, c, l.platform, l.encodeFileName), u = 0;
                try {
                  o.forEach(function(h, g) {
                    u++;
                    var v = (function(C, T) {
                      var S = C || T, E = a[S];
                      if (!E) throw new Error(S + " is not a valid compression method !");
                      return E;
                    })(g.options.compression, l.compression), m = g.options.compressionOptions || l.compressionOptions || {}, y = g.dir, w = g.date;
                    g._compressWorker(v, m).withStreamInfo("file", {
                      name: h,
                      dir: y,
                      date: w,
                      comment: g.comment || "",
                      unixPermissions: g.unixPermissions,
                      dosPermissions: g.dosPermissions
                    }).pipe(f);
                  }), f.entriesCount = u;
                } catch (h) {
                  f.error(h);
                }
                return f;
              };
            },
            {
              "../compressions": 3,
              "./ZipFileWorker": 8
            }
          ],
          10: [
            function(n, r, i) {
              function a() {
                if (!(this instanceof a)) return new a();
                if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                  var s = new a();
                  for (var o in this) typeof this[o] != "function" && (s[o] = this[o]);
                  return s;
                };
              }
              (a.prototype = n("./object")).loadAsync = n("./load"), a.support = n("./support"), a.defaults = n("./defaults"), a.version = "3.10.1", a.loadAsync = function(s, o) {
                return new a().loadAsync(s, o);
              }, a.external = n("./external"), r.exports = a;
            },
            {
              "./defaults": 5,
              "./external": 6,
              "./load": 11,
              "./object": 15,
              "./support": 30
            }
          ],
          11: [
            function(n, r, i) {
              var a = n("./utils"), s = n("./external"), o = n("./utf8"), l = n("./zipEntries"), c = n("./stream/Crc32Probe"), f = n("./nodejsUtils");
              function u(h) {
                return new s.Promise(function(g, v) {
                  var m = h.decompressed.getContentWorker().pipe(new c());
                  m.on("error", function(y) {
                    v(y);
                  }).on("end", function() {
                    m.streamInfo.crc32 !== h.decompressed.crc32 ? v(new Error("Corrupted zip : CRC32 mismatch")) : g();
                  }).resume();
                });
              }
              r.exports = function(h, g) {
                var v = this;
                return g = a.extend(g || {}, {
                  base64: false,
                  checkCRC32: false,
                  optimizedBinaryString: false,
                  createFolders: false,
                  decodeFileName: o.utf8decode
                }), f.isNode && f.isStream(h) ? s.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", h, true, g.optimizedBinaryString, g.base64).then(function(m) {
                  var y = new l(g);
                  return y.load(m), y;
                }).then(function(m) {
                  var y = [
                    s.Promise.resolve(m)
                  ], w = m.files;
                  if (g.checkCRC32) for (var C = 0; C < w.length; C++) y.push(u(w[C]));
                  return s.Promise.all(y);
                }).then(function(m) {
                  for (var y = m.shift(), w = y.files, C = 0; C < w.length; C++) {
                    var T = w[C], S = T.fileNameStr, E = a.resolve(T.fileNameStr);
                    v.file(E, T.decompressed, {
                      binary: true,
                      optimizedBinaryString: true,
                      date: T.date,
                      dir: T.dir,
                      comment: T.fileCommentStr.length ? T.fileCommentStr : null,
                      unixPermissions: T.unixPermissions,
                      dosPermissions: T.dosPermissions,
                      createFolders: g.createFolders
                    }), T.dir || (v.file(E).unsafeOriginalName = S);
                  }
                  return y.zipComment.length && (v.comment = y.zipComment), v;
                });
              };
            },
            {
              "./external": 6,
              "./nodejsUtils": 14,
              "./stream/Crc32Probe": 25,
              "./utf8": 31,
              "./utils": 32,
              "./zipEntries": 33
            }
          ],
          12: [
            function(n, r, i) {
              var a = n("../utils"), s = n("../stream/GenericWorker");
              function o(l, c) {
                s.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = false, this._bindStream(c);
              }
              a.inherits(o, s), o.prototype._bindStream = function(l) {
                var c = this;
                (this._stream = l).pause(), l.on("data", function(f) {
                  c.push({
                    data: f,
                    meta: {
                      percent: 0
                    }
                  });
                }).on("error", function(f) {
                  c.isPaused ? this.generatedError = f : c.error(f);
                }).on("end", function() {
                  c.isPaused ? c._upstreamEnded = true : c.end();
                });
              }, o.prototype.pause = function() {
                return !!s.prototype.pause.call(this) && (this._stream.pause(), true);
              }, o.prototype.resume = function() {
                return !!s.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
              }, r.exports = o;
            },
            {
              "../stream/GenericWorker": 28,
              "../utils": 32
            }
          ],
          13: [
            function(n, r, i) {
              var a = n("readable-stream").Readable;
              function s(o, l, c) {
                a.call(this, l), this._helper = o;
                var f = this;
                o.on("data", function(u, h) {
                  f.push(u) || f._helper.pause(), c && c(h);
                }).on("error", function(u) {
                  f.emit("error", u);
                }).on("end", function() {
                  f.push(null);
                });
              }
              n("../utils").inherits(s, a), s.prototype._read = function() {
                this._helper.resume();
              }, r.exports = s;
            },
            {
              "../utils": 32,
              "readable-stream": 16
            }
          ],
          14: [
            function(n, r, i) {
              r.exports = {
                isNode: typeof Buffer < "u",
                newBufferFrom: function(a, s) {
                  if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, s);
                  if (typeof a == "number") throw new Error('The "data" argument must not be a number');
                  return new Buffer(a, s);
                },
                allocBuffer: function(a) {
                  if (Buffer.alloc) return Buffer.alloc(a);
                  var s = new Buffer(a);
                  return s.fill(0), s;
                },
                isBuffer: function(a) {
                  return Buffer.isBuffer(a);
                },
                isStream: function(a) {
                  return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
                }
              };
            },
            {}
          ],
          15: [
            function(n, r, i) {
              function a(E, b, D) {
                var R, I = o.getTypeOf(b), O = o.extend(D || {}, f);
                O.date = O.date || /* @__PURE__ */ new Date(), O.compression !== null && (O.compression = O.compression.toUpperCase()), typeof O.unixPermissions == "string" && (O.unixPermissions = parseInt(O.unixPermissions, 8)), O.unixPermissions && 16384 & O.unixPermissions && (O.dir = true), O.dosPermissions && 16 & O.dosPermissions && (O.dir = true), O.dir && (E = w(E)), O.createFolders && (R = y(E)) && C.call(this, R, true);
                var L = I === "string" && O.binary === false && O.base64 === false;
                D && D.binary !== void 0 || (O.binary = !L), (b instanceof u && b.uncompressedSize === 0 || O.dir || !b || b.length === 0) && (O.base64 = false, O.binary = true, b = "", O.compression = "STORE", I = "string");
                var N = null;
                N = b instanceof u || b instanceof l ? b : v.isNode && v.isStream(b) ? new m(E, b) : o.prepareContent(E, b, O.binary, O.optimizedBinaryString, O.base64);
                var F = new h(E, N, O);
                this.files[E] = F;
              }
              var s = n("./utf8"), o = n("./utils"), l = n("./stream/GenericWorker"), c = n("./stream/StreamHelper"), f = n("./defaults"), u = n("./compressedObject"), h = n("./zipObject"), g = n("./generate"), v = n("./nodejsUtils"), m = n("./nodejs/NodejsStreamInputAdapter"), y = function(E) {
                E.slice(-1) === "/" && (E = E.substring(0, E.length - 1));
                var b = E.lastIndexOf("/");
                return 0 < b ? E.substring(0, b) : "";
              }, w = function(E) {
                return E.slice(-1) !== "/" && (E += "/"), E;
              }, C = function(E, b) {
                return b = b !== void 0 ? b : f.createFolders, E = w(E), this.files[E] || a.call(this, E, null, {
                  dir: true,
                  createFolders: b
                }), this.files[E];
              };
              function T(E) {
                return Object.prototype.toString.call(E) === "[object RegExp]";
              }
              var S = {
                load: function() {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                },
                forEach: function(E) {
                  var b, D, R;
                  for (b in this.files) R = this.files[b], (D = b.slice(this.root.length, b.length)) && b.slice(0, this.root.length) === this.root && E(D, R);
                },
                filter: function(E) {
                  var b = [];
                  return this.forEach(function(D, R) {
                    E(D, R) && b.push(R);
                  }), b;
                },
                file: function(E, b, D) {
                  if (arguments.length !== 1) return E = this.root + E, a.call(this, E, b, D), this;
                  if (T(E)) {
                    var R = E;
                    return this.filter(function(O, L) {
                      return !L.dir && R.test(O);
                    });
                  }
                  var I = this.files[this.root + E];
                  return I && !I.dir ? I : null;
                },
                folder: function(E) {
                  if (!E) return this;
                  if (T(E)) return this.filter(function(I, O) {
                    return O.dir && E.test(I);
                  });
                  var b = this.root + E, D = C.call(this, b), R = this.clone();
                  return R.root = D.name, R;
                },
                remove: function(E) {
                  E = this.root + E;
                  var b = this.files[E];
                  if (b || (E.slice(-1) !== "/" && (E += "/"), b = this.files[E]), b && !b.dir) delete this.files[E];
                  else for (var D = this.filter(function(I, O) {
                    return O.name.slice(0, E.length) === E;
                  }), R = 0; R < D.length; R++) delete this.files[D[R].name];
                  return this;
                },
                generate: function() {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                },
                generateInternalStream: function(E) {
                  var b, D = {};
                  try {
                    if ((D = o.extend(E || {}, {
                      streamFiles: false,
                      compression: "STORE",
                      compressionOptions: null,
                      type: "",
                      platform: "DOS",
                      comment: null,
                      mimeType: "application/zip",
                      encodeFileName: s.utf8encode
                    })).type = D.type.toLowerCase(), D.compression = D.compression.toUpperCase(), D.type === "binarystring" && (D.type = "string"), !D.type) throw new Error("No output type specified.");
                    o.checkSupport(D.type), D.platform !== "darwin" && D.platform !== "freebsd" && D.platform !== "linux" && D.platform !== "sunos" || (D.platform = "UNIX"), D.platform === "win32" && (D.platform = "DOS");
                    var R = D.comment || this.comment || "";
                    b = g.generateWorker(this, D, R);
                  } catch (I) {
                    (b = new l("error")).error(I);
                  }
                  return new c(b, D.type || "string", D.mimeType);
                },
                generateAsync: function(E, b) {
                  return this.generateInternalStream(E).accumulate(b);
                },
                generateNodeStream: function(E, b) {
                  return (E = E || {}).type || (E.type = "nodebuffer"), this.generateInternalStream(E).toNodejsStream(b);
                }
              };
              r.exports = S;
            },
            {
              "./compressedObject": 2,
              "./defaults": 5,
              "./generate": 9,
              "./nodejs/NodejsStreamInputAdapter": 12,
              "./nodejsUtils": 14,
              "./stream/GenericWorker": 28,
              "./stream/StreamHelper": 29,
              "./utf8": 31,
              "./utils": 32,
              "./zipObject": 35
            }
          ],
          16: [
            function(n, r, i) {
              r.exports = n("stream");
            },
            {
              stream: void 0
            }
          ],
          17: [
            function(n, r, i) {
              var a = n("./DataReader");
              function s(o) {
                a.call(this, o);
                for (var l = 0; l < this.data.length; l++) o[l] = 255 & o[l];
              }
              n("../utils").inherits(s, a), s.prototype.byteAt = function(o) {
                return this.data[this.zero + o];
              }, s.prototype.lastIndexOfSignature = function(o) {
                for (var l = o.charCodeAt(0), c = o.charCodeAt(1), f = o.charCodeAt(2), u = o.charCodeAt(3), h = this.length - 4; 0 <= h; --h) if (this.data[h] === l && this.data[h + 1] === c && this.data[h + 2] === f && this.data[h + 3] === u) return h - this.zero;
                return -1;
              }, s.prototype.readAndCheckSignature = function(o) {
                var l = o.charCodeAt(0), c = o.charCodeAt(1), f = o.charCodeAt(2), u = o.charCodeAt(3), h = this.readData(4);
                return l === h[0] && c === h[1] && f === h[2] && u === h[3];
              }, s.prototype.readData = function(o) {
                if (this.checkOffset(o), o === 0) return [];
                var l = this.data.slice(this.zero + this.index, this.zero + this.index + o);
                return this.index += o, l;
              }, r.exports = s;
            },
            {
              "../utils": 32,
              "./DataReader": 18
            }
          ],
          18: [
            function(n, r, i) {
              var a = n("../utils");
              function s(o) {
                this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
              }
              s.prototype = {
                checkOffset: function(o) {
                  this.checkIndex(this.index + o);
                },
                checkIndex: function(o) {
                  if (this.length < this.zero + o || o < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
                },
                setIndex: function(o) {
                  this.checkIndex(o), this.index = o;
                },
                skip: function(o) {
                  this.setIndex(this.index + o);
                },
                byteAt: function() {
                },
                readInt: function(o) {
                  var l, c = 0;
                  for (this.checkOffset(o), l = this.index + o - 1; l >= this.index; l--) c = (c << 8) + this.byteAt(l);
                  return this.index += o, c;
                },
                readString: function(o) {
                  return a.transformTo("string", this.readData(o));
                },
                readData: function() {
                },
                lastIndexOfSignature: function() {
                },
                readAndCheckSignature: function() {
                },
                readDate: function() {
                  var o = this.readInt(4);
                  return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
                }
              }, r.exports = s;
            },
            {
              "../utils": 32
            }
          ],
          19: [
            function(n, r, i) {
              var a = n("./Uint8ArrayReader");
              function s(o) {
                a.call(this, o);
              }
              n("../utils").inherits(s, a), s.prototype.readData = function(o) {
                this.checkOffset(o);
                var l = this.data.slice(this.zero + this.index, this.zero + this.index + o);
                return this.index += o, l;
              }, r.exports = s;
            },
            {
              "../utils": 32,
              "./Uint8ArrayReader": 21
            }
          ],
          20: [
            function(n, r, i) {
              var a = n("./DataReader");
              function s(o) {
                a.call(this, o);
              }
              n("../utils").inherits(s, a), s.prototype.byteAt = function(o) {
                return this.data.charCodeAt(this.zero + o);
              }, s.prototype.lastIndexOfSignature = function(o) {
                return this.data.lastIndexOf(o) - this.zero;
              }, s.prototype.readAndCheckSignature = function(o) {
                return o === this.readData(4);
              }, s.prototype.readData = function(o) {
                this.checkOffset(o);
                var l = this.data.slice(this.zero + this.index, this.zero + this.index + o);
                return this.index += o, l;
              }, r.exports = s;
            },
            {
              "../utils": 32,
              "./DataReader": 18
            }
          ],
          21: [
            function(n, r, i) {
              var a = n("./ArrayReader");
              function s(o) {
                a.call(this, o);
              }
              n("../utils").inherits(s, a), s.prototype.readData = function(o) {
                if (this.checkOffset(o), o === 0) return new Uint8Array(0);
                var l = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
                return this.index += o, l;
              }, r.exports = s;
            },
            {
              "../utils": 32,
              "./ArrayReader": 17
            }
          ],
          22: [
            function(n, r, i) {
              var a = n("../utils"), s = n("../support"), o = n("./ArrayReader"), l = n("./StringReader"), c = n("./NodeBufferReader"), f = n("./Uint8ArrayReader");
              r.exports = function(u) {
                var h = a.getTypeOf(u);
                return a.checkSupport(h), h !== "string" || s.uint8array ? h === "nodebuffer" ? new c(u) : s.uint8array ? new f(a.transformTo("uint8array", u)) : new o(a.transformTo("array", u)) : new l(u);
              };
            },
            {
              "../support": 30,
              "../utils": 32,
              "./ArrayReader": 17,
              "./NodeBufferReader": 19,
              "./StringReader": 20,
              "./Uint8ArrayReader": 21
            }
          ],
          23: [
            function(n, r, i) {
              i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
            },
            {}
          ],
          24: [
            function(n, r, i) {
              var a = n("./GenericWorker"), s = n("../utils");
              function o(l) {
                a.call(this, "ConvertWorker to " + l), this.destType = l;
              }
              s.inherits(o, a), o.prototype.processChunk = function(l) {
                this.push({
                  data: s.transformTo(this.destType, l.data),
                  meta: l.meta
                });
              }, r.exports = o;
            },
            {
              "../utils": 32,
              "./GenericWorker": 28
            }
          ],
          25: [
            function(n, r, i) {
              var a = n("./GenericWorker"), s = n("../crc32");
              function o() {
                a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
              }
              n("../utils").inherits(o, a), o.prototype.processChunk = function(l) {
                this.streamInfo.crc32 = s(l.data, this.streamInfo.crc32 || 0), this.push(l);
              }, r.exports = o;
            },
            {
              "../crc32": 4,
              "../utils": 32,
              "./GenericWorker": 28
            }
          ],
          26: [
            function(n, r, i) {
              var a = n("../utils"), s = n("./GenericWorker");
              function o(l) {
                s.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
              }
              a.inherits(o, s), o.prototype.processChunk = function(l) {
                if (l) {
                  var c = this.streamInfo[this.propName] || 0;
                  this.streamInfo[this.propName] = c + l.data.length;
                }
                s.prototype.processChunk.call(this, l);
              }, r.exports = o;
            },
            {
              "../utils": 32,
              "./GenericWorker": 28
            }
          ],
          27: [
            function(n, r, i) {
              var a = n("../utils"), s = n("./GenericWorker");
              function o(l) {
                s.call(this, "DataWorker");
                var c = this;
                this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, l.then(function(f) {
                  c.dataIsReady = true, c.data = f, c.max = f && f.length || 0, c.type = a.getTypeOf(f), c.isPaused || c._tickAndRepeat();
                }, function(f) {
                  c.error(f);
                });
              }
              a.inherits(o, s), o.prototype.cleanUp = function() {
                s.prototype.cleanUp.call(this), this.data = null;
              }, o.prototype.resume = function() {
                return !!s.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, a.delay(this._tickAndRepeat, [], this)), true);
              }, o.prototype._tickAndRepeat = function() {
                this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
              }, o.prototype._tick = function() {
                if (this.isPaused || this.isFinished) return false;
                var l = null, c = Math.min(this.max, this.index + 16384);
                if (this.index >= this.max) return this.end();
                switch (this.type) {
                  case "string":
                    l = this.data.substring(this.index, c);
                    break;
                  case "uint8array":
                    l = this.data.subarray(this.index, c);
                    break;
                  case "array":
                  case "nodebuffer":
                    l = this.data.slice(this.index, c);
                }
                return this.index = c, this.push({
                  data: l,
                  meta: {
                    percent: this.max ? this.index / this.max * 100 : 0
                  }
                });
              }, r.exports = o;
            },
            {
              "../utils": 32,
              "./GenericWorker": 28
            }
          ],
          28: [
            function(n, r, i) {
              function a(s) {
                this.name = s || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = {
                  data: [],
                  end: [],
                  error: []
                }, this.previous = null;
              }
              a.prototype = {
                push: function(s) {
                  this.emit("data", s);
                },
                end: function() {
                  if (this.isFinished) return false;
                  this.flush();
                  try {
                    this.emit("end"), this.cleanUp(), this.isFinished = true;
                  } catch (s) {
                    this.emit("error", s);
                  }
                  return true;
                },
                error: function(s) {
                  return !this.isFinished && (this.isPaused ? this.generatedError = s : (this.isFinished = true, this.emit("error", s), this.previous && this.previous.error(s), this.cleanUp()), true);
                },
                on: function(s, o) {
                  return this._listeners[s].push(o), this;
                },
                cleanUp: function() {
                  this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                },
                emit: function(s, o) {
                  if (this._listeners[s]) for (var l = 0; l < this._listeners[s].length; l++) this._listeners[s][l].call(this, o);
                },
                pipe: function(s) {
                  return s.registerPrevious(this);
                },
                registerPrevious: function(s) {
                  if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                  this.streamInfo = s.streamInfo, this.mergeStreamInfo(), this.previous = s;
                  var o = this;
                  return s.on("data", function(l) {
                    o.processChunk(l);
                  }), s.on("end", function() {
                    o.end();
                  }), s.on("error", function(l) {
                    o.error(l);
                  }), this;
                },
                pause: function() {
                  return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
                },
                resume: function() {
                  if (!this.isPaused || this.isFinished) return false;
                  var s = this.isPaused = false;
                  return this.generatedError && (this.error(this.generatedError), s = true), this.previous && this.previous.resume(), !s;
                },
                flush: function() {
                },
                processChunk: function(s) {
                  this.push(s);
                },
                withStreamInfo: function(s, o) {
                  return this.extraStreamInfo[s] = o, this.mergeStreamInfo(), this;
                },
                mergeStreamInfo: function() {
                  for (var s in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, s) && (this.streamInfo[s] = this.extraStreamInfo[s]);
                },
                lock: function() {
                  if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                  this.isLocked = true, this.previous && this.previous.lock();
                },
                toString: function() {
                  var s = "Worker " + this.name;
                  return this.previous ? this.previous + " -> " + s : s;
                }
              }, r.exports = a;
            },
            {}
          ],
          29: [
            function(n, r, i) {
              var a = n("../utils"), s = n("./ConvertWorker"), o = n("./GenericWorker"), l = n("../base64"), c = n("../support"), f = n("../external"), u = null;
              if (c.nodestream) try {
                u = n("../nodejs/NodejsStreamOutputAdapter");
              } catch {
              }
              function h(v, m) {
                return new f.Promise(function(y, w) {
                  var C = [], T = v._internalType, S = v._outputType, E = v._mimeType;
                  v.on("data", function(b, D) {
                    C.push(b), m && m(D);
                  }).on("error", function(b) {
                    C = [], w(b);
                  }).on("end", function() {
                    try {
                      var b = (function(D, R, I) {
                        switch (D) {
                          case "blob":
                            return a.newBlob(a.transformTo("arraybuffer", R), I);
                          case "base64":
                            return l.encode(R);
                          default:
                            return a.transformTo(D, R);
                        }
                      })(S, (function(D, R) {
                        var I, O = 0, L = null, N = 0;
                        for (I = 0; I < R.length; I++) N += R[I].length;
                        switch (D) {
                          case "string":
                            return R.join("");
                          case "array":
                            return Array.prototype.concat.apply([], R);
                          case "uint8array":
                            for (L = new Uint8Array(N), I = 0; I < R.length; I++) L.set(R[I], O), O += R[I].length;
                            return L;
                          case "nodebuffer":
                            return Buffer.concat(R);
                          default:
                            throw new Error("concat : unsupported type '" + D + "'");
                        }
                      })(T, C), E);
                      y(b);
                    } catch (D) {
                      w(D);
                    }
                    C = [];
                  }).resume();
                });
              }
              function g(v, m, y) {
                var w = m;
                switch (m) {
                  case "blob":
                  case "arraybuffer":
                    w = "uint8array";
                    break;
                  case "base64":
                    w = "string";
                }
                try {
                  this._internalType = w, this._outputType = m, this._mimeType = y, a.checkSupport(w), this._worker = v.pipe(new s(w)), v.lock();
                } catch (C) {
                  this._worker = new o("error"), this._worker.error(C);
                }
              }
              g.prototype = {
                accumulate: function(v) {
                  return h(this, v);
                },
                on: function(v, m) {
                  var y = this;
                  return v === "data" ? this._worker.on(v, function(w) {
                    m.call(y, w.data, w.meta);
                  }) : this._worker.on(v, function() {
                    a.delay(m, arguments, y);
                  }), this;
                },
                resume: function() {
                  return a.delay(this._worker.resume, [], this._worker), this;
                },
                pause: function() {
                  return this._worker.pause(), this;
                },
                toNodejsStream: function(v) {
                  if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
                  return new u(this, {
                    objectMode: this._outputType !== "nodebuffer"
                  }, v);
                }
              }, r.exports = g;
            },
            {
              "../base64": 1,
              "../external": 6,
              "../nodejs/NodejsStreamOutputAdapter": 13,
              "../support": 30,
              "../utils": 32,
              "./ConvertWorker": 24,
              "./GenericWorker": 28
            }
          ],
          30: [
            function(n, r, i) {
              if (i.base64 = true, i.array = true, i.string = true, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") i.blob = false;
              else {
                var a = new ArrayBuffer(0);
                try {
                  i.blob = new Blob([
                    a
                  ], {
                    type: "application/zip"
                  }).size === 0;
                } catch {
                  try {
                    var s = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                    s.append(a), i.blob = s.getBlob("application/zip").size === 0;
                  } catch {
                    i.blob = false;
                  }
                }
              }
              try {
                i.nodestream = !!n("readable-stream").Readable;
              } catch {
                i.nodestream = false;
              }
            },
            {
              "readable-stream": 16
            }
          ],
          31: [
            function(n, r, i) {
              for (var a = n("./utils"), s = n("./support"), o = n("./nodejsUtils"), l = n("./stream/GenericWorker"), c = new Array(256), f = 0; f < 256; f++) c[f] = 252 <= f ? 6 : 248 <= f ? 5 : 240 <= f ? 4 : 224 <= f ? 3 : 192 <= f ? 2 : 1;
              c[254] = c[254] = 1;
              function u() {
                l.call(this, "utf-8 decode"), this.leftOver = null;
              }
              function h() {
                l.call(this, "utf-8 encode");
              }
              i.utf8encode = function(g) {
                return s.nodebuffer ? o.newBufferFrom(g, "utf-8") : (function(v) {
                  var m, y, w, C, T, S = v.length, E = 0;
                  for (C = 0; C < S; C++) (64512 & (y = v.charCodeAt(C))) == 55296 && C + 1 < S && (64512 & (w = v.charCodeAt(C + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (w - 56320), C++), E += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
                  for (m = s.uint8array ? new Uint8Array(E) : new Array(E), C = T = 0; T < E; C++) (64512 & (y = v.charCodeAt(C))) == 55296 && C + 1 < S && (64512 & (w = v.charCodeAt(C + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (w - 56320), C++), y < 128 ? m[T++] = y : (y < 2048 ? m[T++] = 192 | y >>> 6 : (y < 65536 ? m[T++] = 224 | y >>> 12 : (m[T++] = 240 | y >>> 18, m[T++] = 128 | y >>> 12 & 63), m[T++] = 128 | y >>> 6 & 63), m[T++] = 128 | 63 & y);
                  return m;
                })(g);
              }, i.utf8decode = function(g) {
                return s.nodebuffer ? a.transformTo("nodebuffer", g).toString("utf-8") : (function(v) {
                  var m, y, w, C, T = v.length, S = new Array(2 * T);
                  for (m = y = 0; m < T; ) if ((w = v[m++]) < 128) S[y++] = w;
                  else if (4 < (C = c[w])) S[y++] = 65533, m += C - 1;
                  else {
                    for (w &= C === 2 ? 31 : C === 3 ? 15 : 7; 1 < C && m < T; ) w = w << 6 | 63 & v[m++], C--;
                    1 < C ? S[y++] = 65533 : w < 65536 ? S[y++] = w : (w -= 65536, S[y++] = 55296 | w >> 10 & 1023, S[y++] = 56320 | 1023 & w);
                  }
                  return S.length !== y && (S.subarray ? S = S.subarray(0, y) : S.length = y), a.applyFromCharCode(S);
                })(g = a.transformTo(s.uint8array ? "uint8array" : "array", g));
              }, a.inherits(u, l), u.prototype.processChunk = function(g) {
                var v = a.transformTo(s.uint8array ? "uint8array" : "array", g.data);
                if (this.leftOver && this.leftOver.length) {
                  if (s.uint8array) {
                    var m = v;
                    (v = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), v.set(m, this.leftOver.length);
                  } else v = this.leftOver.concat(v);
                  this.leftOver = null;
                }
                var y = (function(C, T) {
                  var S;
                  for ((T = T || C.length) > C.length && (T = C.length), S = T - 1; 0 <= S && (192 & C[S]) == 128; ) S--;
                  return S < 0 || S === 0 ? T : S + c[C[S]] > T ? S : T;
                })(v), w = v;
                y !== v.length && (s.uint8array ? (w = v.subarray(0, y), this.leftOver = v.subarray(y, v.length)) : (w = v.slice(0, y), this.leftOver = v.slice(y, v.length))), this.push({
                  data: i.utf8decode(w),
                  meta: g.meta
                });
              }, u.prototype.flush = function() {
                this.leftOver && this.leftOver.length && (this.push({
                  data: i.utf8decode(this.leftOver),
                  meta: {}
                }), this.leftOver = null);
              }, i.Utf8DecodeWorker = u, a.inherits(h, l), h.prototype.processChunk = function(g) {
                this.push({
                  data: i.utf8encode(g.data),
                  meta: g.meta
                });
              }, i.Utf8EncodeWorker = h;
            },
            {
              "./nodejsUtils": 14,
              "./stream/GenericWorker": 28,
              "./support": 30,
              "./utils": 32
            }
          ],
          32: [
            function(n, r, i) {
              var a = n("./support"), s = n("./base64"), o = n("./nodejsUtils"), l = n("./external");
              function c(m) {
                return m;
              }
              function f(m, y) {
                for (var w = 0; w < m.length; ++w) y[w] = 255 & m.charCodeAt(w);
                return y;
              }
              n("setimmediate"), i.newBlob = function(m, y) {
                i.checkSupport("blob");
                try {
                  return new Blob([
                    m
                  ], {
                    type: y
                  });
                } catch {
                  try {
                    var w = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                    return w.append(m), w.getBlob(y);
                  } catch {
                    throw new Error("Bug : can't construct the Blob.");
                  }
                }
              };
              var u = {
                stringifyByChunk: function(m, y, w) {
                  var C = [], T = 0, S = m.length;
                  if (S <= w) return String.fromCharCode.apply(null, m);
                  for (; T < S; ) y === "array" || y === "nodebuffer" ? C.push(String.fromCharCode.apply(null, m.slice(T, Math.min(T + w, S)))) : C.push(String.fromCharCode.apply(null, m.subarray(T, Math.min(T + w, S)))), T += w;
                  return C.join("");
                },
                stringifyByChar: function(m) {
                  for (var y = "", w = 0; w < m.length; w++) y += String.fromCharCode(m[w]);
                  return y;
                },
                applyCanBeUsed: {
                  uint8array: (function() {
                    try {
                      return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                    } catch {
                      return false;
                    }
                  })(),
                  nodebuffer: (function() {
                    try {
                      return a.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
                    } catch {
                      return false;
                    }
                  })()
                }
              };
              function h(m) {
                var y = 65536, w = i.getTypeOf(m), C = true;
                if (w === "uint8array" ? C = u.applyCanBeUsed.uint8array : w === "nodebuffer" && (C = u.applyCanBeUsed.nodebuffer), C) for (; 1 < y; ) try {
                  return u.stringifyByChunk(m, w, y);
                } catch {
                  y = Math.floor(y / 2);
                }
                return u.stringifyByChar(m);
              }
              function g(m, y) {
                for (var w = 0; w < m.length; w++) y[w] = m[w];
                return y;
              }
              i.applyFromCharCode = h;
              var v = {};
              v.string = {
                string: c,
                array: function(m) {
                  return f(m, new Array(m.length));
                },
                arraybuffer: function(m) {
                  return v.string.uint8array(m).buffer;
                },
                uint8array: function(m) {
                  return f(m, new Uint8Array(m.length));
                },
                nodebuffer: function(m) {
                  return f(m, o.allocBuffer(m.length));
                }
              }, v.array = {
                string: h,
                array: c,
                arraybuffer: function(m) {
                  return new Uint8Array(m).buffer;
                },
                uint8array: function(m) {
                  return new Uint8Array(m);
                },
                nodebuffer: function(m) {
                  return o.newBufferFrom(m);
                }
              }, v.arraybuffer = {
                string: function(m) {
                  return h(new Uint8Array(m));
                },
                array: function(m) {
                  return g(new Uint8Array(m), new Array(m.byteLength));
                },
                arraybuffer: c,
                uint8array: function(m) {
                  return new Uint8Array(m);
                },
                nodebuffer: function(m) {
                  return o.newBufferFrom(new Uint8Array(m));
                }
              }, v.uint8array = {
                string: h,
                array: function(m) {
                  return g(m, new Array(m.length));
                },
                arraybuffer: function(m) {
                  return m.buffer;
                },
                uint8array: c,
                nodebuffer: function(m) {
                  return o.newBufferFrom(m);
                }
              }, v.nodebuffer = {
                string: h,
                array: function(m) {
                  return g(m, new Array(m.length));
                },
                arraybuffer: function(m) {
                  return v.nodebuffer.uint8array(m).buffer;
                },
                uint8array: function(m) {
                  return g(m, new Uint8Array(m.length));
                },
                nodebuffer: c
              }, i.transformTo = function(m, y) {
                if (y = y || "", !m) return y;
                i.checkSupport(m);
                var w = i.getTypeOf(y);
                return v[w][m](y);
              }, i.resolve = function(m) {
                for (var y = m.split("/"), w = [], C = 0; C < y.length; C++) {
                  var T = y[C];
                  T === "." || T === "" && C !== 0 && C !== y.length - 1 || (T === ".." ? w.pop() : w.push(T));
                }
                return w.join("/");
              }, i.getTypeOf = function(m) {
                return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : a.nodebuffer && o.isBuffer(m) ? "nodebuffer" : a.uint8array && m instanceof Uint8Array ? "uint8array" : a.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
              }, i.checkSupport = function(m) {
                if (!a[m.toLowerCase()]) throw new Error(m + " is not supported by this platform");
              }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(m) {
                var y, w, C = "";
                for (w = 0; w < (m || "").length; w++) C += "\\x" + ((y = m.charCodeAt(w)) < 16 ? "0" : "") + y.toString(16).toUpperCase();
                return C;
              }, i.delay = function(m, y, w) {
                setImmediate(function() {
                  m.apply(w || null, y || []);
                });
              }, i.inherits = function(m, y) {
                function w() {
                }
                w.prototype = y.prototype, m.prototype = new w();
              }, i.extend = function() {
                var m, y, w = {};
                for (m = 0; m < arguments.length; m++) for (y in arguments[m]) Object.prototype.hasOwnProperty.call(arguments[m], y) && w[y] === void 0 && (w[y] = arguments[m][y]);
                return w;
              }, i.prepareContent = function(m, y, w, C, T) {
                return l.Promise.resolve(y).then(function(S) {
                  return a.blob && (S instanceof Blob || [
                    "[object File]",
                    "[object Blob]"
                  ].indexOf(Object.prototype.toString.call(S)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(E, b) {
                    var D = new FileReader();
                    D.onload = function(R) {
                      E(R.target.result);
                    }, D.onerror = function(R) {
                      b(R.target.error);
                    }, D.readAsArrayBuffer(S);
                  }) : S;
                }).then(function(S) {
                  var E = i.getTypeOf(S);
                  return E ? (E === "arraybuffer" ? S = i.transformTo("uint8array", S) : E === "string" && (T ? S = s.decode(S) : w && C !== true && (S = (function(b) {
                    return f(b, a.uint8array ? new Uint8Array(b.length) : new Array(b.length));
                  })(S))), S) : l.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                });
              };
            },
            {
              "./base64": 1,
              "./external": 6,
              "./nodejsUtils": 14,
              "./support": 30,
              setimmediate: 54
            }
          ],
          33: [
            function(n, r, i) {
              var a = n("./reader/readerFor"), s = n("./utils"), o = n("./signature"), l = n("./zipEntry"), c = n("./support");
              function f(u) {
                this.files = [], this.loadOptions = u;
              }
              f.prototype = {
                checkSignature: function(u) {
                  if (!this.reader.readAndCheckSignature(u)) {
                    this.reader.index -= 4;
                    var h = this.reader.readString(4);
                    throw new Error("Corrupted zip or bug: unexpected signature (" + s.pretty(h) + ", expected " + s.pretty(u) + ")");
                  }
                },
                isSignature: function(u, h) {
                  var g = this.reader.index;
                  this.reader.setIndex(u);
                  var v = this.reader.readString(4) === h;
                  return this.reader.setIndex(g), v;
                },
                readBlockEndOfCentral: function() {
                  this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                  var u = this.reader.readData(this.zipCommentLength), h = c.uint8array ? "uint8array" : "array", g = s.transformTo(h, u);
                  this.zipComment = this.loadOptions.decodeFileName(g);
                },
                readBlockZip64EndOfCentral: function() {
                  this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                  for (var u, h, g, v = this.zip64EndOfCentralSize - 44; 0 < v; ) u = this.reader.readInt(2), h = this.reader.readInt(4), g = this.reader.readData(h), this.zip64ExtensibleData[u] = {
                    id: u,
                    length: h,
                    value: g
                  };
                },
                readBlockZip64EndOfCentralLocator: function() {
                  if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
                },
                readLocalFiles: function() {
                  var u, h;
                  for (u = 0; u < this.files.length; u++) h = this.files[u], this.reader.setIndex(h.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), h.readLocalPart(this.reader), h.handleUTF8(), h.processAttributes();
                },
                readCentralDir: function() {
                  var u;
                  for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); ) (u = new l({
                    zip64: this.zip64
                  }, this.loadOptions)).readCentralPart(this.reader), this.files.push(u);
                  if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                },
                readEndOfCentral: function() {
                  var u = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
                  if (u < 0) throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                  this.reader.setIndex(u);
                  var h = u;
                  if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === s.MAX_VALUE_16BITS || this.diskWithCentralDirStart === s.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === s.MAX_VALUE_16BITS || this.centralDirRecords === s.MAX_VALUE_16BITS || this.centralDirSize === s.MAX_VALUE_32BITS || this.centralDirOffset === s.MAX_VALUE_32BITS) {
                    if (this.zip64 = true, (u = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                    if (this.reader.setIndex(u), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                  }
                  var g = this.centralDirOffset + this.centralDirSize;
                  this.zip64 && (g += 20, g += 12 + this.zip64EndOfCentralSize);
                  var v = h - g;
                  if (0 < v) this.isSignature(h, o.CENTRAL_FILE_HEADER) || (this.reader.zero = v);
                  else if (v < 0) throw new Error("Corrupted zip: missing " + Math.abs(v) + " bytes.");
                },
                prepareReader: function(u) {
                  this.reader = a(u);
                },
                load: function(u) {
                  this.prepareReader(u), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                }
              }, r.exports = f;
            },
            {
              "./reader/readerFor": 22,
              "./signature": 23,
              "./support": 30,
              "./utils": 32,
              "./zipEntry": 34
            }
          ],
          34: [
            function(n, r, i) {
              var a = n("./reader/readerFor"), s = n("./utils"), o = n("./compressedObject"), l = n("./crc32"), c = n("./utf8"), f = n("./compressions"), u = n("./support");
              function h(g, v) {
                this.options = g, this.loadOptions = v;
              }
              h.prototype = {
                isEncrypted: function() {
                  return (1 & this.bitFlag) == 1;
                },
                useUTF8: function() {
                  return (2048 & this.bitFlag) == 2048;
                },
                readLocalPart: function(g) {
                  var v, m;
                  if (g.skip(22), this.fileNameLength = g.readInt(2), m = g.readInt(2), this.fileName = g.readData(this.fileNameLength), g.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                  if ((v = (function(y) {
                    for (var w in f) if (Object.prototype.hasOwnProperty.call(f, w) && f[w].magic === y) return f[w];
                    return null;
                  })(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
                  this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, v, g.readData(this.compressedSize));
                },
                readCentralPart: function(g) {
                  this.versionMadeBy = g.readInt(2), g.skip(2), this.bitFlag = g.readInt(2), this.compressionMethod = g.readString(2), this.date = g.readDate(), this.crc32 = g.readInt(4), this.compressedSize = g.readInt(4), this.uncompressedSize = g.readInt(4);
                  var v = g.readInt(2);
                  if (this.extraFieldsLength = g.readInt(2), this.fileCommentLength = g.readInt(2), this.diskNumberStart = g.readInt(2), this.internalFileAttributes = g.readInt(2), this.externalFileAttributes = g.readInt(4), this.localHeaderOffset = g.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                  g.skip(v), this.readExtraFields(g), this.parseZIP64ExtraField(g), this.fileComment = g.readData(this.fileCommentLength);
                },
                processAttributes: function() {
                  this.unixPermissions = null, this.dosPermissions = null;
                  var g = this.versionMadeBy >> 8;
                  this.dir = !!(16 & this.externalFileAttributes), g == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), g == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
                },
                parseZIP64ExtraField: function() {
                  if (this.extraFields[1]) {
                    var g = a(this.extraFields[1].value);
                    this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = g.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = g.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = g.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = g.readInt(4));
                  }
                },
                readExtraFields: function(g) {
                  var v, m, y, w = g.index + this.extraFieldsLength;
                  for (this.extraFields || (this.extraFields = {}); g.index + 4 < w; ) v = g.readInt(2), m = g.readInt(2), y = g.readData(m), this.extraFields[v] = {
                    id: v,
                    length: m,
                    value: y
                  };
                  g.setIndex(w);
                },
                handleUTF8: function() {
                  var g = u.uint8array ? "uint8array" : "array";
                  if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
                  else {
                    var v = this.findExtraFieldUnicodePath();
                    if (v !== null) this.fileNameStr = v;
                    else {
                      var m = s.transformTo(g, this.fileName);
                      this.fileNameStr = this.loadOptions.decodeFileName(m);
                    }
                    var y = this.findExtraFieldUnicodeComment();
                    if (y !== null) this.fileCommentStr = y;
                    else {
                      var w = s.transformTo(g, this.fileComment);
                      this.fileCommentStr = this.loadOptions.decodeFileName(w);
                    }
                  }
                },
                findExtraFieldUnicodePath: function() {
                  var g = this.extraFields[28789];
                  if (g) {
                    var v = a(g.value);
                    return v.readInt(1) !== 1 || l(this.fileName) !== v.readInt(4) ? null : c.utf8decode(v.readData(g.length - 5));
                  }
                  return null;
                },
                findExtraFieldUnicodeComment: function() {
                  var g = this.extraFields[25461];
                  if (g) {
                    var v = a(g.value);
                    return v.readInt(1) !== 1 || l(this.fileComment) !== v.readInt(4) ? null : c.utf8decode(v.readData(g.length - 5));
                  }
                  return null;
                }
              }, r.exports = h;
            },
            {
              "./compressedObject": 2,
              "./compressions": 3,
              "./crc32": 4,
              "./reader/readerFor": 22,
              "./support": 30,
              "./utf8": 31,
              "./utils": 32
            }
          ],
          35: [
            function(n, r, i) {
              function a(v, m, y) {
                this.name = v, this.dir = y.dir, this.date = y.date, this.comment = y.comment, this.unixPermissions = y.unixPermissions, this.dosPermissions = y.dosPermissions, this._data = m, this._dataBinary = y.binary, this.options = {
                  compression: y.compression,
                  compressionOptions: y.compressionOptions
                };
              }
              var s = n("./stream/StreamHelper"), o = n("./stream/DataWorker"), l = n("./utf8"), c = n("./compressedObject"), f = n("./stream/GenericWorker");
              a.prototype = {
                internalStream: function(v) {
                  var m = null, y = "string";
                  try {
                    if (!v) throw new Error("No output type specified.");
                    var w = (y = v.toLowerCase()) === "string" || y === "text";
                    y !== "binarystring" && y !== "text" || (y = "string"), m = this._decompressWorker();
                    var C = !this._dataBinary;
                    C && !w && (m = m.pipe(new l.Utf8EncodeWorker())), !C && w && (m = m.pipe(new l.Utf8DecodeWorker()));
                  } catch (T) {
                    (m = new f("error")).error(T);
                  }
                  return new s(m, y, "");
                },
                async: function(v, m) {
                  return this.internalStream(v).accumulate(m);
                },
                nodeStream: function(v, m) {
                  return this.internalStream(v || "nodebuffer").toNodejsStream(m);
                },
                _compressWorker: function(v, m) {
                  if (this._data instanceof c && this._data.compression.magic === v.magic) return this._data.getCompressedWorker();
                  var y = this._decompressWorker();
                  return this._dataBinary || (y = y.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(y, v, m);
                },
                _decompressWorker: function() {
                  return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof f ? this._data : new o(this._data);
                }
              };
              for (var u = [
                "asText",
                "asBinary",
                "asNodeBuffer",
                "asUint8Array",
                "asArrayBuffer"
              ], h = function() {
                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
              }, g = 0; g < u.length; g++) a.prototype[u[g]] = h;
              r.exports = a;
            },
            {
              "./compressedObject": 2,
              "./stream/DataWorker": 27,
              "./stream/GenericWorker": 28,
              "./stream/StreamHelper": 29,
              "./utf8": 31
            }
          ],
          36: [
            function(n, r, i) {
              (function(a) {
                var s, o, l = a.MutationObserver || a.WebKitMutationObserver;
                if (l) {
                  var c = 0, f = new l(v), u = a.document.createTextNode("");
                  f.observe(u, {
                    characterData: true
                  }), s = function() {
                    u.data = c = ++c % 2;
                  };
                } else if (a.setImmediate || a.MessageChannel === void 0) s = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
                  var m = a.document.createElement("script");
                  m.onreadystatechange = function() {
                    v(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
                  }, a.document.documentElement.appendChild(m);
                } : function() {
                  setTimeout(v, 0);
                };
                else {
                  var h = new a.MessageChannel();
                  h.port1.onmessage = v, s = function() {
                    h.port2.postMessage(0);
                  };
                }
                var g = [];
                function v() {
                  var m, y;
                  o = true;
                  for (var w = g.length; w; ) {
                    for (y = g, g = [], m = -1; ++m < w; ) y[m]();
                    w = g.length;
                  }
                  o = false;
                }
                r.exports = function(m) {
                  g.push(m) !== 1 || o || s();
                };
              }).call(this, typeof ci < "u" ? ci : typeof self < "u" ? self : typeof window < "u" ? window : {});
            },
            {}
          ],
          37: [
            function(n, r, i) {
              var a = n("immediate");
              function s() {
              }
              var o = {}, l = [
                "REJECTED"
              ], c = [
                "FULFILLED"
              ], f = [
                "PENDING"
              ];
              function u(w) {
                if (typeof w != "function") throw new TypeError("resolver must be a function");
                this.state = f, this.queue = [], this.outcome = void 0, w !== s && m(this, w);
              }
              function h(w, C, T) {
                this.promise = w, typeof C == "function" && (this.onFulfilled = C, this.callFulfilled = this.otherCallFulfilled), typeof T == "function" && (this.onRejected = T, this.callRejected = this.otherCallRejected);
              }
              function g(w, C, T) {
                a(function() {
                  var S;
                  try {
                    S = C(T);
                  } catch (E) {
                    return o.reject(w, E);
                  }
                  S === w ? o.reject(w, new TypeError("Cannot resolve promise with itself")) : o.resolve(w, S);
                });
              }
              function v(w) {
                var C = w && w.then;
                if (w && (typeof w == "object" || typeof w == "function") && typeof C == "function") return function() {
                  C.apply(w, arguments);
                };
              }
              function m(w, C) {
                var T = false;
                function S(D) {
                  T || (T = true, o.reject(w, D));
                }
                function E(D) {
                  T || (T = true, o.resolve(w, D));
                }
                var b = y(function() {
                  C(E, S);
                });
                b.status === "error" && S(b.value);
              }
              function y(w, C) {
                var T = {};
                try {
                  T.value = w(C), T.status = "success";
                } catch (S) {
                  T.status = "error", T.value = S;
                }
                return T;
              }
              (r.exports = u).prototype.finally = function(w) {
                if (typeof w != "function") return this;
                var C = this.constructor;
                return this.then(function(T) {
                  return C.resolve(w()).then(function() {
                    return T;
                  });
                }, function(T) {
                  return C.resolve(w()).then(function() {
                    throw T;
                  });
                });
              }, u.prototype.catch = function(w) {
                return this.then(null, w);
              }, u.prototype.then = function(w, C) {
                if (typeof w != "function" && this.state === c || typeof C != "function" && this.state === l) return this;
                var T = new this.constructor(s);
                return this.state !== f ? g(T, this.state === c ? w : C, this.outcome) : this.queue.push(new h(T, w, C)), T;
              }, h.prototype.callFulfilled = function(w) {
                o.resolve(this.promise, w);
              }, h.prototype.otherCallFulfilled = function(w) {
                g(this.promise, this.onFulfilled, w);
              }, h.prototype.callRejected = function(w) {
                o.reject(this.promise, w);
              }, h.prototype.otherCallRejected = function(w) {
                g(this.promise, this.onRejected, w);
              }, o.resolve = function(w, C) {
                var T = y(v, C);
                if (T.status === "error") return o.reject(w, T.value);
                var S = T.value;
                if (S) m(w, S);
                else {
                  w.state = c, w.outcome = C;
                  for (var E = -1, b = w.queue.length; ++E < b; ) w.queue[E].callFulfilled(C);
                }
                return w;
              }, o.reject = function(w, C) {
                w.state = l, w.outcome = C;
                for (var T = -1, S = w.queue.length; ++T < S; ) w.queue[T].callRejected(C);
                return w;
              }, u.resolve = function(w) {
                return w instanceof this ? w : o.resolve(new this(s), w);
              }, u.reject = function(w) {
                var C = new this(s);
                return o.reject(C, w);
              }, u.all = function(w) {
                var C = this;
                if (Object.prototype.toString.call(w) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                var T = w.length, S = false;
                if (!T) return this.resolve([]);
                for (var E = new Array(T), b = 0, D = -1, R = new this(s); ++D < T; ) I(w[D], D);
                return R;
                function I(O, L) {
                  C.resolve(O).then(function(N) {
                    E[L] = N, ++b !== T || S || (S = true, o.resolve(R, E));
                  }, function(N) {
                    S || (S = true, o.reject(R, N));
                  });
                }
              }, u.race = function(w) {
                var C = this;
                if (Object.prototype.toString.call(w) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                var T = w.length, S = false;
                if (!T) return this.resolve([]);
                for (var E = -1, b = new this(s); ++E < T; ) D = w[E], C.resolve(D).then(function(R) {
                  S || (S = true, o.resolve(b, R));
                }, function(R) {
                  S || (S = true, o.reject(b, R));
                });
                var D;
                return b;
              };
            },
            {
              immediate: 36
            }
          ],
          38: [
            function(n, r, i) {
              var a = {};
              (0, n("./lib/utils/common").assign)(a, n("./lib/deflate"), n("./lib/inflate"), n("./lib/zlib/constants")), r.exports = a;
            },
            {
              "./lib/deflate": 39,
              "./lib/inflate": 40,
              "./lib/utils/common": 41,
              "./lib/zlib/constants": 44
            }
          ],
          39: [
            function(n, r, i) {
              var a = n("./zlib/deflate"), s = n("./utils/common"), o = n("./utils/strings"), l = n("./zlib/messages"), c = n("./zlib/zstream"), f = Object.prototype.toString, u = 0, h = -1, g = 0, v = 8;
              function m(w) {
                if (!(this instanceof m)) return new m(w);
                this.options = s.assign({
                  level: h,
                  method: v,
                  chunkSize: 16384,
                  windowBits: 15,
                  memLevel: 8,
                  strategy: g,
                  to: ""
                }, w || {});
                var C = this.options;
                C.raw && 0 < C.windowBits ? C.windowBits = -C.windowBits : C.gzip && 0 < C.windowBits && C.windowBits < 16 && (C.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
                var T = a.deflateInit2(this.strm, C.level, C.method, C.windowBits, C.memLevel, C.strategy);
                if (T !== u) throw new Error(l[T]);
                if (C.header && a.deflateSetHeader(this.strm, C.header), C.dictionary) {
                  var S;
                  if (S = typeof C.dictionary == "string" ? o.string2buf(C.dictionary) : f.call(C.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(C.dictionary) : C.dictionary, (T = a.deflateSetDictionary(this.strm, S)) !== u) throw new Error(l[T]);
                  this._dict_set = true;
                }
              }
              function y(w, C) {
                var T = new m(C);
                if (T.push(w, true), T.err) throw T.msg || l[T.err];
                return T.result;
              }
              m.prototype.push = function(w, C) {
                var T, S, E = this.strm, b = this.options.chunkSize;
                if (this.ended) return false;
                S = C === ~~C ? C : C === true ? 4 : 0, typeof w == "string" ? E.input = o.string2buf(w) : f.call(w) === "[object ArrayBuffer]" ? E.input = new Uint8Array(w) : E.input = w, E.next_in = 0, E.avail_in = E.input.length;
                do {
                  if (E.avail_out === 0 && (E.output = new s.Buf8(b), E.next_out = 0, E.avail_out = b), (T = a.deflate(E, S)) !== 1 && T !== u) return this.onEnd(T), !(this.ended = true);
                  E.avail_out !== 0 && (E.avail_in !== 0 || S !== 4 && S !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(s.shrinkBuf(E.output, E.next_out))) : this.onData(s.shrinkBuf(E.output, E.next_out)));
                } while ((0 < E.avail_in || E.avail_out === 0) && T !== 1);
                return S === 4 ? (T = a.deflateEnd(this.strm), this.onEnd(T), this.ended = true, T === u) : S !== 2 || (this.onEnd(u), !(E.avail_out = 0));
              }, m.prototype.onData = function(w) {
                this.chunks.push(w);
              }, m.prototype.onEnd = function(w) {
                w === u && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = w, this.msg = this.strm.msg;
              }, i.Deflate = m, i.deflate = y, i.deflateRaw = function(w, C) {
                return (C = C || {}).raw = true, y(w, C);
              }, i.gzip = function(w, C) {
                return (C = C || {}).gzip = true, y(w, C);
              };
            },
            {
              "./utils/common": 41,
              "./utils/strings": 42,
              "./zlib/deflate": 46,
              "./zlib/messages": 51,
              "./zlib/zstream": 53
            }
          ],
          40: [
            function(n, r, i) {
              var a = n("./zlib/inflate"), s = n("./utils/common"), o = n("./utils/strings"), l = n("./zlib/constants"), c = n("./zlib/messages"), f = n("./zlib/zstream"), u = n("./zlib/gzheader"), h = Object.prototype.toString;
              function g(m) {
                if (!(this instanceof g)) return new g(m);
                this.options = s.assign({
                  chunkSize: 16384,
                  windowBits: 0,
                  to: ""
                }, m || {});
                var y = this.options;
                y.raw && 0 <= y.windowBits && y.windowBits < 16 && (y.windowBits = -y.windowBits, y.windowBits === 0 && (y.windowBits = -15)), !(0 <= y.windowBits && y.windowBits < 16) || m && m.windowBits || (y.windowBits += 32), 15 < y.windowBits && y.windowBits < 48 && (15 & y.windowBits) == 0 && (y.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
                var w = a.inflateInit2(this.strm, y.windowBits);
                if (w !== l.Z_OK) throw new Error(c[w]);
                this.header = new u(), a.inflateGetHeader(this.strm, this.header);
              }
              function v(m, y) {
                var w = new g(y);
                if (w.push(m, true), w.err) throw w.msg || c[w.err];
                return w.result;
              }
              g.prototype.push = function(m, y) {
                var w, C, T, S, E, b, D = this.strm, R = this.options.chunkSize, I = this.options.dictionary, O = false;
                if (this.ended) return false;
                C = y === ~~y ? y : y === true ? l.Z_FINISH : l.Z_NO_FLUSH, typeof m == "string" ? D.input = o.binstring2buf(m) : h.call(m) === "[object ArrayBuffer]" ? D.input = new Uint8Array(m) : D.input = m, D.next_in = 0, D.avail_in = D.input.length;
                do {
                  if (D.avail_out === 0 && (D.output = new s.Buf8(R), D.next_out = 0, D.avail_out = R), (w = a.inflate(D, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && I && (b = typeof I == "string" ? o.string2buf(I) : h.call(I) === "[object ArrayBuffer]" ? new Uint8Array(I) : I, w = a.inflateSetDictionary(this.strm, b)), w === l.Z_BUF_ERROR && O === true && (w = l.Z_OK, O = false), w !== l.Z_STREAM_END && w !== l.Z_OK) return this.onEnd(w), !(this.ended = true);
                  D.next_out && (D.avail_out !== 0 && w !== l.Z_STREAM_END && (D.avail_in !== 0 || C !== l.Z_FINISH && C !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (T = o.utf8border(D.output, D.next_out), S = D.next_out - T, E = o.buf2string(D.output, T), D.next_out = S, D.avail_out = R - S, S && s.arraySet(D.output, D.output, T, S, 0), this.onData(E)) : this.onData(s.shrinkBuf(D.output, D.next_out)))), D.avail_in === 0 && D.avail_out === 0 && (O = true);
                } while ((0 < D.avail_in || D.avail_out === 0) && w !== l.Z_STREAM_END);
                return w === l.Z_STREAM_END && (C = l.Z_FINISH), C === l.Z_FINISH ? (w = a.inflateEnd(this.strm), this.onEnd(w), this.ended = true, w === l.Z_OK) : C !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(D.avail_out = 0));
              }, g.prototype.onData = function(m) {
                this.chunks.push(m);
              }, g.prototype.onEnd = function(m) {
                m === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
              }, i.Inflate = g, i.inflate = v, i.inflateRaw = function(m, y) {
                return (y = y || {}).raw = true, v(m, y);
              }, i.ungzip = v;
            },
            {
              "./utils/common": 41,
              "./utils/strings": 42,
              "./zlib/constants": 44,
              "./zlib/gzheader": 47,
              "./zlib/inflate": 49,
              "./zlib/messages": 51,
              "./zlib/zstream": 53
            }
          ],
          41: [
            function(n, r, i) {
              var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
              i.assign = function(l) {
                for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
                  var f = c.shift();
                  if (f) {
                    if (typeof f != "object") throw new TypeError(f + "must be non-object");
                    for (var u in f) f.hasOwnProperty(u) && (l[u] = f[u]);
                  }
                }
                return l;
              }, i.shrinkBuf = function(l, c) {
                return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
              };
              var s = {
                arraySet: function(l, c, f, u, h) {
                  if (c.subarray && l.subarray) l.set(c.subarray(f, f + u), h);
                  else for (var g = 0; g < u; g++) l[h + g] = c[f + g];
                },
                flattenChunks: function(l) {
                  var c, f, u, h, g, v;
                  for (c = u = 0, f = l.length; c < f; c++) u += l[c].length;
                  for (v = new Uint8Array(u), c = h = 0, f = l.length; c < f; c++) g = l[c], v.set(g, h), h += g.length;
                  return v;
                }
              }, o = {
                arraySet: function(l, c, f, u, h) {
                  for (var g = 0; g < u; g++) l[h + g] = c[f + g];
                },
                flattenChunks: function(l) {
                  return [].concat.apply([], l);
                }
              };
              i.setTyped = function(l) {
                l ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, s)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o));
              }, i.setTyped(a);
            },
            {}
          ],
          42: [
            function(n, r, i) {
              var a = n("./common"), s = true, o = true;
              try {
                String.fromCharCode.apply(null, [
                  0
                ]);
              } catch {
                s = false;
              }
              try {
                String.fromCharCode.apply(null, new Uint8Array(1));
              } catch {
                o = false;
              }
              for (var l = new a.Buf8(256), c = 0; c < 256; c++) l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
              function f(u, h) {
                if (h < 65537 && (u.subarray && o || !u.subarray && s)) return String.fromCharCode.apply(null, a.shrinkBuf(u, h));
                for (var g = "", v = 0; v < h; v++) g += String.fromCharCode(u[v]);
                return g;
              }
              l[254] = l[254] = 1, i.string2buf = function(u) {
                var h, g, v, m, y, w = u.length, C = 0;
                for (m = 0; m < w; m++) (64512 & (g = u.charCodeAt(m))) == 55296 && m + 1 < w && (64512 & (v = u.charCodeAt(m + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (v - 56320), m++), C += g < 128 ? 1 : g < 2048 ? 2 : g < 65536 ? 3 : 4;
                for (h = new a.Buf8(C), m = y = 0; y < C; m++) (64512 & (g = u.charCodeAt(m))) == 55296 && m + 1 < w && (64512 & (v = u.charCodeAt(m + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (v - 56320), m++), g < 128 ? h[y++] = g : (g < 2048 ? h[y++] = 192 | g >>> 6 : (g < 65536 ? h[y++] = 224 | g >>> 12 : (h[y++] = 240 | g >>> 18, h[y++] = 128 | g >>> 12 & 63), h[y++] = 128 | g >>> 6 & 63), h[y++] = 128 | 63 & g);
                return h;
              }, i.buf2binstring = function(u) {
                return f(u, u.length);
              }, i.binstring2buf = function(u) {
                for (var h = new a.Buf8(u.length), g = 0, v = h.length; g < v; g++) h[g] = u.charCodeAt(g);
                return h;
              }, i.buf2string = function(u, h) {
                var g, v, m, y, w = h || u.length, C = new Array(2 * w);
                for (g = v = 0; g < w; ) if ((m = u[g++]) < 128) C[v++] = m;
                else if (4 < (y = l[m])) C[v++] = 65533, g += y - 1;
                else {
                  for (m &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && g < w; ) m = m << 6 | 63 & u[g++], y--;
                  1 < y ? C[v++] = 65533 : m < 65536 ? C[v++] = m : (m -= 65536, C[v++] = 55296 | m >> 10 & 1023, C[v++] = 56320 | 1023 & m);
                }
                return f(C, v);
              }, i.utf8border = function(u, h) {
                var g;
                for ((h = h || u.length) > u.length && (h = u.length), g = h - 1; 0 <= g && (192 & u[g]) == 128; ) g--;
                return g < 0 || g === 0 ? h : g + l[u[g]] > h ? g : h;
              };
            },
            {
              "./common": 41
            }
          ],
          43: [
            function(n, r, i) {
              r.exports = function(a, s, o, l) {
                for (var c = 65535 & a | 0, f = a >>> 16 & 65535 | 0, u = 0; o !== 0; ) {
                  for (o -= u = 2e3 < o ? 2e3 : o; f = f + (c = c + s[l++] | 0) | 0, --u; ) ;
                  c %= 65521, f %= 65521;
                }
                return c | f << 16 | 0;
              };
            },
            {}
          ],
          44: [
            function(n, r, i) {
              r.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
              };
            },
            {}
          ],
          45: [
            function(n, r, i) {
              var a = (function() {
                for (var s, o = [], l = 0; l < 256; l++) {
                  s = l;
                  for (var c = 0; c < 8; c++) s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
                  o[l] = s;
                }
                return o;
              })();
              r.exports = function(s, o, l, c) {
                var f = a, u = c + l;
                s ^= -1;
                for (var h = c; h < u; h++) s = s >>> 8 ^ f[255 & (s ^ o[h])];
                return -1 ^ s;
              };
            },
            {}
          ],
          46: [
            function(n, r, i) {
              var a, s = n("../utils/common"), o = n("./trees"), l = n("./adler32"), c = n("./crc32"), f = n("./messages"), u = 0, h = 4, g = 0, v = -2, m = -1, y = 4, w = 2, C = 8, T = 9, S = 286, E = 30, b = 19, D = 2 * S + 1, R = 15, I = 3, O = 258, L = O + I + 1, N = 42, F = 113, V = 1, k = 2, _ = 3, K = 4;
              function Z(G, Se) {
                return G.msg = f[Se], Se;
              }
              function j(G) {
                return (G << 1) - (4 < G ? 9 : 0);
              }
              function B(G) {
                for (var Se = G.length; 0 <= --Se; ) G[Se] = 0;
              }
              function Y(G) {
                var Se = G.state, xe = Se.pending;
                xe > G.avail_out && (xe = G.avail_out), xe !== 0 && (s.arraySet(G.output, Se.pending_buf, Se.pending_out, xe, G.next_out), G.next_out += xe, Se.pending_out += xe, G.total_out += xe, G.avail_out -= xe, Se.pending -= xe, Se.pending === 0 && (Se.pending_out = 0));
              }
              function X(G, Se) {
                o._tr_flush_block(G, 0 <= G.block_start ? G.block_start : -1, G.strstart - G.block_start, Se), G.block_start = G.strstart, Y(G.strm);
              }
              function ie(G, Se) {
                G.pending_buf[G.pending++] = Se;
              }
              function oe(G, Se) {
                G.pending_buf[G.pending++] = Se >>> 8 & 255, G.pending_buf[G.pending++] = 255 & Se;
              }
              function he(G, Se) {
                var xe, re, ne = G.max_chain_length, ce = G.strstart, Oe = G.prev_length, Ve = G.nice_match, de = G.strstart > G.w_size - L ? G.strstart - (G.w_size - L) : 0, We = G.window, Ze = G.w_mask, Ge = G.prev, at = G.strstart + O, ut = We[ce + Oe - 1], it = We[ce + Oe];
                G.prev_length >= G.good_match && (ne >>= 2), Ve > G.lookahead && (Ve = G.lookahead);
                do
                  if (We[(xe = Se) + Oe] === it && We[xe + Oe - 1] === ut && We[xe] === We[ce] && We[++xe] === We[ce + 1]) {
                    ce += 2, xe++;
                    do
                      ;
                    while (We[++ce] === We[++xe] && We[++ce] === We[++xe] && We[++ce] === We[++xe] && We[++ce] === We[++xe] && We[++ce] === We[++xe] && We[++ce] === We[++xe] && We[++ce] === We[++xe] && We[++ce] === We[++xe] && ce < at);
                    if (re = O - (at - ce), ce = at - O, Oe < re) {
                      if (G.match_start = Se, Ve <= (Oe = re)) break;
                      ut = We[ce + Oe - 1], it = We[ce + Oe];
                    }
                  }
                while ((Se = Ge[Se & Ze]) > de && --ne != 0);
                return Oe <= G.lookahead ? Oe : G.lookahead;
              }
              function Le(G) {
                var Se, xe, re, ne, ce, Oe, Ve, de, We, Ze, Ge = G.w_size;
                do {
                  if (ne = G.window_size - G.lookahead - G.strstart, G.strstart >= Ge + (Ge - L)) {
                    for (s.arraySet(G.window, G.window, Ge, Ge, 0), G.match_start -= Ge, G.strstart -= Ge, G.block_start -= Ge, Se = xe = G.hash_size; re = G.head[--Se], G.head[Se] = Ge <= re ? re - Ge : 0, --xe; ) ;
                    for (Se = xe = Ge; re = G.prev[--Se], G.prev[Se] = Ge <= re ? re - Ge : 0, --xe; ) ;
                    ne += Ge;
                  }
                  if (G.strm.avail_in === 0) break;
                  if (Oe = G.strm, Ve = G.window, de = G.strstart + G.lookahead, We = ne, Ze = void 0, Ze = Oe.avail_in, We < Ze && (Ze = We), xe = Ze === 0 ? 0 : (Oe.avail_in -= Ze, s.arraySet(Ve, Oe.input, Oe.next_in, Ze, de), Oe.state.wrap === 1 ? Oe.adler = l(Oe.adler, Ve, Ze, de) : Oe.state.wrap === 2 && (Oe.adler = c(Oe.adler, Ve, Ze, de)), Oe.next_in += Ze, Oe.total_in += Ze, Ze), G.lookahead += xe, G.lookahead + G.insert >= I) for (ce = G.strstart - G.insert, G.ins_h = G.window[ce], G.ins_h = (G.ins_h << G.hash_shift ^ G.window[ce + 1]) & G.hash_mask; G.insert && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[ce + I - 1]) & G.hash_mask, G.prev[ce & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = ce, ce++, G.insert--, !(G.lookahead + G.insert < I)); ) ;
                } while (G.lookahead < L && G.strm.avail_in !== 0);
              }
              function Je(G, Se) {
                for (var xe, re; ; ) {
                  if (G.lookahead < L) {
                    if (Le(G), G.lookahead < L && Se === u) return V;
                    if (G.lookahead === 0) break;
                  }
                  if (xe = 0, G.lookahead >= I && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + I - 1]) & G.hash_mask, xe = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart), xe !== 0 && G.strstart - xe <= G.w_size - L && (G.match_length = he(G, xe)), G.match_length >= I) if (re = o._tr_tally(G, G.strstart - G.match_start, G.match_length - I), G.lookahead -= G.match_length, G.match_length <= G.max_lazy_match && G.lookahead >= I) {
                    for (G.match_length--; G.strstart++, G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + I - 1]) & G.hash_mask, xe = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart, --G.match_length != 0; ) ;
                    G.strstart++;
                  } else G.strstart += G.match_length, G.match_length = 0, G.ins_h = G.window[G.strstart], G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + 1]) & G.hash_mask;
                  else re = o._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++;
                  if (re && (X(G, false), G.strm.avail_out === 0)) return V;
                }
                return G.insert = G.strstart < I - 1 ? G.strstart : I - 1, Se === h ? (X(G, true), G.strm.avail_out === 0 ? _ : K) : G.last_lit && (X(G, false), G.strm.avail_out === 0) ? V : k;
              }
              function Pe(G, Se) {
                for (var xe, re, ne; ; ) {
                  if (G.lookahead < L) {
                    if (Le(G), G.lookahead < L && Se === u) return V;
                    if (G.lookahead === 0) break;
                  }
                  if (xe = 0, G.lookahead >= I && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + I - 1]) & G.hash_mask, xe = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart), G.prev_length = G.match_length, G.prev_match = G.match_start, G.match_length = I - 1, xe !== 0 && G.prev_length < G.max_lazy_match && G.strstart - xe <= G.w_size - L && (G.match_length = he(G, xe), G.match_length <= 5 && (G.strategy === 1 || G.match_length === I && 4096 < G.strstart - G.match_start) && (G.match_length = I - 1)), G.prev_length >= I && G.match_length <= G.prev_length) {
                    for (ne = G.strstart + G.lookahead - I, re = o._tr_tally(G, G.strstart - 1 - G.prev_match, G.prev_length - I), G.lookahead -= G.prev_length - 1, G.prev_length -= 2; ++G.strstart <= ne && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + I - 1]) & G.hash_mask, xe = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart), --G.prev_length != 0; ) ;
                    if (G.match_available = 0, G.match_length = I - 1, G.strstart++, re && (X(G, false), G.strm.avail_out === 0)) return V;
                  } else if (G.match_available) {
                    if ((re = o._tr_tally(G, 0, G.window[G.strstart - 1])) && X(G, false), G.strstart++, G.lookahead--, G.strm.avail_out === 0) return V;
                  } else G.match_available = 1, G.strstart++, G.lookahead--;
                }
                return G.match_available && (re = o._tr_tally(G, 0, G.window[G.strstart - 1]), G.match_available = 0), G.insert = G.strstart < I - 1 ? G.strstart : I - 1, Se === h ? (X(G, true), G.strm.avail_out === 0 ? _ : K) : G.last_lit && (X(G, false), G.strm.avail_out === 0) ? V : k;
              }
              function ot(G, Se, xe, re, ne) {
                this.good_length = G, this.max_lazy = Se, this.nice_length = xe, this.max_chain = re, this.func = ne;
              }
              function vt() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = C, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new s.Buf16(2 * D), this.dyn_dtree = new s.Buf16(2 * (2 * E + 1)), this.bl_tree = new s.Buf16(2 * (2 * b + 1)), B(this.dyn_ltree), B(this.dyn_dtree), B(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new s.Buf16(R + 1), this.heap = new s.Buf16(2 * S + 1), B(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new s.Buf16(2 * S + 1), B(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
              }
              function wt(G) {
                var Se;
                return G && G.state ? (G.total_in = G.total_out = 0, G.data_type = w, (Se = G.state).pending = 0, Se.pending_out = 0, Se.wrap < 0 && (Se.wrap = -Se.wrap), Se.status = Se.wrap ? N : F, G.adler = Se.wrap === 2 ? 0 : 1, Se.last_flush = u, o._tr_init(Se), g) : Z(G, v);
              }
              function Qe(G) {
                var Se = wt(G);
                return Se === g && (function(xe) {
                  xe.window_size = 2 * xe.w_size, B(xe.head), xe.max_lazy_match = a[xe.level].max_lazy, xe.good_match = a[xe.level].good_length, xe.nice_match = a[xe.level].nice_length, xe.max_chain_length = a[xe.level].max_chain, xe.strstart = 0, xe.block_start = 0, xe.lookahead = 0, xe.insert = 0, xe.match_length = xe.prev_length = I - 1, xe.match_available = 0, xe.ins_h = 0;
                })(G.state), Se;
              }
              function _t6(G, Se, xe, re, ne, ce) {
                if (!G) return v;
                var Oe = 1;
                if (Se === m && (Se = 6), re < 0 ? (Oe = 0, re = -re) : 15 < re && (Oe = 2, re -= 16), ne < 1 || T < ne || xe !== C || re < 8 || 15 < re || Se < 0 || 9 < Se || ce < 0 || y < ce) return Z(G, v);
                re === 8 && (re = 9);
                var Ve = new vt();
                return (G.state = Ve).strm = G, Ve.wrap = Oe, Ve.gzhead = null, Ve.w_bits = re, Ve.w_size = 1 << Ve.w_bits, Ve.w_mask = Ve.w_size - 1, Ve.hash_bits = ne + 7, Ve.hash_size = 1 << Ve.hash_bits, Ve.hash_mask = Ve.hash_size - 1, Ve.hash_shift = ~~((Ve.hash_bits + I - 1) / I), Ve.window = new s.Buf8(2 * Ve.w_size), Ve.head = new s.Buf16(Ve.hash_size), Ve.prev = new s.Buf16(Ve.w_size), Ve.lit_bufsize = 1 << ne + 6, Ve.pending_buf_size = 4 * Ve.lit_bufsize, Ve.pending_buf = new s.Buf8(Ve.pending_buf_size), Ve.d_buf = 1 * Ve.lit_bufsize, Ve.l_buf = 3 * Ve.lit_bufsize, Ve.level = Se, Ve.strategy = ce, Ve.method = xe, Qe(G);
              }
              a = [
                new ot(0, 0, 0, 0, function(G, Se) {
                  var xe = 65535;
                  for (xe > G.pending_buf_size - 5 && (xe = G.pending_buf_size - 5); ; ) {
                    if (G.lookahead <= 1) {
                      if (Le(G), G.lookahead === 0 && Se === u) return V;
                      if (G.lookahead === 0) break;
                    }
                    G.strstart += G.lookahead, G.lookahead = 0;
                    var re = G.block_start + xe;
                    if ((G.strstart === 0 || G.strstart >= re) && (G.lookahead = G.strstart - re, G.strstart = re, X(G, false), G.strm.avail_out === 0) || G.strstart - G.block_start >= G.w_size - L && (X(G, false), G.strm.avail_out === 0)) return V;
                  }
                  return G.insert = 0, Se === h ? (X(G, true), G.strm.avail_out === 0 ? _ : K) : (G.strstart > G.block_start && (X(G, false), G.strm.avail_out), V);
                }),
                new ot(4, 4, 8, 4, Je),
                new ot(4, 5, 16, 8, Je),
                new ot(4, 6, 32, 32, Je),
                new ot(4, 4, 16, 16, Pe),
                new ot(8, 16, 32, 32, Pe),
                new ot(8, 16, 128, 128, Pe),
                new ot(8, 32, 128, 256, Pe),
                new ot(32, 128, 258, 1024, Pe),
                new ot(32, 258, 258, 4096, Pe)
              ], i.deflateInit = function(G, Se) {
                return _t6(G, Se, C, 15, 8, 0);
              }, i.deflateInit2 = _t6, i.deflateReset = Qe, i.deflateResetKeep = wt, i.deflateSetHeader = function(G, Se) {
                return G && G.state ? G.state.wrap !== 2 ? v : (G.state.gzhead = Se, g) : v;
              }, i.deflate = function(G, Se) {
                var xe, re, ne, ce;
                if (!G || !G.state || 5 < Se || Se < 0) return G ? Z(G, v) : v;
                if (re = G.state, !G.output || !G.input && G.avail_in !== 0 || re.status === 666 && Se !== h) return Z(G, G.avail_out === 0 ? -5 : v);
                if (re.strm = G, xe = re.last_flush, re.last_flush = Se, re.status === N) if (re.wrap === 2) G.adler = 0, ie(re, 31), ie(re, 139), ie(re, 8), re.gzhead ? (ie(re, (re.gzhead.text ? 1 : 0) + (re.gzhead.hcrc ? 2 : 0) + (re.gzhead.extra ? 4 : 0) + (re.gzhead.name ? 8 : 0) + (re.gzhead.comment ? 16 : 0)), ie(re, 255 & re.gzhead.time), ie(re, re.gzhead.time >> 8 & 255), ie(re, re.gzhead.time >> 16 & 255), ie(re, re.gzhead.time >> 24 & 255), ie(re, re.level === 9 ? 2 : 2 <= re.strategy || re.level < 2 ? 4 : 0), ie(re, 255 & re.gzhead.os), re.gzhead.extra && re.gzhead.extra.length && (ie(re, 255 & re.gzhead.extra.length), ie(re, re.gzhead.extra.length >> 8 & 255)), re.gzhead.hcrc && (G.adler = c(G.adler, re.pending_buf, re.pending, 0)), re.gzindex = 0, re.status = 69) : (ie(re, 0), ie(re, 0), ie(re, 0), ie(re, 0), ie(re, 0), ie(re, re.level === 9 ? 2 : 2 <= re.strategy || re.level < 2 ? 4 : 0), ie(re, 3), re.status = F);
                else {
                  var Oe = C + (re.w_bits - 8 << 4) << 8;
                  Oe |= (2 <= re.strategy || re.level < 2 ? 0 : re.level < 6 ? 1 : re.level === 6 ? 2 : 3) << 6, re.strstart !== 0 && (Oe |= 32), Oe += 31 - Oe % 31, re.status = F, oe(re, Oe), re.strstart !== 0 && (oe(re, G.adler >>> 16), oe(re, 65535 & G.adler)), G.adler = 1;
                }
                if (re.status === 69) if (re.gzhead.extra) {
                  for (ne = re.pending; re.gzindex < (65535 & re.gzhead.extra.length) && (re.pending !== re.pending_buf_size || (re.gzhead.hcrc && re.pending > ne && (G.adler = c(G.adler, re.pending_buf, re.pending - ne, ne)), Y(G), ne = re.pending, re.pending !== re.pending_buf_size)); ) ie(re, 255 & re.gzhead.extra[re.gzindex]), re.gzindex++;
                  re.gzhead.hcrc && re.pending > ne && (G.adler = c(G.adler, re.pending_buf, re.pending - ne, ne)), re.gzindex === re.gzhead.extra.length && (re.gzindex = 0, re.status = 73);
                } else re.status = 73;
                if (re.status === 73) if (re.gzhead.name) {
                  ne = re.pending;
                  do {
                    if (re.pending === re.pending_buf_size && (re.gzhead.hcrc && re.pending > ne && (G.adler = c(G.adler, re.pending_buf, re.pending - ne, ne)), Y(G), ne = re.pending, re.pending === re.pending_buf_size)) {
                      ce = 1;
                      break;
                    }
                    ce = re.gzindex < re.gzhead.name.length ? 255 & re.gzhead.name.charCodeAt(re.gzindex++) : 0, ie(re, ce);
                  } while (ce !== 0);
                  re.gzhead.hcrc && re.pending > ne && (G.adler = c(G.adler, re.pending_buf, re.pending - ne, ne)), ce === 0 && (re.gzindex = 0, re.status = 91);
                } else re.status = 91;
                if (re.status === 91) if (re.gzhead.comment) {
                  ne = re.pending;
                  do {
                    if (re.pending === re.pending_buf_size && (re.gzhead.hcrc && re.pending > ne && (G.adler = c(G.adler, re.pending_buf, re.pending - ne, ne)), Y(G), ne = re.pending, re.pending === re.pending_buf_size)) {
                      ce = 1;
                      break;
                    }
                    ce = re.gzindex < re.gzhead.comment.length ? 255 & re.gzhead.comment.charCodeAt(re.gzindex++) : 0, ie(re, ce);
                  } while (ce !== 0);
                  re.gzhead.hcrc && re.pending > ne && (G.adler = c(G.adler, re.pending_buf, re.pending - ne, ne)), ce === 0 && (re.status = 103);
                } else re.status = 103;
                if (re.status === 103 && (re.gzhead.hcrc ? (re.pending + 2 > re.pending_buf_size && Y(G), re.pending + 2 <= re.pending_buf_size && (ie(re, 255 & G.adler), ie(re, G.adler >> 8 & 255), G.adler = 0, re.status = F)) : re.status = F), re.pending !== 0) {
                  if (Y(G), G.avail_out === 0) return re.last_flush = -1, g;
                } else if (G.avail_in === 0 && j(Se) <= j(xe) && Se !== h) return Z(G, -5);
                if (re.status === 666 && G.avail_in !== 0) return Z(G, -5);
                if (G.avail_in !== 0 || re.lookahead !== 0 || Se !== u && re.status !== 666) {
                  var Ve = re.strategy === 2 ? (function(de, We) {
                    for (var Ze; ; ) {
                      if (de.lookahead === 0 && (Le(de), de.lookahead === 0)) {
                        if (We === u) return V;
                        break;
                      }
                      if (de.match_length = 0, Ze = o._tr_tally(de, 0, de.window[de.strstart]), de.lookahead--, de.strstart++, Ze && (X(de, false), de.strm.avail_out === 0)) return V;
                    }
                    return de.insert = 0, We === h ? (X(de, true), de.strm.avail_out === 0 ? _ : K) : de.last_lit && (X(de, false), de.strm.avail_out === 0) ? V : k;
                  })(re, Se) : re.strategy === 3 ? (function(de, We) {
                    for (var Ze, Ge, at, ut, it = de.window; ; ) {
                      if (de.lookahead <= O) {
                        if (Le(de), de.lookahead <= O && We === u) return V;
                        if (de.lookahead === 0) break;
                      }
                      if (de.match_length = 0, de.lookahead >= I && 0 < de.strstart && (Ge = it[at = de.strstart - 1]) === it[++at] && Ge === it[++at] && Ge === it[++at]) {
                        ut = de.strstart + O;
                        do
                          ;
                        while (Ge === it[++at] && Ge === it[++at] && Ge === it[++at] && Ge === it[++at] && Ge === it[++at] && Ge === it[++at] && Ge === it[++at] && Ge === it[++at] && at < ut);
                        de.match_length = O - (ut - at), de.match_length > de.lookahead && (de.match_length = de.lookahead);
                      }
                      if (de.match_length >= I ? (Ze = o._tr_tally(de, 1, de.match_length - I), de.lookahead -= de.match_length, de.strstart += de.match_length, de.match_length = 0) : (Ze = o._tr_tally(de, 0, de.window[de.strstart]), de.lookahead--, de.strstart++), Ze && (X(de, false), de.strm.avail_out === 0)) return V;
                    }
                    return de.insert = 0, We === h ? (X(de, true), de.strm.avail_out === 0 ? _ : K) : de.last_lit && (X(de, false), de.strm.avail_out === 0) ? V : k;
                  })(re, Se) : a[re.level].func(re, Se);
                  if (Ve !== _ && Ve !== K || (re.status = 666), Ve === V || Ve === _) return G.avail_out === 0 && (re.last_flush = -1), g;
                  if (Ve === k && (Se === 1 ? o._tr_align(re) : Se !== 5 && (o._tr_stored_block(re, 0, 0, false), Se === 3 && (B(re.head), re.lookahead === 0 && (re.strstart = 0, re.block_start = 0, re.insert = 0))), Y(G), G.avail_out === 0)) return re.last_flush = -1, g;
                }
                return Se !== h ? g : re.wrap <= 0 ? 1 : (re.wrap === 2 ? (ie(re, 255 & G.adler), ie(re, G.adler >> 8 & 255), ie(re, G.adler >> 16 & 255), ie(re, G.adler >> 24 & 255), ie(re, 255 & G.total_in), ie(re, G.total_in >> 8 & 255), ie(re, G.total_in >> 16 & 255), ie(re, G.total_in >> 24 & 255)) : (oe(re, G.adler >>> 16), oe(re, 65535 & G.adler)), Y(G), 0 < re.wrap && (re.wrap = -re.wrap), re.pending !== 0 ? g : 1);
              }, i.deflateEnd = function(G) {
                var Se;
                return G && G.state ? (Se = G.state.status) !== N && Se !== 69 && Se !== 73 && Se !== 91 && Se !== 103 && Se !== F && Se !== 666 ? Z(G, v) : (G.state = null, Se === F ? Z(G, -3) : g) : v;
              }, i.deflateSetDictionary = function(G, Se) {
                var xe, re, ne, ce, Oe, Ve, de, We, Ze = Se.length;
                if (!G || !G.state || (ce = (xe = G.state).wrap) === 2 || ce === 1 && xe.status !== N || xe.lookahead) return v;
                for (ce === 1 && (G.adler = l(G.adler, Se, Ze, 0)), xe.wrap = 0, Ze >= xe.w_size && (ce === 0 && (B(xe.head), xe.strstart = 0, xe.block_start = 0, xe.insert = 0), We = new s.Buf8(xe.w_size), s.arraySet(We, Se, Ze - xe.w_size, xe.w_size, 0), Se = We, Ze = xe.w_size), Oe = G.avail_in, Ve = G.next_in, de = G.input, G.avail_in = Ze, G.next_in = 0, G.input = Se, Le(xe); xe.lookahead >= I; ) {
                  for (re = xe.strstart, ne = xe.lookahead - (I - 1); xe.ins_h = (xe.ins_h << xe.hash_shift ^ xe.window[re + I - 1]) & xe.hash_mask, xe.prev[re & xe.w_mask] = xe.head[xe.ins_h], xe.head[xe.ins_h] = re, re++, --ne; ) ;
                  xe.strstart = re, xe.lookahead = I - 1, Le(xe);
                }
                return xe.strstart += xe.lookahead, xe.block_start = xe.strstart, xe.insert = xe.lookahead, xe.lookahead = 0, xe.match_length = xe.prev_length = I - 1, xe.match_available = 0, G.next_in = Ve, G.input = de, G.avail_in = Oe, xe.wrap = ce, g;
              }, i.deflateInfo = "pako deflate (from Nodeca project)";
            },
            {
              "../utils/common": 41,
              "./adler32": 43,
              "./crc32": 45,
              "./messages": 51,
              "./trees": 52
            }
          ],
          47: [
            function(n, r, i) {
              r.exports = function() {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
              };
            },
            {}
          ],
          48: [
            function(n, r, i) {
              r.exports = function(a, s) {
                var o, l, c, f, u, h, g, v, m, y, w, C, T, S, E, b, D, R, I, O, L, N, F, V, k;
                o = a.state, l = a.next_in, V = a.input, c = l + (a.avail_in - 5), f = a.next_out, k = a.output, u = f - (s - a.avail_out), h = f + (a.avail_out - 257), g = o.dmax, v = o.wsize, m = o.whave, y = o.wnext, w = o.window, C = o.hold, T = o.bits, S = o.lencode, E = o.distcode, b = (1 << o.lenbits) - 1, D = (1 << o.distbits) - 1;
                e: do {
                  T < 15 && (C += V[l++] << T, T += 8, C += V[l++] << T, T += 8), R = S[C & b];
                  t: for (; ; ) {
                    if (C >>>= I = R >>> 24, T -= I, (I = R >>> 16 & 255) === 0) k[f++] = 65535 & R;
                    else {
                      if (!(16 & I)) {
                        if ((64 & I) == 0) {
                          R = S[(65535 & R) + (C & (1 << I) - 1)];
                          continue t;
                        }
                        if (32 & I) {
                          o.mode = 12;
                          break e;
                        }
                        a.msg = "invalid literal/length code", o.mode = 30;
                        break e;
                      }
                      O = 65535 & R, (I &= 15) && (T < I && (C += V[l++] << T, T += 8), O += C & (1 << I) - 1, C >>>= I, T -= I), T < 15 && (C += V[l++] << T, T += 8, C += V[l++] << T, T += 8), R = E[C & D];
                      n: for (; ; ) {
                        if (C >>>= I = R >>> 24, T -= I, !(16 & (I = R >>> 16 & 255))) {
                          if ((64 & I) == 0) {
                            R = E[(65535 & R) + (C & (1 << I) - 1)];
                            continue n;
                          }
                          a.msg = "invalid distance code", o.mode = 30;
                          break e;
                        }
                        if (L = 65535 & R, T < (I &= 15) && (C += V[l++] << T, (T += 8) < I && (C += V[l++] << T, T += 8)), g < (L += C & (1 << I) - 1)) {
                          a.msg = "invalid distance too far back", o.mode = 30;
                          break e;
                        }
                        if (C >>>= I, T -= I, (I = f - u) < L) {
                          if (m < (I = L - I) && o.sane) {
                            a.msg = "invalid distance too far back", o.mode = 30;
                            break e;
                          }
                          if (F = w, (N = 0) === y) {
                            if (N += v - I, I < O) {
                              for (O -= I; k[f++] = w[N++], --I; ) ;
                              N = f - L, F = k;
                            }
                          } else if (y < I) {
                            if (N += v + y - I, (I -= y) < O) {
                              for (O -= I; k[f++] = w[N++], --I; ) ;
                              if (N = 0, y < O) {
                                for (O -= I = y; k[f++] = w[N++], --I; ) ;
                                N = f - L, F = k;
                              }
                            }
                          } else if (N += y - I, I < O) {
                            for (O -= I; k[f++] = w[N++], --I; ) ;
                            N = f - L, F = k;
                          }
                          for (; 2 < O; ) k[f++] = F[N++], k[f++] = F[N++], k[f++] = F[N++], O -= 3;
                          O && (k[f++] = F[N++], 1 < O && (k[f++] = F[N++]));
                        } else {
                          for (N = f - L; k[f++] = k[N++], k[f++] = k[N++], k[f++] = k[N++], 2 < (O -= 3); ) ;
                          O && (k[f++] = k[N++], 1 < O && (k[f++] = k[N++]));
                        }
                        break;
                      }
                    }
                    break;
                  }
                } while (l < c && f < h);
                l -= O = T >> 3, C &= (1 << (T -= O << 3)) - 1, a.next_in = l, a.next_out = f, a.avail_in = l < c ? c - l + 5 : 5 - (l - c), a.avail_out = f < h ? h - f + 257 : 257 - (f - h), o.hold = C, o.bits = T;
              };
            },
            {}
          ],
          49: [
            function(n, r, i) {
              var a = n("../utils/common"), s = n("./adler32"), o = n("./crc32"), l = n("./inffast"), c = n("./inftrees"), f = 1, u = 2, h = 0, g = -2, v = 1, m = 852, y = 592;
              function w(N) {
                return (N >>> 24 & 255) + (N >>> 8 & 65280) + ((65280 & N) << 8) + ((255 & N) << 24);
              }
              function C() {
                this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
              }
              function T(N) {
                var F;
                return N && N.state ? (F = N.state, N.total_in = N.total_out = F.total = 0, N.msg = "", F.wrap && (N.adler = 1 & F.wrap), F.mode = v, F.last = 0, F.havedict = 0, F.dmax = 32768, F.head = null, F.hold = 0, F.bits = 0, F.lencode = F.lendyn = new a.Buf32(m), F.distcode = F.distdyn = new a.Buf32(y), F.sane = 1, F.back = -1, h) : g;
              }
              function S(N) {
                var F;
                return N && N.state ? ((F = N.state).wsize = 0, F.whave = 0, F.wnext = 0, T(N)) : g;
              }
              function E(N, F) {
                var V, k;
                return N && N.state ? (k = N.state, F < 0 ? (V = 0, F = -F) : (V = 1 + (F >> 4), F < 48 && (F &= 15)), F && (F < 8 || 15 < F) ? g : (k.window !== null && k.wbits !== F && (k.window = null), k.wrap = V, k.wbits = F, S(N))) : g;
              }
              function b(N, F) {
                var V, k;
                return N ? (k = new C(), (N.state = k).window = null, (V = E(N, F)) !== h && (N.state = null), V) : g;
              }
              var D, R, I = true;
              function O(N) {
                if (I) {
                  var F;
                  for (D = new a.Buf32(512), R = new a.Buf32(32), F = 0; F < 144; ) N.lens[F++] = 8;
                  for (; F < 256; ) N.lens[F++] = 9;
                  for (; F < 280; ) N.lens[F++] = 7;
                  for (; F < 288; ) N.lens[F++] = 8;
                  for (c(f, N.lens, 0, 288, D, 0, N.work, {
                    bits: 9
                  }), F = 0; F < 32; ) N.lens[F++] = 5;
                  c(u, N.lens, 0, 32, R, 0, N.work, {
                    bits: 5
                  }), I = false;
                }
                N.lencode = D, N.lenbits = 9, N.distcode = R, N.distbits = 5;
              }
              function L(N, F, V, k) {
                var _, K = N.state;
                return K.window === null && (K.wsize = 1 << K.wbits, K.wnext = 0, K.whave = 0, K.window = new a.Buf8(K.wsize)), k >= K.wsize ? (a.arraySet(K.window, F, V - K.wsize, K.wsize, 0), K.wnext = 0, K.whave = K.wsize) : (k < (_ = K.wsize - K.wnext) && (_ = k), a.arraySet(K.window, F, V - k, _, K.wnext), (k -= _) ? (a.arraySet(K.window, F, V - k, k, 0), K.wnext = k, K.whave = K.wsize) : (K.wnext += _, K.wnext === K.wsize && (K.wnext = 0), K.whave < K.wsize && (K.whave += _))), 0;
              }
              i.inflateReset = S, i.inflateReset2 = E, i.inflateResetKeep = T, i.inflateInit = function(N) {
                return b(N, 15);
              }, i.inflateInit2 = b, i.inflate = function(N, F) {
                var V, k, _, K, Z, j, B, Y, X, ie, oe, he, Le, Je, Pe, ot, vt, wt, Qe, _t6, G, Se, xe, re, ne = 0, ce = new a.Buf8(4), Oe = [
                  16,
                  17,
                  18,
                  0,
                  8,
                  7,
                  9,
                  6,
                  10,
                  5,
                  11,
                  4,
                  12,
                  3,
                  13,
                  2,
                  14,
                  1,
                  15
                ];
                if (!N || !N.state || !N.output || !N.input && N.avail_in !== 0) return g;
                (V = N.state).mode === 12 && (V.mode = 13), Z = N.next_out, _ = N.output, B = N.avail_out, K = N.next_in, k = N.input, j = N.avail_in, Y = V.hold, X = V.bits, ie = j, oe = B, Se = h;
                e: for (; ; ) switch (V.mode) {
                  case v:
                    if (V.wrap === 0) {
                      V.mode = 13;
                      break;
                    }
                    for (; X < 16; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    if (2 & V.wrap && Y === 35615) {
                      ce[V.check = 0] = 255 & Y, ce[1] = Y >>> 8 & 255, V.check = o(V.check, ce, 2, 0), X = Y = 0, V.mode = 2;
                      break;
                    }
                    if (V.flags = 0, V.head && (V.head.done = false), !(1 & V.wrap) || (((255 & Y) << 8) + (Y >> 8)) % 31) {
                      N.msg = "incorrect header check", V.mode = 30;
                      break;
                    }
                    if ((15 & Y) != 8) {
                      N.msg = "unknown compression method", V.mode = 30;
                      break;
                    }
                    if (X -= 4, G = 8 + (15 & (Y >>>= 4)), V.wbits === 0) V.wbits = G;
                    else if (G > V.wbits) {
                      N.msg = "invalid window size", V.mode = 30;
                      break;
                    }
                    V.dmax = 1 << G, N.adler = V.check = 1, V.mode = 512 & Y ? 10 : 12, X = Y = 0;
                    break;
                  case 2:
                    for (; X < 16; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    if (V.flags = Y, (255 & V.flags) != 8) {
                      N.msg = "unknown compression method", V.mode = 30;
                      break;
                    }
                    if (57344 & V.flags) {
                      N.msg = "unknown header flags set", V.mode = 30;
                      break;
                    }
                    V.head && (V.head.text = Y >> 8 & 1), 512 & V.flags && (ce[0] = 255 & Y, ce[1] = Y >>> 8 & 255, V.check = o(V.check, ce, 2, 0)), X = Y = 0, V.mode = 3;
                  case 3:
                    for (; X < 32; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    V.head && (V.head.time = Y), 512 & V.flags && (ce[0] = 255 & Y, ce[1] = Y >>> 8 & 255, ce[2] = Y >>> 16 & 255, ce[3] = Y >>> 24 & 255, V.check = o(V.check, ce, 4, 0)), X = Y = 0, V.mode = 4;
                  case 4:
                    for (; X < 16; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    V.head && (V.head.xflags = 255 & Y, V.head.os = Y >> 8), 512 & V.flags && (ce[0] = 255 & Y, ce[1] = Y >>> 8 & 255, V.check = o(V.check, ce, 2, 0)), X = Y = 0, V.mode = 5;
                  case 5:
                    if (1024 & V.flags) {
                      for (; X < 16; ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      V.length = Y, V.head && (V.head.extra_len = Y), 512 & V.flags && (ce[0] = 255 & Y, ce[1] = Y >>> 8 & 255, V.check = o(V.check, ce, 2, 0)), X = Y = 0;
                    } else V.head && (V.head.extra = null);
                    V.mode = 6;
                  case 6:
                    if (1024 & V.flags && (j < (he = V.length) && (he = j), he && (V.head && (G = V.head.extra_len - V.length, V.head.extra || (V.head.extra = new Array(V.head.extra_len)), a.arraySet(V.head.extra, k, K, he, G)), 512 & V.flags && (V.check = o(V.check, k, he, K)), j -= he, K += he, V.length -= he), V.length)) break e;
                    V.length = 0, V.mode = 7;
                  case 7:
                    if (2048 & V.flags) {
                      if (j === 0) break e;
                      for (he = 0; G = k[K + he++], V.head && G && V.length < 65536 && (V.head.name += String.fromCharCode(G)), G && he < j; ) ;
                      if (512 & V.flags && (V.check = o(V.check, k, he, K)), j -= he, K += he, G) break e;
                    } else V.head && (V.head.name = null);
                    V.length = 0, V.mode = 8;
                  case 8:
                    if (4096 & V.flags) {
                      if (j === 0) break e;
                      for (he = 0; G = k[K + he++], V.head && G && V.length < 65536 && (V.head.comment += String.fromCharCode(G)), G && he < j; ) ;
                      if (512 & V.flags && (V.check = o(V.check, k, he, K)), j -= he, K += he, G) break e;
                    } else V.head && (V.head.comment = null);
                    V.mode = 9;
                  case 9:
                    if (512 & V.flags) {
                      for (; X < 16; ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      if (Y !== (65535 & V.check)) {
                        N.msg = "header crc mismatch", V.mode = 30;
                        break;
                      }
                      X = Y = 0;
                    }
                    V.head && (V.head.hcrc = V.flags >> 9 & 1, V.head.done = true), N.adler = V.check = 0, V.mode = 12;
                    break;
                  case 10:
                    for (; X < 32; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    N.adler = V.check = w(Y), X = Y = 0, V.mode = 11;
                  case 11:
                    if (V.havedict === 0) return N.next_out = Z, N.avail_out = B, N.next_in = K, N.avail_in = j, V.hold = Y, V.bits = X, 2;
                    N.adler = V.check = 1, V.mode = 12;
                  case 12:
                    if (F === 5 || F === 6) break e;
                  case 13:
                    if (V.last) {
                      Y >>>= 7 & X, X -= 7 & X, V.mode = 27;
                      break;
                    }
                    for (; X < 3; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    switch (V.last = 1 & Y, X -= 1, 3 & (Y >>>= 1)) {
                      case 0:
                        V.mode = 14;
                        break;
                      case 1:
                        if (O(V), V.mode = 20, F !== 6) break;
                        Y >>>= 2, X -= 2;
                        break e;
                      case 2:
                        V.mode = 17;
                        break;
                      case 3:
                        N.msg = "invalid block type", V.mode = 30;
                    }
                    Y >>>= 2, X -= 2;
                    break;
                  case 14:
                    for (Y >>>= 7 & X, X -= 7 & X; X < 32; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    if ((65535 & Y) != (Y >>> 16 ^ 65535)) {
                      N.msg = "invalid stored block lengths", V.mode = 30;
                      break;
                    }
                    if (V.length = 65535 & Y, X = Y = 0, V.mode = 15, F === 6) break e;
                  case 15:
                    V.mode = 16;
                  case 16:
                    if (he = V.length) {
                      if (j < he && (he = j), B < he && (he = B), he === 0) break e;
                      a.arraySet(_, k, K, he, Z), j -= he, K += he, B -= he, Z += he, V.length -= he;
                      break;
                    }
                    V.mode = 12;
                    break;
                  case 17:
                    for (; X < 14; ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    if (V.nlen = 257 + (31 & Y), Y >>>= 5, X -= 5, V.ndist = 1 + (31 & Y), Y >>>= 5, X -= 5, V.ncode = 4 + (15 & Y), Y >>>= 4, X -= 4, 286 < V.nlen || 30 < V.ndist) {
                      N.msg = "too many length or distance symbols", V.mode = 30;
                      break;
                    }
                    V.have = 0, V.mode = 18;
                  case 18:
                    for (; V.have < V.ncode; ) {
                      for (; X < 3; ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      V.lens[Oe[V.have++]] = 7 & Y, Y >>>= 3, X -= 3;
                    }
                    for (; V.have < 19; ) V.lens[Oe[V.have++]] = 0;
                    if (V.lencode = V.lendyn, V.lenbits = 7, xe = {
                      bits: V.lenbits
                    }, Se = c(0, V.lens, 0, 19, V.lencode, 0, V.work, xe), V.lenbits = xe.bits, Se) {
                      N.msg = "invalid code lengths set", V.mode = 30;
                      break;
                    }
                    V.have = 0, V.mode = 19;
                  case 19:
                    for (; V.have < V.nlen + V.ndist; ) {
                      for (; ot = (ne = V.lencode[Y & (1 << V.lenbits) - 1]) >>> 16 & 255, vt = 65535 & ne, !((Pe = ne >>> 24) <= X); ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      if (vt < 16) Y >>>= Pe, X -= Pe, V.lens[V.have++] = vt;
                      else {
                        if (vt === 16) {
                          for (re = Pe + 2; X < re; ) {
                            if (j === 0) break e;
                            j--, Y += k[K++] << X, X += 8;
                          }
                          if (Y >>>= Pe, X -= Pe, V.have === 0) {
                            N.msg = "invalid bit length repeat", V.mode = 30;
                            break;
                          }
                          G = V.lens[V.have - 1], he = 3 + (3 & Y), Y >>>= 2, X -= 2;
                        } else if (vt === 17) {
                          for (re = Pe + 3; X < re; ) {
                            if (j === 0) break e;
                            j--, Y += k[K++] << X, X += 8;
                          }
                          X -= Pe, G = 0, he = 3 + (7 & (Y >>>= Pe)), Y >>>= 3, X -= 3;
                        } else {
                          for (re = Pe + 7; X < re; ) {
                            if (j === 0) break e;
                            j--, Y += k[K++] << X, X += 8;
                          }
                          X -= Pe, G = 0, he = 11 + (127 & (Y >>>= Pe)), Y >>>= 7, X -= 7;
                        }
                        if (V.have + he > V.nlen + V.ndist) {
                          N.msg = "invalid bit length repeat", V.mode = 30;
                          break;
                        }
                        for (; he--; ) V.lens[V.have++] = G;
                      }
                    }
                    if (V.mode === 30) break;
                    if (V.lens[256] === 0) {
                      N.msg = "invalid code -- missing end-of-block", V.mode = 30;
                      break;
                    }
                    if (V.lenbits = 9, xe = {
                      bits: V.lenbits
                    }, Se = c(f, V.lens, 0, V.nlen, V.lencode, 0, V.work, xe), V.lenbits = xe.bits, Se) {
                      N.msg = "invalid literal/lengths set", V.mode = 30;
                      break;
                    }
                    if (V.distbits = 6, V.distcode = V.distdyn, xe = {
                      bits: V.distbits
                    }, Se = c(u, V.lens, V.nlen, V.ndist, V.distcode, 0, V.work, xe), V.distbits = xe.bits, Se) {
                      N.msg = "invalid distances set", V.mode = 30;
                      break;
                    }
                    if (V.mode = 20, F === 6) break e;
                  case 20:
                    V.mode = 21;
                  case 21:
                    if (6 <= j && 258 <= B) {
                      N.next_out = Z, N.avail_out = B, N.next_in = K, N.avail_in = j, V.hold = Y, V.bits = X, l(N, oe), Z = N.next_out, _ = N.output, B = N.avail_out, K = N.next_in, k = N.input, j = N.avail_in, Y = V.hold, X = V.bits, V.mode === 12 && (V.back = -1);
                      break;
                    }
                    for (V.back = 0; ot = (ne = V.lencode[Y & (1 << V.lenbits) - 1]) >>> 16 & 255, vt = 65535 & ne, !((Pe = ne >>> 24) <= X); ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    if (ot && (240 & ot) == 0) {
                      for (wt = Pe, Qe = ot, _t6 = vt; ot = (ne = V.lencode[_t6 + ((Y & (1 << wt + Qe) - 1) >> wt)]) >>> 16 & 255, vt = 65535 & ne, !(wt + (Pe = ne >>> 24) <= X); ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      Y >>>= wt, X -= wt, V.back += wt;
                    }
                    if (Y >>>= Pe, X -= Pe, V.back += Pe, V.length = vt, ot === 0) {
                      V.mode = 26;
                      break;
                    }
                    if (32 & ot) {
                      V.back = -1, V.mode = 12;
                      break;
                    }
                    if (64 & ot) {
                      N.msg = "invalid literal/length code", V.mode = 30;
                      break;
                    }
                    V.extra = 15 & ot, V.mode = 22;
                  case 22:
                    if (V.extra) {
                      for (re = V.extra; X < re; ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      V.length += Y & (1 << V.extra) - 1, Y >>>= V.extra, X -= V.extra, V.back += V.extra;
                    }
                    V.was = V.length, V.mode = 23;
                  case 23:
                    for (; ot = (ne = V.distcode[Y & (1 << V.distbits) - 1]) >>> 16 & 255, vt = 65535 & ne, !((Pe = ne >>> 24) <= X); ) {
                      if (j === 0) break e;
                      j--, Y += k[K++] << X, X += 8;
                    }
                    if ((240 & ot) == 0) {
                      for (wt = Pe, Qe = ot, _t6 = vt; ot = (ne = V.distcode[_t6 + ((Y & (1 << wt + Qe) - 1) >> wt)]) >>> 16 & 255, vt = 65535 & ne, !(wt + (Pe = ne >>> 24) <= X); ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      Y >>>= wt, X -= wt, V.back += wt;
                    }
                    if (Y >>>= Pe, X -= Pe, V.back += Pe, 64 & ot) {
                      N.msg = "invalid distance code", V.mode = 30;
                      break;
                    }
                    V.offset = vt, V.extra = 15 & ot, V.mode = 24;
                  case 24:
                    if (V.extra) {
                      for (re = V.extra; X < re; ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      V.offset += Y & (1 << V.extra) - 1, Y >>>= V.extra, X -= V.extra, V.back += V.extra;
                    }
                    if (V.offset > V.dmax) {
                      N.msg = "invalid distance too far back", V.mode = 30;
                      break;
                    }
                    V.mode = 25;
                  case 25:
                    if (B === 0) break e;
                    if (he = oe - B, V.offset > he) {
                      if ((he = V.offset - he) > V.whave && V.sane) {
                        N.msg = "invalid distance too far back", V.mode = 30;
                        break;
                      }
                      Le = he > V.wnext ? (he -= V.wnext, V.wsize - he) : V.wnext - he, he > V.length && (he = V.length), Je = V.window;
                    } else Je = _, Le = Z - V.offset, he = V.length;
                    for (B < he && (he = B), B -= he, V.length -= he; _[Z++] = Je[Le++], --he; ) ;
                    V.length === 0 && (V.mode = 21);
                    break;
                  case 26:
                    if (B === 0) break e;
                    _[Z++] = V.length, B--, V.mode = 21;
                    break;
                  case 27:
                    if (V.wrap) {
                      for (; X < 32; ) {
                        if (j === 0) break e;
                        j--, Y |= k[K++] << X, X += 8;
                      }
                      if (oe -= B, N.total_out += oe, V.total += oe, oe && (N.adler = V.check = V.flags ? o(V.check, _, oe, Z - oe) : s(V.check, _, oe, Z - oe)), oe = B, (V.flags ? Y : w(Y)) !== V.check) {
                        N.msg = "incorrect data check", V.mode = 30;
                        break;
                      }
                      X = Y = 0;
                    }
                    V.mode = 28;
                  case 28:
                    if (V.wrap && V.flags) {
                      for (; X < 32; ) {
                        if (j === 0) break e;
                        j--, Y += k[K++] << X, X += 8;
                      }
                      if (Y !== (4294967295 & V.total)) {
                        N.msg = "incorrect length check", V.mode = 30;
                        break;
                      }
                      X = Y = 0;
                    }
                    V.mode = 29;
                  case 29:
                    Se = 1;
                    break e;
                  case 30:
                    Se = -3;
                    break e;
                  case 31:
                    return -4;
                  case 32:
                  default:
                    return g;
                }
                return N.next_out = Z, N.avail_out = B, N.next_in = K, N.avail_in = j, V.hold = Y, V.bits = X, (V.wsize || oe !== N.avail_out && V.mode < 30 && (V.mode < 27 || F !== 4)) && L(N, N.output, N.next_out, oe - N.avail_out) ? (V.mode = 31, -4) : (ie -= N.avail_in, oe -= N.avail_out, N.total_in += ie, N.total_out += oe, V.total += oe, V.wrap && oe && (N.adler = V.check = V.flags ? o(V.check, _, oe, N.next_out - oe) : s(V.check, _, oe, N.next_out - oe)), N.data_type = V.bits + (V.last ? 64 : 0) + (V.mode === 12 ? 128 : 0) + (V.mode === 20 || V.mode === 15 ? 256 : 0), (ie == 0 && oe === 0 || F === 4) && Se === h && (Se = -5), Se);
              }, i.inflateEnd = function(N) {
                if (!N || !N.state) return g;
                var F = N.state;
                return F.window && (F.window = null), N.state = null, h;
              }, i.inflateGetHeader = function(N, F) {
                var V;
                return N && N.state ? (2 & (V = N.state).wrap) == 0 ? g : ((V.head = F).done = false, h) : g;
              }, i.inflateSetDictionary = function(N, F) {
                var V, k = F.length;
                return N && N.state ? (V = N.state).wrap !== 0 && V.mode !== 11 ? g : V.mode === 11 && s(1, F, k, 0) !== V.check ? -3 : L(N, F, k, k) ? (V.mode = 31, -4) : (V.havedict = 1, h) : g;
              }, i.inflateInfo = "pako inflate (from Nodeca project)";
            },
            {
              "../utils/common": 41,
              "./adler32": 43,
              "./crc32": 45,
              "./inffast": 48,
              "./inftrees": 50
            }
          ],
          50: [
            function(n, r, i) {
              var a = n("../utils/common"), s = [
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                15,
                17,
                19,
                23,
                27,
                31,
                35,
                43,
                51,
                59,
                67,
                83,
                99,
                115,
                131,
                163,
                195,
                227,
                258,
                0,
                0
              ], o = [
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                17,
                17,
                17,
                17,
                18,
                18,
                18,
                18,
                19,
                19,
                19,
                19,
                20,
                20,
                20,
                20,
                21,
                21,
                21,
                21,
                16,
                72,
                78
              ], l = [
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577,
                0,
                0
              ], c = [
                16,
                16,
                16,
                16,
                17,
                17,
                18,
                18,
                19,
                19,
                20,
                20,
                21,
                21,
                22,
                22,
                23,
                23,
                24,
                24,
                25,
                25,
                26,
                26,
                27,
                27,
                28,
                28,
                29,
                29,
                64,
                64
              ];
              r.exports = function(f, u, h, g, v, m, y, w) {
                var C, T, S, E, b, D, R, I, O, L = w.bits, N = 0, F = 0, V = 0, k = 0, _ = 0, K = 0, Z = 0, j = 0, B = 0, Y = 0, X = null, ie = 0, oe = new a.Buf16(16), he = new a.Buf16(16), Le = null, Je = 0;
                for (N = 0; N <= 15; N++) oe[N] = 0;
                for (F = 0; F < g; F++) oe[u[h + F]]++;
                for (_ = L, k = 15; 1 <= k && oe[k] === 0; k--) ;
                if (k < _ && (_ = k), k === 0) return v[m++] = 20971520, v[m++] = 20971520, w.bits = 1, 0;
                for (V = 1; V < k && oe[V] === 0; V++) ;
                for (_ < V && (_ = V), N = j = 1; N <= 15; N++) if (j <<= 1, (j -= oe[N]) < 0) return -1;
                if (0 < j && (f === 0 || k !== 1)) return -1;
                for (he[1] = 0, N = 1; N < 15; N++) he[N + 1] = he[N] + oe[N];
                for (F = 0; F < g; F++) u[h + F] !== 0 && (y[he[u[h + F]]++] = F);
                if (D = f === 0 ? (X = Le = y, 19) : f === 1 ? (X = s, ie -= 257, Le = o, Je -= 257, 256) : (X = l, Le = c, -1), N = V, b = m, Z = F = Y = 0, S = -1, E = (B = 1 << (K = _)) - 1, f === 1 && 852 < B || f === 2 && 592 < B) return 1;
                for (; ; ) {
                  for (R = N - Z, O = y[F] < D ? (I = 0, y[F]) : y[F] > D ? (I = Le[Je + y[F]], X[ie + y[F]]) : (I = 96, 0), C = 1 << N - Z, V = T = 1 << K; v[b + (Y >> Z) + (T -= C)] = R << 24 | I << 16 | O | 0, T !== 0; ) ;
                  for (C = 1 << N - 1; Y & C; ) C >>= 1;
                  if (C !== 0 ? (Y &= C - 1, Y += C) : Y = 0, F++, --oe[N] == 0) {
                    if (N === k) break;
                    N = u[h + y[F]];
                  }
                  if (_ < N && (Y & E) !== S) {
                    for (Z === 0 && (Z = _), b += V, j = 1 << (K = N - Z); K + Z < k && !((j -= oe[K + Z]) <= 0); ) K++, j <<= 1;
                    if (B += 1 << K, f === 1 && 852 < B || f === 2 && 592 < B) return 1;
                    v[S = Y & E] = _ << 24 | K << 16 | b - m | 0;
                  }
                }
                return Y !== 0 && (v[b + Y] = N - Z << 24 | 64 << 16 | 0), w.bits = _, 0;
              };
            },
            {
              "../utils/common": 41
            }
          ],
          51: [
            function(n, r, i) {
              r.exports = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
              };
            },
            {}
          ],
          52: [
            function(n, r, i) {
              var a = n("../utils/common"), s = 0, o = 1;
              function l(ne) {
                for (var ce = ne.length; 0 <= --ce; ) ne[ce] = 0;
              }
              var c = 0, f = 29, u = 256, h = u + 1 + f, g = 30, v = 19, m = 2 * h + 1, y = 15, w = 16, C = 7, T = 256, S = 16, E = 17, b = 18, D = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                3,
                3,
                3,
                3,
                4,
                4,
                4,
                4,
                5,
                5,
                5,
                5,
                0
              ], R = [
                0,
                0,
                0,
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                4,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                8,
                8,
                9,
                9,
                10,
                10,
                11,
                11,
                12,
                12,
                13,
                13
              ], I = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                3,
                7
              ], O = [
                16,
                17,
                18,
                0,
                8,
                7,
                9,
                6,
                10,
                5,
                11,
                4,
                12,
                3,
                13,
                2,
                14,
                1,
                15
              ], L = new Array(2 * (h + 2));
              l(L);
              var N = new Array(2 * g);
              l(N);
              var F = new Array(512);
              l(F);
              var V = new Array(256);
              l(V);
              var k = new Array(f);
              l(k);
              var _, K, Z, j = new Array(g);
              function B(ne, ce, Oe, Ve, de) {
                this.static_tree = ne, this.extra_bits = ce, this.extra_base = Oe, this.elems = Ve, this.max_length = de, this.has_stree = ne && ne.length;
              }
              function Y(ne, ce) {
                this.dyn_tree = ne, this.max_code = 0, this.stat_desc = ce;
              }
              function X(ne) {
                return ne < 256 ? F[ne] : F[256 + (ne >>> 7)];
              }
              function ie(ne, ce) {
                ne.pending_buf[ne.pending++] = 255 & ce, ne.pending_buf[ne.pending++] = ce >>> 8 & 255;
              }
              function oe(ne, ce, Oe) {
                ne.bi_valid > w - Oe ? (ne.bi_buf |= ce << ne.bi_valid & 65535, ie(ne, ne.bi_buf), ne.bi_buf = ce >> w - ne.bi_valid, ne.bi_valid += Oe - w) : (ne.bi_buf |= ce << ne.bi_valid & 65535, ne.bi_valid += Oe);
              }
              function he(ne, ce, Oe) {
                oe(ne, Oe[2 * ce], Oe[2 * ce + 1]);
              }
              function Le(ne, ce) {
                for (var Oe = 0; Oe |= 1 & ne, ne >>>= 1, Oe <<= 1, 0 < --ce; ) ;
                return Oe >>> 1;
              }
              function Je(ne, ce, Oe) {
                var Ve, de, We = new Array(y + 1), Ze = 0;
                for (Ve = 1; Ve <= y; Ve++) We[Ve] = Ze = Ze + Oe[Ve - 1] << 1;
                for (de = 0; de <= ce; de++) {
                  var Ge = ne[2 * de + 1];
                  Ge !== 0 && (ne[2 * de] = Le(We[Ge]++, Ge));
                }
              }
              function Pe(ne) {
                var ce;
                for (ce = 0; ce < h; ce++) ne.dyn_ltree[2 * ce] = 0;
                for (ce = 0; ce < g; ce++) ne.dyn_dtree[2 * ce] = 0;
                for (ce = 0; ce < v; ce++) ne.bl_tree[2 * ce] = 0;
                ne.dyn_ltree[2 * T] = 1, ne.opt_len = ne.static_len = 0, ne.last_lit = ne.matches = 0;
              }
              function ot(ne) {
                8 < ne.bi_valid ? ie(ne, ne.bi_buf) : 0 < ne.bi_valid && (ne.pending_buf[ne.pending++] = ne.bi_buf), ne.bi_buf = 0, ne.bi_valid = 0;
              }
              function vt(ne, ce, Oe, Ve) {
                var de = 2 * ce, We = 2 * Oe;
                return ne[de] < ne[We] || ne[de] === ne[We] && Ve[ce] <= Ve[Oe];
              }
              function wt(ne, ce, Oe) {
                for (var Ve = ne.heap[Oe], de = Oe << 1; de <= ne.heap_len && (de < ne.heap_len && vt(ce, ne.heap[de + 1], ne.heap[de], ne.depth) && de++, !vt(ce, Ve, ne.heap[de], ne.depth)); ) ne.heap[Oe] = ne.heap[de], Oe = de, de <<= 1;
                ne.heap[Oe] = Ve;
              }
              function Qe(ne, ce, Oe) {
                var Ve, de, We, Ze, Ge = 0;
                if (ne.last_lit !== 0) for (; Ve = ne.pending_buf[ne.d_buf + 2 * Ge] << 8 | ne.pending_buf[ne.d_buf + 2 * Ge + 1], de = ne.pending_buf[ne.l_buf + Ge], Ge++, Ve === 0 ? he(ne, de, ce) : (he(ne, (We = V[de]) + u + 1, ce), (Ze = D[We]) !== 0 && oe(ne, de -= k[We], Ze), he(ne, We = X(--Ve), Oe), (Ze = R[We]) !== 0 && oe(ne, Ve -= j[We], Ze)), Ge < ne.last_lit; ) ;
                he(ne, T, ce);
              }
              function _t6(ne, ce) {
                var Oe, Ve, de, We = ce.dyn_tree, Ze = ce.stat_desc.static_tree, Ge = ce.stat_desc.has_stree, at = ce.stat_desc.elems, ut = -1;
                for (ne.heap_len = 0, ne.heap_max = m, Oe = 0; Oe < at; Oe++) We[2 * Oe] !== 0 ? (ne.heap[++ne.heap_len] = ut = Oe, ne.depth[Oe] = 0) : We[2 * Oe + 1] = 0;
                for (; ne.heap_len < 2; ) We[2 * (de = ne.heap[++ne.heap_len] = ut < 2 ? ++ut : 0)] = 1, ne.depth[de] = 0, ne.opt_len--, Ge && (ne.static_len -= Ze[2 * de + 1]);
                for (ce.max_code = ut, Oe = ne.heap_len >> 1; 1 <= Oe; Oe--) wt(ne, We, Oe);
                for (de = at; Oe = ne.heap[1], ne.heap[1] = ne.heap[ne.heap_len--], wt(ne, We, 1), Ve = ne.heap[1], ne.heap[--ne.heap_max] = Oe, ne.heap[--ne.heap_max] = Ve, We[2 * de] = We[2 * Oe] + We[2 * Ve], ne.depth[de] = (ne.depth[Oe] >= ne.depth[Ve] ? ne.depth[Oe] : ne.depth[Ve]) + 1, We[2 * Oe + 1] = We[2 * Ve + 1] = de, ne.heap[1] = de++, wt(ne, We, 1), 2 <= ne.heap_len; ) ;
                ne.heap[--ne.heap_max] = ne.heap[1], (function(it, fn) {
                  var jt, mr, Di, mn, Wr, Ur, ye = fn.dyn_tree, ke = fn.max_code, rt = fn.stat_desc.static_tree, sn = fn.stat_desc.has_stree, ti = fn.stat_desc.extra_bits, lr = fn.stat_desc.extra_base, vn = fn.stat_desc.max_length, xa = 0;
                  for (mn = 0; mn <= y; mn++) it.bl_count[mn] = 0;
                  for (ye[2 * it.heap[it.heap_max] + 1] = 0, jt = it.heap_max + 1; jt < m; jt++) vn < (mn = ye[2 * ye[2 * (mr = it.heap[jt]) + 1] + 1] + 1) && (mn = vn, xa++), ye[2 * mr + 1] = mn, ke < mr || (it.bl_count[mn]++, Wr = 0, lr <= mr && (Wr = ti[mr - lr]), Ur = ye[2 * mr], it.opt_len += Ur * (mn + Wr), sn && (it.static_len += Ur * (rt[2 * mr + 1] + Wr)));
                  if (xa !== 0) {
                    do {
                      for (mn = vn - 1; it.bl_count[mn] === 0; ) mn--;
                      it.bl_count[mn]--, it.bl_count[mn + 1] += 2, it.bl_count[vn]--, xa -= 2;
                    } while (0 < xa);
                    for (mn = vn; mn !== 0; mn--) for (mr = it.bl_count[mn]; mr !== 0; ) ke < (Di = it.heap[--jt]) || (ye[2 * Di + 1] !== mn && (it.opt_len += (mn - ye[2 * Di + 1]) * ye[2 * Di], ye[2 * Di + 1] = mn), mr--);
                  }
                })(ne, ce), Je(We, ut, ne.bl_count);
              }
              function G(ne, ce, Oe) {
                var Ve, de, We = -1, Ze = ce[1], Ge = 0, at = 7, ut = 4;
                for (Ze === 0 && (at = 138, ut = 3), ce[2 * (Oe + 1) + 1] = 65535, Ve = 0; Ve <= Oe; Ve++) de = Ze, Ze = ce[2 * (Ve + 1) + 1], ++Ge < at && de === Ze || (Ge < ut ? ne.bl_tree[2 * de] += Ge : de !== 0 ? (de !== We && ne.bl_tree[2 * de]++, ne.bl_tree[2 * S]++) : Ge <= 10 ? ne.bl_tree[2 * E]++ : ne.bl_tree[2 * b]++, We = de, ut = (Ge = 0) === Ze ? (at = 138, 3) : de === Ze ? (at = 6, 3) : (at = 7, 4));
              }
              function Se(ne, ce, Oe) {
                var Ve, de, We = -1, Ze = ce[1], Ge = 0, at = 7, ut = 4;
                for (Ze === 0 && (at = 138, ut = 3), Ve = 0; Ve <= Oe; Ve++) if (de = Ze, Ze = ce[2 * (Ve + 1) + 1], !(++Ge < at && de === Ze)) {
                  if (Ge < ut) for (; he(ne, de, ne.bl_tree), --Ge != 0; ) ;
                  else de !== 0 ? (de !== We && (he(ne, de, ne.bl_tree), Ge--), he(ne, S, ne.bl_tree), oe(ne, Ge - 3, 2)) : Ge <= 10 ? (he(ne, E, ne.bl_tree), oe(ne, Ge - 3, 3)) : (he(ne, b, ne.bl_tree), oe(ne, Ge - 11, 7));
                  We = de, ut = (Ge = 0) === Ze ? (at = 138, 3) : de === Ze ? (at = 6, 3) : (at = 7, 4);
                }
              }
              l(j);
              var xe = false;
              function re(ne, ce, Oe, Ve) {
                oe(ne, (c << 1) + (Ve ? 1 : 0), 3), (function(de, We, Ze, Ge) {
                  ot(de), ie(de, Ze), ie(de, ~Ze), a.arraySet(de.pending_buf, de.window, We, Ze, de.pending), de.pending += Ze;
                })(ne, ce, Oe);
              }
              i._tr_init = function(ne) {
                xe || ((function() {
                  var ce, Oe, Ve, de, We, Ze = new Array(y + 1);
                  for (de = Ve = 0; de < f - 1; de++) for (k[de] = Ve, ce = 0; ce < 1 << D[de]; ce++) V[Ve++] = de;
                  for (V[Ve - 1] = de, de = We = 0; de < 16; de++) for (j[de] = We, ce = 0; ce < 1 << R[de]; ce++) F[We++] = de;
                  for (We >>= 7; de < g; de++) for (j[de] = We << 7, ce = 0; ce < 1 << R[de] - 7; ce++) F[256 + We++] = de;
                  for (Oe = 0; Oe <= y; Oe++) Ze[Oe] = 0;
                  for (ce = 0; ce <= 143; ) L[2 * ce + 1] = 8, ce++, Ze[8]++;
                  for (; ce <= 255; ) L[2 * ce + 1] = 9, ce++, Ze[9]++;
                  for (; ce <= 279; ) L[2 * ce + 1] = 7, ce++, Ze[7]++;
                  for (; ce <= 287; ) L[2 * ce + 1] = 8, ce++, Ze[8]++;
                  for (Je(L, h + 1, Ze), ce = 0; ce < g; ce++) N[2 * ce + 1] = 5, N[2 * ce] = Le(ce, 5);
                  _ = new B(L, D, u + 1, h, y), K = new B(N, R, 0, g, y), Z = new B(new Array(0), I, 0, v, C);
                })(), xe = true), ne.l_desc = new Y(ne.dyn_ltree, _), ne.d_desc = new Y(ne.dyn_dtree, K), ne.bl_desc = new Y(ne.bl_tree, Z), ne.bi_buf = 0, ne.bi_valid = 0, Pe(ne);
              }, i._tr_stored_block = re, i._tr_flush_block = function(ne, ce, Oe, Ve) {
                var de, We, Ze = 0;
                0 < ne.level ? (ne.strm.data_type === 2 && (ne.strm.data_type = (function(Ge) {
                  var at, ut = 4093624447;
                  for (at = 0; at <= 31; at++, ut >>>= 1) if (1 & ut && Ge.dyn_ltree[2 * at] !== 0) return s;
                  if (Ge.dyn_ltree[18] !== 0 || Ge.dyn_ltree[20] !== 0 || Ge.dyn_ltree[26] !== 0) return o;
                  for (at = 32; at < u; at++) if (Ge.dyn_ltree[2 * at] !== 0) return o;
                  return s;
                })(ne)), _t6(ne, ne.l_desc), _t6(ne, ne.d_desc), Ze = (function(Ge) {
                  var at;
                  for (G(Ge, Ge.dyn_ltree, Ge.l_desc.max_code), G(Ge, Ge.dyn_dtree, Ge.d_desc.max_code), _t6(Ge, Ge.bl_desc), at = v - 1; 3 <= at && Ge.bl_tree[2 * O[at] + 1] === 0; at--) ;
                  return Ge.opt_len += 3 * (at + 1) + 5 + 5 + 4, at;
                })(ne), de = ne.opt_len + 3 + 7 >>> 3, (We = ne.static_len + 3 + 7 >>> 3) <= de && (de = We)) : de = We = Oe + 5, Oe + 4 <= de && ce !== -1 ? re(ne, ce, Oe, Ve) : ne.strategy === 4 || We === de ? (oe(ne, 2 + (Ve ? 1 : 0), 3), Qe(ne, L, N)) : (oe(ne, 4 + (Ve ? 1 : 0), 3), (function(Ge, at, ut, it) {
                  var fn;
                  for (oe(Ge, at - 257, 5), oe(Ge, ut - 1, 5), oe(Ge, it - 4, 4), fn = 0; fn < it; fn++) oe(Ge, Ge.bl_tree[2 * O[fn] + 1], 3);
                  Se(Ge, Ge.dyn_ltree, at - 1), Se(Ge, Ge.dyn_dtree, ut - 1);
                })(ne, ne.l_desc.max_code + 1, ne.d_desc.max_code + 1, Ze + 1), Qe(ne, ne.dyn_ltree, ne.dyn_dtree)), Pe(ne), Ve && ot(ne);
              }, i._tr_tally = function(ne, ce, Oe) {
                return ne.pending_buf[ne.d_buf + 2 * ne.last_lit] = ce >>> 8 & 255, ne.pending_buf[ne.d_buf + 2 * ne.last_lit + 1] = 255 & ce, ne.pending_buf[ne.l_buf + ne.last_lit] = 255 & Oe, ne.last_lit++, ce === 0 ? ne.dyn_ltree[2 * Oe]++ : (ne.matches++, ce--, ne.dyn_ltree[2 * (V[Oe] + u + 1)]++, ne.dyn_dtree[2 * X(ce)]++), ne.last_lit === ne.lit_bufsize - 1;
              }, i._tr_align = function(ne) {
                oe(ne, 2, 3), he(ne, T, L), (function(ce) {
                  ce.bi_valid === 16 ? (ie(ce, ce.bi_buf), ce.bi_buf = 0, ce.bi_valid = 0) : 8 <= ce.bi_valid && (ce.pending_buf[ce.pending++] = 255 & ce.bi_buf, ce.bi_buf >>= 8, ce.bi_valid -= 8);
                })(ne);
              };
            },
            {
              "../utils/common": 41
            }
          ],
          53: [
            function(n, r, i) {
              r.exports = function() {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
              };
            },
            {}
          ],
          54: [
            function(n, r, i) {
              (function(a) {
                (function(s, o) {
                  if (!s.setImmediate) {
                    var l, c, f, u, h = 1, g = {}, v = false, m = s.document, y = Object.getPrototypeOf && Object.getPrototypeOf(s);
                    y = y && y.setTimeout ? y : s, l = {}.toString.call(s.process) === "[object process]" ? function(S) {
                      process.nextTick(function() {
                        C(S);
                      });
                    } : (function() {
                      if (s.postMessage && !s.importScripts) {
                        var S = true, E = s.onmessage;
                        return s.onmessage = function() {
                          S = false;
                        }, s.postMessage("", "*"), s.onmessage = E, S;
                      }
                    })() ? (u = "setImmediate$" + Math.random() + "$", s.addEventListener ? s.addEventListener("message", T, false) : s.attachEvent("onmessage", T), function(S) {
                      s.postMessage(u + S, "*");
                    }) : s.MessageChannel ? ((f = new MessageChannel()).port1.onmessage = function(S) {
                      C(S.data);
                    }, function(S) {
                      f.port2.postMessage(S);
                    }) : m && "onreadystatechange" in m.createElement("script") ? (c = m.documentElement, function(S) {
                      var E = m.createElement("script");
                      E.onreadystatechange = function() {
                        C(S), E.onreadystatechange = null, c.removeChild(E), E = null;
                      }, c.appendChild(E);
                    }) : function(S) {
                      setTimeout(C, 0, S);
                    }, y.setImmediate = function(S) {
                      typeof S != "function" && (S = new Function("" + S));
                      for (var E = new Array(arguments.length - 1), b = 0; b < E.length; b++) E[b] = arguments[b + 1];
                      var D = {
                        callback: S,
                        args: E
                      };
                      return g[h] = D, l(h), h++;
                    }, y.clearImmediate = w;
                  }
                  function w(S) {
                    delete g[S];
                  }
                  function C(S) {
                    if (v) setTimeout(C, 0, S);
                    else {
                      var E = g[S];
                      if (E) {
                        v = true;
                        try {
                          (function(b) {
                            var D = b.callback, R = b.args;
                            switch (R.length) {
                              case 0:
                                D();
                                break;
                              case 1:
                                D(R[0]);
                                break;
                              case 2:
                                D(R[0], R[1]);
                                break;
                              case 3:
                                D(R[0], R[1], R[2]);
                                break;
                              default:
                                D.apply(o, R);
                            }
                          })(E);
                        } finally {
                          w(S), v = false;
                        }
                      }
                    }
                  }
                  function T(S) {
                    S.source === s && typeof S.data == "string" && S.data.indexOf(u) === 0 && C(+S.data.slice(u.length));
                  }
                })(typeof self > "u" ? a === void 0 ? this : a : self);
              }).call(this, typeof ci < "u" ? ci : typeof self < "u" ? self : typeof window < "u" ? window : {});
            },
            {}
          ]
        }, {}, [
          10
        ])(10);
      });
    })(Ev)), Ev.exports;
  }
  Wge();
  function Hge(t) {
    const e = t.indexOf(".");
    return e === -1 ? t : t.substring(0, e);
  }
  function jge() {
    const e = pE().caseId ?? "1", n = me.useRef(null), r = me.useRef(null), i = me.useRef(null), a = me.useRef(null), s = me.useRef(null), o = me.useRef(null), l = me.useRef(null), [c, f] = me.useState([
      true
    ]), [u, h] = me.useState(null), [g, v] = me.useState(), [m, y] = me.useState(void 0), [w, C] = me.useState([]), [T, S] = me.useState(ls.DEFAULT_SEGMENTATION_OPACITY * 100), [E, b] = me.useState(400), [D, R] = me.useState(50), [I, O] = me.useState(null), [L, N] = me.useState([]), [F, V] = me.useState(null), [k, _] = me.useState(false), [K, Z] = me.useState(null), [j, B] = me.useState(true), [Y, X] = me.useState(false), [ie, oe] = me.useState(true), he = n5();
    me.useEffect(() => {
      (async () => {
        const _t6 = Rv.map((We, Ze) => ({
          label: Hge(We),
          id: Ze + 1
        }));
        C(_t6);
        const G = [
          true
        ];
        _t6.forEach((We) => {
          G[We.id] = true;
        }), f(G);
        const Se = await Fge(n, r, i, "2", e);
        if (oe(false), !Se) return;
        const { segmentationVolumeArray: xe, segRepUIDs: re, renderingEngine: ne, viewportIds: ce, volumeId: Oe } = Se;
        h(re), O(ne), N(ce), V(Oe);
        const { nv: Ve, cmapCopy: de } = await Gge(a, e);
        s.current = de, v(Ve), l.current = xe;
      })();
    }, [
      e
    ]);
    const Le = (Qe, _t6) => {
      const G = Math.max(Qe ?? E, 1), Se = _t6 ?? D;
      if (b(G), R(Se), !I || !L.length || !F) return;
      const xe = Se - G / 2, re = Se + G / 2;
      L.forEach((ne) => {
        const ce = I.getViewport(ne), Oe = ce.getActors();
        for (const Ve of Oe) if (Ve.uid === F) try {
          const de = Ve.actor.getProperty().getRGBTransferFunction(0);
          de.setMappingRange(xe, re), de.updateRange(), ce.render();
        } catch (de) {
          console.warn("[VOI Error]", de);
        }
      });
    };
    me.useEffect(() => {
      I && L.length && F && Le(E, D);
    }, [
      I,
      L,
      F
    ]), me.useEffect(() => {
      if (u && c && g) {
        const Qe = [
          true,
          ...w.map((_t6) => !!c[_t6.id])
        ];
        console.log("150", Qe), Pge(u, Qe), zge(g, Qe, m, s.current);
      }
    }, [
      u,
      c,
      g,
      w,
      m
    ]);
    const Je = (Qe) => {
      const _t6 = Number(Qe.target.value);
      S(_t6), rE(_t6 / 100), iE(a, _t6 / 100);
    }, Pe = (Qe) => {
      S(Qe), rE(Qe / 100), iE(a, Qe / 100);
    }, ot = async () => {
      const _t6 = await (await fetch(`${i5}/api/download/${e}`)).blob(), G = window.URL.createObjectURL(_t6), Se = document.createElement("a");
      Se.href = G, Se.download = `${e}_segmentations.zip`, document.body.appendChild(Se), Se.click(), document.body.removeChild(Se), window.URL.revokeObjectURL(G);
    }, vt = () => {
      const Qe = new FormData();
      m && (Qe.append("sessionKey", m), fetch(`${ls.API_ORIGIN}/api/terminate-session`, {
        method: "POST",
        body: Qe
      }).then((_t6) => _t6.json()).then((_t6) => console.log(_t6.message))), he("/");
    };
    return [
      1,
      17,
      30,
      35,
      121
    ].filter((Qe) => Qe === Number(e)).length === 0 ? (he("/"), null) : be.jsxs("div", {
      className: "VisualizationPage",
      style: {
        display: "flex",
        overflow: "hidden",
        flexDirection: "column",
        height: "100vh",
        width: "100vw"
      },
      children: [
        be.jsxs("div", {
          style: {
            position: "relative"
          },
          children: [
            be.jsx("div", {
              className: "sidebar position-absolute z-3 top-0 left-0",
              children: be.jsxs("div", {
                children: [
                  be.jsxs("div", {
                    className: "flex",
                    children: [
                      be.jsx("div", {
                        className: "hover:bg-gray-700 z-3 cursor-pointer bg-[#0f0824] p-2 ml-4 mt-4 rounded-lg w-fit",
                        onClick: () => B((Qe) => !Qe),
                        children: be.jsx(yW, {
                          color: "white"
                        })
                      }),
                      be.jsx("div", {
                        className: "hover:bg-gray-700 z-3 cursor-pointer bg-[#0f0824] p-2 ml-4 mt-4 rounded-lg w-fit",
                        onClick: () => vt(),
                        children: be.jsx(gW, {
                          color: "white"
                        })
                      })
                    ]
                  }),
                  be.jsx("div", {
                    className: `text-black bg-[#0f0824] m-[2vh] z-3 rounded-lg w-fit p-6 pt-3 gap-3 flex flex-col relative transition-all duration-100 origin-top-left ${j ? "scale-0" : "scale-100"}`,
                    children: !j && be.jsxs(be.Fragment, {
                      children: [
                        be.jsx("div", {
                          className: "flex items-center justify-center mb-2",
                          children: be.jsx("div", {
                            className: "text-white font-bold text-xl",
                            children: `Case ID: ${e}`
                          })
                        }),
                        be.jsx(xW, {
                          opacityValue: T,
                          handleOpacityOnSliderChange: Je,
                          handleOpacityOnFormSubmit: Pe
                        }),
                        be.jsx(SW, {
                          windowWidth: E,
                          windowCenter: D,
                          onWindowChange: Le
                        }),
                        be.jsx("button", {
                          className: "text-white relative pt-3 !bg-blue-700 hover:!border-white",
                          onClick: () => {
                            X((Qe) => !Qe), B((Qe) => !Qe);
                          },
                          children: "Manage organs"
                        }),
                        be.jsxs("div", {
                          className: "flex gap-3 items-center justify-center",
                          children: [
                            be.jsxs("div", {
                              className: "group hover:bg-gray-700 cursor-pointer p-2 rounded-md relative  ",
                              children: [
                                be.jsx(hW, {
                                  onClick: ot,
                                  className: "w-6 h-6 text-white relative"
                                }),
                                be.jsx("span", {
                                  className: "transition-all pointer-events-none duration-100 scale-0 group-hover:scale-100 absolute top-0 left-12 z-1 bg-gray-900 text-white rounded-md p-2",
                                  children: "Download"
                                })
                              ]
                            }),
                            be.jsxs("div", {
                              className: "group hover:bg-gray-700 cursor-pointer p-2 rounded-md relative",
                              children: [
                                be.jsx(mW, {
                                  className: "w-6 h-6 text-white relative",
                                  onClick: () => _((Qe) => !Qe)
                                }),
                                be.jsx("span", {
                                  className: "transition-all pointer-events-none duration-100 scale-0 group-hover:scale-100 absolute top-0 left-12 z-1 bg-gray-900 text-white rounded-md p-2",
                                  children: "Report"
                                })
                              ]
                            })
                          ]
                        })
                      ]
                    })
                  })
                ]
              })
            }),
            ie ? be.jsx("div", {
              className: "flex z-3 absolute top-0 left-0 w-screen h-screen items-center justify-center",
              children: be.jsxs("div", {
                role: "status",
                children: [
                  be.jsxs("svg", {
                    "aria-hidden": "true",
                    className: "w-8 h-8 text-gray-200 animate-spin dark:text-gray-600 fill-blue-600",
                    viewBox: "0 0 100 101",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [
                      be.jsx("path", {
                        d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                        fill: "currentColor"
                      }),
                      be.jsx("path", {
                        d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                        fill: "currentFill"
                      })
                    ]
                  }),
                  be.jsx("span", {
                    className: "sr-only",
                    children: "Loading..."
                  })
                ]
              })
            }) : be.jsxs("div", {
              className: "visualization-container",
              ref: o,
              style: {
                overflow: "hidden"
              },
              children: [
                be.jsx("div", {
                  className: "axial",
                  ref: n,
                  onMouseDown: (Qe) => Z({
                    orientation: "axial",
                    x: Math.floor(Qe.clientX - Qe.currentTarget.getBoundingClientRect().left),
                    y: Math.floor(Qe.clientY - Qe.currentTarget.getBoundingClientRect().top)
                  })
                }),
                be.jsx("div", {
                  className: "sagittal",
                  ref: r,
                  onMouseDown: (Qe) => Z({
                    orientation: "sagittal",
                    x: Math.floor(Qe.clientX - Qe.currentTarget.getBoundingClientRect().left),
                    y: Math.floor(Qe.clientY - Qe.currentTarget.getBoundingClientRect().top)
                  })
                }),
                be.jsx("div", {
                  className: "coronal",
                  ref: i,
                  onMouseDown: (Qe) => Z({
                    orientation: "coronal",
                    x: Math.floor(Qe.clientX - Qe.currentTarget.getBoundingClientRect().left),
                    y: Math.floor(Qe.clientY - Qe.currentTarget.getBoundingClientRect().top)
                  })
                }),
                be.jsx("div", {
                  className: "render",
                  children: be.jsx("div", {
                    className: "canvas",
                    children: be.jsx("canvas", {
                      ref: a
                    })
                  })
                })
              ]
            })
          ]
        }),
        be.jsx(CW, {
          setCheckState: f,
          checkBoxData: w,
          checkState: c,
          sessionId: m,
          clabelId: e,
          setShowTaskDetails: B,
          setShowOrganDetails: X,
          showOrganDetails: Y
        }),
        k && be.jsx(TW, {
          id: e,
          onClose: () => _(false)
        })
      ]
    });
  }
  const Kge = void 0;
  function Yge() {
    return be.jsx(be.Fragment, {
      children: be.jsx(o_, {
        children: be.jsx(a_, {
          children: be.jsx("div", {
            className: "App",
            children: be.jsx(qB, {
              basename: Kge,
              children: be.jsxs(EB, {
                children: [
                  be.jsx(Dv, {
                    path: "/",
                    element: be.jsx(T_, {})
                  }),
                  be.jsx(Dv, {
                    path: "/case/:caseId",
                    element: be.jsx(jge, {})
                  })
                ]
              })
            })
          })
        })
      })
    });
  }
  UF.createRoot(document.getElementById("root")).render(be.jsx(me.StrictMode, {
    children: be.jsx(Yge, {})
  }));
})();
